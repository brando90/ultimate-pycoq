{"add0": {"text": "Theorem add0: forall n: nat, add 0 n = n.\n    intro n. unfold add. reflexivity. Qed.\n", "definition": " forall n: nat, add 0 n = n.", "proof": "\n    intro n. unfold add. reflexivity. ", "def_ranges": [306, 0, 306, 43], "proof_ranges": [307, 0, 307, 42], "proof_steps": [{"text": "intro n.", "goal_before": ["forall n : nat, 0 + n = n"], "goal_after": ["0 + n = n"], "proof_term_before": [], "proof_term_after": ["(fun n : nat => ?Goal)"]}, {"text": "unfold add.", "goal_before": ["0 + n = n"], "goal_after": ["n = n"], "proof_term_before": ["(fun n : nat => ?Goal)"], "proof_term_after": ["(fun n : nat => ?Goal : 0 + n = n)"]}, {"text": "reflexivity.", "goal_before": ["n = n"], "goal_after": [], "proof_term_before": ["(fun n : nat => ?Goal : 0 + n = n)"], "proof_term_after": ["(fun n : nat => eq_refl : 0 + n = n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat => eq_refl : 0 + n = n)"], "proof_term_after": []}]}, "andb_commutative": {"text": "Theorem andb_commutative: forall b c, andb b c = andb c b.\n  intros b c. destruct c. reflexivity. reflexivity. Qed.\n", "definition": " forall b c, andb b c = andb c b.", "proof": "\n  intros b c. destruct c. reflexivity. reflexivity. ", "def_ranges": [738, 0, 738, 58], "proof_ranges": [739, 0, 739, 56], "proof_steps": [{"text": "intros b c.", "goal_before": ["forall b c : bool, b && c = c && b"], "goal_after": ["b && c = c && b"], "proof_term_before": [], "proof_term_after": ["(fun b c : bool => ?Goal)"]}, {"text": "destruct c.", "goal_before": ["b && c = c && b"], "goal_after": ["b && true = true && b", "b && false = false && b"], "proof_term_before": ["(fun b c : bool => ?Goal)"], "proof_term_after": ["(fun b c : bool =>\n match c as b0 return (b && b0 = b0 && b) with\n | true => ?Goal\n | false => ?Goal0\n end)"]}, {"text": "reflexivity.", "goal_before": ["b && true = true && b", "b && false = false && b"], "goal_after": ["b && false = false && b"], "proof_term_before": ["(fun b c : bool =>\n match c as b0 return (b && b0 = b0 && b) with\n | true => ?Goal\n | false => ?Goal0\n end)"], "proof_term_after": ["(fun b c : bool =>\n match c as b0 return (b && b0 = b0 && b) with\n | true => eq_refl\n | false => ?Goal\n end)"]}, {"text": "reflexivity.", "goal_before": ["b && false = false && b"], "goal_after": [], "proof_term_before": ["(fun b c : bool =>\n match c as b0 return (b && b0 = b0 && b) with\n | true => eq_refl\n | false => ?Goal\n end)"], "proof_term_after": ["(fun b c : bool =>\n match c as b0 return (b && b0 = b0 && b) with\n | true => eq_refl\n | false => eq_refl\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun b c : bool =>\n match c as b0 return (b && b0 = b0 && b) with\n | true => eq_refl\n | false => eq_refl\n end)"], "proof_term_after": []}]}, "add01": {"text": "Theorem add01: forall n: nat, add n 0 = n.\n    intro n. unfold add. (* \u043f\u043e\u043a\u0430 \u043d\u0435 \u0437\u043d\u0430\u044e \u043a\u0430\u043a \u0434\u043e\u043a\u0430\u0437\u0430\u0442\u044c *)\n    destruct n.\n    - reflexivity.\n    - destruct n as [|nn]. Abort.  (* we need proof by induction, that is the  next chapter *)\n", "definition": " forall n: nat, add n 0 = n.", "proof": "\n    intro n. unfold add. (* \u043f\u043e\u043a\u0430 \u043d\u0435 \u0437\u043d\u0430\u044e \u043a\u0430\u043a \u0434\u043e\u043a\u0430\u0437\u0430\u0442\u044c *)\n    destruct n.\n    - reflexivity.\n    - destruct n as [|nn]. Abort.  (* we need proof by induction, that is the  next chapter *)", "def_ranges": [323, 0, 323, 44], "proof_ranges": [324, 0, 327, 33], "proof_steps": [{"text": "intro n.", "goal_before": ["forall n : nat, n + 0 = n"], "goal_after": ["n + 0 = n"], "proof_term_before": [], "proof_term_after": ["(fun n : nat => ?Goal)"]}, {"text": "unfold add.", "goal_before": ["n + 0 = n"], "goal_after": ["(fix add (n0 m : nat) {struct n0} : nat :=\n   match n0 with\n   | 0 => m\n   | S n1 => add n1 (S m)\n   end) n 0 = n"], "proof_term_before": ["(fun n : nat => ?Goal)"], "proof_term_after": ["(fun n : nat => ?Goal : n + 0 = n)"]}, {"text": "destruct n.", "goal_before": ["(fix add (n0 m : nat) {struct n0} : nat :=\n   match n0 with\n   | 0 => m\n   | S n1 => add n1 (S m)\n   end) n 0 = n"], "goal_after": ["0 = 0", "(fix add (n0 m : nat) {struct n0} : nat :=\n   match n0 with\n   | 0 => m\n   | S n1 => add n1 (S m)\n   end) n 1 = S n"], "proof_term_before": ["(fun n : nat => ?Goal : n + 0 = n)"], "proof_term_after": ["(fun n : nat =>\n match\n   n as n0\n   return\n     ((fix add (n1 m : nat) {struct n1} : nat :=\n         match n1 with\n         | 0 => m\n         | S n2 => add n2 (S m)\n         end) n0 0 = n0)\n with\n | 0 => ?Goal\n | S n0 => (fun n1 : nat => ?Goal0@{n:=n1}) n0\n end\n :\n n + 0 = n)"]}, {"text": "reflexivity.", "goal_before": ["0 = 0", "(fix add (n0 m : nat) {struct n0} : nat :=\n   match n0 with\n   | 0 => m\n   | S n1 => add n1 (S m)\n   end) n 1 = S n"], "goal_after": ["(fix add (n0 m : nat) {struct n0} : nat :=\n   match n0 with\n   | 0 => m\n   | S n1 => add n1 (S m)\n   end) n 1 = S n"], "proof_term_before": ["(fun n : nat =>\n match\n   n as n0\n   return\n     ((fix add (n1 m : nat) {struct n1} : nat :=\n         match n1 with\n         | 0 => m\n         | S n2 => add n2 (S m)\n         end) n0 0 = n0)\n with\n | 0 => ?Goal\n | S n0 => (fun n1 : nat => ?Goal0@{n:=n1}) n0\n end\n :\n n + 0 = n)"], "proof_term_after": ["(fun n : nat =>\n match\n   n as n0\n   return\n     ((fix add (n1 m : nat) {struct n1} : nat :=\n         match n1 with\n         | 0 => m\n         | S n2 => add n2 (S m)\n         end) n0 0 = n0)\n with\n | 0 => eq_refl\n | S n0 => (fun n1 : nat => ?Goal@{n:=n1}) n0\n end\n :\n n + 0 = n)"]}, {"text": "destruct n as [|nn].", "goal_before": ["(fix add (n0 m : nat) {struct n0} : nat :=\n   match n0 with\n   | 0 => m\n   | S n1 => add n1 (S m)\n   end) n 1 = S n"], "goal_after": ["1 = 1", "(fix add (n m : nat) {struct n} : nat :=\n   match n with\n   | 0 => m\n   | S n1 => add n1 (S m)\n   end) nn 2 = S (S nn)"], "proof_term_before": ["(fun n : nat =>\n match\n   n as n0\n   return\n     ((fix add (n1 m : nat) {struct n1} : nat :=\n         match n1 with\n         | 0 => m\n         | S n2 => add n2 (S m)\n         end) n0 0 = n0)\n with\n | 0 => eq_refl\n | S n0 => (fun n1 : nat => ?Goal@{n:=n1}) n0\n end\n :\n n + 0 = n)"], "proof_term_after": ["(fun n : nat =>\n match\n   n as n0\n   return\n     ((fix add (n1 m : nat) {struct n1} : nat :=\n         match n1 with\n         | 0 => m\n         | S n2 => add n2 (S m)\n         end) n0 0 = n0)\n with\n | 0 => eq_refl\n | S n0 =>\n     (fun n1 : nat =>\n      match\n        n1 as n2\n        return\n          ((fix add (n3 m : nat) {struct n3} : nat :=\n              match n3 with\n              | 0 => m\n              | S n4 => add n4 (S m)\n              end) n2 1 = S n2)\n      with\n      | 0 => ?Goal\n      | S n2 => (fun nn : nat => ?Goal0) n2\n      end) n0\n end\n :\n n + 0 = n)"]}, {"text": "Abort.", "goal_before": ["1 = 1", "(fix add (n m : nat) {struct n} : nat :=\n   match n with\n   | 0 => m\n   | S n1 => add n1 (S m)\n   end) nn 2 = S (S nn)"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n match\n   n as n0\n   return\n     ((fix add (n1 m : nat) {struct n1} : nat :=\n         match n1 with\n         | 0 => m\n         | S n2 => add n2 (S m)\n         end) n0 0 = n0)\n with\n | 0 => eq_refl\n | S n0 =>\n     (fun n1 : nat =>\n      match\n        n1 as n2\n        return\n          ((fix add (n3 m : nat) {struct n3} : nat :=\n              match n3 with\n              | 0 => m\n              | S n4 => add n4 (S m)\n              end) n2 1 = S n2)\n      with\n      | 0 => ?Goal\n      | S n2 => (fun nn : nat => ?Goal0) n2\n      end) n0\n end\n :\n n + 0 = n)"], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}]}, "plus_id_example": {"text": "Theorem plus_id_example: forall n m: nat, n = m -> n + n = m + m.\n  intros n m.\n  intros H.\n  rewrite H.\n  reflexivity.\nQed.\n", "definition": " forall n m: nat, n = m -> n + n = m + m.", "proof": "\n  intros n m.\n  intros H.\n  rewrite H.\n  reflexivity.\n", "def_ranges": [650, 0, 650, 65], "proof_ranges": [651, 0, 655, 4], "proof_steps": [{"text": "intros n m.", "goal_before": ["forall n m : nat, n = m -> n + n = m + m"], "goal_after": ["n = m -> n + n = m + m"], "proof_term_before": [], "proof_term_after": ["(fun n m : nat => ?Goal)"]}, {"text": "intros H.", "goal_before": ["n = m -> n + n = m + m"], "goal_after": ["n + n = m + m"], "proof_term_before": ["(fun n m : nat => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (H : n = m) => ?Goal)"]}, {"text": "rewrite H.", "goal_before": ["n + n = m + m"], "goal_after": ["m + m = m + m"], "proof_term_before": ["(fun (n m : nat) (H : n = m) => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (H : n = m) =>\n eq_ind_r (fun n0 : nat => n0 + n0 = m + m) ?Goal H)"]}, {"text": "reflexivity.", "goal_before": ["m + m = m + m"], "goal_after": [], "proof_term_before": ["(fun (n m : nat) (H : n = m) =>\n eq_ind_r (fun n0 : nat => n0 + n0 = m + m) ?Goal H)"], "proof_term_after": ["(fun (n m : nat) (H : n = m) =>\n eq_ind_r (fun n0 : nat => n0 + n0 = m + m) eq_refl H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n m : nat) (H : n = m) =>\n eq_ind_r (fun n0 : nat => n0 + n0 = m + m) eq_refl H)"], "proof_term_after": []}]}, "plus_0_n": {"text": "Theorem plus_0_n: forall n: nat, 0 + n = n.\n  simpl. reflexivity. Qed.\n", "definition": " forall n: nat, 0 + n = n.", "proof": "\n  simpl. reflexivity. ", "def_ranges": [646, 0, 646, 43], "proof_ranges": [647, 0, 647, 26], "proof_steps": [{"text": "simpl.", "goal_before": ["forall n : nat, 0 + n = n"], "goal_after": ["forall n : nat, n = n"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall n : nat, 0 + n = n)"]}, {"text": "reflexivity.", "goal_before": ["forall n : nat, n = n"], "goal_after": [], "proof_term_before": ["(?Goal : forall n : nat, 0 + n = n)"], "proof_term_after": ["((fun n : nat => eq_refl) : forall n : nat, 0 + n = n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun n : nat => eq_refl) : forall n : nat, 0 + n = n)"], "proof_term_after": []}]}, "plus_1_l": {"text": "Theorem plus_1_l: forall n:nat, 1 + n = S n.\n  intro n.\n  unfold plus.\n  reflexivity.\nQed.\n", "definition": " forall n:nat, 1 + n = S n.", "proof": "\n  intro n.\n  unfold plus.\n  reflexivity.\n", "def_ranges": [658, 0, 658, 44], "proof_ranges": [659, 0, 662, 4], "proof_steps": [{"text": "intro n.", "goal_before": ["forall n : nat, 1 + n = S n"], "goal_after": ["1 + n = S n"], "proof_term_before": [], "proof_term_after": ["(fun n : nat => ?Goal)"]}, {"text": "unfold plus.", "goal_before": ["1 + n = S n"], "goal_after": ["S n = S n"], "proof_term_before": ["(fun n : nat => ?Goal)"], "proof_term_after": ["(fun n : nat => ?Goal : 1 + n = S n)"]}, {"text": "reflexivity.", "goal_before": ["S n = S n"], "goal_after": [], "proof_term_before": ["(fun n : nat => ?Goal : 1 + n = S n)"], "proof_term_after": ["(fun n : nat => eq_refl : 1 + n = S n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat => eq_refl : 1 + n = S n)"], "proof_term_after": []}]}, "mult_0_1": {"text": "Theorem mult_0_1: forall n:nat, 0 * n = 0.\n  intros n.\n  unfold mult.\n  reflexivity.\nQed.\n", "definition": " forall n:nat, 0 * n = 0.", "proof": "\n  intros n.\n  unfold mult.\n  reflexivity.\n", "def_ranges": [665, 0, 665, 42], "proof_ranges": [666, 0, 669, 4], "proof_steps": [{"text": "intros n.", "goal_before": ["forall n : nat, 0 * n = 0"], "goal_after": ["0 * n = 0"], "proof_term_before": [], "proof_term_after": ["(fun n : nat => ?Goal)"]}, {"text": "unfold mult.", "goal_before": ["0 * n = 0"], "goal_after": ["0 = 0"], "proof_term_before": ["(fun n : nat => ?Goal)"], "proof_term_after": ["(fun n : nat => ?Goal : 0 * n = 0)"]}, {"text": "reflexivity.", "goal_before": ["0 = 0"], "goal_after": [], "proof_term_before": ["(fun n : nat => ?Goal : 0 * n = 0)"], "proof_term_after": ["(fun n : nat => eq_refl : 0 * n = 0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat => eq_refl : 0 * n = 0)"], "proof_term_after": []}]}, "plus_id_exercise": {"text": "Theorem plus_id_exercise: forall n m o: nat,\n    n = m -> m = o -> n + m = m + o.\n  intros n m o.\n  intros h1 h2.\n  rewrite h1.\n  rewrite h2.\n  reflexivity.\nQed.\n", "definition": " forall n m o: nat,\n    n = m -> m = o -> n + m = m + o.", "proof": "\n  intros n m o.\n  intros h1 h2.\n  rewrite h1.\n  rewrite h2.\n  reflexivity.\n", "def_ranges": [672, 0, 673, 36], "proof_ranges": [674, 0, 679, 4], "proof_steps": [{"text": "intros n m o.", "goal_before": ["forall n m o : nat, n = m -> m = o -> n + m = m + o"], "goal_after": ["n = m -> m = o -> n + m = m + o"], "proof_term_before": [], "proof_term_after": ["(fun n m o : nat => ?Goal)"]}, {"text": "intros h1 h2.", "goal_before": ["n = m -> m = o -> n + m = m + o"], "goal_after": ["n + m = m + o"], "proof_term_before": ["(fun n m o : nat => ?Goal)"], "proof_term_after": ["(fun (n m o : nat) (h1 : n = m) (h2 : m = o) => ?Goal)"]}, {"text": "rewrite h1.", "goal_before": ["n + m = m + o"], "goal_after": ["m + m = m + o"], "proof_term_before": ["(fun (n m o : nat) (h1 : n = m) (h2 : m = o) => ?Goal)"], "proof_term_after": ["(fun (n m o : nat) (h1 : n = m) (h2 : m = o) =>\n eq_ind_r (fun n0 : nat => n0 + m = m + o) ?Goal h1)"]}, {"text": "rewrite h2.", "goal_before": ["m + m = m + o"], "goal_after": ["o + o = o + o"], "proof_term_before": ["(fun (n m o : nat) (h1 : n = m) (h2 : m = o) =>\n eq_ind_r (fun n0 : nat => n0 + m = m + o) ?Goal h1)"], "proof_term_after": ["(fun (n m o : nat) (h1 : n = m) (h2 : m = o) =>\n eq_ind_r (fun n0 : nat => n0 + m = m + o)\n   (eq_ind_r (fun m0 : nat => m0 + m0 = m0 + o) ?Goal h2) h1)"]}, {"text": "reflexivity.", "goal_before": ["o + o = o + o"], "goal_after": [], "proof_term_before": ["(fun (n m o : nat) (h1 : n = m) (h2 : m = o) =>\n eq_ind_r (fun n0 : nat => n0 + m = m + o)\n   (eq_ind_r (fun m0 : nat => m0 + m0 = m0 + o) ?Goal h2) h1)"], "proof_term_after": ["(fun (n m o : nat) (h1 : n = m) (h2 : m = o) =>\n eq_ind_r (fun n0 : nat => n0 + m = m + o)\n   (eq_ind_r (fun m0 : nat => m0 + m0 = m0 + o) eq_refl h2) h1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n m o : nat) (h1 : n = m) (h2 : m = o) =>\n eq_ind_r (fun n0 : nat => n0 + m = m + o)\n   (eq_ind_r (fun m0 : nat => m0 + m0 = m0 + o) eq_refl h2) h1)"], "proof_term_after": []}]}, "mult_0_plus": {"text": "Theorem mult_0_plus: forall n m: nat,\n    (0 + n) * m = n * m.\n  intros n m.\n  unfold plus.\n  reflexivity.\nQed.\n", "definition": " forall n m: nat,\n    (0 + n) * m = n * m.", "proof": "\n  intros n m.\n  unfold plus.\n  reflexivity.\n", "def_ranges": [682, 0, 683, 24], "proof_ranges": [684, 0, 687, 4], "proof_steps": [{"text": "intros n m.", "goal_before": ["forall n m : nat, (0 + n) * m = n * m"], "goal_after": ["(0 + n) * m = n * m"], "proof_term_before": [], "proof_term_after": ["(fun n m : nat => ?Goal)"]}, {"text": "unfold plus.", "goal_before": ["(0 + n) * m = n * m"], "goal_after": ["n * m = n * m"], "proof_term_before": ["(fun n m : nat => ?Goal)"], "proof_term_after": ["(fun n m : nat => ?Goal : (0 + n) * m = n * m)"]}, {"text": "reflexivity.", "goal_before": ["n * m = n * m"], "goal_after": [], "proof_term_before": ["(fun n m : nat => ?Goal : (0 + n) * m = n * m)"], "proof_term_after": ["(fun n m : nat => eq_refl : (0 + n) * m = n * m)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n m : nat => eq_refl : (0 + n) * m = n * m)"], "proof_term_after": []}]}, "mult_S_1": {"text": "Theorem mult_S_1: forall n m: nat,\n    m = S n -> m * (1 + n) = m * m.\n  intros n m.\n  intros H.\n  unfold plus.\n  rewrite -> H.\n  reflexivity.\nQed.\n", "definition": " forall n m: nat,\n    m = S n -> m * (1 + n) = m * m.", "proof": "\n  intros n m.\n  intros H.\n  unfold plus.\n  rewrite -> H.\n  reflexivity.\n", "def_ranges": [689, 0, 690, 35], "proof_ranges": [691, 0, 696, 4], "proof_steps": [{"text": "intros n m.", "goal_before": ["forall n m : nat, m = S n -> m * (1 + n) = m * m"], "goal_after": ["m = S n -> m * (1 + n) = m * m"], "proof_term_before": [], "proof_term_after": ["(fun n m : nat => ?Goal)"]}, {"text": "intros H.", "goal_before": ["m = S n -> m * (1 + n) = m * m"], "goal_after": ["m * (1 + n) = m * m"], "proof_term_before": ["(fun n m : nat => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (H : m = S n) => ?Goal)"]}, {"text": "unfold plus.", "goal_before": ["m * (1 + n) = m * m"], "goal_after": ["m * S n = m * m"], "proof_term_before": ["(fun (n m : nat) (H : m = S n) => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (H : m = S n) => ?Goal : m * (1 + n) = m * m)"]}, {"text": "rewrite -> H.", "goal_before": ["m * S n = m * m"], "goal_after": ["S n * S n = S n * S n"], "proof_term_before": ["(fun (n m : nat) (H : m = S n) => ?Goal : m * (1 + n) = m * m)"], "proof_term_after": ["(fun (n m : nat) (H : m = S n) =>\n eq_ind_r (fun m0 : nat => m0 * S n = m0 * m0) ?Goal H : m * (1 + n) = m * m)"]}, {"text": "reflexivity.", "goal_before": ["S n * S n = S n * S n"], "goal_after": [], "proof_term_before": ["(fun (n m : nat) (H : m = S n) =>\n eq_ind_r (fun m0 : nat => m0 * S n = m0 * m0) ?Goal H : m * (1 + n) = m * m)"], "proof_term_after": ["(fun (n m : nat) (H : m = S n) =>\n eq_ind_r (fun m0 : nat => m0 * S n = m0 * m0) eq_refl H\n :\n m * (1 + n) = m * m)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n m : nat) (H : m = S n) =>\n eq_ind_r (fun m0 : nat => m0 * S n = m0 * m0) eq_refl H\n :\n m * (1 + n) = m * m)"], "proof_term_after": []}]}, "plus_1_neq_0_first_try": {"text": "Theorem plus_1_neq_0_first_try: forall n: nat,\n    (n + 1) =? 0 = false.\n  intros n.\n  unfold eqb.\n  simpl.\n  destruct n as [| n1].\n  -  simpl.\n     reflexivity.\n  -  simpl.\n    reflexivity.\nQed.\n", "definition": " forall n: nat,\n    (n + 1) =? 0 = false.", "proof": "\n  intros n.\n  unfold eqb.\n  simpl.\n  destruct n as [| n1].\n  -  simpl.\n     reflexivity.\n  -  simpl.\n    reflexivity.\n", "def_ranges": [699, 0, 700, 25], "proof_ranges": [701, 0, 709, 4], "proof_steps": [{"text": "intros n.", "goal_before": ["forall n : nat, (n + 1 =? 0) = false"], "goal_after": ["(n + 1 =? 0) = false"], "proof_term_before": [], "proof_term_after": ["(fun n : nat => ?Goal)"]}, {"text": "unfold eqb.", "goal_before": ["(n + 1 =? 0) = false"], "goal_after": ["(fix eqb (n0 m : nat) {struct n0} : bool :=\n   match n0 with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n1 => match m with\n             | 0 => false\n             | S m1 => eqb n1 m1\n             end\n   end) (n + 1) 0 = false"], "proof_term_before": ["(fun n : nat => ?Goal)"], "proof_term_after": ["(fun n : nat => ?Goal : (n + 1 =? 0) = false)"]}, {"text": "simpl.", "goal_before": ["(fix eqb (n0 m : nat) {struct n0} : bool :=\n   match n0 with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n1 => match m with\n             | 0 => false\n             | S m1 => eqb n1 m1\n             end\n   end) (n + 1) 0 = false"], "goal_after": ["(fix eqb (n0 m : nat) {struct n0} : bool :=\n   match n0 with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n1 => match m with\n             | 0 => false\n             | S m1 => eqb n1 m1\n             end\n   end) (n + 1) 0 = false"], "proof_term_before": ["(fun n : nat => ?Goal : (n + 1 =? 0) = false)"], "proof_term_after": ["(fun n : nat =>\n (?Goal\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"]}, {"text": "destruct n as [| n1].", "goal_before": ["(fix eqb (n0 m : nat) {struct n0} : bool :=\n   match n0 with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n1 => match m with\n             | 0 => false\n             | S m1 => eqb n1 m1\n             end\n   end) (n + 1) 0 = false"], "goal_after": ["(fix eqb (n m : nat) {struct n} : bool :=\n   match n with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n1 => match m with\n             | 0 => false\n             | S m1 => eqb n1 m1\n             end\n   end) (0 + 1) 0 = false", "(fix eqb (n m : nat) {struct n} : bool :=\n   match n with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n0 => match m with\n             | 0 => false\n             | S m1 => eqb n0 m1\n             end\n   end) (S n1 + 1) 0 = false"], "proof_term_before": ["(fun n : nat =>\n (?Goal\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"], "proof_term_after": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 => ?Goal\n  | S n0 => (fun n1 : nat => ?Goal0) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"]}, {"text": "simpl.", "goal_before": ["(fix eqb (n m : nat) {struct n} : bool :=\n   match n with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n1 => match m with\n             | 0 => false\n             | S m1 => eqb n1 m1\n             end\n   end) (0 + 1) 0 = false", "(fix eqb (n m : nat) {struct n} : bool :=\n   match n with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n0 => match m with\n             | 0 => false\n             | S m1 => eqb n0 m1\n             end\n   end) (S n1 + 1) 0 = false"], "goal_after": ["false = false", "(fix eqb (n m : nat) {struct n} : bool :=\n   match n with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n0 => match m with\n             | 0 => false\n             | S m1 => eqb n0 m1\n             end\n   end) (S n1 + 1) 0 = false"], "proof_term_before": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 => ?Goal\n  | S n0 => (fun n1 : nat => ?Goal0) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"], "proof_term_after": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 =>\n      ?Goal0\n      :\n      (fix eqb (n0 m : nat) {struct n0} : bool :=\n         match n0 with\n         | 0 => match m with\n                | 0 => true\n                | S _ => false\n                end\n         | S n1 => match m with\n                   | 0 => false\n                   | S m1 => eqb n1 m1\n                   end\n         end) (0 + 1) 0 = false\n  | S n0 => (fun n1 : nat => ?Goal) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"]}, {"text": "reflexivity.", "goal_before": ["false = false", "(fix eqb (n m : nat) {struct n} : bool :=\n   match n with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n0 => match m with\n             | 0 => false\n             | S m1 => eqb n0 m1\n             end\n   end) (S n1 + 1) 0 = false"], "goal_after": ["(fix eqb (n m : nat) {struct n} : bool :=\n   match n with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n0 => match m with\n             | 0 => false\n             | S m1 => eqb n0 m1\n             end\n   end) (S n1 + 1) 0 = false"], "proof_term_before": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 =>\n      ?Goal0\n      :\n      (fix eqb (n0 m : nat) {struct n0} : bool :=\n         match n0 with\n         | 0 => match m with\n                | 0 => true\n                | S _ => false\n                end\n         | S n1 => match m with\n                   | 0 => false\n                   | S m1 => eqb n1 m1\n                   end\n         end) (0 + 1) 0 = false\n  | S n0 => (fun n1 : nat => ?Goal) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"], "proof_term_after": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 =>\n      eq_refl\n      :\n      (fix eqb (n0 m : nat) {struct n0} : bool :=\n         match n0 with\n         | 0 => match m with\n                | 0 => true\n                | S _ => false\n                end\n         | S n1 => match m with\n                   | 0 => false\n                   | S m1 => eqb n1 m1\n                   end\n         end) (0 + 1) 0 = false\n  | S n0 => (fun n1 : nat => ?Goal) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"]}, {"text": "simpl.", "goal_before": ["(fix eqb (n m : nat) {struct n} : bool :=\n   match n with\n   | 0 => match m with\n          | 0 => true\n          | S _ => false\n          end\n   | S n0 => match m with\n             | 0 => false\n             | S m1 => eqb n0 m1\n             end\n   end) (S n1 + 1) 0 = false"], "goal_after": ["false = false"], "proof_term_before": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 =>\n      eq_refl\n      :\n      (fix eqb (n0 m : nat) {struct n0} : bool :=\n         match n0 with\n         | 0 => match m with\n                | 0 => true\n                | S _ => false\n                end\n         | S n1 => match m with\n                   | 0 => false\n                   | S m1 => eqb n1 m1\n                   end\n         end) (0 + 1) 0 = false\n  | S n0 => (fun n1 : nat => ?Goal) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"], "proof_term_after": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 =>\n      eq_refl\n      :\n      (fix eqb (n0 m : nat) {struct n0} : bool :=\n         match n0 with\n         | 0 => match m with\n                | 0 => true\n                | S _ => false\n                end\n         | S n1 => match m with\n                   | 0 => false\n                   | S m1 => eqb n1 m1\n                   end\n         end) (0 + 1) 0 = false\n  | S n0 =>\n      (fun n1 : nat =>\n       ?Goal\n       :\n       (fix eqb (n2 m : nat) {struct n2} : bool :=\n          match n2 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n3 => match m with\n                    | 0 => false\n                    | S m1 => eqb n3 m1\n                    end\n          end) (S n1 + 1) 0 = false) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"]}, {"text": "reflexivity.", "goal_before": ["false = false"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 =>\n      eq_refl\n      :\n      (fix eqb (n0 m : nat) {struct n0} : bool :=\n         match n0 with\n         | 0 => match m with\n                | 0 => true\n                | S _ => false\n                end\n         | S n1 => match m with\n                   | 0 => false\n                   | S m1 => eqb n1 m1\n                   end\n         end) (0 + 1) 0 = false\n  | S n0 =>\n      (fun n1 : nat =>\n       ?Goal\n       :\n       (fix eqb (n2 m : nat) {struct n2} : bool :=\n          match n2 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n3 => match m with\n                    | 0 => false\n                    | S m1 => eqb n3 m1\n                    end\n          end) (S n1 + 1) 0 = false) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"], "proof_term_after": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 =>\n      eq_refl\n      :\n      (fix eqb (n0 m : nat) {struct n0} : bool :=\n         match n0 with\n         | 0 => match m with\n                | 0 => true\n                | S _ => false\n                end\n         | S n1 => match m with\n                   | 0 => false\n                   | S m1 => eqb n1 m1\n                   end\n         end) (0 + 1) 0 = false\n  | S n0 =>\n      (fun n1 : nat =>\n       eq_refl\n       :\n       (fix eqb (n2 m : nat) {struct n2} : bool :=\n          match n2 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n3 => match m with\n                    | 0 => false\n                    | S m1 => eqb n3 m1\n                    end\n          end) (S n1 + 1) 0 = false) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n (match\n    n as n0\n    return\n      ((fix eqb (n1 m : nat) {struct n1} : bool :=\n          match n1 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n2 => match m with\n                    | 0 => false\n                    | S m1 => eqb n2 m1\n                    end\n          end) (n0 + 1) 0 = false)\n  with\n  | 0 =>\n      eq_refl\n      :\n      (fix eqb (n0 m : nat) {struct n0} : bool :=\n         match n0 with\n         | 0 => match m with\n                | 0 => true\n                | S _ => false\n                end\n         | S n1 => match m with\n                   | 0 => false\n                   | S m1 => eqb n1 m1\n                   end\n         end) (0 + 1) 0 = false\n  | S n0 =>\n      (fun n1 : nat =>\n       eq_refl\n       :\n       (fix eqb (n2 m : nat) {struct n2} : bool :=\n          match n2 with\n          | 0 => match m with\n                 | 0 => true\n                 | S _ => false\n                 end\n          | S n3 => match m with\n                    | 0 => false\n                    | S m1 => eqb n3 m1\n                    end\n          end) (S n1 + 1) 0 = false) n0\n  end\n  :\n  (fix eqb (n0 m : nat) {struct n0} : bool :=\n     match n0 with\n     | 0 => match m with\n            | 0 => true\n            | S _ => false\n            end\n     | S n1 => match m with\n               | 0 => false\n               | S m1 => eqb n1 m1\n               end\n     end) (n + 1) 0 = false)\n :\n (n + 1 =? 0) = false)"], "proof_term_after": []}]}, "negb_involutive": {"text": "Theorem negb_involutive: forall b: bool,\n    negb (negb b) = b.\n  intros b. destruct b. unfold negb. reflexivity.\n  unfold negb. reflexivity. Qed.\n", "definition": " forall b: bool,\n    negb (negb b) = b.", "proof": "\n  intros b. destruct b. unfold negb. reflexivity.\n  unfold negb. reflexivity. ", "def_ranges": [733, 0, 734, 22], "proof_ranges": [735, 0, 736, 32], "proof_steps": [{"text": "intros b.", "goal_before": ["forall b : bool, negb (negb b) = b"], "goal_after": ["negb (negb b) = b"], "proof_term_before": [], "proof_term_after": ["(fun b : bool => ?Goal)"]}, {"text": "destruct b.", "goal_before": ["negb (negb b) = b"], "goal_after": ["negb (negb true) = true", "negb (negb false) = false"], "proof_term_before": ["(fun b : bool => ?Goal)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => ?Goal\n | false => ?Goal0\n end)"]}, {"text": "unfold negb.", "goal_before": ["negb (negb true) = true", "negb (negb false) = false"], "goal_after": ["true = true", "negb (negb false) = false"], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => ?Goal\n | false => ?Goal0\n end)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => ?Goal0 : negb (negb true) = true\n | false => ?Goal\n end)"]}, {"text": "reflexivity.", "goal_before": ["true = true", "negb (negb false) = false"], "goal_after": ["negb (negb false) = false"], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => ?Goal0 : negb (negb true) = true\n | false => ?Goal\n end)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => eq_refl : negb (negb true) = true\n | false => ?Goal\n end)"]}, {"text": "unfold negb.", "goal_before": ["negb (negb false) = false"], "goal_after": ["false = false"], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => eq_refl : negb (negb true) = true\n | false => ?Goal\n end)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => eq_refl : negb (negb true) = true\n | false => ?Goal : negb (negb false) = false\n end)"]}, {"text": "reflexivity.", "goal_before": ["false = false"], "goal_after": [], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => eq_refl : negb (negb true) = true\n | false => ?Goal : negb (negb false) = false\n end)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => eq_refl : negb (negb true) = true\n | false => eq_refl : negb (negb false) = false\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (negb (negb b0) = b0) with\n | true => eq_refl : negb (negb true) = true\n | false => eq_refl : negb (negb false) = false\n end)"], "proof_term_after": []}]}, "andb_commutative1": {"text": "Theorem andb_commutative1: forall b c, andb b c = andb c b.\n  intros b c. destruct b eqn:Eb.\n  { destruct c eqn:Ec.\n    { reflexivity. } \n    { reflexivity. } }\n  { destruct c eqn:Ec.\n    { reflexivity. }\n    { reflexivity. } }\n  Qed.\n", "definition": " forall b c, andb b c = andb c b.", "proof": "\n  intros b c. destruct b eqn:Eb.\n  { destruct c eqn:Ec.\n    { reflexivity. } \n    { reflexivity. } }\n  { destruct c eqn:Ec.\n    { reflexivity. }\n    { reflexivity. } }\n  ", "def_ranges": [742, 0, 742, 59], "proof_ranges": [743, 0, 750, 6], "proof_steps": [{"text": "intros b c.", "goal_before": ["forall b c : bool, b && c = c && b"], "goal_after": ["b && c = c && b"], "proof_term_before": [], "proof_term_after": ["(fun b c : bool => ?Goal)"]}, {"text": "destruct b eqn:Eb.", "goal_before": ["b && c = c && b"], "goal_after": ["true && c = c && true", "false && c = c && false"], "proof_term_before": ["(fun b c : bool => ?Goal)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true => fun Eb0 : b = true => ?Goal@{Eb:=Eb0}\n | false => fun Eb0 : b = false => ?Goal0@{Eb:=Eb0}\n end Eb)"]}, {"text": "destruct c eqn:Ec.", "goal_before": ["true && c = c && true", "false && c = c && false"], "goal_after": ["true && true = true && true", "true && false = false && true", "false && c = c && false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true => fun Eb0 : b = true => ?Goal@{Eb:=Eb0}\n | false => fun Eb0 : b = false => ?Goal0@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun Ec0 : c = true => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     | false => fun Ec0 : c = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true && true = true && true", "true && false = false && true", "false && c = c && false"], "goal_after": ["true && false = false && true", "false && c = c && false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun Ec0 : c = true => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     | false => fun Ec0 : c = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true && false = false && true", "false && c = c && false"], "goal_after": ["false && c = c && false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "destruct c eqn:Ec.", "goal_before": ["false && c = c && false"], "goal_after": ["false && true = true && false", "false && false = false && false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> false && b2 = b2 && false) with\n     | true => fun Ec0 : c = true => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["false && true = true && false", "false && false = false && false"], "goal_after": ["false && false = false && false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> false && b2 = b2 && false) with\n     | true => fun Ec0 : c = true => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> false && b2 = b2 && false) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun Ec0 : c = false => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["false && false = false && false"], "goal_after": [], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> false && b2 = b2 && false) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun Ec0 : c = false => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n | false =>\n     fun _ : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> false && b2 = b2 && false) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n end Eb)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = c && b1) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 = b2 && true) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n | false =>\n     fun _ : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> false && b2 = b2 && false) with\n     | true => fun _ : c = true => eq_refl\n     | false => fun _ : c = false => eq_refl\n     end Ec\n end Eb)"], "proof_term_after": []}]}, "andb3_exchange": {"text": "Theorem andb3_exchange:\n  forall b c d, andb (andb b c) d = andb (andb b d) c.\n  intros b c d. destruct b eqn:Eb.\n  - destruct c eqn:Ec.\n    { destruct d eqn:Ed.\n      reflexivity.\n      reflexivity. }\n    { destruct d eqn:Ed.\n      reflexivity.\n      reflexivity. }\n  - destruct c eqn:Ec.\n    { destruct d eqn:Ed.\n      - reflexivity.\n      - reflexivity.\n    }\n    { destruct d eqn:Ed.\n      - reflexivity.\n      - reflexivity.\n    }\nQed.\n", "definition": "\n  forall b c d, andb (andb b c) d = andb (andb b d) c.", "proof": "\n  intros b c d. destruct b eqn:Eb.\n  - destruct c eqn:Ec.\n    { destruct d eqn:Ed.\n      reflexivity.\n      reflexivity. }\n    { destruct d eqn:Ed.\n      reflexivity.\n      reflexivity. }\n  - destruct c eqn:Ec.\n    { destruct d eqn:Ed.\n      - reflexivity.\n      - reflexivity.\n    }\n    { destruct d eqn:Ed.\n      - reflexivity.\n      - reflexivity.\n    }\n", "def_ranges": [753, 0, 754, 54], "proof_ranges": [755, 0, 772, 4], "proof_steps": [{"text": "intros b c d.", "goal_before": ["forall b c d : bool, b && c && d = b && d && c"], "goal_after": ["b && c && d = b && d && c"], "proof_term_before": [], "proof_term_after": ["(fun b c d : bool => ?Goal)"]}, {"text": "destruct b eqn:Eb.", "goal_before": ["b && c && d = b && d && c"], "goal_after": ["true && c && d = true && d && c", "false && c && d = false && d && c"], "proof_term_before": ["(fun b c d : bool => ?Goal)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true => fun Eb0 : b = true => ?Goal@{Eb:=Eb0}\n | false => fun Eb0 : b = false => ?Goal0@{Eb:=Eb0}\n end Eb)"]}, {"text": "destruct c eqn:Ec.", "goal_before": ["true && c && d = true && d && c", "false && c && d = false && d && c"], "goal_after": ["true && true && d = true && d && true", "true && false && d = true && d && false", "false && c && d = false && d && c"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true => fun Eb0 : b = true => ?Goal@{Eb:=Eb0}\n | false => fun Eb0 : b = false => ?Goal0@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true => fun Ec0 : c = true => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     | false => fun Ec0 : c = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "destruct d eqn:Ed.", "goal_before": ["true && true && d = true && d && true", "true && false && d = true && d && false", "false && c && d = false && d && c"], "goal_after": ["true && true && true = true && true && true", "true && true && false = true && false && true", "true && false && d = true && d && false", "false && c && d = false && d && c"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true => fun Ec0 : c = true => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     | false => fun Ec0 : c = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun Ec0 : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun Ed0 : d = true => ?Goal1@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         | false => fun Ed0 : d = false => ?Goal2@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true && true && true = true && true && true", "true && true && false = true && false && true", "true && false && d = true && d && false", "false && c && d = false && d && c"], "goal_after": ["true && true && false = true && false && true", "true && false && d = true && d && false", "false && c && d = false && d && c"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun Ec0 : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun Ed0 : d = true => ?Goal1@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         | false => fun Ed0 : d = false => ?Goal2@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun Ec0 : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun Ed0 : d = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true && true && false = true && false && true", "true && false && d = true && d && false", "false && c && d = false && d && c"], "goal_after": ["true && false && d = true && d && false", "false && c && d = false && d && c"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun Ec0 : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun Ed0 : d = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "destruct d eqn:Ed.", "goal_before": ["true && false && d = true && d && false", "false && c && d = false && d && c"], "goal_after": ["true && false && true = true && true && false", "true && false && false = true && false && false", "false && c && d = false && d && c"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun Ec0 : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun Ed0 : d = true => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         | false => fun Ed0 : d = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true && false && true = true && true && false", "true && false && false = true && false && false", "false && c && d = false && d && c"], "goal_after": ["true && false && false = true && false && false", "false && c && d = false && d && c"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun Ec0 : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun Ed0 : d = true => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         | false => fun Ed0 : d = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun Ec0 : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun Ed0 : d = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true && false && false = true && false && false", "false && c && d = false && d && c"], "goal_after": ["false && c && d = false && d && c"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun Eb0 : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun Ec0 : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun Ed0 : d = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "destruct c eqn:Ec.", "goal_before": ["false && c && d = false && d && c"], "goal_after": ["false && true && d = false && d && true", "false && false && d = false && d && false"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true => fun Ec0 : c = true => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"]}, {"text": "destruct d eqn:Ed.", "goal_before": ["false && true && d = false && d && true", "false && false && d = false && d && false"], "goal_after": ["false && true && true = false && true && true", "false && true && false = false && false && true", "false && false && d = false && d && false"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true => fun Ec0 : c = true => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     | false => fun Ec0 : c = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun Ec0 : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun Ed0 : d = true => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         | false => fun Ed0 : d = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["false && true && true = false && true && true", "false && true && false = false && false && true", "false && false && d = false && d && false"], "goal_after": ["false && true && false = false && false && true", "false && false && d = false && d && false"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun Ec0 : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun Ed0 : d = true => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         | false => fun Ed0 : d = false => ?Goal1@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun Ec0 : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun Ed0 : d = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["false && true && false = false && false && true", "false && false && d = false && d && false"], "goal_after": ["false && false && d = false && d && false"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun Ec0 : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun Ed0 : d = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"]}, {"text": "destruct d eqn:Ed.", "goal_before": ["false && false && d = false && d && false"], "goal_after": ["false && false && true = false && true && false", "false && false && false = false && false && false"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false => fun Ec0 : c = false => ?Goal@{Eb:=Eb0; Ec:=Ec0}\n     end Ec\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun Ec0 : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && false && b3 = false && b3 && false)\n         with\n         | true => fun Ed0 : d = true => ?Goal@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         | false => fun Ed0 : d = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     end Ec\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["false && false && true = false && true && false", "false && false && false = false && false && false"], "goal_after": ["false && false && false = false && false && false"], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun Ec0 : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && false && b3 = false && b3 && false)\n         with\n         | true => fun Ed0 : d = true => ?Goal@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         | false => fun Ed0 : d = false => ?Goal0@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     end Ec\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun Ec0 : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && false && b3 = false && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun Ed0 : d = false => ?Goal@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     end Ec\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["false && false && false = false && false && false"], "goal_after": [], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun Eb0 : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun Ec0 : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && false && b3 = false && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun Ed0 : d = false => ?Goal@{Eb:=Eb0; Ec:=Ec0; Ed:=Ed0}\n         end Ed\n     end Ec\n end Eb)"], "proof_term_after": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun _ : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && false && b3 = false && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n end Eb)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun b c d : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c && d = b1 && d && c) with\n | true =>\n     fun _ : b = true =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match b1 as b2 return (c = b2 -> true && b2 && d = true && d && b2) with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && true && b3 = true && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> true && false && b3 = true && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n | false =>\n     fun _ : b = false =>\n     let b1 := c in\n     let Ec : c = b1 := eq_refl in\n     match\n       b1 as b2 return (c = b2 -> false && b2 && d = false && d && b2)\n     with\n     | true =>\n         fun _ : c = true =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && true && b3 = false && b3 && true)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     | false =>\n         fun _ : c = false =>\n         let b2 := d in\n         let Ed : d = b2 := eq_refl in\n         match\n           b2 as b3\n           return (d = b3 -> false && false && b3 = false && b3 && false)\n         with\n         | true => fun _ : d = true => eq_refl\n         | false => fun _ : d = false => eq_refl\n         end Ed\n     end Ec\n end Eb)"], "proof_term_after": []}]}, "plus_1_neq_00": {"text": "Theorem plus_1_neq_00: forall n: nat,\n    (n + 1) =? 0 = false.\nProof.\n  intros [|n].\n  - reflexivity.\n  - reflexivity.\nQed.\n", "definition": " forall n: nat,\n    (n + 1) =? 0 = false.\n", "proof": "\n  intros [|n].\n  - reflexivity.\n  - reflexivity.\n", "def_ranges": [797, 0, 798, 25], "proof_ranges": [799, 0, 803, 4], "proof_steps": [{"text": "intros [|n].", "goal_before": ["forall n : nat, (n + 1 =? 0) = false"], "goal_after": ["(0 + 1 =? 0) = false", "(S n + 1 =? 0) = false"], "proof_term_before": [], "proof_term_after": ["(fun n0 : nat =>\n match n0 as n return ((n + 1 =? 0) = false) with\n | 0 => ?Goal\n | S n => (fun n1 : nat => ?Goal0@{n:=n1}) n\n end)"]}, {"text": "reflexivity.", "goal_before": ["(0 + 1 =? 0) = false", "(S n + 1 =? 0) = false"], "goal_after": ["(S n + 1 =? 0) = false"], "proof_term_before": ["(fun n0 : nat =>\n match n0 as n return ((n + 1 =? 0) = false) with\n | 0 => ?Goal\n | S n => (fun n1 : nat => ?Goal0@{n:=n1}) n\n end)"], "proof_term_after": ["(fun n0 : nat =>\n match n0 as n return ((n + 1 =? 0) = false) with\n | 0 => eq_refl\n | S n => (fun n1 : nat => ?Goal@{n:=n1}) n\n end)"]}, {"text": "reflexivity.", "goal_before": ["(S n + 1 =? 0) = false"], "goal_after": [], "proof_term_before": ["(fun n0 : nat =>\n match n0 as n return ((n + 1 =? 0) = false) with\n | 0 => eq_refl\n | S n => (fun n1 : nat => ?Goal@{n:=n1}) n\n end)"], "proof_term_after": ["(fun n0 : nat =>\n match n0 as n return ((n + 1 =? 0) = false) with\n | 0 => eq_refl\n | S n => (fun _ : nat => eq_refl) n\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n0 : nat =>\n match n0 as n return ((n + 1 =? 0) = false) with\n | 0 => eq_refl\n | S n => (fun _ : nat => eq_refl) n\n end)"], "proof_term_after": []}]}, "andb_comm": {"text": "Theorem andb_comm:\n  forall b c, andb b c = andb c b.\nProof.\n  intros [] [].\n  - reflexivity.\n  - reflexivity.\n  - reflexivity.\n  - reflexivity.\nQed.\n", "definition": "\n  forall b c, andb b c = andb c b.\n", "proof": "\n  intros [] [].\n  - reflexivity.\n  - reflexivity.\n  - reflexivity.\n  - reflexivity.\n", "def_ranges": [808, 0, 809, 34], "proof_ranges": [810, 0, 816, 4], "proof_steps": [{"text": "intros [] [].", "goal_before": ["forall b c : bool, b && c = c && b"], "goal_after": ["true && true = true && true", "true && false = false && true", "false && true = true && false", "false && false = false && false"], "proof_term_before": [], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => ?Goal\n     | false => ?Goal0\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => ?Goal1\n     | false => ?Goal2\n     end\n end)"]}, {"text": "reflexivity.", "goal_before": ["true && true = true && true", "true && false = false && true", "false && true = true && false", "false && false = false && false"], "goal_after": ["true && false = false && true", "false && true = true && false", "false && false = false && false"], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => ?Goal\n     | false => ?Goal0\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => ?Goal1\n     | false => ?Goal2\n     end\n end)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => eq_refl\n     | false => ?Goal\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => ?Goal0\n     | false => ?Goal1\n     end\n end)"]}, {"text": "reflexivity.", "goal_before": ["true && false = false && true", "false && true = true && false", "false && false = false && false"], "goal_after": ["false && true = true && false", "false && false = false && false"], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => eq_refl\n     | false => ?Goal\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => ?Goal0\n     | false => ?Goal1\n     end\n end)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => eq_refl\n     | false => eq_refl\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => ?Goal\n     | false => ?Goal0\n     end\n end)"]}, {"text": "reflexivity.", "goal_before": ["false && true = true && false", "false && false = false && false"], "goal_after": ["false && false = false && false"], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => eq_refl\n     | false => eq_refl\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => ?Goal\n     | false => ?Goal0\n     end\n end)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => eq_refl\n     | false => eq_refl\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => eq_refl\n     | false => ?Goal\n     end\n end)"]}, {"text": "reflexivity.", "goal_before": ["false && false = false && false"], "goal_after": [], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => eq_refl\n     | false => eq_refl\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => eq_refl\n     | false => ?Goal\n     end\n end)"], "proof_term_after": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => eq_refl\n     | false => eq_refl\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => eq_refl\n     | false => eq_refl\n     end\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun b : bool =>\n match b as b0 return (forall c : bool, b0 && c = c && b0) with\n | true =>\n     fun c : bool =>\n     match c as b0 return (true && b0 = b0 && true) with\n     | true => eq_refl\n     | false => eq_refl\n     end\n | false =>\n     fun c : bool =>\n     match c as b0 return (false && b0 = b0 && false) with\n     | true => eq_refl\n     | false => eq_refl\n     end\n end)"], "proof_term_after": []}]}, "andb_true_elim2": {"text": "Theorem andb_true_elim2: forall b c: bool,\n    andb b c = true -> c = true.\nProof.\n  intros b c.  destruct c eqn:Ec.\n  - destruct b eqn: Eb.\n    intro H.\n    reflexivity.\n    intro H.\n    reflexivity.\n  -  destruct b.\n     unfold andb.\n     intro H.\n     exact H.\n     unfold andb.\n     intro H.\n     exact H.\nQed.\n", "definition": " forall b c: bool,\n    andb b c = true -> c = true.\n", "proof": "\n  intros b c.  destruct c eqn:Ec.\n  - destruct b eqn: Eb.\n    intro H.\n    reflexivity.\n    intro H.\n    reflexivity.\n  -  destruct b.\n     unfold andb.\n     intro H.\n     exact H.\n     unfold andb.\n     intro H.\n     exact H.\n", "def_ranges": [820, 0, 821, 32], "proof_ranges": [822, 0, 836, 4], "proof_steps": [{"text": "intros b c.", "goal_before": ["forall b c : bool, b && c = true -> c = true"], "goal_after": ["b && c = true -> c = true"], "proof_term_before": [], "proof_term_after": ["(fun b c : bool => ?Goal)"]}, {"text": "destruct c eqn:Ec.", "goal_before": ["b && c = true -> c = true"], "goal_after": ["b && true = true -> true = true", "b && false = true -> false = true"], "proof_term_before": ["(fun b c : bool => ?Goal)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true => fun Ec0 : c = true => ?Goal@{Ec:=Ec0}\n | false => fun Ec0 : c = false => ?Goal0@{Ec:=Ec0}\n end Ec)"]}, {"text": "destruct b eqn: Eb.", "goal_before": ["b && true = true -> true = true", "b && false = true -> false = true"], "goal_after": ["true && true = true -> true = true", "false && true = true -> true = true", "b && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true => fun Ec0 : c = true => ?Goal@{Ec:=Ec0}\n | false => fun Ec0 : c = false => ?Goal0@{Ec:=Ec0}\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun Ec0 : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun Eb0 : b = true => ?Goal0@{Ec:=Ec0; Eb:=Eb0}\n     | false => fun Eb0 : b = false => ?Goal1@{Ec:=Ec0; Eb:=Eb0}\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"]}, {"text": "intro H.", "goal_before": ["true && true = true -> true = true", "false && true = true -> true = true", "b && false = true -> false = true"], "goal_after": ["true = true", "false && true = true -> true = true", "b && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun Ec0 : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun Eb0 : b = true => ?Goal0@{Ec:=Ec0; Eb:=Eb0}\n     | false => fun Eb0 : b = false => ?Goal1@{Ec:=Ec0; Eb:=Eb0}\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun Ec0 : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true =>\n         fun (Eb0 : b = true) (H : true && true = true) =>\n         ?Goal1@{Ec:=Ec0; Eb:=Eb0}\n     | false => fun Eb0 : b = false => ?Goal0@{Ec:=Ec0; Eb:=Eb0}\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"]}, {"text": "reflexivity.", "goal_before": ["true = true", "false && true = true -> true = true", "b && false = true -> false = true"], "goal_after": ["false && true = true -> true = true", "b && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun Ec0 : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true =>\n         fun (Eb0 : b = true) (H : true && true = true) =>\n         ?Goal1@{Ec:=Ec0; Eb:=Eb0}\n     | false => fun Eb0 : b = false => ?Goal0@{Ec:=Ec0; Eb:=Eb0}\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun Ec0 : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun Eb0 : b = false => ?Goal0@{Ec:=Ec0; Eb:=Eb0}\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"]}, {"text": "intro H.", "goal_before": ["false && true = true -> true = true", "b && false = true -> false = true"], "goal_after": ["true = true", "b && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun Ec0 : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun Eb0 : b = false => ?Goal0@{Ec:=Ec0; Eb:=Eb0}\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun Ec0 : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false =>\n         fun (Eb0 : b = false) (H : false && true = true) =>\n         ?Goal0@{Ec:=Ec0; Eb:=Eb0}\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"]}, {"text": "reflexivity.", "goal_before": ["true = true", "b && false = true -> false = true"], "goal_after": ["b && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun Ec0 : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false =>\n         fun (Eb0 : b = false) (H : false && true = true) =>\n         ?Goal0@{Ec:=Ec0; Eb:=Eb0}\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"]}, {"text": "destruct b.", "goal_before": ["b && false = true -> false = true"], "goal_after": ["true && false = true -> false = true", "false && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false => fun Ec0 : c = false => ?Goal@{Ec:=Ec0}\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true => ?Goal@{Ec:=Ec0}\n     | false => ?Goal0@{Ec:=Ec0}\n     end\n end Ec)"]}, {"text": "unfold andb.", "goal_before": ["true && false = true -> false = true", "false && false = true -> false = true"], "goal_after": ["false = true -> false = true", "false && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true => ?Goal@{Ec:=Ec0}\n     | false => ?Goal0@{Ec:=Ec0}\n     end\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true => ?Goal0@{Ec:=Ec0} : true && false = true -> false = true\n     | false => ?Goal@{Ec:=Ec0}\n     end\n end Ec)"]}, {"text": "intro H.", "goal_before": ["false = true -> false = true", "false && false = true -> false = true"], "goal_after": ["false = true", "false && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true => ?Goal0@{Ec:=Ec0} : true && false = true -> false = true\n     | false => ?Goal@{Ec:=Ec0}\n     end\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => ?Goal0@{Ec:=Ec0})\n         :\n         true && false = true -> false = true\n     | false => ?Goal@{Ec:=Ec0}\n     end\n end Ec)"]}, {"text": "exact H.", "goal_before": ["false = true", "false && false = true -> false = true"], "goal_after": ["false && false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => ?Goal0@{Ec:=Ec0})\n         :\n         true && false = true -> false = true\n     | false => ?Goal@{Ec:=Ec0}\n     end\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => H) : true && false = true -> false = true\n     | false => ?Goal@{Ec:=Ec0}\n     end\n end Ec)"]}, {"text": "unfold andb.", "goal_before": ["false && false = true -> false = true"], "goal_after": ["false = true -> false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => H) : true && false = true -> false = true\n     | false => ?Goal@{Ec:=Ec0}\n     end\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => H) : true && false = true -> false = true\n     | false => ?Goal@{Ec:=Ec0} : false && false = true -> false = true\n     end\n end Ec)"]}, {"text": "intro H.", "goal_before": ["false = true -> false = true"], "goal_after": ["false = true"], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => H) : true && false = true -> false = true\n     | false => ?Goal@{Ec:=Ec0} : false && false = true -> false = true\n     end\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => H) : true && false = true -> false = true\n     | false =>\n         (fun H : false = true => ?Goal@{Ec:=Ec0})\n         :\n         false && false = true -> false = true\n     end\n end Ec)"]}, {"text": "exact H.", "goal_before": ["false = true"], "goal_after": [], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun Ec0 : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => H) : true && false = true -> false = true\n     | false =>\n         (fun H : false = true => ?Goal@{Ec:=Ec0})\n         :\n         false && false = true -> false = true\n     end\n end Ec)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun _ : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => H) : true && false = true -> false = true\n     | false =>\n         (fun H : false = true => H) : false && false = true -> false = true\n     end\n end Ec)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun b c : bool =>\n let b0 := c in\n let Ec : c = b0 := eq_refl in\n match b0 as b1 return (c = b1 -> b && b1 = true -> b1 = true) with\n | true =>\n     fun _ : c = true =>\n     let b1 := b in\n     let Eb : b = b1 := eq_refl in\n     match b1 as b2 return (b = b2 -> b2 && true = true -> true = true) with\n     | true => fun (_ : b = true) (_ : true && true = true) => eq_refl\n     | false => fun (_ : b = false) (_ : false && true = true) => eq_refl\n     end Eb\n | false =>\n     fun _ : c = false =>\n     match b as b1 return (b1 && false = true -> false = true) with\n     | true =>\n         (fun H : false = true => H) : true && false = true -> false = true\n     | false =>\n         (fun H : false = true => H) : false && false = true -> false = true\n     end\n end Ec)"], "proof_term_after": []}]}, "zero_nbeq_plus_1": {"text": "Theorem zero_nbeq_plus_1: forall n: nat,\n    0 =? (n + 1) = false.\n  intros n. simpl. unfold plus. simpl. destruct n.\n  - reflexivity.\n  - reflexivity.\nQed.\n", "definition": " forall n: nat,\n    0 =? (n + 1) = false.", "proof": "\n  intros n. simpl. unfold plus. simpl. destruct n.\n  - reflexivity.\n  - reflexivity.\n", "def_ranges": [847, 0, 848, 25], "proof_ranges": [849, 0, 852, 4], "proof_steps": [{"text": "intros n.", "goal_before": ["forall n : nat, (0 =? n + 1) = false"], "goal_after": ["(0 =? n + 1) = false"], "proof_term_before": [], "proof_term_after": ["(fun n : nat => ?Goal)"]}, {"text": "simpl.", "goal_before": ["(0 =? n + 1) = false"], "goal_after": ["match n + 1 with\n| 0 => true\n| S _ => false\nend = false"], "proof_term_before": ["(fun n : nat => ?Goal)"], "proof_term_after": ["(fun n : nat => ?Goal : (0 =? n + 1) = false)"]}, {"text": "unfold plus.", "goal_before": ["match n + 1 with\n| 0 => true\n| S _ => false\nend = false"], "goal_after": ["match\n  (fix add (n0 m : nat) {struct n0} : nat :=\n     match n0 with\n     | 0 => m\n     | S p => S (add p m)\n     end) n 1\nwith\n| 0 => true\n| S _ => false\nend = false"], "proof_term_before": ["(fun n : nat => ?Goal : (0 =? n + 1) = false)"], "proof_term_after": ["(fun n : nat =>\n (?Goal : match n + 1 with\n          | 0 => true\n          | S _ => false\n          end = false)\n :\n (0 =? n + 1) = false)"]}, {"text": "simpl.", "goal_before": ["match\n  (fix add (n0 m : nat) {struct n0} : nat :=\n     match n0 with\n     | 0 => m\n     | S p => S (add p m)\n     end) n 1\nwith\n| 0 => true\n| S _ => false\nend = false"], "goal_after": ["match\n  (fix add (n0 m : nat) {struct n0} : nat :=\n     match n0 with\n     | 0 => m\n     | S p => S (add p m)\n     end) n 1\nwith\n| 0 => true\n| S _ => false\nend = false"], "proof_term_before": ["(fun n : nat =>\n (?Goal : match n + 1 with\n          | 0 => true\n          | S _ => false\n          end = false)\n :\n (0 =? n + 1) = false)"], "proof_term_after": ["(fun n : nat =>\n ((?Goal\n   :\n   match\n     (fix add (n0 m : nat) {struct n0} : nat :=\n        match n0 with\n        | 0 => m\n        | S p => S (add p m)\n        end) n 1\n   with\n   | 0 => true\n   | S _ => false\n   end = false)\n  :\n  match n + 1 with\n  | 0 => true\n  | S _ => false\n  end = false)\n :\n (0 =? n + 1) = false)"]}, {"text": "destruct n.", "goal_before": ["match\n  (fix add (n0 m : nat) {struct n0} : nat :=\n     match n0 with\n     | 0 => m\n     | S p => S (add p m)\n     end) n 1\nwith\n| 0 => true\n| S _ => false\nend = false"], "goal_after": ["false = false", "false = false"], "proof_term_before": ["(fun n : nat =>\n ((?Goal\n   :\n   match\n     (fix add (n0 m : nat) {struct n0} : nat :=\n        match n0 with\n        | 0 => m\n        | S p => S (add p m)\n        end) n 1\n   with\n   | 0 => true\n   | S _ => false\n   end = false)\n  :\n  match n + 1 with\n  | 0 => true\n  | S _ => false\n  end = false)\n :\n (0 =? n + 1) = false)"], "proof_term_after": ["(fun n : nat =>\n ((match\n     n as n0\n     return\n       (match\n          (fix add (n1 m : nat) {struct n1} : nat :=\n             match n1 with\n             | 0 => m\n             | S p => S (add p m)\n             end) n0 1\n        with\n        | 0 => true\n        | S _ => false\n        end = false)\n   with\n   | 0 => ?Goal\n   | S n0 => (fun n1 : nat => ?Goal0@{n:=n1}) n0\n   end\n   :\n   match\n     (fix add (n0 m : nat) {struct n0} : nat :=\n        match n0 with\n        | 0 => m\n        | S p => S (add p m)\n        end) n 1\n   with\n   | 0 => true\n   | S _ => false\n   end = false)\n  :\n  match n + 1 with\n  | 0 => true\n  | S _ => false\n  end = false)\n :\n (0 =? n + 1) = false)"]}, {"text": "reflexivity.", "goal_before": ["false = false", "false = false"], "goal_after": ["false = false"], "proof_term_before": ["(fun n : nat =>\n ((match\n     n as n0\n     return\n       (match\n          (fix add (n1 m : nat) {struct n1} : nat :=\n             match n1 with\n             | 0 => m\n             | S p => S (add p m)\n             end) n0 1\n        with\n        | 0 => true\n        | S _ => false\n        end = false)\n   with\n   | 0 => ?Goal\n   | S n0 => (fun n1 : nat => ?Goal0@{n:=n1}) n0\n   end\n   :\n   match\n     (fix add (n0 m : nat) {struct n0} : nat :=\n        match n0 with\n        | 0 => m\n        | S p => S (add p m)\n        end) n 1\n   with\n   | 0 => true\n   | S _ => false\n   end = false)\n  :\n  match n + 1 with\n  | 0 => true\n  | S _ => false\n  end = false)\n :\n (0 =? n + 1) = false)"], "proof_term_after": ["(fun n : nat =>\n ((match\n     n as n0\n     return\n       (match\n          (fix add (n1 m : nat) {struct n1} : nat :=\n             match n1 with\n             | 0 => m\n             | S p => S (add p m)\n             end) n0 1\n        with\n        | 0 => true\n        | S _ => false\n        end = false)\n   with\n   | 0 => eq_refl\n   | S n0 => (fun n1 : nat => ?Goal@{n:=n1}) n0\n   end\n   :\n   match\n     (fix add (n0 m : nat) {struct n0} : nat :=\n        match n0 with\n        | 0 => m\n        | S p => S (add p m)\n        end) n 1\n   with\n   | 0 => true\n   | S _ => false\n   end = false)\n  :\n  match n + 1 with\n  | 0 => true\n  | S _ => false\n  end = false)\n :\n (0 =? n + 1) = false)"]}, {"text": "reflexivity.", "goal_before": ["false = false"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n ((match\n     n as n0\n     return\n       (match\n          (fix add (n1 m : nat) {struct n1} : nat :=\n             match n1 with\n             | 0 => m\n             | S p => S (add p m)\n             end) n0 1\n        with\n        | 0 => true\n        | S _ => false\n        end = false)\n   with\n   | 0 => eq_refl\n   | S n0 => (fun n1 : nat => ?Goal@{n:=n1}) n0\n   end\n   :\n   match\n     (fix add (n0 m : nat) {struct n0} : nat :=\n        match n0 with\n        | 0 => m\n        | S p => S (add p m)\n        end) n 1\n   with\n   | 0 => true\n   | S _ => false\n   end = false)\n  :\n  match n + 1 with\n  | 0 => true\n  | S _ => false\n  end = false)\n :\n (0 =? n + 1) = false)"], "proof_term_after": ["(fun n : nat =>\n ((match\n     n as n0\n     return\n       (match\n          (fix add (n1 m : nat) {struct n1} : nat :=\n             match n1 with\n             | 0 => m\n             | S p => S (add p m)\n             end) n0 1\n        with\n        | 0 => true\n        | S _ => false\n        end = false)\n   with\n   | 0 => eq_refl\n   | S n0 => (fun _ : nat => eq_refl) n0\n   end\n   :\n   match\n     (fix add (n0 m : nat) {struct n0} : nat :=\n        match n0 with\n        | 0 => m\n        | S p => S (add p m)\n        end) n 1\n   with\n   | 0 => true\n   | S _ => false\n   end = false)\n  :\n  match n + 1 with\n  | 0 => true\n  | S _ => false\n  end = false)\n :\n (0 =? n + 1) = false)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n ((match\n     n as n0\n     return\n       (match\n          (fix add (n1 m : nat) {struct n1} : nat :=\n             match n1 with\n             | 0 => m\n             | S p => S (add p m)\n             end) n0 1\n        with\n        | 0 => true\n        | S _ => false\n        end = false)\n   with\n   | 0 => eq_refl\n   | S n0 => (fun _ : nat => eq_refl) n0\n   end\n   :\n   match\n     (fix add (n0 m : nat) {struct n0} : nat :=\n        match n0 with\n        | 0 => m\n        | S p => S (add p m)\n        end) n 1\n   with\n   | 0 => true\n   | S _ => false\n   end = false)\n  :\n  match n + 1 with\n  | 0 => true\n  | S _ => false\n  end = false)\n :\n (0 =? n + 1) = false)"], "proof_term_after": []}]}, "identity_fn_applied_twice": {"text": "Theorem identity_fn_applied_twice:\n  forall (f: bool -> bool),\n    (forall (x: bool), f x = x) ->\n    forall (b: bool), f (f b) = b.\n  intros. rewrite H. rewrite H. reflexivity. Qed.\n", "definition": "\n  forall (f: bool -> bool),\n    (forall (x: bool), f x = x) ->\n    forall (b: bool), f (f b) = b.", "proof": "\n  intros. rewrite H. rewrite H. reflexivity. ", "def_ranges": [932, 0, 935, 34], "proof_ranges": [936, 0, 936, 49], "proof_steps": [{"text": "intros.", "goal_before": ["forall f : bool -> bool,\n(forall x : bool, f x = x) -> forall b : bool, f (f b) = b"], "goal_after": ["f (f b) = b"], "proof_term_before": [], "proof_term_after": ["(fun (f : bool -> bool) (H : forall x : bool, f x = x) (b : bool) => ?Goal)"]}, {"text": "rewrite H.", "goal_before": ["f (f b) = b"], "goal_after": ["f b = b"], "proof_term_before": ["(fun (f : bool -> bool) (H : forall x : bool, f x = x) (b : bool) => ?Goal)"], "proof_term_after": ["(fun (f : bool -> bool) (H : forall x : bool, f x = x) (b : bool) =>\n eq_ind_r (fun b0 : bool => b0 = b) ?Goal (H (f b)))"]}, {"text": "rewrite H.", "goal_before": ["f b = b"], "goal_after": ["b = b"], "proof_term_before": ["(fun (f : bool -> bool) (H : forall x : bool, f x = x) (b : bool) =>\n eq_ind_r (fun b0 : bool => b0 = b) ?Goal (H (f b)))"], "proof_term_after": ["(fun (f : bool -> bool) (H : forall x : bool, f x = x) (b : bool) =>\n eq_ind_r (fun b0 : bool => b0 = b)\n   (eq_ind_r (fun b0 : bool => b0 = b) ?Goal (H b)) \n   (H (f b)))"]}, {"text": "reflexivity.", "goal_before": ["b = b"], "goal_after": [], "proof_term_before": ["(fun (f : bool -> bool) (H : forall x : bool, f x = x) (b : bool) =>\n eq_ind_r (fun b0 : bool => b0 = b)\n   (eq_ind_r (fun b0 : bool => b0 = b) ?Goal (H b)) \n   (H (f b)))"], "proof_term_after": ["(fun (f : bool -> bool) (H : forall x : bool, f x = x) (b : bool) =>\n eq_ind_r (fun b0 : bool => b0 = b)\n   (eq_ind_r (fun b0 : bool => b0 = b) eq_refl (H b)) \n   (H (f b)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (f : bool -> bool) (H : forall x : bool, f x = x) (b : bool) =>\n eq_ind_r (fun b0 : bool => b0 = b)\n   (eq_ind_r (fun b0 : bool => b0 = b) eq_refl (H b)) \n   (H (f b)))"], "proof_term_after": []}]}, "andb_eq_orb": {"text": "Theorem andb_eq_orb:\n  forall (b c : bool),    (andb b c = orb b c) -> b = c.\nProof.\n  intros b c.\n  destruct b eqn:Eb.\n  - destruct c.\n    { simpl. intros. reflexivity. }\n    { simpl. intros. rewrite H. reflexivity. }\n  - destruct c.\n    { simpl. intros. rewrite H. reflexivity. }\n    { simpl. reflexivity. }\nQed.\n", "definition": "\n  forall (b c : bool),    (andb b c = orb b c) -> b = c.\n", "proof": "\n  intros b c.\n  destruct b eqn:Eb.\n  - destruct c.\n    { simpl. intros. reflexivity. }\n    { simpl. intros. rewrite H. reflexivity. }\n  - destruct c.\n    { simpl. intros. rewrite H. reflexivity. }\n    { simpl. reflexivity. }\n", "def_ranges": [959, 0, 960, 56], "proof_ranges": [961, 0, 970, 4], "proof_steps": [{"text": "intros b c.", "goal_before": ["forall b c : bool, b && c = b || c -> b = c"], "goal_after": ["b && c = b || c -> b = c"], "proof_term_before": [], "proof_term_after": ["(fun b c : bool => ?Goal)"]}, {"text": "destruct b eqn:Eb.", "goal_before": ["b && c = b || c -> b = c"], "goal_after": ["true && c = true || c -> true = c", "false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool => ?Goal)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true => fun Eb0 : b = true => ?Goal@{Eb:=Eb0}\n | false => fun Eb0 : b = false => ?Goal0@{Eb:=Eb0}\n end Eb)"]}, {"text": "destruct c.", "goal_before": ["true && c = true || c -> true = c", "false && c = false || c -> false = c"], "goal_after": ["true && true = true || true -> true = true", "true && false = true || false -> true = false", "false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true => fun Eb0 : b = true => ?Goal@{Eb:=Eb0}\n | false => fun Eb0 : b = false => ?Goal0@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true => ?Goal0@{Eb:=Eb0}\n     | false => ?Goal1@{Eb:=Eb0}\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "simpl.", "goal_before": ["true && true = true || true -> true = true", "true && false = true || false -> true = false", "false && c = false || c -> false = c"], "goal_after": ["true = true -> true = true", "true && false = true || false -> true = false", "false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true => ?Goal0@{Eb:=Eb0}\n     | false => ?Goal1@{Eb:=Eb0}\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true => ?Goal1@{Eb:=Eb0} : true && true = true || true -> true = true\n     | false => ?Goal0@{Eb:=Eb0}\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "intros.", "goal_before": ["true = true -> true = true", "true && false = true || false -> true = false", "false && c = false || c -> false = c"], "goal_after": ["true = true", "true && false = true || false -> true = false", "false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true => ?Goal1@{Eb:=Eb0} : true && true = true || true -> true = true\n     | false => ?Goal0@{Eb:=Eb0}\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun H : true = true => ?Goal1@{Eb:=Eb0})\n         :\n         true && true = true || true -> true = true\n     | false => ?Goal0@{Eb:=Eb0}\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true = true", "true && false = true || false -> true = false", "false && c = false || c -> false = c"], "goal_after": ["true && false = true || false -> true = false", "false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun H : true = true => ?Goal1@{Eb:=Eb0})\n         :\n         true && true = true || true -> true = true\n     | false => ?Goal0@{Eb:=Eb0}\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false => ?Goal0@{Eb:=Eb0}\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "simpl.", "goal_before": ["true && false = true || false -> true = false", "false && c = false || c -> false = c"], "goal_after": ["false = true -> true = false", "false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false => ?Goal0@{Eb:=Eb0}\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         ?Goal0@{Eb:=Eb0} : true && false = true || false -> true = false\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "intros.", "goal_before": ["false = true -> true = false", "false && c = false || c -> false = c"], "goal_after": ["true = false", "false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         ?Goal0@{Eb:=Eb0} : true && false = true || false -> true = false\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true => ?Goal0@{Eb:=Eb0})\n         :\n         true && false = true || false -> true = false\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "rewrite H.", "goal_before": ["true = false", "false && c = false || c -> false = c"], "goal_after": ["true = true", "false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true => ?Goal0@{Eb:=Eb0})\n         :\n         true && false = true || false -> true = false\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) ?Goal0@{Eb:=Eb0} H)\n         :\n         true && false = true || false -> true = false\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true = true", "false && c = false || c -> false = c"], "goal_after": ["false && c = false || c -> false = c"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun Eb0 : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) ?Goal0@{Eb:=Eb0} H)\n         :\n         true && false = true || false -> true = false\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"]}, {"text": "destruct c.", "goal_before": ["false && c = false || c -> false = c"], "goal_after": ["false && true = false || true -> false = true", "false && false = false || false -> false = false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false => fun Eb0 : b = false => ?Goal@{Eb:=Eb0}\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true => ?Goal@{Eb:=Eb0}\n     | false => ?Goal0@{Eb:=Eb0}\n     end\n end Eb)"]}, {"text": "simpl.", "goal_before": ["false && true = false || true -> false = true", "false && false = false || false -> false = false"], "goal_after": ["false = true -> false = true", "false && false = false || false -> false = false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true => ?Goal@{Eb:=Eb0}\n     | false => ?Goal0@{Eb:=Eb0}\n     end\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         ?Goal0@{Eb:=Eb0} : false && true = false || true -> false = true\n     | false => ?Goal@{Eb:=Eb0}\n     end\n end Eb)"]}, {"text": "intros.", "goal_before": ["false = true -> false = true", "false && false = false || false -> false = false"], "goal_after": ["false = true", "false && false = false || false -> false = false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         ?Goal0@{Eb:=Eb0} : false && true = false || true -> false = true\n     | false => ?Goal@{Eb:=Eb0}\n     end\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true => ?Goal0@{Eb:=Eb0})\n         :\n         false && true = false || true -> false = true\n     | false => ?Goal@{Eb:=Eb0}\n     end\n end Eb)"]}, {"text": "rewrite H.", "goal_before": ["false = true", "false && false = false || false -> false = false"], "goal_after": ["true = true", "false && false = false || false -> false = false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true => ?Goal0@{Eb:=Eb0})\n         :\n         false && true = false || true -> false = true\n     | false => ?Goal@{Eb:=Eb0}\n     end\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => b1 = true) ?Goal0@{Eb:=Eb0} H)\n         :\n         false && true = false || true -> false = true\n     | false => ?Goal@{Eb:=Eb0}\n     end\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["true = true", "false && false = false || false -> false = false"], "goal_after": ["false && false = false || false -> false = false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => b1 = true) ?Goal0@{Eb:=Eb0} H)\n         :\n         false && true = false || true -> false = true\n     | false => ?Goal@{Eb:=Eb0}\n     end\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => b1 = true) eq_refl H)\n         :\n         false && true = false || true -> false = true\n     | false => ?Goal@{Eb:=Eb0}\n     end\n end Eb)"]}, {"text": "simpl.", "goal_before": ["false && false = false || false -> false = false"], "goal_after": ["false = false -> false = false"], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => b1 = true) eq_refl H)\n         :\n         false && true = false || true -> false = true\n     | false => ?Goal@{Eb:=Eb0}\n     end\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => b1 = true) eq_refl H)\n         :\n         false && true = false || true -> false = true\n     | false =>\n         ?Goal@{Eb:=Eb0} : false && false = false || false -> false = false\n     end\n end Eb)"]}, {"text": "reflexivity.", "goal_before": ["false = false -> false = false"], "goal_after": [], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun Eb0 : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => b1 = true) eq_refl H)\n         :\n         false && true = false || true -> false = true\n     | false =>\n         ?Goal@{Eb:=Eb0} : false && false = false || false -> false = false\n     end\n end Eb)"], "proof_term_after": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun _ : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => b1 = true) eq_refl H)\n         :\n         false && true = false || true -> false = true\n     | false =>\n         (fun _ : false = false => eq_refl)\n         :\n         false && false = false || false -> false = false\n     end\n end Eb)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun b c : bool =>\n let b0 := b in\n let Eb : b = b0 := eq_refl in\n match b0 as b1 return (b = b1 -> b1 && c = b1 || c -> b1 = c) with\n | true =>\n     fun _ : b = true =>\n     match c as b1 return (true && b1 = true || b1 -> true = b1) with\n     | true =>\n         (fun _ : true = true => eq_refl)\n         :\n         true && true = true || true -> true = true\n     | false =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => true = b1) eq_refl H)\n         :\n         true && false = true || false -> true = false\n     end\n | false =>\n     fun _ : b = false =>\n     match c as b1 return (false && b1 = false || b1 -> false = b1) with\n     | true =>\n         (fun H : false = true =>\n          eq_ind_r (fun b1 : bool => b1 = true) eq_refl H)\n         :\n         false && true = false || true -> false = true\n     | false =>\n         (fun _ : false = false => eq_refl)\n         :\n         false && false = false || false -> false = false\n     end\n end Eb)"], "proof_term_after": []}]}}