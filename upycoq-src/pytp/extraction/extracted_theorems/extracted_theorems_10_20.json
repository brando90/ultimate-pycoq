[{"path": "/home/jizej/proverbot9001/coq-projects/InfSeqExt/subseq.v", "name": "subseq_inf_often", "text": "Theorem subseq_inf_often :\n  forall P si s, subseqs si s -> always1 P si -> inf_often P s.\nProof using.\nintros P. red. cofix sio.\nintros si s su a.\nconstructor.\n- apply subseqs_eventually with si; assumption.\n- genclear a. case su. \n  clear su si s; intros (s0, si) s sf su a; simpl in * |- * . \n  apply (sio si); clear sio.\n  * induction sf; simpl.\n    trivial. \n    apply subseqs_tl. assumption (* induction hyp *). \n  * change (always1 P (tl (Cons s0 si))). case a; simpl; trivial. \nQed.\n", "definition": "\n  forall P si s, subseqs si s -> always1 P si -> inf_often P s.", "proof": "\nProof using.\nintros P. red. cofix sio.\nintros si s su a.\nconstructor.\n- apply subseqs_eventually with si; assumption.\n- genclear a. case su. \n  clear su si s; intros (s0, si) s sf su a; simpl in * |- * . \n  apply (sio si); clear sio.\n  * induction sf; simpl.\n    trivial. \n    apply subseqs_tl. assumption (* induction hyp *). \n  * change (always1 P (tl (Cons s0 si))). case a; simpl; trivial. \n", "def_ranges": [66, 0, 67, 63], "proof_ranges": [68, 0, 80, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (P : infseq T -> Prop) (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> inf_often P s"], "goal_after": ["forall (P : infseq T -> Prop) (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> inf_often P s"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros P.", "goal_before": ["forall (P : infseq T -> Prop) (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> inf_often P s"], "goal_after": ["forall (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> inf_often P s"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun P : infseq T -> Prop => ?Goal)"]}, {"text": "red.", "goal_before": ["forall (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> inf_often P s"], "goal_after": ["forall (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> always (eventually P) s"], "proof_term_before": ["(fun P : infseq T -> Prop => ?Goal)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n ?Goal\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "cofix sio.", "goal_before": ["forall (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> always (eventually P) s"], "goal_after": ["forall (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> always (eventually P) s"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n ?Goal\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio :\n      forall (si : infseq (infseq T)) (s : infseq T),\n      subseqs si s -> always1 P si -> always (eventually P) s :=\n    ?Goal)\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "intros si s su a.", "goal_before": ["forall (si : infseq (infseq T)) (s : infseq T),\nsubseqs si s -> always1 P si -> always (eventually P) s"], "goal_after": ["always (eventually P) s"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio :\n      forall (si : infseq (infseq T)) (s : infseq T),\n      subseqs si s -> always1 P si -> always (eventually P) s :=\n    ?Goal)\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    ?Goal)\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "constructor.", "goal_before": ["always (eventually P) s"], "goal_after": ["eventually P s", "always (eventually P) (tl s)"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    ?Goal)\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s ?Goal ?Goal0)\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "apply subseqs_eventually with si; assumption.", "goal_before": ["eventually P s", "always (eventually P) (tl s)"], "goal_after": ["always (eventually P) (tl s)"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s ?Goal ?Goal0)\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a) ?Goal)\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "genclear a.", "goal_before": ["always (eventually P) (tl s)"], "goal_after": ["always1 P si -> always (eventually P) (tl s)"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a) ?Goal)\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a) (?Goal a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "case su.", "goal_before": ["always1 P si -> always (eventually P) (tl s)"], "goal_after": ["forall (si0 : infseq (infseq T)) (s0 : infseq T),\nsuff (hd si0) s0 ->\nsubseqs (tl si0) (tl (hd si0)) ->\nalways1 P si0 -> always (eventually P) (tl s0)"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a) (?Goal a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 => ?Goal si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "clear su si s; intros (s0, si) s sf su a; simpl in * |- * .", "goal_before": ["forall (si0 : infseq (infseq T)) (s0 : infseq T),\nsuff (hd si0) s0 ->\nsubseqs (tl si0) (tl (hd si0)) ->\nalways1 P si0 -> always (eventually P) (tl s0)"], "goal_after": ["always (eventually P) (tl s)"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 => ?Goal si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "apply (sio si); clear sio.", "goal_before": ["always (eventually P) (tl s)"], "goal_after": ["subseqs si (tl s)", "always1 P si"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                   ?Goal0@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "induction sf; simpl.", "goal_before": ["subseqs si (tl s)", "always1 P si"], "goal_after": ["subseqs si (tl s0)", "subseqs si s1", "always1 P si"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                   ?Goal0@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (?Goal0@{s0:=s1; si:=si2; su:=su0; a:=a0}\n                       :\n                       subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (sf0 : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       ?Goal1@{s0:=s1; si:=si2; x:=x1; s1:=s3; sf:=sf0;\n                               su:=su0; a:=a0}\n                       :\n                       subseqs si2 (tl (Cons x1 s3))) s2 sf)\n                   ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "trivial.", "goal_before": ["subseqs si (tl s0)", "subseqs si s1", "always1 P si"], "goal_after": ["subseqs si s1", "always1 P si"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (?Goal0@{s0:=s1; si:=si2; su:=su0; a:=a0}\n                       :\n                       subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (sf0 : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       ?Goal1@{s0:=s1; si:=si2; x:=x1; s1:=s3; sf:=sf0;\n                               su:=su0; a:=a0}\n                       :\n                       subseqs si2 (tl (Cons x1 s3))) s2 sf)\n                   ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (sf0 : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       ?Goal0@{s0:=s1; si:=si2; x:=x1; s1:=s3; sf:=sf0;\n                               su:=su0; a:=a0}\n                       :\n                       subseqs si2 (tl (Cons x1 s3))) s2 sf)\n                   ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "apply subseqs_tl.", "goal_before": ["subseqs si s1", "always1 P si"], "goal_after": ["subseqs si (tl s1)", "always1 P si"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (sf0 : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       ?Goal0@{s0:=s1; si:=si2; x:=x1; s1:=s3; sf:=sf0;\n                               su:=su0; a:=a0}\n                       :\n                       subseqs si2 (tl (Cons x1 s3))) s2 sf)\n                   ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (sf0 : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       subseqs_tl si2 s3\n                         ?Goal0@{s0:=s1; si:=si2; x:=x1; s1:=s3; sf:=sf0;\n                                 su:=su0; a:=a0}\n                       :\n                       subseqs si2 (tl (Cons x1 s3))) s2 sf)\n                   ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "assumption.", "goal_before": ["subseqs si (tl s1)", "always1 P si"], "goal_after": ["always1 P si"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (sf0 : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       subseqs_tl si2 s3\n                         ?Goal0@{s0:=s1; si:=si2; x:=x1; s1:=s3; sf:=sf0;\n                                 su:=su0; a:=a0}\n                       :\n                       subseqs si2 (tl (Cons x1 s3))) s2 sf)\n                   ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (_ : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       subseqs_tl si2 s3 IHsf : subseqs si2 (tl (Cons x1 s3)))\n                      s2 sf) ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "change (always1 P (tl (Cons s0 si))).", "goal_before": ["always1 P si"], "goal_after": ["always1 P (tl (Cons s0 si))"], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (_ : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       subseqs_tl si2 s3 IHsf : subseqs si2 (tl (Cons x1 s3)))\n                      s2 sf) ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (_ : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       subseqs_tl si2 s3 IHsf : subseqs si2 (tl (Cons x1 s3)))\n                      s2 sf) ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "case a; simpl; trivial.", "goal_before": ["always1 P (tl (Cons s0 si))"], "goal_after": [], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (_ : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       subseqs_tl si2 s3 IHsf : subseqs si2 (tl (Cons x1 s3)))\n                      s2 sf) ?Goal@{s0:=s1; si:=si2; s:=s2; su:=su0; a:=a0}\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (_ : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       subseqs_tl si2 s3 IHsf : subseqs si2 (tl (Cons x1 s3)))\n                      s2 sf)\n                   match a0 in (always1 _ i0) return (always1 P (tl i0)) with\n                   | Always1 _ _ x1 s3 x2 x3 =>\n                       ((fun (x4 : infseq T) (s4 : infseq (infseq T))\n                           (_ : P x4) (H0 : always1 P s4) => H0)\n                        :\n                        forall (x4 : infseq T) (s4 : infseq (infseq T)),\n                        P x4 -> always1 P s4 -> always1 P (tl (Cons x4 s4)))\n                         x1 s3 x2 x3\n                   end\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun P : infseq T -> Prop =>\n (cofix sio\n    (si : infseq (infseq T)) (s : infseq T) (su : subseqs si s)\n    (a : always1 P si) : always (eventually P) s :=\n    Always T (eventually P) s (subseqs_eventually P si s su a)\n      (match\n         su in (subseqs i i0)\n         return (always1 P i -> always (eventually P) (tl i0))\n       with\n       | Subseqs si0 s0 x x0 =>\n           (fun si1 : infseq (infseq T) =>\n            match\n              si1 as i\n              return\n                (forall s1 : infseq T,\n                 suff (hd i) s1 ->\n                 subseqs (tl i) (tl (hd i)) ->\n                 always1 P i -> always (eventually P) (tl s1))\n            with\n            | Cons t i =>\n                (fun (s1 : infseq T) (si2 : infseq (infseq T))\n                   (s2 : infseq T) (sf : suff (hd (Cons s1 si2)) s2)\n                   (su0 : subseqs (tl (Cons s1 si2)) (tl (hd (Cons s1 si2))))\n                   (a0 : always1 P (Cons s1 si2)) =>\n                 sio si2 (tl s2)\n                   (suff_ind s1 (fun s3 : infseq T => subseqs si2 (tl s3))\n                      (su0 : subseqs si2 (tl s1))\n                      (fun (x1 : T) (s3 : infseq T) \n                         (_ : suff s1 s3) (IHsf : subseqs si2 (tl s3)) =>\n                       subseqs_tl si2 s3 IHsf : subseqs si2 (tl (Cons x1 s3)))\n                      s2 sf)\n                   match a0 in (always1 _ i0) return (always1 P (tl i0)) with\n                   | Always1 _ _ x1 s3 x2 x3 =>\n                       ((fun (x4 : infseq T) (s4 : infseq (infseq T))\n                           (_ : P x4) (H0 : always1 P s4) => H0)\n                        :\n                        forall (x4 : infseq T) (s4 : infseq (infseq T)),\n                        P x4 -> always1 P s4 -> always1 P (tl (Cons x4 s4)))\n                         x1 s3 x2 x3\n                   end\n                 :\n                 always (eventually P) (tl s2)) t i\n            end) si0 s0 x x0\n       end a))\n :\n forall (si : infseq (infseq T)) (s : infseq T),\n subseqs si s -> always1 P si -> inf_often P s)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/InfSeqExt/subseq.v", "name": "eventually_suff", "text": "Theorem eventually_suff :\n   forall P s', eventually P s' -> ex_suff P s'.\nProof using.\nintros P s ev. induction ev.   \n- exists s; [ constructor | assumption]. \n- destruct IHev. exists s0. \n  * constructor; assumption.\n  * assumption.\nQed.\n", "definition": "\n   forall P s', eventually P s' -> ex_suff P s'.", "proof": "\nProof using.\nintros P s ev. induction ev.   \n- exists s; [ constructor | assumption]. \n- destruct IHev. exists s0. \n  * constructor; assumption.\n  * assumption.\n", "def_ranges": [87, 0, 88, 48], "proof_ranges": [89, 0, 95, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (P : infseq T -> Prop) (s' : infseq T),\neventually P s' -> ex_suff P s'"], "goal_after": ["forall (P : infseq T -> Prop) (s' : infseq T),\neventually P s' -> ex_suff P s'"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros P s ev.", "goal_before": ["forall (P : infseq T -> Prop) (s' : infseq T),\neventually P s' -> ex_suff P s'"], "goal_after": ["ex_suff P s"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) => ?Goal)"]}, {"text": "induction ev.", "goal_before": ["ex_suff P s"], "goal_after": ["ex_suff P s", "ex_suff P (Cons x s)"], "proof_term_before": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) => ?Goal)"], "proof_term_after": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => ?Goal@{s:=s0})\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    => ?Goal0@{s:=s0; ev:=ev0}) s ev)"]}, {"text": "exists s; [ constructor | assumption].", "goal_before": ["ex_suff P s", "ex_suff P (Cons x s)"], "goal_after": ["ex_suff P (Cons x s)"], "proof_term_before": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => ?Goal@{s:=s0})\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    => ?Goal0@{s:=s0; ev:=ev0}) s ev)"], "proof_term_after": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    => ?Goal@{s:=s0; ev:=ev0}) s ev)"]}, {"text": "destruct IHev.", "goal_before": ["ex_suff P (Cons x s)"], "goal_after": ["ex_suff P (Cons x s)"], "proof_term_before": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    => ?Goal@{s:=s0; ev:=ev0}) s ev)"], "proof_term_after": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    =>\n    match IHev with\n    | Esp _ _ s1 x0 x1 =>\n        (fun (s2 : infseq T) (H : suff s2 s0) (H0 : P s2) =>\n         ?Goal@{s:=s0; ev:=ev0; s0:=s2}) s1 x0 x1\n    end) s ev)"]}, {"text": "exists s0.", "goal_before": ["ex_suff P (Cons x s)"], "goal_after": ["suff s0 (Cons x s)", "P s0"], "proof_term_before": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    =>\n    match IHev with\n    | Esp _ _ s1 x0 x1 =>\n        (fun (s2 : infseq T) (H : suff s2 s0) (H0 : P s2) =>\n         ?Goal@{s:=s0; ev:=ev0; s0:=s2}) s1 x0 x1\n    end) s ev)"], "proof_term_after": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    =>\n    match IHev with\n    | Esp _ _ s1 x0 x1 =>\n        (fun (s2 : infseq T) (H : suff s2 s0) (H0 : P s2) =>\n         Esp P (Cons x s0) s2 ?Goal@{s:=s0; ev:=ev0; s0:=s2}\n           ?Goal0@{s:=s0; ev:=ev0; s0:=s2}) s1 x0 x1\n    end) s ev)"]}, {"text": "constructor; assumption.", "goal_before": ["suff s0 (Cons x s)", "P s0"], "goal_after": ["P s0"], "proof_term_before": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    =>\n    match IHev with\n    | Esp _ _ s1 x0 x1 =>\n        (fun (s2 : infseq T) (H : suff s2 s0) (H0 : P s2) =>\n         Esp P (Cons x s0) s2 ?Goal@{s:=s0; ev:=ev0; s0:=s2}\n           ?Goal0@{s:=s0; ev:=ev0; s0:=s2}) s1 x0 x1\n    end) s ev)"], "proof_term_after": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    =>\n    match IHev with\n    | Esp _ _ s1 x0 x1 =>\n        (fun (s2 : infseq T) (H : suff s2 s0) (H0 : P s2) =>\n         Esp P (Cons x s0) s2 (sp_next s2 x s0 H)\n           ?Goal@{s:=s0; ev:=ev0; s0:=s2}) s1 x0 x1\n    end) s ev)"]}, {"text": "assumption.", "goal_before": ["P s0"], "goal_after": [], "proof_term_before": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (ev0 : eventually P s0) (IHev : ex_suff P s0)\n    =>\n    match IHev with\n    | Esp _ _ s1 x0 x1 =>\n        (fun (s2 : infseq T) (H : suff s2 s0) (H0 : P s2) =>\n         Esp P (Cons x s0) s2 (sp_next s2 x s0 H)\n           ?Goal@{s:=s0; ev:=ev0; s0:=s2}) s1 x0 x1\n    end) s ev)"], "proof_term_after": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (_ : eventually P s0) (IHev : ex_suff P s0)\n    =>\n    match IHev with\n    | Esp _ _ s1 x0 x1 =>\n        (fun (s2 : infseq T) (H : suff s2 s0) (H0 : P s2) =>\n         Esp P (Cons x s0) s2 (sp_next s2 x s0 H) H0) s1 x0 x1\n    end) s ev)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (P : infseq T -> Prop) (s : infseq T) (ev : eventually P s) =>\n eventually_ind T P (fun s0 : infseq T => ex_suff P s0)\n   (fun (s0 : infseq T) (H : P s0) => Esp P s0 s0 (sp_eq s0) H)\n   (fun (x : T) (s0 : infseq T) (_ : eventually P s0) (IHev : ex_suff P s0)\n    =>\n    match IHev with\n    | Esp _ _ s1 x0 x1 =>\n        (fun (s2 : infseq T) (H : suff s2 s0) (H0 : P s2) =>\n         Esp P (Cons x s0) s2 (sp_next s2 x s0 H) H0) s1 x0 x1\n    end) s ev)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/markov/markov.v", "name": "markov", "text": "Theorem markov:\n(forall(U:Type)(F:Ensemble(Ensemble U))(F':sigalg_0 _ F)(F'':sigalg_1 _ F)(F'''\n:sigalg_2 _ F)(u:forall A,F A->R)(u':msur_0 _ _ F' F'' F''' u)(u'':msur_1 _ _\nF' F'' F''' u)(u''':msur_2 _ _ F' F'' F''' u)(u'''':msur_3 _ _ F' F'' F''' u)(f\n:U->R)(f':forall x:U,f x>=0)(f'':msurable _ _ F' F'' F''' f)(a:R)(a':0<a),\nforall L,lebint _ _ _ _ _ u u' u'' u''' u'''' f f' f''(Full_set U)(sigalg_P3 U\nF F' F'' F''') L\n->u(fun x:U=>f x>=a)(msurable_P1 _ _ F' F'' F''' f f' f'' a a')<=/a*L)%R.\n\nintros U F F' F'' F''' u u' u'' u''' u'''' f f' f'' a a' L L'.\napply(Rmult_le_reg_l a). auto.\nreplace(a*(/a*L))%R with L.\n2:rewrite<-Rmult_assoc. 2:rewrite Rinv_r. 2:ring. 2:auto with real.\nset(A:=(fun x:U=>f x>=a)%R).\nset(A':=msurable_P1 U F F' F'' F''' f f' f'' a a').\nset(v:=fun i:nat=>INR i).\nset(w:=fun i:nat=>if eq_nat_dec i 0 then Complement _ A\n       else if eq_nat_dec i 1 then A else Empty_set _).\nset(I:=lebint_s U F F' F'' F''' u u' u'' u''' u'''' 2 v w\n       (simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)\n       (simple_P8 _ _ F' F'' F''' A A')(Full_set _)\n       (sigalg_P3 U F F' F'' F''')).\n\nreplace(u A A')with I.\n2:unfold I.\n2:unfold w.\n2:apply lebint_P1 with(f:=f). 2:auto. 2:auto.\n2:red. 2:intros. 2:apply Full_intro.\n\nreplace(a*I)%R with(lebint_s U F F' F'' F''' u u' u'' u''' u'''' 2(fun i=>v i*a)w\n (simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P13 U F F' F'' F''' 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)\n (simple_P7 _ _)(simple_P8 U F F' F'' F''' A A')a a')\n (Full_set _)(sigalg_P3 U F F' F'' F'''))%R.\n2:apply(lebint_P2 U F F' F'' F''' u u' u'' u''' u'''' 2 v w\n(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)\n(simple_P8 U F F' F'' F''' A A')(Full_set U)(sigalg_P3 U F F' F'' F''')a a').\n\napply(lebint_P0 U F F' F'' F''' u u' u'' u''' u'''' 2(fun i:nat=>v i*a)w\n (simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P13 U F F' F'' F''' 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)\n (simple_P7 _ _)(simple_P8 U F F' F'' F''' A A')a a')f f' f'')%R.\n2:exact L'.\n\nintro y.\nelim(simple_P0 U 2(fun i=>v i*a)w\n (simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\ny)%R.\n\nintros i p. elim(classic(i=0)).\nintro H. simpl. rewrite H. simpl. replace(0*a)%R with 0%R. intuition. ring.\nintro H. assert(H1:i=1). intuition. simpl. rewrite H1. simpl. replace(1*a)%R with a.\n2:ring.\nrewrite H1 in p. intuition. Qed.\n", "definition": "\n(forall(U:Type)(F:Ensemble(Ensemble U))(F':sigalg_0 _ F)(F'':sigalg_1 _ F)(F'''\n:sigalg_2 _ F)(u:forall A,F A->R)(u':msur_0 _ _ F' F'' F''' u)(u'':msur_1 _ _\nF' F'' F''' u)(u''':msur_2 _ _ F' F'' F''' u)(u'''':msur_3 _ _ F' F'' F''' u)(f\n:U->R)(f':forall x:U,f x>=0)(f'':msurable _ _ F' F'' F''' f)(a:R)(a':0<a),\nforall L,lebint _ _ _ _ _ u u' u'' u''' u'''' f f' f''(Full_set U)(sigalg_P3 U\nF F' F'' F''') L\n->u(fun x:U=>f x>=a)(msurable_P1 _ _ F' F'' F''' f f' f'' a a')<=/a*L)%R.", "proof": "\n\nintros U F F' F'' F''' u u' u'' u''' u'''' f f' f'' a a' L L'.\napply(Rmult_le_reg_l a). auto.\nreplace(a*(/a*L))%R with L.\n2:rewrite<-Rmult_assoc. 2:rewrite Rinv_r. 2:ring. 2:auto with real.\nset(A:=(fun x:U=>f x>=a)%R).\nset(A':=msurable_P1 U F F' F'' F''' f f' f'' a a').\nset(v:=fun i:nat=>INR i).\nset(w:=fun i:nat=>if eq_nat_dec i 0 then Complement _ A\n       else if eq_nat_dec i 1 then A else Empty_set _).\nset(I:=lebint_s U F F' F'' F''' u u' u'' u''' u'''' 2 v w\n       (simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)\n       (simple_P8 _ _ F' F'' F''' A A')(Full_set _)\n       (sigalg_P3 U F F' F'' F''')).\n\nreplace(u A A')with I.\n2:unfold I.\n2:unfold w.\n2:apply lebint_P1 with(f:=f). 2:auto. 2:auto.\n2:red. 2:intros. 2:apply Full_intro.\n\nreplace(a*I)%R with(lebint_s U F F' F'' F''' u u' u'' u''' u'''' 2(fun i=>v i*a)w\n (simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P13 U F F' F'' F''' 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)\n (simple_P7 _ _)(simple_P8 U F F' F'' F''' A A')a a')\n (Full_set _)(sigalg_P3 U F F' F'' F'''))%R.\n2:apply(lebint_P2 U F F' F'' F''' u u' u'' u''' u'''' 2 v w\n(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)\n(simple_P8 U F F' F'' F''' A A')(Full_set U)(sigalg_P3 U F F' F'' F''')a a').\n\napply(lebint_P0 U F F' F'' F''' u u' u'' u''' u'''' 2(fun i:nat=>v i*a)w\n (simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P13 U F F' F'' F''' 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)\n (simple_P7 _ _)(simple_P8 U F F' F'' F''' A A')a a')f f' f'')%R.\n2:exact L'.\n\nintro y.\nelim(simple_P0 U 2(fun i=>v i*a)w\n (simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\n(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')\ny)%R.\n\nintros i p. elim(classic(i=0)).\nintro H. simpl. rewrite H. simpl. replace(0*a)%R with 0%R. intuition. ring.\nintro H. assert(H1:i=1). intuition. simpl. rewrite H1. simpl. replace(1*a)%R with a.\n2:ring.\nrewrite H1 in p. intuition. ", "def_ranges": [673, 0, 680, 73], "proof_ranges": [681, 0, 735, 32], "proof_steps": [{"text": "intros U F F' F'' F''' u u' u'' u''' u'''' f f' f'' a a' L L'.", "goal_before": ["forall (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n  (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n  (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n  (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n  (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n  (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n  (a : R) (a' : (0 < a)%R) (L : R),\nlebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n  (Full_set U) (sigalg_P3 U F F' F'' F''') L ->\n(u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n / a * L)%R"], "goal_after": ["(u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n / a * L)%R"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) => \n ?Goal)"]}, {"text": "apply(Rmult_le_reg_l a).", "goal_before": ["(u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n / a * L)%R"], "goal_after": ["(0 < a)%R", "(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n a * (/ a * L))%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) => \n ?Goal)"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) ?Goal ?Goal0)"]}, {"text": "auto.", "goal_before": ["(0 < a)%R", "(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n a * (/ a * L))%R"], "goal_after": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n a * (/ a * L))%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) ?Goal ?Goal0)"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a' ?Goal)"]}, {"text": "replace(a*(/a*L))%R with L.", "goal_before": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n a * (/ a * L))%R"], "goal_after": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R", "L = (a * (/ a * L))%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a' ?Goal)"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R := ?Goal in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal0 (a * (/ a * L))%R H))"]}, {"text": "2:rewrite<-Rmult_assoc.", "goal_before": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R", "L = (a * (/ a * L))%R"], "goal_after": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R", "L = (a * / a * L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R := ?Goal in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal0 (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r) \n        ?Goal0 (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal (a * (/ a * L))%R H))"]}, {"text": "2:rewrite Rinv_r.", "goal_before": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R", "L = (a * / a * L)%R"], "goal_after": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R", "L = (1 * L)%R", "a <> 0%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r) \n        ?Goal0 (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R) ?Goal0 (Rinv_r a ?Goal1))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal (a * (/ a * L))%R H))"]}, {"text": "2:ring.", "goal_before": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R", "L = (1 * L)%R", "a <> 0%R"], "goal_after": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R", "a <> 0%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R) ?Goal0 (Rinv_r a ?Goal1))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true)) \n           (Rinv_r a ?Goal0)) (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal (a * (/ a * L))%R H))"]}, {"text": "2:auto with real.", "goal_before": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R", "a <> 0%R"], "goal_after": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true)) \n           (Rinv_r a ?Goal0)) (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal (a * (/ a * L))%R H))"]}, {"text": "set(A:=(fun x:U=>f x>=a)%R).", "goal_before": ["(a * u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n L)%R"], "goal_after": ["(a * u A (msurable_P1 U F F' F'' F''' f f' f'' a a') <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) ?Goal (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) (let A := fun x : U => (f x >= a)%R in ?Goal) \n      (a * (/ a * L))%R H))"]}, {"text": "set(A':=msurable_P1 U F F' F'' F''' f f' f'' a a').", "goal_before": ["(a * u A (msurable_P1 U F F' F'' F''' f f' f'' a a') <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R) (let A := fun x : U => (f x >= a)%R in ?Goal) \n      (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       ?Goal) (a * (/ a * L))%R H))"]}, {"text": "set(v:=fun i:nat=>INR i).", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "set(w:=fun i:nat=>if eq_nat_dec i 0 then Complement _ A", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": []}, {"text": "else if eq_nat_dec i 1 then A else Empty_set _).", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "set(I:=lebint_s U F F' F'' F''' u u' u'' u''' u'''' 2 v w", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "(simple_P8 _ _ F' F'' F''' A A')(Full_set _)", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "(sigalg_P3 U F F' F'' F''')).", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "replace(u A A')with I.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "2:unfold I.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "2:unfold w.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "2:apply lebint_P1 with(f:=f).", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "2:auto.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "2:auto.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "2:red.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "2:intros.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": []}, {"text": "2:apply Full_intro.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "replace(a*I)%R with(lebint_s U F F' F'' F''' u u' u'' u''' u'''' 2(fun i=>v i*a)w", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P13 U F F' F'' F''' 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P7 _ _)(simple_P8 U F F' F'' F''' A A')a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(Full_set _)(sigalg_P3 U F F' F'' F'''))%R.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "2:apply(lebint_P2 U F F' F'' F''' u u' u'' u''' u'''' 2 v w", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P8 U F F' F'' F''' A A')(Full_set U)(sigalg_P3 U F F' F'' F''')a a').", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply(lebint_P0 U F F' F'' F''' u u' u'' u''' u'''' 2(fun i:nat=>v i*a)w", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "(simple_P13 U F F' F'' F''' 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"]}, {"text": "(simple_P7 _ _)(simple_P8 U F F' F'' F''' A A')a a')f f' f'')%R.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal : (a * u A A' <= L)%R)\n      (a * (/ a * L))%R H))"]}, {"text": "2:exact L'.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal : (a * u A A' <= L)%R)\n      (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal : (a * u A A' <= L)%R)\n      (a * (/ a * L))%R H))"]}, {"text": "intro y.", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in ?Goal : (a * u A A' <= L)%R)\n      (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       (?Goal : (a * u A A' <= L)%R) : (a * u A A' <= L)%R) \n      (a * (/ a * L))%R H))"]}, {"text": "elim(simple_P0 U 2(fun i=>v i*a)w", "goal_before": ["(a * u A A' <= L)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       (?Goal : (a * u A A' <= L)%R) : (a * u A A' <= L)%R) \n      (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "(simple_P9 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "(simple_P10 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "(simple_P11 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "(simple_P12 _ 2 v w(simple_P4 _ _)(simple_P5 _ _)(simple_P6 _ _)(simple_P7 _ _)a a')", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "y)%R.", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "intros i p.", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0) : (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0 : (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "elim(classic(i=0)).", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0 : (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0 : (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "intro H.", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in ?Goal0 : (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         (?Goal0 : (a * u A A' <= L)%R) : (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "simpl.", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "a = (1 * a)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         (?Goal0 : (a * u A A' <= L)%R) : (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         ((let H1 : a = (1 * a)%R := ?Goal0 in ?Goal1) : (a * u A A' <= L)%R)\n         :\n         (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "rewrite H.", "goal_before": ["(a * u A A' <= L)%R", "a = (1 * a)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         ((let H1 : a = (1 * a)%R := ?Goal0 in ?Goal1) : (a * u A A' <= L)%R)\n         :\n         (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         ((let H1 : a = (1 * a)%R :=\n             let hyp_list := nil in\n             let fv_list := (a :: nil)%list in\n             RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n               (Ring_polynom.PEX Z 1)\n               (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                  (Ring_polynom.PEX Z 1)) I\n               (eq_refl\n                <:\n                (let lmp :=\n                   Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub\n                     Z.opp Zeq_bool Z.quotrem hyp_list in\n                 Ring_polynom.Peq Zeq_bool\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEX Z 1))\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                         (Ring_polynom.PEX Z 1)))) = true) in\n           ?Goal0)\n          :\n          (a * u A A' <= L)%R)\n         :\n         (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "simpl.", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         ((let H1 : a = (1 * a)%R :=\n             let hyp_list := nil in\n             let fv_list := (a :: nil)%list in\n             RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n               (Ring_polynom.PEX Z 1)\n               (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                  (Ring_polynom.PEX Z 1)) I\n               (eq_refl\n                <:\n                (let lmp :=\n                   Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub\n                     Z.opp Zeq_bool Z.quotrem hyp_list in\n                 Ring_polynom.Peq Zeq_bool\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEX Z 1))\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                         (Ring_polynom.PEX Z 1)))) = true) in\n           ?Goal0)\n          :\n          (a * u A A' <= L)%R)\n         :\n         (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         ((let H1 : a = (1 * a)%R :=\n             let hyp_list := nil in\n             let fv_list := (a :: nil)%list in\n             RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n               (Ring_polynom.PEX Z 1)\n               (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                  (Ring_polynom.PEX Z 1)) I\n               (eq_refl\n                <:\n                (let lmp :=\n                   Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub\n                     Z.opp Zeq_bool Z.quotrem hyp_list in\n                 Ring_polynom.Peq Zeq_bool\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEX Z 1))\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                         (Ring_polynom.PEX Z 1)))) = true) in\n           ?Goal0)\n          :\n          (a * u A A' <= L)%R)\n         :\n         (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "replace(0*a)%R with 0%R.", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         ((let H1 : a = (1 * a)%R :=\n             let hyp_list := nil in\n             let fv_list := (a :: nil)%list in\n             RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n               (Ring_polynom.PEX Z 1)\n               (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                  (Ring_polynom.PEX Z 1)) I\n               (eq_refl\n                <:\n                (let lmp :=\n                   Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub\n                     Z.opp Zeq_bool Z.quotrem hyp_list in\n                 Ring_polynom.Peq Zeq_bool\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEX Z 1))\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                         (Ring_polynom.PEX Z 1)))) = true) in\n           ?Goal0)\n          :\n          (a * u A A' <= L)%R)\n         :\n         (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         ((let H1 : a = (1 * a)%R :=\n             let hyp_list := nil in\n             let fv_list := (a :: nil)%list in\n             RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n               (Ring_polynom.PEX Z 1)\n               (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                  (Ring_polynom.PEX Z 1)) I\n               (eq_refl\n                <:\n                (let lmp :=\n                   Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub\n                     Z.opp Zeq_bool Z.quotrem hyp_list in\n                 Ring_polynom.Peq Zeq_bool\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEX Z 1))\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                         (Ring_polynom.PEX Z 1)))) = true) in\n           ?Goal0)\n          :\n          (a * u A A' <= L)%R)\n         :\n         (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"]}, {"text": "intuition.", "goal_before": ["(a * u A A' <= L)%R", "0%R = (0 * a)%R"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (F : Ensemble (Ensemble U)) (F' : sigalg_0 U F)\n   (F'' : sigalg_1 U F) (F''' : sigalg_2 U F)\n   (u : forall A : Ensemble U, F A -> R) (u' : msur_0 U F F' F'' F''' u)\n   (u'' : msur_1 U F F' F'' F''' u) (u''' : msur_2 U F F' F'' F''' u)\n   (u'''' : msur_3 U F F' F'' F''' u) (f : U -> R)\n   (f' : forall x : U, (f x >= 0)%R) (f'' : msurable U F F' F'' F''' f)\n   (a : R) (a' : (0 < a)%R) (L : R)\n   (L' : lebint U F F' F'' F''' u u' u'' u''' u'''' f f' f'' \n           (Full_set U) (sigalg_P3 U F F' F'' F''') L) =>\n Rmult_le_reg_l a\n   (u (fun x : U => (f x >= a)%R) (msurable_P1 U F F' F'' F''' f f' f'' a a'))\n   (/ a * L) a'\n   (let H : L = (a * (/ a * L))%R :=\n      eq_ind (a * / a * L)%R (fun r : R => L = r)\n        (eq_ind_r (fun r : R => L = (r * L)%R)\n           (let hyp_list := nil in\n            let fv_list := (L :: nil)%list in\n            RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n              (Ring_polynom.PEX Z 1)\n              (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                 (Ring_polynom.PEX Z 1)) I\n              (eq_refl\n               <:\n               (let lmp :=\n                  Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                    Zeq_bool Z.quotrem hyp_list in\n                Ring_polynom.Peq Zeq_bool\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEX Z 1))\n                  (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                     Zeq_bool Z.quotrem ring_subst_niter lmp\n                     (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                        (Ring_polynom.PEX Z 1)))) = true))\n           (Rinv_r a\n              (Rminus_not_eq_right a 0\n                 (Rminus_eq_contra 0 a\n                    (Rlt_dichotomy_converse 0 a (or_introl a'))))))\n        (a * (/ a * L))%R (Rmult_assoc a (/ a) L) in\n    eq_ind L\n      (fun r : R =>\n       (a *\n        u (fun x : U => f x >= a) (msurable_P1 U F F' F'' F''' f f' f'' a a') <=\n        r)%R)\n      (let A := fun x : U => (f x >= a)%R in\n       let A' : F (fun x : U => (f x >= a)%R) :=\n         msurable_P1 U F F' F'' F''' f f' f'' a a' in\n       let v := fun i : nat => INR i in\n       ((let H0 : 0%R = (0 * a)%R := ?Goal in\n         ((let H1 : a = (1 * a)%R :=\n             let hyp_list := nil in\n             let fv_list := (a :: nil)%list in\n             RField_ring_lemma1 ring_subst_niter fv_list hyp_list\n               (Ring_polynom.PEX Z 1)\n               (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                  (Ring_polynom.PEX Z 1)) I\n               (eq_refl\n                <:\n                (let lmp :=\n                   Ring_polynom.mk_monpol_list 0%Z 1%Z Z.add Z.mul Z.sub\n                     Z.opp Zeq_bool Z.quotrem hyp_list in\n                 Ring_polynom.Peq Zeq_bool\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEX Z 1))\n                   (Ring_polynom.norm_subst 0%Z 1%Z Z.add Z.mul Z.sub Z.opp\n                      Zeq_bool Z.quotrem ring_subst_niter lmp\n                      (Ring_polynom.PEmul (Ring_polynom.PEc 1%Z)\n                         (Ring_polynom.PEX Z 1)))) = true) in\n           ?Goal0)\n          :\n          (a * u A A' <= L)%R)\n         :\n         (a * u A A' <= L)%R)\n        :\n        (a * u A A' <= L)%R)\n       :\n       (a * u A A' <= L)%R) (a * (/ a * L))%R H))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UList.v", "name": "ulist_inv", "text": "Theorem ulist_inv : forall a l, ulist (a :: l) -> ulist l.\nProof using.  \nintros a l H; inversion H; auto.\nQed.\n", "definition": " forall a l, ulist (a :: l) -> ulist l.", "proof": "\nProof using.  \nintros a l H; inversion H; auto.\n", "def_ranges": [42, 0, 42, 58], "proof_ranges": [43, 0, 45, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l : list A), ulist (a :: l) -> ulist l"], "goal_after": ["forall (a : A) (l : list A), ulist (a :: l) -> ulist l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l H; inversion H; auto.", "goal_before": ["forall (a : A) (l : list A), ulist (a :: l) -> ulist l"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l : list A) (H : ulist (a :: l)) =>\n let H0 : a :: l = a :: l -> ulist l :=\n   match H in (ulist l0) return (l0 = a :: l -> ulist l) with\n   | ulist_nil =>\n       fun H0 : nil = a :: l =>\n       (fun H1 : nil = a :: l =>\n        let H2 : False :=\n          eq_ind nil\n            (fun e : list A =>\n             match e with\n             | nil => True\n             | _ :: _ => False\n             end) I (a :: l) H1 in\n        False_ind (ulist l) H2) H0\n   | ulist_cons a0 l0 x x0 =>\n       (fun (a1 : A) (l1 : list A) (H0 : ~ In a1 l1) \n          (H1 : ulist l1) (H2 : a1 :: l1 = a :: l) =>\n        (fun H3 : a1 :: l1 = a :: l =>\n         let H4 : l1 = l :=\n           f_equal\n             (fun e : list A => match e with\n                                | nil => l1\n                                | _ :: l2 => l2\n                                end) H3 in\n         (let H5 : a1 = a :=\n            f_equal\n              (fun e : list A => match e with\n                                 | nil => a1\n                                 | a2 :: _ => a2\n                                 end) H3 in\n          (fun H6 : a1 = a =>\n           let H7 : a1 = a := H6 in\n           eq_ind_r\n             (fun a2 : A => l1 = l -> ~ In a2 l1 -> ulist l1 -> ulist l)\n             (fun H8 : l1 = l =>\n              let H9 : l1 = l := H8 in\n              eq_ind_r (fun l2 : list A => ~ In a l2 -> ulist l2 -> ulist l)\n                (fun (_ : ~ In a l) (H11 : ulist l) => H11) H9) H7) H5) H4)\n          H2 H0 H1) a0 l0 x x0\n   end in\n H0 eq_refl)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (l : list A) (H : ulist (a :: l)) =>\n let H0 : a :: l = a :: l -> ulist l :=\n   match H in (ulist l0) return (l0 = a :: l -> ulist l) with\n   | ulist_nil =>\n       fun H0 : nil = a :: l =>\n       (fun H1 : nil = a :: l =>\n        let H2 : False :=\n          eq_ind nil\n            (fun e : list A =>\n             match e with\n             | nil => True\n             | _ :: _ => False\n             end) I (a :: l) H1 in\n        False_ind (ulist l) H2) H0\n   | ulist_cons a0 l0 x x0 =>\n       (fun (a1 : A) (l1 : list A) (H0 : ~ In a1 l1) \n          (H1 : ulist l1) (H2 : a1 :: l1 = a :: l) =>\n        (fun H3 : a1 :: l1 = a :: l =>\n         let H4 : l1 = l :=\n           f_equal\n             (fun e : list A => match e with\n                                | nil => l1\n                                | _ :: l2 => l2\n                                end) H3 in\n         (let H5 : a1 = a :=\n            f_equal\n              (fun e : list A => match e with\n                                 | nil => a1\n                                 | a2 :: _ => a2\n                                 end) H3 in\n          (fun H6 : a1 = a =>\n           let H7 : a1 = a := H6 in\n           eq_ind_r\n             (fun a2 : A => l1 = l -> ~ In a2 l1 -> ulist l1 -> ulist l)\n             (fun H8 : l1 = l =>\n              let H9 : l1 = l := H8 in\n              eq_ind_r (fun l2 : list A => ~ In a l2 -> ulist l2 -> ulist l)\n                (fun (_ : ~ In a l) (H11 : ulist l) => H11) H9) H7) H5) H4)\n          H2 H0 H1) a0 l0 x x0\n   end in\n H0 eq_refl)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UList.v", "name": "ulist_app", "text": "Theorem ulist_app :\n forall l1 l2,\n ulist l1 ->\n ulist l2 -> (forall a : A, In a l1 -> In a l2 -> False) -> ulist (l1 ++ l2).\nProof using.  \nintros L1; elim L1; simpl in |- *; auto.\nintros a l H l2 H0 H1 H2; apply ulist_cons; simpl in |- *; auto.\nred in |- *; intros H3; case in_app_or with (1 := H3); auto; intros H4.\ninversion H0; auto.\napply H2 with a; auto.\napply H; auto.\napply ulist_inv with (1 := H0); auto.\nintros a0 H3 H4; apply (H2 a0); auto.\nQed.\n", "definition": "\n forall l1 l2,\n ulist l1 ->\n ulist l2 -> (forall a : A, In a l1 -> In a l2 -> False) -> ulist (l1 ++ l2).", "proof": "\nProof using.  \nintros L1; elim L1; simpl in |- *; auto.\nintros a l H l2 H0 H1 H2; apply ulist_cons; simpl in |- *; auto.\nred in |- *; intros H3; case in_app_or with (1 := H3); auto; intros H4.\ninversion H0; auto.\napply H2 with a; auto.\napply H; auto.\napply ulist_inv with (1 := H0); auto.\nintros a0 H3 H4; apply (H2 a0); auto.\n", "def_ranges": [48, 0, 51, 77], "proof_ranges": [52, 0, 61, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 : list A,\nulist l1 ->\nulist l2 -> (forall a : A, In a l1 -> In a l2 -> False) -> ulist (l1 ++ l2)"], "goal_after": ["forall l1 l2 : list A,\nulist l1 ->\nulist l2 -> (forall a : A, In a l1 -> In a l2 -> False) -> ulist (l1 ++ l2)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros L1; elim L1; simpl in |- *; auto.", "goal_before": ["forall l1 l2 : list A,\nulist l1 ->\nulist l2 -> (forall a : A, In a l1 -> In a l2 -> False) -> ulist (l1 ++ l2)"], "goal_after": ["forall (a : A) (l : list A),\n(forall l2 : list A,\n ulist l ->\n ulist l2 -> (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\nforall l2 : list A,\nulist (a :: l) ->\nulist l2 ->\n(forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) ->\nulist (a :: l ++ l2)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"]}, {"text": "intros a l H l2 H0 H1 H2; apply ulist_cons; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l : list A),\n(forall l2 : list A,\n ulist l ->\n ulist l2 -> (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\nforall l2 : list A,\nulist (a :: l) ->\nulist l2 ->\n(forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) ->\nulist (a :: l ++ l2)"], "goal_after": ["~ In a (l ++ l2)", "ulist (l ++ l2)"], "proof_term_before": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"], "proof_term_after": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2) (?Goal : ~ In a (l ++ l2))\n       (?Goal0 : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"]}, {"text": "red in |- *; intros H3; case in_app_or with (1 := H3); auto; intros H4.", "goal_before": ["~ In a (l ++ l2)", "ulist (l ++ l2)"], "goal_after": ["False", "False", "ulist (l ++ l2)"], "proof_term_before": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2) (?Goal : ~ In a (l ++ l2))\n       (?Goal0 : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"], "proof_term_after": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x => (fun H4 : In a l => ?Goal0) x\n          | or_intror x => (fun H4 : In a l2 => ?Goal1) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2)) (?Goal : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"]}, {"text": "inversion H0; auto.", "goal_before": ["False", "False", "ulist (l ++ l2)"], "goal_after": ["False", "ulist (l ++ l2)"], "proof_term_before": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x => (fun H4 : In a l => ?Goal0) x\n          | or_intror x => (fun H4 : In a l2 => ?Goal1) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2)) (?Goal : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"], "proof_term_after": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x => (fun H4 : In a l2 => ?Goal0) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2)) (?Goal : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"]}, {"text": "apply H2 with a; auto.", "goal_before": ["False", "ulist (l ++ l2)"], "goal_after": ["ulist (l ++ l2)"], "proof_term_before": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x => (fun H4 : In a l2 => ?Goal0) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2)) (?Goal : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"], "proof_term_after": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x =>\n              (fun H4 : In a l2 => H2 a (or_introl eq_refl) H4) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2)) (?Goal : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"]}, {"text": "apply H; auto.", "goal_before": ["ulist (l ++ l2)"], "goal_after": ["ulist l", "forall a0 : A, In a0 l -> In a0 l2 -> False"], "proof_term_before": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x =>\n              (fun H4 : In a l2 => H2 a (or_introl eq_refl) H4) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2)) (?Goal : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"], "proof_term_after": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x =>\n              (fun H4 : In a l2 => H2 a (or_introl eq_refl) H4) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2)) (H l2 ?Goal H1 ?Goal0 : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"]}, {"text": "apply ulist_inv with (1 := H0); auto.", "goal_before": ["ulist l", "forall a0 : A, In a0 l -> In a0 l2 -> False"], "goal_after": ["forall a0 : A, In a0 l -> In a0 l2 -> False"], "proof_term_before": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x =>\n              (fun H4 : In a l2 => H2 a (or_introl eq_refl) H4) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2)) (H l2 ?Goal H1 ?Goal0 : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"], "proof_term_after": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x =>\n              (fun H4 : In a l2 => H2 a (or_introl eq_refl) H4) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2))\n       (H l2 (ulist_inv a l H0) H1 ?Goal : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"]}, {"text": "intros a0 H3 H4; apply (H2 a0); auto.", "goal_before": ["forall a0 : A, In a0 l -> In a0 l2 -> False"], "goal_after": [], "proof_term_before": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x =>\n              (fun H4 : In a l2 => H2 a (or_introl eq_refl) H4) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2))\n       (H l2 (ulist_inv a l H0) H1 ?Goal : ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"], "proof_term_after": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x =>\n              (fun H4 : In a l2 => H2 a (or_introl eq_refl) H4) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2))\n       (H l2 (ulist_inv a l H0) H1\n          (fun (a0 : A) (H3 : In a0 l) (H4 : In a0 l2) =>\n           H2 a0 (or_intror H3) H4)\n        :\n        ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun L1 : list A =>\n list_ind\n   (fun L2 : list A =>\n    forall l2 : list A,\n    ulist L2 ->\n    ulist l2 ->\n    (forall a : A, In a L2 -> In a l2 -> False) -> ulist (L2 ++ l2))\n   ((fun (l2 : list A) (_ : ulist nil) (H0 : ulist l2)\n       (_ : forall a : A, False -> In a l2 -> False) => H0)\n    :\n    forall l2 : list A,\n    ulist nil ->\n    ulist l2 ->\n    (forall a : A, In a nil -> In a l2 -> False) -> ulist (nil ++ l2))\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A,\n            ulist l ->\n            ulist l2 ->\n            (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2))\n       (l2 : list A) (H0 : ulist (a :: l)) (H1 : ulist l2)\n       (H2 : forall a0 : A, a = a0 \\/ In a0 l -> In a0 l2 -> False) =>\n     ulist_cons a (l ++ l2)\n       (((fun H3 : In a (l ++ l2) =>\n          match in_app_or l l2 a H3 with\n          | or_introl x =>\n              (fun H4 : In a l =>\n               let H5 : a :: l = a :: l -> False :=\n                 match H0 in (ulist l0) return (l0 = a :: l -> False) with\n                 | ulist_nil =>\n                     fun H5 : nil = a :: l =>\n                     (fun H6 : nil = a :: l =>\n                      let H7 : False :=\n                        eq_ind nil\n                          (fun e : list A =>\n                           match e with\n                           | nil => True\n                           | _ :: _ => False\n                           end) I (a :: l) H6 in\n                      False_ind False H7) H5\n                 | ulist_cons a0 l0 x0 x1 =>\n                     (fun (a1 : A) (l1 : list A) (H5 : ~ In a1 l1)\n                        (H6 : ulist l1) (H7 : a1 :: l1 = a :: l) =>\n                      (fun H8 : a1 :: l1 = a :: l =>\n                       let H9 : l1 = l :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => l1\n                            | _ :: l3 => l3\n                            end) H8 in\n                       (let H10 : a1 = a :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => a1\n                             | a2 :: _ => a2\n                             end) H8 in\n                        (fun H11 : a1 = a =>\n                         let H12 : a1 = a := H11 in\n                         eq_ind_r\n                           (fun a2 : A =>\n                            l1 = l -> ~ In a2 l1 -> ulist l1 -> False)\n                           (fun H13 : l1 = l =>\n                            let H14 : l1 = l := H13 in\n                            eq_ind_r\n                              (fun l3 : list A =>\n                               ~ In a l3 -> ulist l3 -> False)\n                              (fun (H15 : ~ In a l) (_ : ulist l) => H15 H4)\n                              H14) H12) H10) H9) H7 H5 H6) a0 l0 x0 x1\n                 end in\n               H5 eq_refl) x\n          | or_intror x =>\n              (fun H4 : In a l2 => H2 a (or_introl eq_refl) H4) x\n          end)\n         :\n         ~ In a (l ++ l2))\n        :\n        ~ In a (l ++ l2))\n       (H l2 (ulist_inv a l H0) H1\n          (fun (a0 : A) (H3 : In a0 l) (H4 : In a0 l2) =>\n           H2 a0 (or_intror H3) H4)\n        :\n        ulist (l ++ l2)))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A,\n     ulist l ->\n     ulist l2 ->\n     (forall a0 : A, In a0 l -> In a0 l2 -> False) -> ulist (l ++ l2)) ->\n    forall l2 : list A,\n    ulist (a :: l) ->\n    ulist l2 ->\n    (forall a0 : A, In a0 (a :: l) -> In a0 l2 -> False) ->\n    ulist ((a :: l) ++ l2)) L1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UList.v", "name": "ulist_app_inv", "text": "Theorem ulist_app_inv :\n forall l1 l2 (a : A), ulist (l1 ++ l2) -> In a l1 -> In a l2 -> False.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 a0 H0 [H1| H1] H2.\ninversion H0; auto.\ncase H5; rewrite H1; auto with datatypes.\napply (H l2 a0); auto.\napply ulist_inv with (1 := H0); auto.\nQed.\n", "definition": "\n forall l1 l2 (a : A), ulist (l1 ++ l2) -> In a l1 -> In a l2 -> False.", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 a0 H0 [H1| H1] H2.\ninversion H0; auto.\ncase H5; rewrite H1; auto with datatypes.\napply (H l2 a0); auto.\napply ulist_inv with (1 := H0); auto.\n", "def_ranges": [64, 0, 65, 71], "proof_ranges": [66, 0, 73, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l1 l2 : list A) (a : A),\nulist (l1 ++ l2) -> In a l1 -> In a l2 -> False"], "goal_after": ["forall (l1 l2 : list A) (a : A),\nulist (l1 ++ l2) -> In a l1 -> In a l2 -> False"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall (l1 l2 : list A) (a : A),\nulist (l1 ++ l2) -> In a l1 -> In a l2 -> False"], "goal_after": ["forall (a : A) (l : list A),\n(forall (l2 : list A) (a0 : A),\n ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\nforall (l2 : list A) (a0 : A),\nulist (a :: l ++ l2) -> a = a0 \\/ In a0 l -> In a0 l2 -> False"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"]}, {"text": "intros a l H l2 a0 H0 [H1| H1] H2.", "goal_before": ["forall (a : A) (l : list A),\n(forall (l2 : list A) (a0 : A),\n ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\nforall (l2 : list A) (a0 : A),\nulist (a :: l ++ l2) -> a = a0 \\/ In a0 l -> In a0 l2 -> False"], "goal_after": ["False", "False"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x => (fun (H1 : a = a0) (H2 : In a0 l2) => ?Goal) x\n     | or_intror x => (fun (H1 : In a0 l) (H2 : In a0 l2) => ?Goal0) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"]}, {"text": "inversion H0; auto.", "goal_before": ["False", "False"], "goal_after": ["False", "False"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x => (fun (H1 : a = a0) (H2 : In a0 l2) => ?Goal) x\n     | or_intror x => (fun (H1 : In a0 l) (H2 : In a0 l2) => ?Goal0) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : a = a0) (H2 : In a0 l2) =>\n          let H4 : a :: l ++ l2 = a :: l ++ l2 -> False :=\n            match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> False) with\n            | ulist_nil =>\n                fun H4 : nil = a :: l ++ l2 =>\n                (fun H5 : nil = a :: l ++ l2 =>\n                 let H6 : False :=\n                   eq_ind nil\n                     (fun e : list A =>\n                      match e with\n                      | nil => True\n                      | _ :: _ => False\n                      end) I (a :: l ++ l2) H5 in\n                 False_ind False H6) H4\n            | ulist_cons a1 l0 x0 x1 =>\n                (fun (a2 : A) (l3 : list A) (H4 : ~ In a2 l3) \n                   (H5 : ulist l3) (H6 : a2 :: l3 = a :: l ++ l2) =>\n                 (fun H7 : a2 :: l3 = a :: l ++ l2 =>\n                  let H8 : l3 = l ++ l2 :=\n                    f_equal\n                      (fun e : list A =>\n                       match e with\n                       | nil => l3\n                       | _ :: l4 => l4\n                       end) H7 in\n                  (let H9 : a2 = a :=\n                     f_equal\n                       (fun e : list A =>\n                        match e with\n                        | nil => a2\n                        | a3 :: _ => a3\n                        end) H7 in\n                   (fun H10 : a2 = a =>\n                    let H11 : a2 = a := H10 in\n                    eq_ind_r\n                      (fun a3 : A =>\n                       l3 = l ++ l2 -> ~ In a3 l3 -> ulist l3 -> False)\n                      (fun H12 : l3 = l ++ l2 =>\n                       let H13 : l3 = l ++ l2 := H12 in\n                       eq_ind_r\n                         (fun l4 : list A => ~ In a l4 -> ulist l4 -> False)\n                         (fun (H14 : ~ In a (l ++ l2))\n                            (H15 : ulist (l ++ l2)) =>\n                          ?Goal0@{a1:=a2; l0:=l3; H5:=H14; H6:=H15; H3:=H10;\n                                  H4:=H12}) H13) H11) H9) H8) H6 H4 H5) a1 l0\n                  x0 x1\n            end in\n          H4 eq_refl) x\n     | or_intror x => (fun (H1 : In a0 l) (H2 : In a0 l2) => ?Goal) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"]}, {"text": "case H5; rewrite H1; auto with datatypes.", "goal_before": ["False", "False"], "goal_after": ["False"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : a = a0) (H2 : In a0 l2) =>\n          let H4 : a :: l ++ l2 = a :: l ++ l2 -> False :=\n            match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> False) with\n            | ulist_nil =>\n                fun H4 : nil = a :: l ++ l2 =>\n                (fun H5 : nil = a :: l ++ l2 =>\n                 let H6 : False :=\n                   eq_ind nil\n                     (fun e : list A =>\n                      match e with\n                      | nil => True\n                      | _ :: _ => False\n                      end) I (a :: l ++ l2) H5 in\n                 False_ind False H6) H4\n            | ulist_cons a1 l0 x0 x1 =>\n                (fun (a2 : A) (l3 : list A) (H4 : ~ In a2 l3) \n                   (H5 : ulist l3) (H6 : a2 :: l3 = a :: l ++ l2) =>\n                 (fun H7 : a2 :: l3 = a :: l ++ l2 =>\n                  let H8 : l3 = l ++ l2 :=\n                    f_equal\n                      (fun e : list A =>\n                       match e with\n                       | nil => l3\n                       | _ :: l4 => l4\n                       end) H7 in\n                  (let H9 : a2 = a :=\n                     f_equal\n                       (fun e : list A =>\n                        match e with\n                        | nil => a2\n                        | a3 :: _ => a3\n                        end) H7 in\n                   (fun H10 : a2 = a =>\n                    let H11 : a2 = a := H10 in\n                    eq_ind_r\n                      (fun a3 : A =>\n                       l3 = l ++ l2 -> ~ In a3 l3 -> ulist l3 -> False)\n                      (fun H12 : l3 = l ++ l2 =>\n                       let H13 : l3 = l ++ l2 := H12 in\n                       eq_ind_r\n                         (fun l4 : list A => ~ In a l4 -> ulist l4 -> False)\n                         (fun (H14 : ~ In a (l ++ l2))\n                            (H15 : ulist (l ++ l2)) =>\n                          ?Goal0@{a1:=a2; l0:=l3; H5:=H14; H6:=H15; H3:=H10;\n                                  H4:=H12}) H13) H11) H9) H8) H6 H4 H5) a1 l0\n                  x0 x1\n            end in\n          H4 eq_refl) x\n     | or_intror x => (fun (H1 : In a0 l) (H2 : In a0 l2) => ?Goal) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : a = a0) (H2 : In a0 l2) =>\n          let H4 : a :: l ++ l2 = a :: l ++ l2 -> False :=\n            match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> False) with\n            | ulist_nil =>\n                fun H4 : nil = a :: l ++ l2 =>\n                (fun H5 : nil = a :: l ++ l2 =>\n                 let H6 : False :=\n                   eq_ind nil\n                     (fun e : list A =>\n                      match e with\n                      | nil => True\n                      | _ :: _ => False\n                      end) I (a :: l ++ l2) H5 in\n                 False_ind False H6) H4\n            | ulist_cons a1 l0 x0 x1 =>\n                (fun (a2 : A) (l3 : list A) (H4 : ~ In a2 l3) \n                   (H5 : ulist l3) (H6 : a2 :: l3 = a :: l ++ l2) =>\n                 (fun H7 : a2 :: l3 = a :: l ++ l2 =>\n                  let H8 : l3 = l ++ l2 :=\n                    f_equal\n                      (fun e : list A =>\n                       match e with\n                       | nil => l3\n                       | _ :: l4 => l4\n                       end) H7 in\n                  (let H9 : a2 = a :=\n                     f_equal\n                       (fun e : list A =>\n                        match e with\n                        | nil => a2\n                        | a3 :: _ => a3\n                        end) H7 in\n                   (fun H10 : a2 = a =>\n                    let H11 : a2 = a := H10 in\n                    eq_ind_r\n                      (fun a3 : A =>\n                       l3 = l ++ l2 -> ~ In a3 l3 -> ulist l3 -> False)\n                      (fun H12 : l3 = l ++ l2 =>\n                       let H13 : l3 = l ++ l2 := H12 in\n                       eq_ind_r\n                         (fun l4 : list A => ~ In a l4 -> ulist l4 -> False)\n                         (fun (H14 : ~ In a (l ++ l2)) (_ : ulist (l ++ l2))\n                          =>\n                          match\n                            H14\n                              (eq_ind_r (fun a3 : A => In a3 (l ++ l2))\n                                 (in_or_app l l2 a0 (or_intror H2)) H1)\n                            return False\n                          with\n                          end) H13) H11) H9) H8) H6 H4 H5) a1 l0 x0 x1\n            end in\n          H4 eq_refl) x\n     | or_intror x => (fun (H1 : In a0 l) (H2 : In a0 l2) => ?Goal) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"]}, {"text": "apply (H l2 a0); auto.", "goal_before": ["False"], "goal_after": ["ulist (l ++ l2)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : a = a0) (H2 : In a0 l2) =>\n          let H4 : a :: l ++ l2 = a :: l ++ l2 -> False :=\n            match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> False) with\n            | ulist_nil =>\n                fun H4 : nil = a :: l ++ l2 =>\n                (fun H5 : nil = a :: l ++ l2 =>\n                 let H6 : False :=\n                   eq_ind nil\n                     (fun e : list A =>\n                      match e with\n                      | nil => True\n                      | _ :: _ => False\n                      end) I (a :: l ++ l2) H5 in\n                 False_ind False H6) H4\n            | ulist_cons a1 l0 x0 x1 =>\n                (fun (a2 : A) (l3 : list A) (H4 : ~ In a2 l3) \n                   (H5 : ulist l3) (H6 : a2 :: l3 = a :: l ++ l2) =>\n                 (fun H7 : a2 :: l3 = a :: l ++ l2 =>\n                  let H8 : l3 = l ++ l2 :=\n                    f_equal\n                      (fun e : list A =>\n                       match e with\n                       | nil => l3\n                       | _ :: l4 => l4\n                       end) H7 in\n                  (let H9 : a2 = a :=\n                     f_equal\n                       (fun e : list A =>\n                        match e with\n                        | nil => a2\n                        | a3 :: _ => a3\n                        end) H7 in\n                   (fun H10 : a2 = a =>\n                    let H11 : a2 = a := H10 in\n                    eq_ind_r\n                      (fun a3 : A =>\n                       l3 = l ++ l2 -> ~ In a3 l3 -> ulist l3 -> False)\n                      (fun H12 : l3 = l ++ l2 =>\n                       let H13 : l3 = l ++ l2 := H12 in\n                       eq_ind_r\n                         (fun l4 : list A => ~ In a l4 -> ulist l4 -> False)\n                         (fun (H14 : ~ In a (l ++ l2)) (_ : ulist (l ++ l2))\n                          =>\n                          match\n                            H14\n                              (eq_ind_r (fun a3 : A => In a3 (l ++ l2))\n                                 (in_or_app l l2 a0 (or_intror H2)) H1)\n                            return False\n                          with\n                          end) H13) H11) H9) H8) H6 H4 H5) a1 l0 x0 x1\n            end in\n          H4 eq_refl) x\n     | or_intror x => (fun (H1 : In a0 l) (H2 : In a0 l2) => ?Goal) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : a = a0) (H2 : In a0 l2) =>\n          let H4 : a :: l ++ l2 = a :: l ++ l2 -> False :=\n            match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> False) with\n            | ulist_nil =>\n                fun H4 : nil = a :: l ++ l2 =>\n                (fun H5 : nil = a :: l ++ l2 =>\n                 let H6 : False :=\n                   eq_ind nil\n                     (fun e : list A =>\n                      match e with\n                      | nil => True\n                      | _ :: _ => False\n                      end) I (a :: l ++ l2) H5 in\n                 False_ind False H6) H4\n            | ulist_cons a1 l0 x0 x1 =>\n                (fun (a2 : A) (l3 : list A) (H4 : ~ In a2 l3) \n                   (H5 : ulist l3) (H6 : a2 :: l3 = a :: l ++ l2) =>\n                 (fun H7 : a2 :: l3 = a :: l ++ l2 =>\n                  let H8 : l3 = l ++ l2 :=\n                    f_equal\n                      (fun e : list A =>\n                       match e with\n                       | nil => l3\n                       | _ :: l4 => l4\n                       end) H7 in\n                  (let H9 : a2 = a :=\n                     f_equal\n                       (fun e : list A =>\n                        match e with\n                        | nil => a2\n                        | a3 :: _ => a3\n                        end) H7 in\n                   (fun H10 : a2 = a =>\n                    let H11 : a2 = a := H10 in\n                    eq_ind_r\n                      (fun a3 : A =>\n                       l3 = l ++ l2 -> ~ In a3 l3 -> ulist l3 -> False)\n                      (fun H12 : l3 = l ++ l2 =>\n                       let H13 : l3 = l ++ l2 := H12 in\n                       eq_ind_r\n                         (fun l4 : list A => ~ In a l4 -> ulist l4 -> False)\n                         (fun (H14 : ~ In a (l ++ l2)) (_ : ulist (l ++ l2))\n                          =>\n                          match\n                            H14\n                              (eq_ind_r (fun a3 : A => In a3 (l ++ l2))\n                                 (in_or_app l l2 a0 (or_intror H2)) H1)\n                            return False\n                          with\n                          end) H13) H11) H9) H8) H6 H4 H5) a1 l0 x0 x1\n            end in\n          H4 eq_refl) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In a0 l2) => H l2 a0 ?Goal H1 H2) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"]}, {"text": "apply ulist_inv with (1 := H0); auto.", "goal_before": ["ulist (l ++ l2)"], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : a = a0) (H2 : In a0 l2) =>\n          let H4 : a :: l ++ l2 = a :: l ++ l2 -> False :=\n            match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> False) with\n            | ulist_nil =>\n                fun H4 : nil = a :: l ++ l2 =>\n                (fun H5 : nil = a :: l ++ l2 =>\n                 let H6 : False :=\n                   eq_ind nil\n                     (fun e : list A =>\n                      match e with\n                      | nil => True\n                      | _ :: _ => False\n                      end) I (a :: l ++ l2) H5 in\n                 False_ind False H6) H4\n            | ulist_cons a1 l0 x0 x1 =>\n                (fun (a2 : A) (l3 : list A) (H4 : ~ In a2 l3) \n                   (H5 : ulist l3) (H6 : a2 :: l3 = a :: l ++ l2) =>\n                 (fun H7 : a2 :: l3 = a :: l ++ l2 =>\n                  let H8 : l3 = l ++ l2 :=\n                    f_equal\n                      (fun e : list A =>\n                       match e with\n                       | nil => l3\n                       | _ :: l4 => l4\n                       end) H7 in\n                  (let H9 : a2 = a :=\n                     f_equal\n                       (fun e : list A =>\n                        match e with\n                        | nil => a2\n                        | a3 :: _ => a3\n                        end) H7 in\n                   (fun H10 : a2 = a =>\n                    let H11 : a2 = a := H10 in\n                    eq_ind_r\n                      (fun a3 : A =>\n                       l3 = l ++ l2 -> ~ In a3 l3 -> ulist l3 -> False)\n                      (fun H12 : l3 = l ++ l2 =>\n                       let H13 : l3 = l ++ l2 := H12 in\n                       eq_ind_r\n                         (fun l4 : list A => ~ In a l4 -> ulist l4 -> False)\n                         (fun (H14 : ~ In a (l ++ l2)) (_ : ulist (l ++ l2))\n                          =>\n                          match\n                            H14\n                              (eq_ind_r (fun a3 : A => In a3 (l ++ l2))\n                                 (in_or_app l l2 a0 (or_intror H2)) H1)\n                            return False\n                          with\n                          end) H13) H11) H9) H8) H6 H4 H5) a1 l0 x0 x1\n            end in\n          H4 eq_refl) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In a0 l2) => H l2 a0 ?Goal H1 H2) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : a = a0) (H2 : In a0 l2) =>\n          let H4 : a :: l ++ l2 = a :: l ++ l2 -> False :=\n            match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> False) with\n            | ulist_nil =>\n                fun H4 : nil = a :: l ++ l2 =>\n                (fun H5 : nil = a :: l ++ l2 =>\n                 let H6 : False :=\n                   eq_ind nil\n                     (fun e : list A =>\n                      match e with\n                      | nil => True\n                      | _ :: _ => False\n                      end) I (a :: l ++ l2) H5 in\n                 False_ind False H6) H4\n            | ulist_cons a1 l0 x0 x1 =>\n                (fun (a2 : A) (l3 : list A) (H4 : ~ In a2 l3) \n                   (H5 : ulist l3) (H6 : a2 :: l3 = a :: l ++ l2) =>\n                 (fun H7 : a2 :: l3 = a :: l ++ l2 =>\n                  let H8 : l3 = l ++ l2 :=\n                    f_equal\n                      (fun e : list A =>\n                       match e with\n                       | nil => l3\n                       | _ :: l4 => l4\n                       end) H7 in\n                  (let H9 : a2 = a :=\n                     f_equal\n                       (fun e : list A =>\n                        match e with\n                        | nil => a2\n                        | a3 :: _ => a3\n                        end) H7 in\n                   (fun H10 : a2 = a =>\n                    let H11 : a2 = a := H10 in\n                    eq_ind_r\n                      (fun a3 : A =>\n                       l3 = l ++ l2 -> ~ In a3 l3 -> ulist l3 -> False)\n                      (fun H12 : l3 = l ++ l2 =>\n                       let H13 : l3 = l ++ l2 := H12 in\n                       eq_ind_r\n                         (fun l4 : list A => ~ In a l4 -> ulist l4 -> False)\n                         (fun (H14 : ~ In a (l ++ l2)) (_ : ulist (l ++ l2))\n                          =>\n                          match\n                            H14\n                              (eq_ind_r (fun a3 : A => In a3 (l ++ l2))\n                                 (in_or_app l l2 a0 (or_intror H2)) H1)\n                            return False\n                          with\n                          end) H13) H11) H9) H8) H6 H4 H5) a1 l0 x0 x1\n            end in\n          H4 eq_refl) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In a0 l2) =>\n          H l2 a0 (ulist_inv a (l ++ l2) H0) H1 H2) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    ulist (l2 ++ l3) -> In a l2 -> In a l3 -> False)\n   ((fun (l2 : list A) (a : A) (_ : ulist l2) (H0 : False) (_ : In a l2) =>\n     H0)\n    :\n    forall (l2 : list A) (a : A),\n    ulist (nil ++ l2) -> In a nil -> In a l2 -> False)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) \n       (l2 : list A) (a0 : A) (H0 : ulist (a :: l ++ l2))\n       (H3 : a = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : a = a0) (H2 : In a0 l2) =>\n          let H4 : a :: l ++ l2 = a :: l ++ l2 -> False :=\n            match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> False) with\n            | ulist_nil =>\n                fun H4 : nil = a :: l ++ l2 =>\n                (fun H5 : nil = a :: l ++ l2 =>\n                 let H6 : False :=\n                   eq_ind nil\n                     (fun e : list A =>\n                      match e with\n                      | nil => True\n                      | _ :: _ => False\n                      end) I (a :: l ++ l2) H5 in\n                 False_ind False H6) H4\n            | ulist_cons a1 l0 x0 x1 =>\n                (fun (a2 : A) (l3 : list A) (H4 : ~ In a2 l3) \n                   (H5 : ulist l3) (H6 : a2 :: l3 = a :: l ++ l2) =>\n                 (fun H7 : a2 :: l3 = a :: l ++ l2 =>\n                  let H8 : l3 = l ++ l2 :=\n                    f_equal\n                      (fun e : list A =>\n                       match e with\n                       | nil => l3\n                       | _ :: l4 => l4\n                       end) H7 in\n                  (let H9 : a2 = a :=\n                     f_equal\n                       (fun e : list A =>\n                        match e with\n                        | nil => a2\n                        | a3 :: _ => a3\n                        end) H7 in\n                   (fun H10 : a2 = a =>\n                    let H11 : a2 = a := H10 in\n                    eq_ind_r\n                      (fun a3 : A =>\n                       l3 = l ++ l2 -> ~ In a3 l3 -> ulist l3 -> False)\n                      (fun H12 : l3 = l ++ l2 =>\n                       let H13 : l3 = l ++ l2 := H12 in\n                       eq_ind_r\n                         (fun l4 : list A => ~ In a l4 -> ulist l4 -> False)\n                         (fun (H14 : ~ In a (l ++ l2)) (_ : ulist (l ++ l2))\n                          =>\n                          match\n                            H14\n                              (eq_ind_r (fun a3 : A => In a3 (l ++ l2))\n                                 (in_or_app l l2 a0 (or_intror H2)) H1)\n                            return False\n                          with\n                          end) H13) H11) H9) H8) H6 H4 H5) a1 l0 x0 x1\n            end in\n          H4 eq_refl) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In a0 l2) =>\n          H l2 a0 (ulist_inv a (l ++ l2) H0) H1 H2) x\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     ulist (l ++ l2) -> In a0 l -> In a0 l2 -> False) ->\n    forall (l2 : list A) (a0 : A),\n    ulist ((a :: l) ++ l2) -> In a0 (a :: l) -> In a0 l2 -> False) l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UList.v", "name": "ulist_app_inv_l", "text": "Theorem ulist_app_inv_l : forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l1.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 H0; inversion H0; apply ulist_cons; auto.\nContradict H3; auto with datatypes.\napply H with l2; auto.\nQed.\n", "definition": " forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l1.", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 H0; inversion H0; apply ulist_cons; auto.\nContradict H3; auto with datatypes.\napply H with l2; auto.\n", "def_ranges": [76, 0, 76, 78], "proof_ranges": [77, 0, 82, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l1"], "goal_after": ["forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l1"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l1"], "goal_after": ["forall l2 : list A, ulist l2 -> ulist nil", "forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist (a :: l)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l2)\n   (?Goal : forall l2 : list A, ulist (nil ++ l2) -> ulist nil)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist (a :: l)) l1)"]}, {"text": "intros a l H l2 H0; inversion H0; apply ulist_cons; auto.", "goal_before": ["forall l2 : list A, ulist l2 -> ulist nil", "forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist (a :: l)"], "goal_after": ["forall l2 : list A, ulist l2 -> ulist nil", "forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist (a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l2)\n   (?Goal : forall l2 : list A, ulist (nil ++ l2) -> ulist nil)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist (a :: l)) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l2)\n   (?Goal : forall l2 : list A, ulist (nil ++ l2) -> ulist nil)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist (a :: l)) l1)"]}, {"text": "Contradict H3; auto with datatypes.", "goal_before": ["forall l2 : list A, ulist l2 -> ulist nil", "forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist (a :: l)"], "goal_after": ["forall l2 : list A, ulist l2 -> ulist nil", "forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist (a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l2)\n   (?Goal : forall l2 : list A, ulist (nil ++ l2) -> ulist nil)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist (a :: l)) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l2)\n   (?Goal : forall l2 : list A, ulist (nil ++ l2) -> ulist nil)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist (a :: l)) l1)"]}, {"text": "apply H with l2; auto.", "goal_before": ["forall l2 : list A, ulist l2 -> ulist nil", "forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist (a :: l)"], "goal_after": ["forall l2 : list A, ulist l2 -> ulist nil", "forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist (a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l2)\n   (?Goal : forall l2 : list A, ulist (nil ++ l2) -> ulist nil)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist (a :: l)) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l2)\n   (?Goal : forall l2 : list A, ulist (nil ++ l2) -> ulist nil)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist (a :: l)) l1)"]}, {"text": "Qed.", "goal_before": ["forall l2 : list A, ulist l2 -> ulist nil", "forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist (a :: l)"], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l2)\n   (?Goal : forall l2 : list A, ulist (nil ++ l2) -> ulist nil)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist (a :: l)) l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UList.v", "name": "ulist_app_inv_r", "text": "Theorem ulist_app_inv_r : forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 H0; inversion H0; auto.\nQed.\n", "definition": " forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l2.", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 H0; inversion H0; auto.\n", "def_ranges": [85, 0, 85, 78], "proof_ranges": [86, 0, 89, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l2"], "goal_after": ["forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall l1 l2 : list A, ulist (l1 ++ l2) -> ulist l2"], "goal_after": ["forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l2) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist l2"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l3)\n   ((fun (l2 : list A) (H : ulist l2) => H)\n    :\n    forall l2 : list A, ulist (nil ++ l2) -> ulist l2)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l2) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist l2) l1)"]}, {"text": "intros a l H l2 H0; inversion H0; auto.", "goal_before": ["forall (a : A) (l : list A),\n(forall l2 : list A, ulist (l ++ l2) -> ulist l2) ->\nforall l2 : list A, ulist (a :: l ++ l2) -> ulist l2"], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l3)\n   ((fun (l2 : list A) (H : ulist l2) => H)\n    :\n    forall l2 : list A, ulist (nil ++ l2) -> ulist l2)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l2) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist l2) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l3)\n   ((fun (l2 : list A) (H : ulist l2) => H)\n    :\n    forall l2 : list A, ulist (nil ++ l2) -> ulist l2)\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A, ulist (l ++ l2) -> ulist l2) \n       (l2 : list A) (H0 : ulist (a :: l ++ l2)) =>\n     let H1 : a :: l ++ l2 = a :: l ++ l2 -> ulist l2 :=\n       match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> ulist l2) with\n       | ulist_nil =>\n           fun H1 : nil = a :: l ++ l2 =>\n           (fun H2 : nil = a :: l ++ l2 =>\n            let H3 : False :=\n              eq_ind nil\n                (fun e : list A =>\n                 match e with\n                 | nil => True\n                 | _ :: _ => False\n                 end) I (a :: l ++ l2) H2 in\n            False_ind (ulist l2) H3) H1\n       | ulist_cons a0 l0 x x0 =>\n           (fun (a1 : A) (l3 : list A) (H1 : ~ In a1 l3) \n              (H2 : ulist l3) (H3 : a1 :: l3 = a :: l ++ l2) =>\n            (fun H4 : a1 :: l3 = a :: l ++ l2 =>\n             let H5 : l3 = l ++ l2 :=\n               f_equal\n                 (fun e : list A =>\n                  match e with\n                  | nil => l3\n                  | _ :: l4 => l4\n                  end) H4 in\n             (let H6 : a1 = a :=\n                f_equal\n                  (fun e : list A =>\n                   match e with\n                   | nil => a1\n                   | a2 :: _ => a2\n                   end) H4 in\n              (fun H7 : a1 = a =>\n               let H8 : a1 = a := H7 in\n               eq_ind_r\n                 (fun a2 : A =>\n                  l3 = l ++ l2 -> ~ In a2 l3 -> ulist l3 -> ulist l2)\n                 (fun H9 : l3 = l ++ l2 =>\n                  let H10 : l3 = l ++ l2 := H9 in\n                  eq_ind_r\n                    (fun l4 : list A => ~ In a l4 -> ulist l4 -> ulist l2)\n                    (fun (_ : ~ In a (l ++ l2)) (H12 : ulist (l ++ l2)) =>\n                     H l2 H12) H10) H8) H6) H5) H3 H1 H2) a0 l0 x x0\n       end in\n     H1 eq_refl)\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l2) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist l2) l1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, ulist (l2 ++ l3) -> ulist l3)\n   ((fun (l2 : list A) (H : ulist l2) => H)\n    :\n    forall l2 : list A, ulist (nil ++ l2) -> ulist l2)\n   ((fun (a : A) (l : list A)\n       (H : forall l2 : list A, ulist (l ++ l2) -> ulist l2) \n       (l2 : list A) (H0 : ulist (a :: l ++ l2)) =>\n     let H1 : a :: l ++ l2 = a :: l ++ l2 -> ulist l2 :=\n       match H0 in (ulist l0) return (l0 = a :: l ++ l2 -> ulist l2) with\n       | ulist_nil =>\n           fun H1 : nil = a :: l ++ l2 =>\n           (fun H2 : nil = a :: l ++ l2 =>\n            let H3 : False :=\n              eq_ind nil\n                (fun e : list A =>\n                 match e with\n                 | nil => True\n                 | _ :: _ => False\n                 end) I (a :: l ++ l2) H2 in\n            False_ind (ulist l2) H3) H1\n       | ulist_cons a0 l0 x x0 =>\n           (fun (a1 : A) (l3 : list A) (H1 : ~ In a1 l3) \n              (H2 : ulist l3) (H3 : a1 :: l3 = a :: l ++ l2) =>\n            (fun H4 : a1 :: l3 = a :: l ++ l2 =>\n             let H5 : l3 = l ++ l2 :=\n               f_equal\n                 (fun e : list A =>\n                  match e with\n                  | nil => l3\n                  | _ :: l4 => l4\n                  end) H4 in\n             (let H6 : a1 = a :=\n                f_equal\n                  (fun e : list A =>\n                   match e with\n                   | nil => a1\n                   | a2 :: _ => a2\n                   end) H4 in\n              (fun H7 : a1 = a =>\n               let H8 : a1 = a := H7 in\n               eq_ind_r\n                 (fun a2 : A =>\n                  l3 = l ++ l2 -> ~ In a2 l3 -> ulist l3 -> ulist l2)\n                 (fun H9 : l3 = l ++ l2 =>\n                  let H10 : l3 = l ++ l2 := H9 in\n                  eq_ind_r\n                    (fun l4 : list A => ~ In a l4 -> ulist l4 -> ulist l2)\n                    (fun (_ : ~ In a (l ++ l2)) (H12 : ulist (l ++ l2)) =>\n                     H l2 H12) H10) H8) H6) H5) H3 H1 H2) a0 l0 x x0\n       end in\n     H1 eq_refl)\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, ulist (l ++ l2) -> ulist l2) ->\n    forall l2 : list A, ulist ((a :: l) ++ l2) -> ulist l2) l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UList.v", "name": "ulist_perm", "text": "Theorem ulist_perm :\n forall l1 l2 : list A, permutation l1 l2 -> ulist l1 -> ulist l2.\nProof using.\nintros l1 l2 H; elim H; clear H l1 l2; simpl in |- *; auto.\nintros a l1 l2 H0 H1 H2; apply ulist_cons; auto.\ninversion H2; auto.\nContradict H4; apply permutation_in with (1 := permutation_sym _ _ _ H0);\n auto.\ninversion H2; auto.\nintros a b L H0; apply ulist_cons; auto.\ninversion H0; auto.\ninversion H3; auto.\nsimpl in |- *; Contradict H7; case H7; auto.\nintros H8; case H2; rewrite H8; simpl in |- *; auto.\napply ulist_cons; auto.\ninversion H0; auto.\nContradict H2; simpl in |- *; auto.\ninversion H0; auto.\ninversion H3; auto.\nQed.\n", "definition": "\n forall l1 l2 : list A, permutation l1 l2 -> ulist l1 -> ulist l2.", "proof": "\nProof using.\nintros l1 l2 H; elim H; clear H l1 l2; simpl in |- *; auto.\nintros a l1 l2 H0 H1 H2; apply ulist_cons; auto.\ninversion H2; auto.\nContradict H4; apply permutation_in with (1 := permutation_sym _ _ _ H0);\n auto.\ninversion H2; auto.\nintros a b L H0; apply ulist_cons; auto.\ninversion H0; auto.\ninversion H3; auto.\nsimpl in |- *; Contradict H7; case H7; auto.\nintros H8; case H2; rewrite H8; simpl in |- *; auto.\napply ulist_cons; auto.\ninversion H0; auto.\nContradict H2; simpl in |- *; auto.\ninversion H0; auto.\ninversion H3; auto.\n", "def_ranges": [101, 0, 102, 66], "proof_ranges": [103, 0, 120, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 H; elim H; clear H l1 l2; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l1 l2 H0 H1 H2; apply ulist_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Contradict H4; apply permutation_in with (1 := permutation_sym _ _ _ H0);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b L H0; apply ulist_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; Contradict H7; case H7; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H8; case H2; rewrite H8; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ulist_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Contradict H2; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/SubstPred.v", "name": "subst_pred_ordered_cover_l", "text": "Theorem subst_pred_ordered_cover_l :\n forall (t1 t2 : btree A) (l1 l2 : list (btree A)),\n subst_pred l1 l2 t1 t2 -> ordered_cover l1 t1.\nProof using.\nintros t1 t2 l1 l2 H; elim H; auto.\nQed.\n", "definition": "\n forall (t1 t2 : btree A) (l1 l2 : list (btree A)),\n subst_pred l1 l2 t1 t2 -> ordered_cover l1 t1.", "proof": "\nProof using.\nintros t1 t2 l1 l2 H; elim H; auto.\n", "def_ranges": [44, 0, 46, 47], "proof_ranges": [47, 0, 49, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 t2 l1 l2 H; elim H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/SubstPred.v", "name": "subst_pred_ordered_cover_r", "text": "Theorem subst_pred_ordered_cover_r :\n forall (t1 t2 : btree A) (l1 l2 : list (btree A)),\n subst_pred l1 l2 t1 t2 -> ordered_cover l2 t2.\nProof using.\nintros t1 t2 l1 l2 H; elim H; auto.\nQed.\n", "definition": "\n forall (t1 t2 : btree A) (l1 l2 : list (btree A)),\n subst_pred l1 l2 t1 t2 -> ordered_cover l2 t2.", "proof": "\nProof using.\nintros t1 t2 l1 l2 H; elim H; auto.\n", "def_ranges": [52, 0, 54, 47], "proof_ranges": [55, 0, 57, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 t2 l1 l2 H; elim H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/SubstPred.v", "name": "subst_pred_length", "text": "Theorem subst_pred_length :\n forall (t1 t2 : btree A) (l1 l2 : list (btree A)),\n subst_pred l1 l2 t1 t2 -> length l1 = length l2.\nProof using.\nintros t1 t2 l1 l2 H; elim H; auto.\nintros t0 t3 t4 t5 l0 l3 l4 l5 l6 l7 H0 H1 H2 H3; repeat rewrite length_app; auto.\nQed.\n", "definition": "\n forall (t1 t2 : btree A) (l1 l2 : list (btree A)),\n subst_pred l1 l2 t1 t2 -> length l1 = length l2.", "proof": "\nProof using.\nintros t1 t2 l1 l2 H; elim H; auto.\nintros t0 t3 t4 t5 l0 l3 l4 l5 l6 l7 H0 H1 H2 H3; repeat rewrite length_app; auto.\n", "def_ranges": [60, 0, 62, 49], "proof_ranges": [63, 0, 66, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 t2 l1 l2 H; elim H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t0 t3 t4 t5 l0 l3 l4 l5 l6 l7 H0 H1 H2 H3; repeat rewrite length_app; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/SubstPred.v", "name": "ordered_cover_subst_pred", "text": "Theorem ordered_cover_subst_pred :\n forall (t1 : btree A) (l1 l2 : list (btree A)),\n ordered_cover l1 t1 ->\n length l1 = length l2 -> exists t2 : btree A, subst_pred l1 l2 t1 t2.\nProof using.\nintros t1 l1 l2 H; generalize l2; elim H; clear t1 l1 l2 H.\nintros t l l2; case l2.\nsimpl in |- *; intros; discriminate.\nintros b l0; case l0; simpl in |- *; auto.\nintros H; exists b; auto.\nintros; discriminate.\nintros t1 t2 l1 l2 l3 H H0 H1 H2 l0 H3.\ncase (H0 (first_n l0 (length l1))); auto.\nrewrite first_n_length; auto;\n (rewrite <- H3; rewrite length_app; auto with arith).\nintros t4 HH1.\ncase (H2 (skip_n l0 (length l1))); auto.\nrewrite skip_n_length; auto;\n (rewrite <- H3; rewrite length_app; rewrite minus_plus; auto with arith).\nintros t5 HH2.\nexists (node t4 t5); auto.\nrewrite <- (first_n_skip_n_app _ (length l1) l0); auto.\nQed.\n", "definition": "\n forall (t1 : btree A) (l1 l2 : list (btree A)),\n ordered_cover l1 t1 ->\n length l1 = length l2 -> exists t2 : btree A, subst_pred l1 l2 t1 t2.", "proof": "\nProof using.\nintros t1 l1 l2 H; generalize l2; elim H; clear t1 l1 l2 H.\nintros t l l2; case l2.\nsimpl in |- *; intros; discriminate.\nintros b l0; case l0; simpl in |- *; auto.\nintros H; exists b; auto.\nintros; discriminate.\nintros t1 t2 l1 l2 l3 H H0 H1 H2 l0 H3.\ncase (H0 (first_n l0 (length l1))); auto.\nrewrite first_n_length; auto;\n (rewrite <- H3; rewrite length_app; auto with arith).\nintros t4 HH1.\ncase (H2 (skip_n l0 (length l1))); auto.\nrewrite skip_n_length; auto;\n (rewrite <- H3; rewrite length_app; rewrite minus_plus; auto with arith).\nintros t5 HH2.\nexists (node t4 t5); auto.\nrewrite <- (first_n_skip_n_app _ (length l1) l0); auto.\n", "def_ranges": [69, 0, 72, 70], "proof_ranges": [73, 0, 91, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 l1 l2 H; generalize l2; elim H; clear t1 l1 l2 H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t l l2; case l2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b l0; case l0; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H; exists b; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 t2 l1 l2 l3 H H0 H1 H2 l0 H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H0 (first_n l0 (length l1))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite first_n_length; auto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(rewrite <- H3; rewrite length_app; auto with arith).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t4 HH1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H2 (skip_n l0 (length l1))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite skip_n_length; auto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(rewrite <- H3; rewrite length_app; rewrite minus_plus; auto with arith).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t5 HH2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (node t4 t5); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (first_n_skip_n_app _ (length l1) l0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/SubstPred.v", "name": "height_pred_subst_pred", "text": "Theorem height_pred_subst_pred :\n forall (n : nat) (ln : list nat) (t1 : btree A) (l1 l2 : list (btree A)),\n height_pred n ln l1 t1 ->\n length l1 = length l2 ->\n exists t2 : btree A, height_pred n ln l2 t2 /\\ subst_pred l1 l2 t1 t2.\nProof using.\nintros n ln t1 l1 l2 H; generalize l2; elim H; clear H n ln t1 l1 l2; auto.\nintros n t l2; case l2.\nsimpl in |- *; intros; discriminate.\nintros b l0; case l0; intros; try discriminate; exists b; auto.\nintros n ln1 ln2 t1 t2 l1 l2 H H0 H1 H2 l0 H3.\ncase (H0 (first_n l0 (length l1))); auto.\nrewrite first_n_length; auto;\n (rewrite <- H3; rewrite length_app; auto with arith).\nintros t4 (HH1, HH2).\ncase (H2 (skip_n l0 (length l1))); auto.\nrewrite skip_n_length; auto;\n (rewrite <- H3; rewrite length_app; rewrite minus_plus; auto with arith).\nintros t5 (HH3, HH4).\nexists (node t4 t5); rewrite <- (first_n_skip_n_app _ (length l1) l0); auto.\nQed.\n", "definition": "\n forall (n : nat) (ln : list nat) (t1 : btree A) (l1 l2 : list (btree A)),\n height_pred n ln l1 t1 ->\n length l1 = length l2 ->\n exists t2 : btree A, height_pred n ln l2 t2 /\\ subst_pred l1 l2 t1 t2.", "proof": "\nProof using.\nintros n ln t1 l1 l2 H; generalize l2; elim H; clear H n ln t1 l1 l2; auto.\nintros n t l2; case l2.\nsimpl in |- *; intros; discriminate.\nintros b l0; case l0; intros; try discriminate; exists b; auto.\nintros n ln1 ln2 t1 t2 l1 l2 H H0 H1 H2 l0 H3.\ncase (H0 (first_n l0 (length l1))); auto.\nrewrite first_n_length; auto;\n (rewrite <- H3; rewrite length_app; auto with arith).\nintros t4 (HH1, HH2).\ncase (H2 (skip_n l0 (length l1))); auto.\nrewrite skip_n_length; auto;\n (rewrite <- H3; rewrite length_app; rewrite minus_plus; auto with arith).\nintros t5 (HH3, HH4).\nexists (node t4 t5); rewrite <- (first_n_skip_n_app _ (length l1) l0); auto.\n", "def_ranges": [94, 0, 98, 71], "proof_ranges": [99, 0, 114, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n ln t1 l1 l2 H; generalize l2; elim H; clear H n ln t1 l1 l2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n t l2; case l2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b l0; case l0; intros; try discriminate; exists b; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n ln1 ln2 t1 t2 l1 l2 H H0 H1 H2 l0 H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H0 (first_n l0 (length l1))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite first_n_length; auto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(rewrite <- H3; rewrite length_app; auto with arith).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t4 (HH1, HH2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H2 (skip_n l0 (length l1))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite skip_n_length; auto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(rewrite <- H3; rewrite length_app; rewrite minus_plus; auto with arith).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t5 (HH3, HH4).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (node t4 t5); rewrite <- (first_n_skip_n_app _ (length l1) l0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/ISort.v", "name": "insert_ordered", "text": "Theorem insert_ordered :\n forall l : list A,\n ordered order l -> forall a : A, ordered order (insert a l).\nProof using order_fun_false order_fun_true.\nintros l H'; elim H'; clear H' l; auto.\nsimpl in |- *; auto.\nintros a b; simpl in |- *.\ngeneralize (refl_equal (order_fun b a));\n pattern (order_fun b a) at -1 in |- *; case (order_fun b a); \n intros Eq0; auto.\nintros a b l H'0 H'1 H'2 a0.\nsimpl in |- *.\ngeneralize (refl_equal (order_fun a0 a));\n pattern (order_fun a0 a) at -1 in |- *; case (order_fun a0 a); \n intros Eq0; auto.\ngeneralize (H'2 a0); simpl in |- *.\ngeneralize (refl_equal (order_fun a0 b));\n pattern (order_fun a0 b) at -1 in |- *; case (order_fun a0 b); \n intros Eq1; auto.\nQed.\n", "definition": "\n forall l : list A,\n ordered order l -> forall a : A, ordered order (insert a l).", "proof": "\nProof using order_fun_false order_fun_true.\nintros l H'; elim H'; clear H' l; auto.\nsimpl in |- *; auto.\nintros a b; simpl in |- *.\ngeneralize (refl_equal (order_fun b a));\n pattern (order_fun b a) at -1 in |- *; case (order_fun b a); \n intros Eq0; auto.\nintros a b l H'0 H'1 H'2 a0.\nsimpl in |- *.\ngeneralize (refl_equal (order_fun a0 a));\n pattern (order_fun a0 a) at -1 in |- *; case (order_fun a0 a); \n intros Eq0; auto.\ngeneralize (H'2 a0); simpl in |- *.\ngeneralize (refl_equal (order_fun a0 b));\n pattern (order_fun a0 b) at -1 in |- *; case (order_fun a0 b); \n intros Eq1; auto.\n", "def_ranges": [49, 0, 51, 61], "proof_ranges": [52, 0, 68, 4], "proof_steps": [{"text": "Proof using order_fun_false order_fun_true.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l H'; elim H'; clear H' l; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (refl_equal (order_fun b a));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern (order_fun b a) at -1 in |- *; case (order_fun b a);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Eq0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b l H'0 H'1 H'2 a0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (refl_equal (order_fun a0 a));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern (order_fun a0 a) at -1 in |- *; case (order_fun a0 a);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Eq0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'2 a0); simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (refl_equal (order_fun a0 b));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/ISort.v", "name": "insert_permutation", "text": "Theorem insert_permutation :\n forall (L : list A) (a : A), permutation (a :: L) (insert a L).\nProof using.\nintros L; elim L; simpl in |- *; auto.\nintros b l H' a.\nCaseEq (order_fun a b); intros H1; auto.\napply permutation_trans with (l2 := b :: a :: l); auto.\nQed.\n", "definition": "\n forall (L : list A) (a : A), permutation (a :: L) (insert a L).", "proof": "\nProof using.\nintros L; elim L; simpl in |- *; auto.\nintros b l H' a.\nCaseEq (order_fun a b); intros H1; auto.\napply permutation_trans with (l2 := b :: a :: l); auto.\n", "def_ranges": [71, 0, 72, 64], "proof_ranges": [73, 0, 78, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros L; elim L; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b l H' a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "CaseEq (order_fun a b); intros H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (l2 := b :: a :: l); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/ISort.v", "name": "isort_ordered", "text": "Theorem isort_ordered : forall l : list A, ordered order (isort l).\nProof using order_fun_false order_fun_true. \nintros l; elim l; simpl in |- *; auto.\nQed.\n", "definition": " forall l : list A, ordered order (isort l).", "proof": "\nProof using order_fun_false order_fun_true. \nintros l; elim l; simpl in |- *; auto.\n", "def_ranges": [89, 0, 89, 67], "proof_ranges": [90, 0, 92, 4], "proof_steps": [{"text": "Proof using order_fun_false order_fun_true.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/ISort.v", "name": "isort_permutation", "text": "Theorem isort_permutation : forall l : list A, permutation l (isort l).\nProof using.\nintros l; elim l; clear l; simpl in |- *; auto.\nintros a l H'.\napply permutation_trans with (l2 := a :: isort l); auto.\nQed.\n", "definition": " forall l : list A, permutation l (isort l).", "proof": "\nProof using.\nintros l; elim l; clear l; simpl in |- *; auto.\nintros a l H'.\napply permutation_trans with (l2 := a :: isort l); auto.\n", "def_ranges": [95, 0, 95, 71], "proof_ranges": [96, 0, 100, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l; elim l; clear l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (l2 := a :: isort l); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UniqueKey.v", "name": "unique_key_inv", "text": "Theorem unique_key_inv : forall a l, unique_key (a :: l) -> unique_key l.\nProof using.  \nintros a l H; inversion H; auto.\nQed.\n", "definition": " forall a l, unique_key (a :: l) -> unique_key l.", "proof": "\nProof using.  \nintros a l H; inversion H; auto.\n", "def_ranges": [41, 0, 41, 73], "proof_ranges": [42, 0, 44, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l H; inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UniqueKey.v", "name": "unique_key_in", "text": "Theorem unique_key_in :\n forall (a : A) (b1 b2 : B) l, unique_key ((a, b1) :: l) -> ~ In (a, b2) l.\nProof using.\nintros a b1 b2 l H; inversion H; auto.\nQed.\n", "definition": "\n forall (a : A) (b1 b2 : B) l, unique_key ((a, b1) :: l) -> ~ In (a, b2) l.", "proof": "\nProof using.\nintros a b1 b2 l H; inversion H; auto.\n", "def_ranges": [47, 0, 48, 75], "proof_ranges": [49, 0, 51, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b1 b2 l H; inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UniqueKey.v", "name": "unique_key_in_inv", "text": "Theorem unique_key_in_inv :\n forall a l1 l2 l, unique_key l -> In (a, l1) l -> In (a, l2) l -> l1 = l2.\nProof using.\nintros a l1 l2 l H; generalize a l1 l2; elim H; simpl in |- *; auto;\n clear H a l1 l2 l.\nintros a l1 l2 H; case H.\nintros a b l H H0 H1 a0 l1 l2 [H2| H2] [H3| H3].\ninjection H2; injection H3; intros; apply trans_equal with b; auto.\ncase (H l2); injection H2; intros H4 H5; rewrite H5; auto.\ncase (H l1); injection H3; intros H4 H5; rewrite H5; auto.\napply H1 with (1 := H2) (2 := H3); auto.\nQed.\n", "definition": "\n forall a l1 l2 l, unique_key l -> In (a, l1) l -> In (a, l2) l -> l1 = l2.", "proof": "\nProof using.\nintros a l1 l2 l H; generalize a l1 l2; elim H; simpl in |- *; auto;\n clear H a l1 l2 l.\nintros a l1 l2 H; case H.\nintros a b l H H0 H1 a0 l1 l2 [H2| H2] [H3| H3].\ninjection H2; injection H3; intros; apply trans_equal with b; auto.\ncase (H l2); injection H2; intros H4 H5; rewrite H5; auto.\ncase (H l1); injection H3; intros H4 H5; rewrite H5; auto.\napply H1 with (1 := H2) (2 := H3); auto.\n", "def_ranges": [54, 0, 55, 75], "proof_ranges": [56, 0, 65, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l1 l2 l H; generalize a l1 l2; elim H; simpl in |- *; auto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H a l1 l2 l.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l1 l2 H; case H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b l H H0 H1 a0 l1 l2 [H2| H2] [H3| H3].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H2; injection H3; intros; apply trans_equal with b; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H l2); injection H2; intros H4 H5; rewrite H5; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H l1); injection H3; intros H4 H5; rewrite H5; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H1 with (1 := H2) (2 := H3); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UniqueKey.v", "name": "unique_key_perm", "text": "Theorem unique_key_perm :\n forall l1 l2, permutation l1 l2 -> unique_key l1 -> unique_key l2.\nProof using.\nintros l1 l2 H; elim H; auto.\nintros (a1, b1) L1 L2 H0 H1 H2; apply unique_key_cons.\nintros b; red in |- *; intros H3; case (unique_key_in _ _ b _ H2).\napply permutation_in with (2 := H3); auto.\napply permutation_sym; auto.\napply H1; apply unique_key_inv with (1 := H2); auto.\nintros (a1, b1) (a2, b2) L H0; apply unique_key_cons.\nintros b; red in |- *; simpl in |- *; intros [H1| H1].\ncase (unique_key_in _ _ b2 _ H0); auto.\ninjection H1; intros H2 H3; rewrite H3; simpl in |- *; auto.\ncase (unique_key_in _ _ b _ (unique_key_inv _ _ H0)); auto.\napply unique_key_cons.\nintros b; red in |- *; simpl in |- *; intros H1;\n case (unique_key_in _ _ b _ H0); simpl in |- *; auto.\napply unique_key_inv with (a := (a2, b2));\n apply unique_key_inv with (1 := H0).\nQed.\n", "definition": "\n forall l1 l2, permutation l1 l2 -> unique_key l1 -> unique_key l2.", "proof": "\nProof using.\nintros l1 l2 H; elim H; auto.\nintros (a1, b1) L1 L2 H0 H1 H2; apply unique_key_cons.\nintros b; red in |- *; intros H3; case (unique_key_in _ _ b _ H2).\napply permutation_in with (2 := H3); auto.\napply permutation_sym; auto.\napply H1; apply unique_key_inv with (1 := H2); auto.\nintros (a1, b1) (a2, b2) L H0; apply unique_key_cons.\nintros b; red in |- *; simpl in |- *; intros [H1| H1].\ncase (unique_key_in _ _ b2 _ H0); auto.\ninjection H1; intros H2 H3; rewrite H3; simpl in |- *; auto.\ncase (unique_key_in _ _ b _ (unique_key_inv _ _ H0)); auto.\napply unique_key_cons.\nintros b; red in |- *; simpl in |- *; intros H1;\n case (unique_key_in _ _ b _ H0); simpl in |- *; auto.\napply unique_key_inv with (a := (a2, b2));\n apply unique_key_inv with (1 := H0).\n", "def_ranges": [68, 0, 69, 67], "proof_ranges": [70, 0, 87, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 H; elim H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a1, b1) L1 L2 H0 H1 H2; apply unique_key_cons.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b; red in |- *; intros H3; case (unique_key_in _ _ b _ H2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_in with (2 := H3); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_sym; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H1; apply unique_key_inv with (1 := H2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a1, b1) (a2, b2) L H0; apply unique_key_cons.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b; red in |- *; simpl in |- *; intros [H1| H1].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (unique_key_in _ _ b2 _ H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H1; intros H2 H3; rewrite H3; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (unique_key_in _ _ b _ (unique_key_inv _ _ H0)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_cons.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b; red in |- *; simpl in |- *; intros H1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (unique_key_in _ _ b _ H0); simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_inv with (a := (a2, b2));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_inv with (1 := H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UniqueKey.v", "name": "unique_key_app", "text": "Theorem unique_key_app :\n forall l1 l2,\n unique_key l1 ->\n unique_key l2 ->\n (forall a b c, In (a, b) l1 -> In (a, c) l2 -> False) ->\n unique_key (l1 ++ l2).\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros (a1, ll1) l H l2 H0 H1 H2; apply unique_key_cons; auto.\nintros b; red in |- *; intros H3.\ncase in_app_or with (1 := H3).\nchange (~ In (a1, b) l) in |- *; apply unique_key_in with (1 := H0).\nintros H4; apply (H2 a1 ll1 b); auto.\napply H; auto.\napply unique_key_inv with (1 := H0); auto.\nintros a b c H3 H4; apply (H2 a b c); auto.\nQed.\n", "definition": "\n forall l1 l2,\n unique_key l1 ->\n unique_key l2 ->\n (forall a b c, In (a, b) l1 -> In (a, c) l2 -> False) ->\n unique_key (l1 ++ l2).", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros (a1, ll1) l H l2 H0 H1 H2; apply unique_key_cons; auto.\nintros b; red in |- *; intros H3.\ncase in_app_or with (1 := H3).\nchange (~ In (a1, b) l) in |- *; apply unique_key_in with (1 := H0).\nintros H4; apply (H2 a1 ll1 b); auto.\napply H; auto.\napply unique_key_inv with (1 := H0); auto.\nintros a b c H3 H4; apply (H2 a b c); auto.\n", "def_ranges": [90, 0, 95, 23], "proof_ranges": [96, 0, 106, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a1, ll1) l H l2 H0 H1 H2; apply unique_key_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b; red in |- *; intros H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case in_app_or with (1 := H3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (~ In (a1, b) l) in |- *; apply unique_key_in with (1 := H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H4; apply (H2 a1 ll1 b); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_inv with (1 := H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b c H3 H4; apply (H2 a b c); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UniqueKey.v", "name": "unique_key_ulist", "text": "Theorem unique_key_ulist :\n forall l : list (A * B), unique_key l -> ulist (map (fst (B:=_)) l).\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H H0; apply ulist_cons.\ninversion H0.\nred in |- *; intros H5; case in_map_inv with (1 := H5).\nintros (b2, l2); simpl in |- *; intros (Hb1, Hb2); case (H3 l2); auto.\nrewrite Hb2; auto.\napply H; apply unique_key_inv with (1 := H0); auto.\nQed.\n", "definition": "\n forall l : list (A * B), unique_key l -> ulist (map (fst (B:=_)) l).", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H H0; apply ulist_cons.\ninversion H0.\nred in |- *; intros H5; case in_map_inv with (1 := H5).\nintros (b2, l2); simpl in |- *; intros (Hb1, Hb2); case (H3 l2); auto.\nrewrite Hb2; auto.\napply H; apply unique_key_inv with (1 := H0); auto.\n", "def_ranges": [109, 0, 110, 69], "proof_ranges": [111, 0, 119, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l0 H H0; apply ulist_cons.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; intros H5; case in_map_inv with (1 := H5).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (b2, l2); simpl in |- *; intros (Hb1, Hb2); case (H3 l2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite Hb2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H; apply unique_key_inv with (1 := H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UniqueKey.v", "name": "ulist_unique_key", "text": "Theorem ulist_unique_key :\n forall l : list (A * B), ulist (map (fst (B:=_)) l) -> unique_key l.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a; case a.\nintros a0 b l0 H H0; apply unique_key_cons; auto.\nintros b0; red in |- *; intros H1; absurd (In a0 (map (fst (B:=_)) l0)); auto.\ninversion H0; auto.\nchange (In (fst (a0, b0)) (map (fst (B:=_)) l0)) in |- *; auto with datatypes.\napply in_map; auto.\napply H; apply ulist_inv with (1 := H0); auto.\nQed. \n", "definition": "\n forall l : list (A * B), ulist (map (fst (B:=_)) l) -> unique_key l.", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a; case a.\nintros a0 b l0 H H0; apply unique_key_cons; auto.\nintros b0; red in |- *; intros H1; absurd (In a0 (map (fst (B:=_)) l0)); auto.\ninversion H0; auto.\nchange (In (fst (a0, b0)) (map (fst (B:=_)) l0)) in |- *; auto with datatypes.\napply in_map; auto.\napply H; apply ulist_inv with (1 := H0); auto.\n", "def_ranges": [122, 0, 123, 69], "proof_ranges": [124, 0, 133, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a; case a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b l0 H H0; apply unique_key_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b0; red in |- *; intros H1; absurd (In a0 (map (fst (B:=_)) l0)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (In (fst (a0, b0)) (map (fst (B:=_)) l0)) in |- *; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply in_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H; apply ulist_inv with (1 := H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/UniqueKey.v", "name": "unique_key_map", "text": "Theorem unique_key_map :\n forall (A B C D : Type) l (f : A * B -> C * D),\n unique_key l ->\n (forall a b, fst (f a) = fst (f b) -> fst a = fst b) -> unique_key (map f l).\nProof using.\nintros A B C D l f H; elim H; simpl in |- *; auto.\nintros a b l0 H0 H1 H2 H3.\nCaseEq (f (a, b)); intros fa fb Hf; auto.\napply unique_key_cons; auto.\ngeneralize H0; elim l0; simpl in |- *; auto.\nintros (a0, b0) l1 H4 H5 b1; red in |- *; intros [H6| H6].\ncase (H5 b0); left; apply f_equal2 with (f := pair (A:=A) (B:=B)); auto.\nchange (fst (a0, b0) = fst (a, b)) in |- *.\napply H3; auto.\nrewrite H6; rewrite Hf; simpl in |- *; auto.\ngeneralize H6; change (~ In (fa, b1) (map f l1)) in |- *.\napply H4.\nintros b2; red in |- *; intros H7.\ncase (H5 b2); auto.\nQed.\n", "definition": "\n forall (A B C D : Type) l (f : A * B -> C * D),\n unique_key l ->\n (forall a b, fst (f a) = fst (f b) -> fst a = fst b) -> unique_key (map f l).", "proof": "\nProof using.\nintros A B C D l f H; elim H; simpl in |- *; auto.\nintros a b l0 H0 H1 H2 H3.\nCaseEq (f (a, b)); intros fa fb Hf; auto.\napply unique_key_cons; auto.\ngeneralize H0; elim l0; simpl in |- *; auto.\nintros (a0, b0) l1 H4 H5 b1; red in |- *; intros [H6| H6].\ncase (H5 b0); left; apply f_equal2 with (f := pair (A:=A) (B:=B)); auto.\nchange (fst (a0, b0) = fst (a, b)) in |- *.\napply H3; auto.\nrewrite H6; rewrite Hf; simpl in |- *; auto.\ngeneralize H6; change (~ In (fa, b1) (map f l1)) in |- *.\napply H4.\nintros b2; red in |- *; intros H7.\ncase (H5 b2); auto.\n", "def_ranges": [140, 0, 143, 78], "proof_ranges": [144, 0, 159, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A B C D l f H; elim H; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b l0 H0 H1 H2 H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "CaseEq (f (a, b)); intros fa fb Hf; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H0; elim l0; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a0, b0) l1 H4 H5 b1; red in |- *; intros [H6| H6].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H5 b0); left; apply f_equal2 with (f := pair (A:=A) (B:=B)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (fst (a0, b0) = fst (a, b)) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H6; rewrite Hf; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H6; change (~ In (fa, b1) (map f l1)) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b2; red in |- *; intros H7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H5 b2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/OneStep.v", "name": "one_step_weight_tree_list", "text": "Theorem one_step_weight_tree_list :\n forall l1 l2 l3 : list (btree A),\n one_step l1 l2 ->\n one_step l1 l3 -> weight_tree_list f l2 = weight_tree_list f l3.\nProof using.\nintros l1 l2 l3 (l4, (t1, (t2, (H1, (H2, H3)))))\n (l5, (t3, (t4, (H4, (H5, H6))))).\nrewrite weight_tree_list_permutation with (1 := H3).\nrewrite weight_tree_list_permutation with (1 := H6).\nrepeat rewrite weight_tree_list_node.\napply f_equal2 with (f := plus).\ncut\n (map (sum_leaves f) (t1 :: t2 :: l4) = map (sum_leaves f) (t3 :: t4 :: l5)).\nsimpl in |- *; intros H7; injection H7.\nintros H8 H9 H10; repeat apply f_equal2 with (f := plus); auto.\napply ordered_sum_leaves_eq; auto.\napply permutation_trans with (2 := H5); auto.\napply permutation_sym; auto.\nrewrite <- weight_tree_list_permutation with (1 := H2).\napply weight_tree_list_permutation; auto.\nQed.\n", "definition": "\n forall l1 l2 l3 : list (btree A),\n one_step l1 l2 ->\n one_step l1 l3 -> weight_tree_list f l2 = weight_tree_list f l3.", "proof": "\nProof using.\nintros l1 l2 l3 (l4, (t1, (t2, (H1, (H2, H3)))))\n (l5, (t3, (t4, (H4, (H5, H6))))).\nrewrite weight_tree_list_permutation with (1 := H3).\nrewrite weight_tree_list_permutation with (1 := H6).\nrepeat rewrite weight_tree_list_node.\napply f_equal2 with (f := plus).\ncut\n (map (sum_leaves f) (t1 :: t2 :: l4) = map (sum_leaves f) (t3 :: t4 :: l5)).\nsimpl in |- *; intros H7; injection H7.\nintros H8 H9 H10; repeat apply f_equal2 with (f := plus); auto.\napply ordered_sum_leaves_eq; auto.\napply permutation_trans with (2 := H5); auto.\napply permutation_sym; auto.\nrewrite <- weight_tree_list_permutation with (1 := H2).\napply weight_tree_list_permutation; auto.\n", "def_ranges": [44, 0, 47, 65], "proof_ranges": [48, 0, 64, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 l3 (l4, (t1, (t2, (H1, (H2, H3)))))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l5, (t3, (t4, (H4, (H5, H6))))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite weight_tree_list_permutation with (1 := H3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite weight_tree_list_permutation with (1 := H6).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite weight_tree_list_node.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := plus).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (sum_leaves f) (t1 :: t2 :: l4) = map (sum_leaves f) (t3 :: t4 :: l5)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros H7; injection H7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H8 H9 H10; repeat apply f_equal2 with (f := plus); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_sum_leaves_eq; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (2 := H5); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_sym; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- weight_tree_list_permutation with (1 := H2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply weight_tree_list_permutation; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/OneStep.v", "name": "one_step_same_sum_leaves", "text": "Theorem one_step_same_sum_leaves :\n forall l1 l2 l3 : list (btree A),\n one_step l1 l2 -> one_step l1 l3 -> same_sum_leaves f l2 l3.\nintros l1 l2 l3 (l4, (t1, (t2, (H1, (H2, H3)))))\n (l5, (t3, (t4, (H4, (H5, H6))))).\nProof using.\nred in |- *.\nexists (node t1 t2 :: l4); exists (node t3 t4 :: l5); auto; simpl in |- *;\n auto.\nsplit; auto; split; auto.\ncut\n (map (sum_leaves f) (t1 :: t2 :: l4) = map (sum_leaves f) (t3 :: t4 :: l5)).\nsimpl in |- *; intros H7; injection H7; intros H8 H9 H10;\n apply f_equal2 with (f := cons (A:=nat)); auto.\napply ordered_sum_leaves_eq; auto.\napply permutation_trans with (2 := H5); auto.\napply permutation_sym; auto.\nQed.\n", "definition": "\n forall l1 l2 l3 : list (btree A),\n one_step l1 l2 -> one_step l1 l3 -> same_sum_leaves f l2 l3.", "proof": "\nintros l1 l2 l3 (l4, (t1, (t2, (H1, (H2, H3)))))\n (l5, (t3, (t4, (H4, (H5, H6))))).\nProof using.\nred in |- *.\nexists (node t1 t2 :: l4); exists (node t3 t4 :: l5); auto; simpl in |- *;\n auto.\nsplit; auto; split; auto.\ncut\n (map (sum_leaves f) (t1 :: t2 :: l4) = map (sum_leaves f) (t3 :: t4 :: l5)).\nsimpl in |- *; intros H7; injection H7; intros H8 H9 H10;\n apply f_equal2 with (f := cons (A:=nat)); auto.\napply ordered_sum_leaves_eq; auto.\napply permutation_trans with (2 := H5); auto.\napply permutation_sym; auto.\n", "def_ranges": [67, 0, 69, 61], "proof_ranges": [70, 0, 84, 4], "proof_steps": [{"text": "intros l1 l2 l3 (l4, (t1, (t2, (H1, (H2, H3)))))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l5, (t3, (t4, (H4, (H5, H6))))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (node t1 t2 :: l4); exists (node t3 t4 :: l5); auto; simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto; split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (sum_leaves f) (t1 :: t2 :: l4) = map (sum_leaves f) (t3 :: t4 :: l5)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros H7; injection H7; intros H8 H9 H10;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := cons (A:=nat)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_sum_leaves_eq; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (2 := H5); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/OneStep.v", "name": "one_step_comp", "text": "Theorem one_step_comp :\n forall l1 l2 l3 l4 : list (btree A),\n weight_tree_list f l1 = weight_tree_list f l2 ->\n same_sum_leaves f l1 l2 ->\n one_step l1 l3 ->\n one_step l2 l4 ->\n weight_tree_list f l3 = weight_tree_list f l4 /\\ same_sum_leaves f l3 l4.\nProof using.\nintros l1 l2 l3 l4 H1 (l5, (l6, (H2, (H3, H4))))\n (l7, (t1, (t2, (H5, (H6, H7))))) (l8, (t3, (t4, (H8, (H9, H10))))).\ncut\n (map (sum_leaves f) (t1 :: t2 :: l7) = map (sum_leaves f) (t3 :: t4 :: l8)).\nintros H11.\nsplit.\nrewrite weight_tree_list_permutation with (1 := H7).\nrewrite weight_tree_list_permutation with (1 := H10).\nrepeat rewrite weight_tree_list_node.\napply f_equal2 with (f := plus).\ninjection H11; intros H12 H13 H14; auto.\nrewrite weight_tree_list_permutation with (1 := permutation_sym _ _ _ H6).\nrewrite weight_tree_list_permutation with (1 := permutation_sym _ _ _ H9);\n auto.\nred in |- *; exists (node t1 t2 :: l7); exists (node t3 t4 :: l8);\n repeat (split; auto).\nsimpl in |- *.\nsimpl in H11; injection H11; auto.\nintros; apply f_equal2 with (f := cons (A:=nat)); auto.\napply ordered_perm_antisym_eq with (order := le).\nexact le_trans.\nexact le_antisym.\napply permutation_trans with (map (sum_leaves f) l1).\ngeneralize\n (permutation_map _ _ (sum_leaves f) _ _ (permutation_sym _ _ _ H6)); \n auto.\napply permutation_trans with (map (sum_leaves f) l5).\ngeneralize (permutation_map _ _ (sum_leaves f) _ _ H2); auto.\nrewrite H4.\napply permutation_trans with (map (sum_leaves f) l2).\ngeneralize\n (permutation_map _ _ (sum_leaves f) _ _ (permutation_sym _ _ _ H3)); \n auto.\ngeneralize (permutation_map _ _ (sum_leaves f) _ _ H9); auto.\nchange (ordered le (map (sum_leaves f) (t1 :: t2 :: l7))) in |- *.\napply ordered_map_inv; auto.\nchange (ordered le (map (sum_leaves f) (t3 :: t4 :: l8))) in |- *.\napply ordered_map_inv; auto.\nQed.\n", "definition": "\n forall l1 l2 l3 l4 : list (btree A),\n weight_tree_list f l1 = weight_tree_list f l2 ->\n same_sum_leaves f l1 l2 ->\n one_step l1 l3 ->\n one_step l2 l4 ->\n weight_tree_list f l3 = weight_tree_list f l4 /\\ same_sum_leaves f l3 l4.", "proof": "\nProof using.\nintros l1 l2 l3 l4 H1 (l5, (l6, (H2, (H3, H4))))\n (l7, (t1, (t2, (H5, (H6, H7))))) (l8, (t3, (t4, (H8, (H9, H10))))).\ncut\n (map (sum_leaves f) (t1 :: t2 :: l7) = map (sum_leaves f) (t3 :: t4 :: l8)).\nintros H11.\nsplit.\nrewrite weight_tree_list_permutation with (1 := H7).\nrewrite weight_tree_list_permutation with (1 := H10).\nrepeat rewrite weight_tree_list_node.\napply f_equal2 with (f := plus).\ninjection H11; intros H12 H13 H14; auto.\nrewrite weight_tree_list_permutation with (1 := permutation_sym _ _ _ H6).\nrewrite weight_tree_list_permutation with (1 := permutation_sym _ _ _ H9);\n auto.\nred in |- *; exists (node t1 t2 :: l7); exists (node t3 t4 :: l8);\n repeat (split; auto).\nsimpl in |- *.\nsimpl in H11; injection H11; auto.\nintros; apply f_equal2 with (f := cons (A:=nat)); auto.\napply ordered_perm_antisym_eq with (order := le).\nexact le_trans.\nexact le_antisym.\napply permutation_trans with (map (sum_leaves f) l1).\ngeneralize\n (permutation_map _ _ (sum_leaves f) _ _ (permutation_sym _ _ _ H6)); \n auto.\napply permutation_trans with (map (sum_leaves f) l5).\ngeneralize (permutation_map _ _ (sum_leaves f) _ _ H2); auto.\nrewrite H4.\napply permutation_trans with (map (sum_leaves f) l2).\ngeneralize\n (permutation_map _ _ (sum_leaves f) _ _ (permutation_sym _ _ _ H3)); \n auto.\ngeneralize (permutation_map _ _ (sum_leaves f) _ _ H9); auto.\nchange (ordered le (map (sum_leaves f) (t1 :: t2 :: l7))) in |- *.\napply ordered_map_inv; auto.\nchange (ordered le (map (sum_leaves f) (t3 :: t4 :: l8))) in |- *.\napply ordered_map_inv; auto.\n", "def_ranges": [87, 0, 93, 74], "proof_ranges": [94, 0, 133, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 l3 l4 H1 (l5, (l6, (H2, (H3, H4))))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l7, (t1, (t2, (H5, (H6, H7))))) (l8, (t3, (t4, (H8, (H9, H10))))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (sum_leaves f) (t1 :: t2 :: l7) = map (sum_leaves f) (t3 :: t4 :: l8)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite weight_tree_list_permutation with (1 := H7).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite weight_tree_list_permutation with (1 := H10).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite weight_tree_list_node.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := plus).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H11; intros H12 H13 H14; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite weight_tree_list_permutation with (1 := permutation_sym _ _ _ H6).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite weight_tree_list_permutation with (1 := permutation_sym _ _ _ H9);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; exists (node t1 t2 :: l7); exists (node t3 t4 :: l8);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat (split; auto).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in H11; injection H11; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; apply f_equal2 with (f := cons (A:=nat)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_perm_antisym_eq with (order := le).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact le_trans.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact le_antisym.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (map (sum_leaves f) l1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(permutation_map _ _ (sum_leaves f) _ _ (permutation_sym _ _ _ H6));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (map (sum_leaves f) l5).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (permutation_map _ _ (sum_leaves f) _ _ H2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (map (sum_leaves f) l2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(permutation_map _ _ (sum_leaves f) _ _ (permutation_sym _ _ _ H3));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (permutation_map _ _ (sum_leaves f) _ _ H9); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (ordered le (map (sum_leaves f) (t1 :: t2 :: l7))) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Prod2List.v", "name": "prod2list_app", "text": "Theorem prod2list_app :\n forall l1 l2 l3 l4,\n length l1 = length l2 ->\n prod2list (l1 ++ l3) (l2 ++ l4) = prod2list l1 l2 + prod2list l3 l4.\nProof using.\nintros l1 l2 l3 l4 H; unfold prod2list in |- *.\nrewrite map2_app; auto.\nrewrite fold_left_app.\nrewrite plus_comm.\napply sym_equal.\nrepeat\n rewrite\n  fold_left_eta with (f := plus) (f1 := fun a b : nat => a + (fun x => x) b);\n auto.\napply sym_equal; rewrite <- fold_plus_split with (f := fun x : nat => x);\n auto.\napply plus_comm.\nQed.\n", "definition": "\n forall l1 l2 l3 l4,\n length l1 = length l2 ->\n prod2list (l1 ++ l3) (l2 ++ l4) = prod2list l1 l2 + prod2list l3 l4.", "proof": "\nProof using.\nintros l1 l2 l3 l4 H; unfold prod2list in |- *.\nrewrite map2_app; auto.\nrewrite fold_left_app.\nrewrite plus_comm.\napply sym_equal.\nrepeat\n rewrite\n  fold_left_eta with (f := plus) (f1 := fun a b : nat => a + (fun x => x) b);\n auto.\napply sym_equal; rewrite <- fold_plus_split with (f := fun x : nat => x);\n auto.\napply plus_comm.\n", "def_ranges": [43, 0, 46, 69], "proof_ranges": [47, 0, 60, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 l3 l4 H; unfold prod2list in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite map2_app; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite fold_left_app.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite plus_comm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sym_equal.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fold_left_eta with (f := plus) (f1 := fun a b : nat => a + (fun x => x) b);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sym_equal; rewrite <- fold_plus_split with (f := fun x : nat => x);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Prod2List.v", "name": "prod2list_le_l", "text": "Theorem prod2list_le_l :\n forall a b c d l1 l2 l3 l4 l5 l6,\n length l1 = length l4 ->\n length l2 = length l5 ->\n length l3 = length l6 ->\n sum_leaves f c <= sum_leaves f d ->\n a <= b ->\n prod2list (l1 ++ a :: l2 ++ b :: l3) (l4 ++ d :: l5 ++ c :: l6) <=\n prod2list (l1 ++ a :: l2 ++ b :: l3) (l4 ++ c :: l5 ++ d :: l6).\nProof using.\nintros a b c d l1 l2 l3 l4 l5 l6 H H0 H1 H2 H3;\n change\n   (prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n      (l4 ++ (d :: nil) ++ l5 ++ (c :: nil) ++ l6) <=\n    prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n      (l4 ++ (c :: nil) ++ l5 ++ (d :: nil) ++ l6)) \n  in |- *.\nrepeat rewrite prod2list_app; auto.\napply plus_le_compat; auto with arith.\nrepeat rewrite plus_assoc; apply plus_le_compat; auto.\nrepeat rewrite (fun x y z => plus_comm (prod2list (x :: y) z)).\nrepeat rewrite plus_assoc_reverse; apply plus_le_compat; auto.\nunfold prod2list in |- *; simpl in |- *.\nrewrite le_plus_minus with (1 := H3); auto.\nrewrite le_plus_minus with (1 := H2); auto.\nreplace\n (a * (sum_leaves f c + (sum_leaves f d - sum_leaves f c)) + weight_tree f d +\n  ((a + (b - a)) * sum_leaves f c + weight_tree f c)) with\n (a * sum_leaves f c + weight_tree f c +\n  (a * (sum_leaves f d - sum_leaves f c) + (a + (b - a)) * sum_leaves f c +\n   weight_tree f d)); [ idtac | ring ].\napply plus_le_compat; auto with arith.\napply plus_le_compat; auto with arith.\nrepeat rewrite mult_plus_distr_l || rewrite mult_plus_distr_r;\n auto with arith.\nreplace\n (a * (sum_leaves f d - sum_leaves f c) +\n  (a * sum_leaves f c + (b - a) * sum_leaves f c)) with\n (a * sum_leaves f c + (b - a) * sum_leaves f c +\n  (a * (sum_leaves f d - sum_leaves f c) + 0)); [ auto with arith | ring ].\nQed.\n", "definition": "\n forall a b c d l1 l2 l3 l4 l5 l6,\n length l1 = length l4 ->\n length l2 = length l5 ->\n length l3 = length l6 ->\n sum_leaves f c <= sum_leaves f d ->\n a <= b ->\n prod2list (l1 ++ a :: l2 ++ b :: l3) (l4 ++ d :: l5 ++ c :: l6) <=\n prod2list (l1 ++ a :: l2 ++ b :: l3) (l4 ++ c :: l5 ++ d :: l6).", "proof": "\nProof using.\nintros a b c d l1 l2 l3 l4 l5 l6 H H0 H1 H2 H3;\n change\n   (prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n      (l4 ++ (d :: nil) ++ l5 ++ (c :: nil) ++ l6) <=\n    prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n      (l4 ++ (c :: nil) ++ l5 ++ (d :: nil) ++ l6)) \n  in |- *.\nrepeat rewrite prod2list_app; auto.\napply plus_le_compat; auto with arith.\nrepeat rewrite plus_assoc; apply plus_le_compat; auto.\nrepeat rewrite (fun x y z => plus_comm (prod2list (x :: y) z)).\nrepeat rewrite plus_assoc_reverse; apply plus_le_compat; auto.\nunfold prod2list in |- *; simpl in |- *.\nrewrite le_plus_minus with (1 := H3); auto.\nrewrite le_plus_minus with (1 := H2); auto.\nreplace\n (a * (sum_leaves f c + (sum_leaves f d - sum_leaves f c)) + weight_tree f d +\n  ((a + (b - a)) * sum_leaves f c + weight_tree f c)) with\n (a * sum_leaves f c + weight_tree f c +\n  (a * (sum_leaves f d - sum_leaves f c) + (a + (b - a)) * sum_leaves f c +\n   weight_tree f d)); [ idtac | ring ].\napply plus_le_compat; auto with arith.\napply plus_le_compat; auto with arith.\nrepeat rewrite mult_plus_distr_l || rewrite mult_plus_distr_r;\n auto with arith.\nreplace\n (a * (sum_leaves f d - sum_leaves f c) +\n  (a * sum_leaves f c + (b - a) * sum_leaves f c)) with\n (a * sum_leaves f c + (b - a) * sum_leaves f c +\n  (a * (sum_leaves f d - sum_leaves f c) + 0)); [ auto with arith | ring ].\n", "def_ranges": [63, 0, 71, 65], "proof_ranges": [72, 0, 103, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b c d l1 l2 l3 l4 l5 l6 H H0 H1 H2 H3;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l4 ++ (d :: nil) ++ l5 ++ (c :: nil) ++ l6) <=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l4 ++ (c :: nil) ++ l5 ++ (d :: nil) ++ l6))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite prod2list_app; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply plus_le_compat; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc; apply plus_le_compat; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite (fun x y z => plus_comm (prod2list (x :: y) z)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc_reverse; apply plus_le_compat; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold prod2list in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite le_plus_minus with (1 := H3); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite le_plus_minus with (1 := H2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(a * (sum_leaves f c + (sum_leaves f d - sum_leaves f c)) + weight_tree f d +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((a + (b - a)) * sum_leaves f c + weight_tree f c)) with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(a * sum_leaves f c + weight_tree f c +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(a * (sum_leaves f d - sum_leaves f c) + (a + (b - a)) * sum_leaves f c +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "weight_tree f d)); [ idtac | ring ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply plus_le_compat; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply plus_le_compat; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Prod2List.v", "name": "prod2list_le_r", "text": "Theorem prod2list_le_r :\n forall a b c d l1 l2 l3 l4 l5 l6,\n length l1 = length l4 ->\n length l2 = length l5 ->\n length l3 = length l6 ->\n sum_leaves f d <= sum_leaves f c ->\n b <= a ->\n prod2list (l1 ++ a :: l2 ++ b :: l3) (l4 ++ d :: l5 ++ c :: l6) <=\n prod2list (l1 ++ a :: l2 ++ b :: l3) (l4 ++ c :: l5 ++ d :: l6).\nProof using.\nintros a b c d l1 l2 l3 l4 l5 l6 H H0 H1 H2 H3;\n change\n   (prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n      (l4 ++ (d :: nil) ++ l5 ++ (c :: nil) ++ l6) <=\n    prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n      (l4 ++ (c :: nil) ++ l5 ++ (d :: nil) ++ l6)) \n  in |- *.\nrepeat rewrite prod2list_app; auto.\napply plus_le_compat; auto with arith.\nrepeat rewrite plus_assoc; apply plus_le_compat; auto.\nrepeat rewrite (fun x y z => plus_comm (prod2list (x :: y) z)).\nrepeat rewrite plus_assoc_reverse; apply plus_le_compat; auto.\nunfold prod2list in |- *; simpl in |- *.\nrewrite le_plus_minus with (1 := H3); auto.\nrewrite le_plus_minus with (1 := H2); auto.\nreplace\n ((b + (a - b)) * (sum_leaves f d + (sum_leaves f c - sum_leaves f d)) +\n  weight_tree f c + (b * sum_leaves f d + weight_tree f d)) with\n ((b + (a - b)) * sum_leaves f d + weight_tree f d +\n  ((b + (a - b)) * (sum_leaves f c - sum_leaves f d) + b * sum_leaves f d +\n   weight_tree f c)); [ idtac | ring ].\napply plus_le_compat; auto with arith.\napply plus_le_compat; auto with arith.\nrepeat rewrite mult_plus_distr_l || rewrite mult_plus_distr_r;\n auto with arith.\nreplace (b * sum_leaves f d + b * (sum_leaves f c - sum_leaves f d)) with\n (b * (sum_leaves f c - sum_leaves f d) + 0 + b * sum_leaves f d);\n [ auto with arith | ring ].\nQed.\n", "definition": "\n forall a b c d l1 l2 l3 l4 l5 l6,\n length l1 = length l4 ->\n length l2 = length l5 ->\n length l3 = length l6 ->\n sum_leaves f d <= sum_leaves f c ->\n b <= a ->\n prod2list (l1 ++ a :: l2 ++ b :: l3) (l4 ++ d :: l5 ++ c :: l6) <=\n prod2list (l1 ++ a :: l2 ++ b :: l3) (l4 ++ c :: l5 ++ d :: l6).", "proof": "\nProof using.\nintros a b c d l1 l2 l3 l4 l5 l6 H H0 H1 H2 H3;\n change\n   (prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n      (l4 ++ (d :: nil) ++ l5 ++ (c :: nil) ++ l6) <=\n    prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n      (l4 ++ (c :: nil) ++ l5 ++ (d :: nil) ++ l6)) \n  in |- *.\nrepeat rewrite prod2list_app; auto.\napply plus_le_compat; auto with arith.\nrepeat rewrite plus_assoc; apply plus_le_compat; auto.\nrepeat rewrite (fun x y z => plus_comm (prod2list (x :: y) z)).\nrepeat rewrite plus_assoc_reverse; apply plus_le_compat; auto.\nunfold prod2list in |- *; simpl in |- *.\nrewrite le_plus_minus with (1 := H3); auto.\nrewrite le_plus_minus with (1 := H2); auto.\nreplace\n ((b + (a - b)) * (sum_leaves f d + (sum_leaves f c - sum_leaves f d)) +\n  weight_tree f c + (b * sum_leaves f d + weight_tree f d)) with\n ((b + (a - b)) * sum_leaves f d + weight_tree f d +\n  ((b + (a - b)) * (sum_leaves f c - sum_leaves f d) + b * sum_leaves f d +\n   weight_tree f c)); [ idtac | ring ].\napply plus_le_compat; auto with arith.\napply plus_le_compat; auto with arith.\nrepeat rewrite mult_plus_distr_l || rewrite mult_plus_distr_r;\n auto with arith.\nreplace (b * sum_leaves f d + b * (sum_leaves f c - sum_leaves f d)) with\n (b * (sum_leaves f c - sum_leaves f d) + 0 + b * sum_leaves f d);\n [ auto with arith | ring ].\n", "def_ranges": [106, 0, 114, 65], "proof_ranges": [115, 0, 144, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b c d l1 l2 l3 l4 l5 l6 H H0 H1 H2 H3;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l4 ++ (d :: nil) ++ l5 ++ (c :: nil) ++ l6) <=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "prod2list (l1 ++ (a :: nil) ++ l2 ++ (b :: nil) ++ l3)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l4 ++ (c :: nil) ++ l5 ++ (d :: nil) ++ l6))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite prod2list_app; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply plus_le_compat; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc; apply plus_le_compat; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite (fun x y z => plus_comm (prod2list (x :: y) z)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc_reverse; apply plus_le_compat; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold prod2list in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite le_plus_minus with (1 := H3); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite le_plus_minus with (1 := H2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((b + (a - b)) * (sum_leaves f d + (sum_leaves f c - sum_leaves f d)) +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "weight_tree f c + (b * sum_leaves f d + weight_tree f d)) with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((b + (a - b)) * sum_leaves f d + weight_tree f d +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((b + (a - b)) * (sum_leaves f c - sum_leaves f d) + b * sum_leaves f d +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "weight_tree f c)); [ idtac | ring ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply plus_le_compat; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Prod2List.v", "name": "prod2list_eq", "text": "Theorem prod2list_eq :\n forall a b c l1 l2 l3 l4 l5 l6,\n length l1 = length l4 ->\n length l2 = length l5 ->\n length l3 = length l6 ->\n prod2list (l1 ++ a :: l2 ++ a :: l3) (l4 ++ b :: l5 ++ c :: l6) =\n prod2list (l1 ++ a :: l2 ++ a :: l3) (l4 ++ c :: l5 ++ b :: l6).\nProof using.\nintros a b c l1 l2 l3 l4 l5 l6 H H0 H1;\n change\n   (prod2list (l1 ++ (a :: nil) ++ l2 ++ (a :: nil) ++ l3)\n      (l4 ++ (b :: nil) ++ l5 ++ (c :: nil) ++ l6) =\n    prod2list (l1 ++ (a :: nil) ++ l2 ++ (a :: nil) ++ l3)\n      (l4 ++ (c :: nil) ++ l5 ++ (b :: nil) ++ l6)) \n  in |- *.\nrepeat rewrite prod2list_app; auto with arith.\nring.\nQed.\n", "definition": "\n forall a b c l1 l2 l3 l4 l5 l6,\n length l1 = length l4 ->\n length l2 = length l5 ->\n length l3 = length l6 ->\n prod2list (l1 ++ a :: l2 ++ a :: l3) (l4 ++ b :: l5 ++ c :: l6) =\n prod2list (l1 ++ a :: l2 ++ a :: l3) (l4 ++ c :: l5 ++ b :: l6).", "proof": "\nProof using.\nintros a b c l1 l2 l3 l4 l5 l6 H H0 H1;\n change\n   (prod2list (l1 ++ (a :: nil) ++ l2 ++ (a :: nil) ++ l3)\n      (l4 ++ (b :: nil) ++ l5 ++ (c :: nil) ++ l6) =\n    prod2list (l1 ++ (a :: nil) ++ l2 ++ (a :: nil) ++ l3)\n      (l4 ++ (c :: nil) ++ l5 ++ (b :: nil) ++ l6)) \n  in |- *.\nrepeat rewrite prod2list_app; auto with arith.\nring.\n", "def_ranges": [147, 0, 153, 65], "proof_ranges": [154, 0, 164, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b c l1 l2 l3 l4 l5 l6 H H0 H1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(prod2list (l1 ++ (a :: nil) ++ l2 ++ (a :: nil) ++ l3)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l4 ++ (b :: nil) ++ l5 ++ (c :: nil) ++ l6) =", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "prod2list (l1 ++ (a :: nil) ++ l2 ++ (a :: nil) ++ l3)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(l4 ++ (c :: nil) ++ l5 ++ (b :: nil) ++ l6))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Prod2List.v", "name": "prod2list_reorder", "text": "Theorem prod2list_reorder :\n forall a b b1 l1 l2 l3 l4 l5,\n length l1 = length l3 ->\n length l2 = length l4 ->\n (forall b, In b l1 -> b <= a) ->\n (forall b, In b l2 -> b <= a) ->\n permutation (l3 ++ b :: l4) (b1 :: l5) ->\n ordered (sum_order f) (b1 :: l5) ->\n exists l6 : _,\n   (exists l7 : _,\n      length l1 = length l6 /\\\n      length l2 = length l7 /\\\n      permutation (b1 :: l5) (l6 ++ b1 :: l7) /\\\n      prod2list (l1 ++ a :: l2) (l6 ++ b1 :: l7) <=\n      prod2list (l1 ++ a :: l2) (l3 ++ b :: l4)).\nProof using.\nintros a b b1 l1 l2 l3 l4 l5 H H0 H1 H2 H3 H4.\ncut (In b (b1 :: l5));\n [ simpl in |- *; intros [HH0| HH0]\n | apply permutation_in with (1 := H3); auto with datatypes ].\nexists l3; exists l4; repeat (split; auto).\npattern b1 at 2 in |- *; rewrite HH0; apply permutation_sym; auto.\nrewrite HH0; auto.\ncut (In b1 (l3 ++ b :: l4));\n [ intros HH1\n | apply permutation_in with (1 := permutation_sym _ _ _ H3);\n    auto with datatypes ].\ncase in_app_or with (1 := HH1); intros HH2.\ncase in_ex_app with (1 := HH2).\nintros l6 (l7, HH3); exists (l6 ++ b :: l7); exists l4; repeat (split; auto).\napply trans_equal with (1 := H).\nrewrite HH3; repeat rewrite length_app; simpl in |- *; auto with arith.\napply permutation_sym; apply permutation_trans with (2 := H3); auto.\nrewrite HH3.\nrepeat rewrite app_ass.\nsimpl in |- *; apply permutation_transposition.\nrewrite HH3; auto.\nrepeat rewrite app_ass.\ncase (same_length_ex _ _ b1 l6 l7 l1); auto.\nrewrite <- HH3; auto.\nintros l8 (l9, (b2, (HH4, (HH5, HH6)))).\nrewrite HH6.\nrepeat rewrite app_ass; simpl in |- *.\napply prod2list_le_l; auto.\nchange (sum_order f b1 b) in |- *.\napply ordered_trans with (2 := H4); auto.\nunfold sum_order in |- *; intros a0 b0 c H5 H6; apply le_trans with (1 := H5);\n auto.\napply H1; rewrite HH6; auto with datatypes.\nsimpl in HH2; case HH2; intros HH3.\nexists l3; exists l4; repeat (split; auto); try (rewrite <- HH3; auto; fail).\npattern b1 at 2 in |- *; rewrite <- HH3; apply permutation_sym; auto.\ncase in_ex_app with (1 := HH3).\nintros l6 (l7, HH4); exists l3; exists (l6 ++ b :: l7); repeat (split; auto).\napply trans_equal with (1 := H0).\nrewrite HH4; repeat rewrite length_app; simpl in |- *; auto with arith.\napply permutation_sym; apply permutation_trans with (2 := H3); auto.\nrewrite HH4.\nsimpl in |- *; apply permutation_transposition.\nrewrite HH4; auto.\ncase (same_length_ex _ _ b1 l6 l7 l2); auto.\nrewrite <- HH4; auto.\nintros l8 (l9, (b2, (HH5, (HH6, HH7)))).\nrewrite HH7.\napply prod2list_le_r; auto.\nchange (sum_order f b1 b) in |- *.\napply ordered_trans with (2 := H4); auto.\nunfold sum_order in |- *; intros a0 b0 c H5 H6; apply le_trans with (1 := H5);\n auto.\napply H2; rewrite HH7; auto with datatypes.\nQed.\n", "definition": "\n forall a b b1 l1 l2 l3 l4 l5,\n length l1 = length l3 ->\n length l2 = length l4 ->\n (forall b, In b l1 -> b <= a) ->\n (forall b, In b l2 -> b <= a) ->\n permutation (l3 ++ b :: l4) (b1 :: l5) ->\n ordered (sum_order f) (b1 :: l5) ->\n exists l6 : _,\n   (exists l7 : _,\n      length l1 = length l6 /\\\n      length l2 = length l7 /\\\n      permutation (b1 :: l5) (l6 ++ b1 :: l7) /\\\n      prod2list (l1 ++ a :: l2) (l6 ++ b1 :: l7) <=\n      prod2list (l1 ++ a :: l2) (l3 ++ b :: l4)).", "proof": "\nProof using.\nintros a b b1 l1 l2 l3 l4 l5 H H0 H1 H2 H3 H4.\ncut (In b (b1 :: l5));\n [ simpl in |- *; intros [HH0| HH0]\n | apply permutation_in with (1 := H3); auto with datatypes ].\nexists l3; exists l4; repeat (split; auto).\npattern b1 at 2 in |- *; rewrite HH0; apply permutation_sym; auto.\nrewrite HH0; auto.\ncut (In b1 (l3 ++ b :: l4));\n [ intros HH1\n | apply permutation_in with (1 := permutation_sym _ _ _ H3);\n    auto with datatypes ].\ncase in_app_or with (1 := HH1); intros HH2.\ncase in_ex_app with (1 := HH2).\nintros l6 (l7, HH3); exists (l6 ++ b :: l7); exists l4; repeat (split; auto).\napply trans_equal with (1 := H).\nrewrite HH3; repeat rewrite length_app; simpl in |- *; auto with arith.\napply permutation_sym; apply permutation_trans with (2 := H3); auto.\nrewrite HH3.\nrepeat rewrite app_ass.\nsimpl in |- *; apply permutation_transposition.\nrewrite HH3; auto.\nrepeat rewrite app_ass.\ncase (same_length_ex _ _ b1 l6 l7 l1); auto.\nrewrite <- HH3; auto.\nintros l8 (l9, (b2, (HH4, (HH5, HH6)))).\nrewrite HH6.\nrepeat rewrite app_ass; simpl in |- *.\napply prod2list_le_l; auto.\nchange (sum_order f b1 b) in |- *.\napply ordered_trans with (2 := H4); auto.\nunfold sum_order in |- *; intros a0 b0 c H5 H6; apply le_trans with (1 := H5);\n auto.\napply H1; rewrite HH6; auto with datatypes.\nsimpl in HH2; case HH2; intros HH3.\nexists l3; exists l4; repeat (split; auto); try (rewrite <- HH3; auto; fail).\npattern b1 at 2 in |- *; rewrite <- HH3; apply permutation_sym; auto.\ncase in_ex_app with (1 := HH3).\nintros l6 (l7, HH4); exists l3; exists (l6 ++ b :: l7); repeat (split; auto).\napply trans_equal with (1 := H0).\nrewrite HH4; repeat rewrite length_app; simpl in |- *; auto with arith.\napply permutation_sym; apply permutation_trans with (2 := H3); auto.\nrewrite HH4.\nsimpl in |- *; apply permutation_transposition.\nrewrite HH4; auto.\ncase (same_length_ex _ _ b1 l6 l7 l2); auto.\nrewrite <- HH4; auto.\nintros l8 (l9, (b2, (HH5, (HH6, HH7)))).\nrewrite HH7.\napply prod2list_le_r; auto.\nchange (sum_order f b1 b) in |- *.\napply ordered_trans with (2 := H4); auto.\nunfold sum_order in |- *; intros a0 b0 c H5 H6; apply le_trans with (1 := H5);\n auto.\napply H2; rewrite HH7; auto with datatypes.\n", "def_ranges": [167, 0, 181, 49], "proof_ranges": [182, 0, 237, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b b1 l1 l2 l3 l4 l5 H H0 H1 H2 H3 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (In b (b1 :: l5));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ simpl in |- *; intros [HH0| HH0]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| apply permutation_in with (1 := H3); auto with datatypes ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists l3; exists l4; repeat (split; auto).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern b1 at 2 in |- *; rewrite HH0; apply permutation_sym; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (In b1 (l3 ++ b :: l4));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intros HH1", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| apply permutation_in with (1 := permutation_sym _ _ _ H3);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with datatypes ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case in_app_or with (1 := HH1); intros HH2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case in_ex_app with (1 := HH2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l6 (l7, HH3); exists (l6 ++ b :: l7); exists l4; repeat (split; auto).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply trans_equal with (1 := H).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH3; repeat rewrite length_app; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_sym; apply permutation_trans with (2 := H3); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite app_ass.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; apply permutation_transposition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite app_ass.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (same_length_ex _ _ b1 l6 l7 l1); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- HH3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l8 (l9, (b2, (HH4, (HH5, HH6)))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite app_ass; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply prod2list_le_l; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (sum_order f b1 b) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_trans with (2 := H4); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold sum_order in |- *; intros a0 b0 c H5 H6; apply le_trans with (1 := H5);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H1; rewrite HH6; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in HH2; case HH2; intros HH3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists l3; exists l4; repeat (split; auto); try (rewrite <- HH3; auto; fail).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern b1 at 2 in |- *; rewrite <- HH3; apply permutation_sym; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case in_ex_app with (1 := HH3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l6 (l7, HH4); exists l3; exists (l6 ++ b :: l7); repeat (split; auto).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply trans_equal with (1 := H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH4; repeat rewrite length_app; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_sym; apply permutation_trans with (2 := H3); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; apply permutation_transposition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH4; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (same_length_ex _ _ b1 l6 l7 l2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- HH4; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l8 (l9, (b2, (HH5, (HH6, HH7)))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply prod2list_le_r; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (sum_order f b1 b) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_trans with (2 := H4); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Prod2List.v", "name": "prod2list_reorder2", "text": "Theorem prod2list_reorder2 :\n forall a b c b1 c1 l1 l2 l3 l4 l5,\n length l1 = length l3 ->\n length l2 = length l4 ->\n (forall b, In b l1 -> b <= a) ->\n (forall b, In b l2 -> b <= a) ->\n permutation (l3 ++ b :: c :: l4) (b1 :: c1 :: l5) ->\n ordered (sum_order f) (b1 :: c1 :: l5) ->\n exists l6 : _,\n   (exists l7 : _,\n      length l1 = length l6 /\\\n      length l2 = length l7 /\\\n      permutation (b1 :: c1 :: l5) (l6 ++ b1 :: c1 :: l7) /\\\n      prod2list (l1 ++ a :: a :: l2) (l6 ++ b1 :: c1 :: l7) <=\n      prod2list (l1 ++ a :: a :: l2) (l3 ++ b :: c :: l4)).\nProof using.\nintros a b c b1 c1 l1 l2 l3 l4 l5 H H0 H1 H2 H3 H4.\ncase (prod2list_reorder a b b1 l1 (a :: l2) l3 (c :: l4) (c1 :: l5));\n simpl in |- *; auto.\nintros b0 [H5| H5]; auto.\nrewrite H5; auto.\nintros l6 (l7, (HH1, (HH2, (HH3, HH4)))).\ngeneralize HH2 HH3 HH4; case l7; clear HH2 HH3 HH4 l7.\nintros; discriminate.\nintros c2 l7 HH2 HH3 HH4.\ncase (prod2list_reorder a c2 c1 l1 l2 l6 l7 l5); simpl in |- *; auto.\napply permutation_inv with (a := b1); auto.\napply permutation_sym; apply permutation_trans with (1 := HH3).\nchange\n  (permutation (l6 ++ (b1 :: nil) ++ c2 :: l7)\n     (((b1 :: nil) ++ l6) ++ c2 :: l7)) in |- *.\nrepeat rewrite <- app_ass.\napply permutation_app_comp; auto.\napply ordered_inv with (1 := H4); auto.\nintros l8 (l9, (HH5, (HH6, (HH7, HH8)))).\nexists l8; exists l9; repeat (split; auto).\napply permutation_trans with ((b1 :: c1 :: l9) ++ l8); auto.\nsimpl in |- *; apply permutation_skip; auto.\napply permutation_trans with (1 := HH7).\napply permutation_trans with ((c1 :: l9) ++ l8); auto.\napply le_trans with (2 := HH4).\nchange\n  (prod2list (l1 ++ (a :: nil) ++ a :: l2) (l8 ++ (b1 :: nil) ++ c1 :: l9) <=\n   prod2list (l1 ++ (a :: nil) ++ a :: l2) (l6 ++ (b1 :: nil) ++ c2 :: l7))\n in |- *.\ngeneralize HH8; repeat rewrite prod2list_app; auto with arith.\nintros HH9.\nrepeat rewrite plus_assoc.\nrepeat rewrite (fun x => plus_comm (prod2list l1 x)).\nrepeat rewrite plus_assoc_reverse; auto with arith.\nQed.\n", "definition": "\n forall a b c b1 c1 l1 l2 l3 l4 l5,\n length l1 = length l3 ->\n length l2 = length l4 ->\n (forall b, In b l1 -> b <= a) ->\n (forall b, In b l2 -> b <= a) ->\n permutation (l3 ++ b :: c :: l4) (b1 :: c1 :: l5) ->\n ordered (sum_order f) (b1 :: c1 :: l5) ->\n exists l6 : _,\n   (exists l7 : _,\n      length l1 = length l6 /\\\n      length l2 = length l7 /\\\n      permutation (b1 :: c1 :: l5) (l6 ++ b1 :: c1 :: l7) /\\\n      prod2list (l1 ++ a :: a :: l2) (l6 ++ b1 :: c1 :: l7) <=\n      prod2list (l1 ++ a :: a :: l2) (l3 ++ b :: c :: l4)).", "proof": "\nProof using.\nintros a b c b1 c1 l1 l2 l3 l4 l5 H H0 H1 H2 H3 H4.\ncase (prod2list_reorder a b b1 l1 (a :: l2) l3 (c :: l4) (c1 :: l5));\n simpl in |- *; auto.\nintros b0 [H5| H5]; auto.\nrewrite H5; auto.\nintros l6 (l7, (HH1, (HH2, (HH3, HH4)))).\ngeneralize HH2 HH3 HH4; case l7; clear HH2 HH3 HH4 l7.\nintros; discriminate.\nintros c2 l7 HH2 HH3 HH4.\ncase (prod2list_reorder a c2 c1 l1 l2 l6 l7 l5); simpl in |- *; auto.\napply permutation_inv with (a := b1); auto.\napply permutation_sym; apply permutation_trans with (1 := HH3).\nchange\n  (permutation (l6 ++ (b1 :: nil) ++ c2 :: l7)\n     (((b1 :: nil) ++ l6) ++ c2 :: l7)) in |- *.\nrepeat rewrite <- app_ass.\napply permutation_app_comp; auto.\napply ordered_inv with (1 := H4); auto.\nintros l8 (l9, (HH5, (HH6, (HH7, HH8)))).\nexists l8; exists l9; repeat (split; auto).\napply permutation_trans with ((b1 :: c1 :: l9) ++ l8); auto.\nsimpl in |- *; apply permutation_skip; auto.\napply permutation_trans with (1 := HH7).\napply permutation_trans with ((c1 :: l9) ++ l8); auto.\napply le_trans with (2 := HH4).\nchange\n  (prod2list (l1 ++ (a :: nil) ++ a :: l2) (l8 ++ (b1 :: nil) ++ c1 :: l9) <=\n   prod2list (l1 ++ (a :: nil) ++ a :: l2) (l6 ++ (b1 :: nil) ++ c2 :: l7))\n in |- *.\ngeneralize HH8; repeat rewrite prod2list_app; auto with arith.\nintros HH9.\nrepeat rewrite plus_assoc.\nrepeat rewrite (fun x => plus_comm (prod2list l1 x)).\nrepeat rewrite plus_assoc_reverse; auto with arith.\n", "def_ranges": [240, 0, 254, 59], "proof_ranges": [255, 0, 290, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b c b1 c1 l1 l2 l3 l4 l5 H H0 H1 H2 H3 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (prod2list_reorder a b b1 l1 (a :: l2) l3 (c :: l4) (c1 :: l5));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b0 [H5| H5]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H5; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l6 (l7, (HH1, (HH2, (HH3, HH4)))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize HH2 HH3 HH4; case l7; clear HH2 HH3 HH4 l7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c2 l7 HH2 HH3 HH4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (prod2list_reorder a c2 c1 l1 l2 l6 l7 l5); simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_inv with (a := b1); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_sym; apply permutation_trans with (1 := HH3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(permutation (l6 ++ (b1 :: nil) ++ c2 :: l7)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(((b1 :: nil) ++ l6) ++ c2 :: l7)) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite <- app_ass.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_app_comp; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_inv with (1 := H4); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l8 (l9, (HH5, (HH6, (HH7, HH8)))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists l8; exists l9; repeat (split; auto).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with ((b1 :: c1 :: l9) ++ l8); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; apply permutation_skip; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (1 := HH7).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with ((c1 :: l9) ++ l8); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply le_trans with (2 := HH4).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(prod2list (l1 ++ (a :: nil) ++ a :: l2) (l8 ++ (b1 :: nil) ++ c1 :: l9) <=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "prod2list (l1 ++ (a :: nil) ++ a :: l2) (l6 ++ (b1 :: nil) ++ c2 :: l7))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize HH8; repeat rewrite prod2list_app; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HH9.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/OrderedCover.v", "name": "ordered_cover_cover", "text": "Theorem ordered_cover_cover :\n forall (l : list (btree A)) (t : btree A), ordered_cover l t -> cover l t.\nintros l t H; elim H; auto.\nintros t1 t2 l1 l2 l3 H0 H1 H2 H3.\nProof using.\napply cover_app; auto.\nQed.\n", "definition": "\n forall (l : list (btree A)) (t : btree A), ordered_cover l t -> cover l t.", "proof": "\nintros l t H; elim H; auto.\nintros t1 t2 l1 l2 l3 H0 H1 H2 H3.\nProof using.\napply cover_app; auto.\n", "def_ranges": [44, 0, 45, 75], "proof_ranges": [46, 0, 50, 4], "proof_steps": [{"text": "intros l t H; elim H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 t2 l1 l2 l3 H0 H1 H2 H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply cover_app; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/OrderedCover.v", "name": "cover_ordered_cover", "text": "Theorem cover_ordered_cover :\n forall (l1 : list (btree A)) (t : btree A),\n cover l1 t -> exists l2 : _, permutation l1 l2 /\\ ordered_cover l2 t.\nProof using.\nintros l1; elim l1 using list_length_ind.\nintros l0 H t; case t.\nintros a H1; rewrite cover_inv_leaf with (1 := H1).\nexists (leaf a :: nil); auto.\nintros t1 t2 H1; case cover_inv_app with (1 := H1).\nintros H2; exists l0; split; auto; rewrite H2; auto.\nintros (l2, (l3, ((HH1, HH2), HH3))).\ncase H with (2 := HH1); auto.\nrewrite permutation_length with (1 := HH3).\ngeneralize HH2; rewrite length_app; case l3; simpl in |- *; auto with arith.\nintros HH4; case cover_not_nil with (1 := HH4); auto.\nintros; rewrite plus_comm; simpl in |- *; auto with arith.\nintros l4 (HP1, HP2).\ncase H with (2 := HH2); auto.\nrewrite permutation_length with (1 := HH3).\ngeneralize HH1; rewrite length_app; case l2; simpl in |- *; auto with arith.\nintros HH4; case cover_not_nil with (1 := HH4); auto.\nintros l5 (HP3, HP4).\nexists (l4 ++ l5); split; auto.\napply permutation_trans with (1 := HH3); auto.\nQed.\n", "definition": "\n forall (l1 : list (btree A)) (t : btree A),\n cover l1 t -> exists l2 : _, permutation l1 l2 /\\ ordered_cover l2 t.", "proof": "\nProof using.\nintros l1; elim l1 using list_length_ind.\nintros l0 H t; case t.\nintros a H1; rewrite cover_inv_leaf with (1 := H1).\nexists (leaf a :: nil); auto.\nintros t1 t2 H1; case cover_inv_app with (1 := H1).\nintros H2; exists l0; split; auto; rewrite H2; auto.\nintros (l2, (l3, ((HH1, HH2), HH3))).\ncase H with (2 := HH1); auto.\nrewrite permutation_length with (1 := HH3).\ngeneralize HH2; rewrite length_app; case l3; simpl in |- *; auto with arith.\nintros HH4; case cover_not_nil with (1 := HH4); auto.\nintros; rewrite plus_comm; simpl in |- *; auto with arith.\nintros l4 (HP1, HP2).\ncase H with (2 := HH2); auto.\nrewrite permutation_length with (1 := HH3).\ngeneralize HH1; rewrite length_app; case l2; simpl in |- *; auto with arith.\nintros HH4; case cover_not_nil with (1 := HH4); auto.\nintros l5 (HP3, HP4).\nexists (l4 ++ l5); split; auto.\napply permutation_trans with (1 := HH3); auto.\n", "def_ranges": [53, 0, 55, 70], "proof_ranges": [56, 0, 77, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1; elim l1 using list_length_ind.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l0 H t; case t.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a H1; rewrite cover_inv_leaf with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (leaf a :: nil); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 t2 H1; case cover_inv_app with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H2; exists l0; split; auto; rewrite H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (l2, (l3, ((HH1, HH2), HH3))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case H with (2 := HH1); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite permutation_length with (1 := HH3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize HH2; rewrite length_app; case l3; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HH4; case cover_not_nil with (1 := HH4); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; rewrite plus_comm; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l4 (HP1, HP2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case H with (2 := HH2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite permutation_length with (1 := HH3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize HH1; rewrite length_app; case l2; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HH4; case cover_not_nil with (1 := HH4); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l5 (HP3, HP4).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (l4 ++ l5); split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (1 := HH3); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/OrderedCover.v", "name": "ulist_ordered_cover", "text": "Theorem ulist_ordered_cover :\n forall l1 l2 t,\n ordered_cover l1 t ->\n ulist l2 -> l1 = map (fun x : A => leaf x) l2 -> all_leaves t = l2.\nProof using.\nintros l1 l2 t H; generalize l2; elim H; clear H l1 l2 t; simpl in |- *; auto.\nintros t l l2; case l2; simpl in |- *; auto.\nintros; discriminate.\nintros a0 l0 H H0; injection H0; intros H1 H2; rewrite H2; auto.\ngeneralize H1; case l0; simpl in |- *; auto.\nintros; discriminate.\nintros t1 t2 l1 l2 l3 H H0 H1 H2 l0 H3 H4.\ncut\n ((exists l3 : list A, l1 = map (fun x : A => leaf x) l3) /\\\n  (exists l4 : list A, l2 = map (fun x : A => leaf x) l4)).\nintros ((l4, HH1), (l5, HH2)).\ncut (l0 = l4 ++ l5); [ intros HH3 | idtac ].\nrewrite HH3.\napply f_equal2 with (f := app (A:=A)).\napply H0; auto.\napply ulist_app_inv_l with (l2 := l5); rewrite <- HH3; auto.\napply H2; auto.\napply ulist_app_inv_r with (l1 := l4); rewrite <- HH3; auto.\nrewrite HH2 in H4; rewrite HH1 in H4.\nrewrite <- map_app in H4.\ngeneralize H4; generalize (l4 ++ l5); elim l0; simpl in |- *; auto.\nintros l; case l; simpl in |- *; auto.\nintros; discriminate.\nintros a0 l H5 l6; case l6; simpl in |- *; auto.\nintros; discriminate.\nintros a1 l7 H6; apply f_equal2 with (f := cons (A:=A)); auto.\ninjection H6; auto.\ninjection H6; auto.\ngeneralize H4; generalize l2 l0; elim l1; simpl in |- *; auto.\nintros l4 l5 H5; split; [ exists (nil (A:=A)) | exists l5 ]; auto.\nintros a0 l H5 l4 l5; case l5; simpl in |- *; auto.\nintros; discriminate.\nintros a1 l6 H6; case (H5 l4 l6); auto.\ninjection H6; auto.\nintros (l7, HH5) (l8, HH6); split; [ exists (a1 :: l7) | exists l8 ];\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=btree A)); auto.\ninjection H6; auto.\nQed.\n", "definition": "\n forall l1 l2 t,\n ordered_cover l1 t ->\n ulist l2 -> l1 = map (fun x : A => leaf x) l2 -> all_leaves t = l2.", "proof": "\nProof using.\nintros l1 l2 t H; generalize l2; elim H; clear H l1 l2 t; simpl in |- *; auto.\nintros t l l2; case l2; simpl in |- *; auto.\nintros; discriminate.\nintros a0 l0 H H0; injection H0; intros H1 H2; rewrite H2; auto.\ngeneralize H1; case l0; simpl in |- *; auto.\nintros; discriminate.\nintros t1 t2 l1 l2 l3 H H0 H1 H2 l0 H3 H4.\ncut\n ((exists l3 : list A, l1 = map (fun x : A => leaf x) l3) /\\\n  (exists l4 : list A, l2 = map (fun x : A => leaf x) l4)).\nintros ((l4, HH1), (l5, HH2)).\ncut (l0 = l4 ++ l5); [ intros HH3 | idtac ].\nrewrite HH3.\napply f_equal2 with (f := app (A:=A)).\napply H0; auto.\napply ulist_app_inv_l with (l2 := l5); rewrite <- HH3; auto.\napply H2; auto.\napply ulist_app_inv_r with (l1 := l4); rewrite <- HH3; auto.\nrewrite HH2 in H4; rewrite HH1 in H4.\nrewrite <- map_app in H4.\ngeneralize H4; generalize (l4 ++ l5); elim l0; simpl in |- *; auto.\nintros l; case l; simpl in |- *; auto.\nintros; discriminate.\nintros a0 l H5 l6; case l6; simpl in |- *; auto.\nintros; discriminate.\nintros a1 l7 H6; apply f_equal2 with (f := cons (A:=A)); auto.\ninjection H6; auto.\ninjection H6; auto.\ngeneralize H4; generalize l2 l0; elim l1; simpl in |- *; auto.\nintros l4 l5 H5; split; [ exists (nil (A:=A)) | exists l5 ]; auto.\nintros a0 l H5 l4 l5; case l5; simpl in |- *; auto.\nintros; discriminate.\nintros a1 l6 H6; case (H5 l4 l6); auto.\ninjection H6; auto.\nintros (l7, HH5) (l8, HH6); split; [ exists (a1 :: l7) | exists l8 ];\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=btree A)); auto.\ninjection H6; auto.\n", "def_ranges": [83, 0, 86, 68], "proof_ranges": [87, 0, 126, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 t H; generalize l2; elim H; clear H l1 l2 t; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t l l2; case l2; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 l0 H H0; injection H0; intros H1 H2; rewrite H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H1; case l0; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 t2 l1 l2 l3 H H0 H1 H2 l0 H3 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((exists l3 : list A, l1 = map (fun x : A => leaf x) l3) /\\", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(exists l4 : list A, l2 = map (fun x : A => leaf x) l4)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros ((l4, HH1), (l5, HH2)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (l0 = l4 ++ l5); [ intros HH3 | idtac ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := app (A:=A)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ulist_app_inv_l with (l2 := l5); rewrite <- HH3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ulist_app_inv_r with (l1 := l4); rewrite <- HH3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HH2 in H4; rewrite HH1 in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- map_app in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H4; generalize (l4 ++ l5); elim l0; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l; case l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 l H5 l6; case l6; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a1 l7 H6; apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H6; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H6; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H4; generalize l2 l0; elim l1; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l4 l5 H5; split; [ exists (nil (A:=A)) | exists l5 ]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 l H5 l4 l5; case l5; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a1 l6 H6; case (H5 l4 l6); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H6; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (l7, HH5) (l8, HH6); split; [ exists (a1 :: l7) | exists l8 ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := cons (A:=btree A)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/CoverMin.v", "name": "cover_min_one", "text": "Theorem cover_min_one : forall t : btree A, cover_min (t :: nil) t.\nProof using.\nintros t; split; auto.\nintros t2 H; inversion H; auto.\ngeneralize (permutation_length _ _ _ H0); simpl in |- *; intros; discriminate.\nQed.\n", "definition": " forall t : btree A, cover_min (t :: nil) t.", "proof": "\nProof using.\nintros t; split; auto.\nintros t2 H; inversion H; auto.\ngeneralize (permutation_length _ _ _ H0); simpl in |- *; intros; discriminate.\n", "def_ranges": [37, 0, 37, 67], "proof_ranges": [38, 0, 42, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t; split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t2 H; inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (permutation_length _ _ _ H0); simpl in |- *; intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/CoverMin.v", "name": "cover_min_permutation", "text": "Theorem cover_min_permutation :\n forall (t : btree A) (l1 l2 : list (btree A)),\n cover_min l1 t -> permutation l1 l2 -> cover_min l2 t.\nProof using.\nintros t l1 l2 H H0; split.\napply cover_permutation with (2 := H0); auto.\ninversion H; auto.\nintros t2 H1.\nassert (cover l1 t2).\ninversion H; auto.\napply cover_permutation with (2 := permutation_sym _ _ _ H0); auto.\ninversion H; auto.\nQed.\n", "definition": "\n forall (t : btree A) (l1 l2 : list (btree A)),\n cover_min l1 t -> permutation l1 l2 -> cover_min l2 t.", "proof": "\nProof using.\nintros t l1 l2 H H0; split.\napply cover_permutation with (2 := H0); auto.\ninversion H; auto.\nintros t2 H1.\nassert (cover l1 t2).\ninversion H; auto.\napply cover_permutation with (2 := permutation_sym _ _ _ H0); auto.\ninversion H; auto.\n", "def_ranges": [46, 0, 48, 55], "proof_ranges": [49, 0, 58, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t l1 l2 H H0; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply cover_permutation with (2 := H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t2 H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (cover l1 t2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply cover_permutation with (2 := permutation_sym _ _ _ H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/CoverMin.v", "name": "cover_min_ex", "text": "Theorem cover_min_ex :\n forall l : list (btree A), l <> nil -> exists t : btree A, cover_min l t.\nProof using.\nintros l H;\n generalize (find_min_correct (btree A) (weight_tree f) (all_cover _ l)).\ncase (find_min (weight_tree f) (all_cover _ l)).\nintros p; case p.\nintros n b ((H1, H2), H3); exists b; auto.\nsplit; auto.\napply all_cover_cover; auto.\nintros t2 H4; apply H3.\napply cover_all_cover; auto.\nintros H0.\ncase (one_cover_ex _ l); auto.\nintros x H1; absurd (In x (all_cover A l)).\nrewrite H0; simpl in |- *; red in |- *; intros H2; case H2.\napply cover_all_cover; auto.\nQed.\n", "definition": "\n forall l : list (btree A), l <> nil -> exists t : btree A, cover_min l t.", "proof": "\nProof using.\nintros l H;\n generalize (find_min_correct (btree A) (weight_tree f) (all_cover _ l)).\ncase (find_min (weight_tree f) (all_cover _ l)).\nintros p; case p.\nintros n b ((H1, H2), H3); exists b; auto.\nsplit; auto.\napply all_cover_cover; auto.\nintros t2 H4; apply H3.\napply cover_all_cover; auto.\nintros H0.\ncase (one_cover_ex _ l); auto.\nintros x H1; absurd (In x (all_cover A l)).\nrewrite H0; simpl in |- *; red in |- *; intros H2; case H2.\napply cover_all_cover; auto.\n", "def_ranges": [61, 0, 62, 74], "proof_ranges": [63, 0, 78, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l H;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (find_min_correct (btree A) (weight_tree f) (all_cover _ l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (find_min (weight_tree f) (all_cover _ l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p; case p.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n b ((H1, H2), H3); exists b; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply all_cover_cover; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t2 H4; apply H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply cover_all_cover; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (one_cover_ex _ l); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H1; absurd (In x (all_cover A l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H0; simpl in |- *; red in |- *; intros H2; case H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply cover_all_cover; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "fold_plus_split", "text": "Theorem fold_plus_split :\n forall (B : Type) (l : list B) (c : nat) (f : B -> nat),\n c + fold_left (fun (a : nat) (b : B) => a + f b) l 0 =\n fold_left (fun (a : nat) (b : B) => a + f b) l c.\nProof using.\nintros B l; elim l; simpl in |- *; auto.\nintros a l0 H c f.\nrewrite <- (H (f a)).\nrewrite <- (H (c + f a)).\nrewrite plus_assoc_reverse; auto.\nQed.\n", "definition": "\n forall (B : Type) (l : list B) (c : nat) (f : B -> nat),\n c + fold_left (fun (a : nat) (b : B) => a + f b) l 0 =\n fold_left (fun (a : nat) (b : B) => a + f b) l c.", "proof": "\nProof using.\nintros B l; elim l; simpl in |- *; auto.\nintros a l0 H c f.\nrewrite <- (H (f a)).\nrewrite <- (H (c + f a)).\nrewrite plus_assoc_reverse; auto.\n", "def_ranges": [33, 0, 36, 50], "proof_ranges": [37, 0, 43, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros B l; elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l0 H c f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (H (f a)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (H (c + f a)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite plus_assoc_reverse; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "fold_plus_permutation", "text": "Theorem fold_plus_permutation :\n forall (B : Type) (l1 l2 : list B) (c : nat) (f : B -> nat),\n permutation l1 l2 ->\n fold_left (fun (a : nat) (b : B) => a + f b) l1 c =\n fold_left (fun (a : nat) (b : B) => a + f b) l2 c.\nProof using.\nintros B l1 l2 c f H; generalize c f; elim H; clear H l1 l2 c f;\n simpl in |- *; auto.\nintros a b L c f; repeat rewrite <- plus_assoc; rewrite (plus_comm (f a));\n auto.\nintros L1 L2 L3 H H0 H1 H2 c f; apply trans_equal with (1 := H0 c f); auto.\nQed.\n", "definition": "\n forall (B : Type) (l1 l2 : list B) (c : nat) (f : B -> nat),\n permutation l1 l2 ->\n fold_left (fun (a : nat) (b : B) => a + f b) l1 c =\n fold_left (fun (a : nat) (b : B) => a + f b) l2 c.", "proof": "\nProof using.\nintros B l1 l2 c f H; generalize c f; elim H; clear H l1 l2 c f;\n simpl in |- *; auto.\nintros a b L c f; repeat rewrite <- plus_assoc; rewrite (plus_comm (f a));\n auto.\nintros L1 L2 L3 H H0 H1 H2 c f; apply trans_equal with (1 := H0 c f); auto.\n", "def_ranges": [45, 0, 49, 51], "proof_ranges": [50, 0, 56, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros B l1 l2 c f H; generalize c f; elim H; clear H l1 l2 c f;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b L c f; repeat rewrite <- plus_assoc; rewrite (plus_comm (f a));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros L1 L2 L3 H H0 H1 H2 c f; apply trans_equal with (1 := H0 c f); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "length_encode_nId", "text": "Theorem length_encode_nId :\n forall a l1 l n,\n length (encode eqA_dec ((a, l1) :: l) (id_list a n)) = n * length l1.\nProof using.\nintros a l1 l n; elim n; simpl in |- *; auto.\nintros n0 H; case (eqA_dec a a); auto.\nintros e; rewrite length_app; rewrite H; auto.\nintros H1; case H1; auto.\nQed.\n", "definition": "\n forall a l1 l n,\n length (encode eqA_dec ((a, l1) :: l) (id_list a n)) = n * length l1.", "proof": "\nProof using.\nintros a l1 l n; elim n; simpl in |- *; auto.\nintros n0 H; case (eqA_dec a a); auto.\nintros e; rewrite length_app; rewrite H; auto.\nintros H1; case H1; auto.\n", "def_ranges": [58, 0, 60, 70], "proof_ranges": [61, 0, 66, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l1 l n; elim n; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n0 H; case (eqA_dec a a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e; rewrite length_app; rewrite H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H1; case H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "frequency_length", "text": "Theorem frequency_length :\n forall (m : list A) (c : code A),\n unique_key c ->\n length (encode eqA_dec c m) =\n fold_left\n   (fun a b => a + number_of_occurrences eqA_dec (fst b) m * length (snd b))\n   c 0.\nProof using.\nintros m c; generalize m; elim c; clear c m; simpl in |- *; auto.\nintros m; elim m; simpl in |- *; auto.\nintros (a, l1) l Rec m H; simpl in |- *.\ncase (number_of_occurrences_permutation_ex A eqA_dec m a);\n intros m1 (Hm1, Hm2).\nrewrite\n permutation_length\n                    with\n                    (1 := \n                      encode_permutation_val _ eqA_dec _ _ ((a, l1) :: l) Hm1).\nrewrite encode_app; auto.\nrewrite length_app; auto.\nrewrite length_encode_nId.\nrewrite encode_cons_inv; auto.\nrewrite Rec; simpl in |- *; auto.\nrewrite <-\n fold_plus_split\n                 with\n                 (f := \n                   fun b : A * list bool =>\n                   number_of_occurrences eqA_dec (fst b) m * length (snd b))\n                (c := number_of_occurrences eqA_dec a m * length l1).\napply f_equal2 with (f := plus); auto.\ncut (forall l2, ~ In (a, l2) l).\nelim l; simpl in |- *; auto.\nintros (a2, l2) l3; simpl in |- *; intros Rec1 H4.\nrewrite <-\n fold_plus_split\n                 with\n                 (c := number_of_occurrences eqA_dec a2 m1 * length l2)\n                (f := \n                  fun b : A * list bool =>\n                  number_of_occurrences eqA_dec (fst b) m1 * length (snd b)).\nrewrite <-\n fold_plus_split\n                 with\n                 (c := number_of_occurrences eqA_dec a2 m * length l2)\n                (f := \n                  fun b : A * list bool =>\n                  number_of_occurrences eqA_dec (fst b) m * length (snd b)).\napply f_equal2 with (f := plus); auto.\n2: apply Rec1; auto.\n2: intros l0; red in |- *; intros H0; case (H4 l0); auto.\n2: intros l2; red in |- *; intros H0;\n    case unique_key_in with (1 := H) (a := a) (b2 := l2); \n    auto.\n2: apply unique_key_inv with (1 := H); auto.\napply f_equal2 with (f := mult); auto.\napply\n trans_equal\n  with\n    (2 := number_of_occurrences_permutation _ eqA_dec _ _ a2\n            (permutation_sym _ _ _ Hm1)).\nrewrite number_of_occurrences_app.\nreplace\n (number_of_occurrences eqA_dec a2\n    (id_list a (number_of_occurrences eqA_dec a m))) with 0; \n auto.\ncut (a2 <> a).\nelim (number_of_occurrences eqA_dec a m); simpl in |- *; auto.\nintros n H0 H1; case (eqA_dec a2 a); simpl in |- *; auto.\nintros e; case H1; auto.\nred in |- *; intros H0; case (H4 l2); left;\n apply f_equal2 with (f := pair (A:=A) (B:=list bool)); \n auto.\nQed.\n", "definition": "\n forall (m : list A) (c : code A),\n unique_key c ->\n length (encode eqA_dec c m) =\n fold_left\n   (fun a b => a + number_of_occurrences eqA_dec (fst b) m * length (snd b))\n   c 0.", "proof": "\nProof using.\nintros m c; generalize m; elim c; clear c m; simpl in |- *; auto.\nintros m; elim m; simpl in |- *; auto.\nintros (a, l1) l Rec m H; simpl in |- *.\ncase (number_of_occurrences_permutation_ex A eqA_dec m a);\n intros m1 (Hm1, Hm2).\nrewrite\n permutation_length\n                    with\n                    (1 := \n                      encode_permutation_val _ eqA_dec _ _ ((a, l1) :: l) Hm1).\nrewrite encode_app; auto.\nrewrite length_app; auto.\nrewrite length_encode_nId.\nrewrite encode_cons_inv; auto.\nrewrite Rec; simpl in |- *; auto.\nrewrite <-\n fold_plus_split\n                 with\n                 (f := \n                   fun b : A * list bool =>\n                   number_of_occurrences eqA_dec (fst b) m * length (snd b))\n                (c := number_of_occurrences eqA_dec a m * length l1).\napply f_equal2 with (f := plus); auto.\ncut (forall l2, ~ In (a, l2) l).\nelim l; simpl in |- *; auto.\nintros (a2, l2) l3; simpl in |- *; intros Rec1 H4.\nrewrite <-\n fold_plus_split\n                 with\n                 (c := number_of_occurrences eqA_dec a2 m1 * length l2)\n                (f := \n                  fun b : A * list bool =>\n                  number_of_occurrences eqA_dec (fst b) m1 * length (snd b)).\nrewrite <-\n fold_plus_split\n                 with\n                 (c := number_of_occurrences eqA_dec a2 m * length l2)\n                (f := \n                  fun b : A * list bool =>\n                  number_of_occurrences eqA_dec (fst b) m * length (snd b)).\napply f_equal2 with (f := plus); auto.\n2: apply Rec1; auto.\n2: intros l0; red in |- *; intros H0; case (H4 l0); auto.\n2: intros l2; red in |- *; intros H0;\n    case unique_key_in with (1 := H) (a := a) (b2 := l2); \n    auto.\n2: apply unique_key_inv with (1 := H); auto.\napply f_equal2 with (f := mult); auto.\napply\n trans_equal\n  with\n    (2 := number_of_occurrences_permutation _ eqA_dec _ _ a2\n            (permutation_sym _ _ _ Hm1)).\nrewrite number_of_occurrences_app.\nreplace\n (number_of_occurrences eqA_dec a2\n    (id_list a (number_of_occurrences eqA_dec a m))) with 0; \n auto.\ncut (a2 <> a).\nelim (number_of_occurrences eqA_dec a m); simpl in |- *; auto.\nintros n H0 H1; case (eqA_dec a2 a); simpl in |- *; auto.\nintros e; case H1; auto.\nred in |- *; intros H0; case (H4 l2); left;\n apply f_equal2 with (f := pair (A:=A) (B:=list bool)); \n auto.\n", "def_ranges": [68, 0, 74, 7], "proof_ranges": [75, 0, 141, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m c; generalize m; elim c; clear c m; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m; elim m; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a, l1) l Rec m H; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (number_of_occurrences_permutation_ex A eqA_dec m a);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m1 (Hm1, Hm2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "permutation_length", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(1 :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "encode_permutation_val _ eqA_dec _ _ ((a, l1) :: l) Hm1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite encode_app; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite length_app; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite length_encode_nId.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite encode_cons_inv; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite Rec; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <-", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fold_plus_split", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(f :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fun b : A * list bool =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "number_of_occurrences eqA_dec (fst b) m * length (snd b))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(c := number_of_occurrences eqA_dec a m * length l1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := plus); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (forall l2, ~ In (a, l2) l).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a2, l2) l3; simpl in |- *; intros Rec1 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <-", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fold_plus_split", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(c := number_of_occurrences eqA_dec a2 m1 * length l2)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(f :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fun b : A * list bool =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "number_of_occurrences eqA_dec (fst b) m1 * length (snd b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <-", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fold_plus_split", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(c := number_of_occurrences eqA_dec a2 m * length l2)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(f :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fun b : A * list bool =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "number_of_occurrences eqA_dec (fst b) m * length (snd b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := plus); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply Rec1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros l0; red in |- *; intros H0; case (H4 l0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros l2; red in |- *; intros H0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case unique_key_in with (1 := H) (a := a) (b2 := l2);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply unique_key_inv with (1 := H); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := mult); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "weight_permutation", "text": "Theorem weight_permutation :\n forall m c1 c2,\n unique_prefix c1 -> permutation c1 c2 -> weight m c1 = weight m c2.\nProof using.\nintros m c1 c2 H H0; unfold weight in |- *.\napply f_equal with (f := length (A:=bool)).\napply encode_permutation; auto.\nQed.\n", "definition": "\n forall m c1 c2,\n unique_prefix c1 -> permutation c1 c2 -> weight m c1 = weight m c2.", "proof": "\nProof using.\nintros m c1 c2 H H0; unfold weight in |- *.\napply f_equal with (f := length (A:=bool)).\napply encode_permutation; auto.\n", "def_ranges": [145, 0, 147, 68], "proof_ranges": [148, 0, 152, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m c1 c2 H H0; unfold weight in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal with (f := length (A:=bool)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply encode_permutation; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "ulist_unique_key", "text": "Theorem ulist_unique_key :\n forall (A B : Type) (l : list (A * B)),\n ulist (map (fst (B:=_)) l) -> unique_key l.\nProof using.\nintros AA BB l; elim l; simpl in |- *; auto.\nintros a; case a.\nintros a0 b l0 H H0; apply unique_key_cons; auto.\nintros b0; red in |- *; intros H1; absurd (In a0 (map (fst (B:=_)) l0)); auto.\ninversion H0; auto.\nchange (In (fst (a0, b0)) (map (fst (B:=_)) l0)) in |- *; auto with datatypes.\napply in_map; auto.\napply H; apply ulist_inv with (1 := H0); auto.\nQed.\n", "definition": "\n forall (A B : Type) (l : list (A * B)),\n ulist (map (fst (B:=_)) l) -> unique_key l.", "proof": "\nProof using.\nintros AA BB l; elim l; simpl in |- *; auto.\nintros a; case a.\nintros a0 b l0 H H0; apply unique_key_cons; auto.\nintros b0; red in |- *; intros H1; absurd (In a0 (map (fst (B:=_)) l0)); auto.\ninversion H0; auto.\nchange (In (fst (a0, b0)) (map (fst (B:=_)) l0)) in |- *; auto with datatypes.\napply in_map; auto.\napply H; apply ulist_inv with (1 := H0); auto.\n", "def_ranges": [159, 0, 161, 44], "proof_ranges": [162, 0, 171, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros AA BB l; elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a; case a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b l0 H H0; apply unique_key_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b0; red in |- *; intros H1; absurd (In a0 (map (fst (B:=_)) l0)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (In (fst (a0, b0)) (map (fst (B:=_)) l0)) in |- *; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply in_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H; apply ulist_inv with (1 := H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "restrict_code_unique_key", "text": "Theorem restrict_code_unique_key :\n forall (m : list A) (c : code A), unique_key (restrict_code m c).\nProof using.\nintros m c; apply ulist_unique_key.\nunfold restrict_code in |- *.\nreplace\n (map (fst (B:=_))\n    (map (fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))\n       (frequency_list eqA_dec m))) with\n (map (fst (B:=_)) (frequency_list eqA_dec m)).\napply unique_key_ulist; auto.\nelim (frequency_list eqA_dec m); simpl in |- *; auto with datatypes.\nintros a l H; apply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n", "definition": "\n forall (m : list A) (c : code A), unique_key (restrict_code m c).", "proof": "\nProof using.\nintros m c; apply ulist_unique_key.\nunfold restrict_code in |- *.\nreplace\n (map (fst (B:=_))\n    (map (fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))\n       (frequency_list eqA_dec m))) with\n (map (fst (B:=_)) (frequency_list eqA_dec m)).\napply unique_key_ulist; auto.\nelim (frequency_list eqA_dec m); simpl in |- *; auto with datatypes.\nintros a l H; apply f_equal2 with (f := cons (A:=A)); auto.\n", "def_ranges": [173, 0, 174, 66], "proof_ranges": [175, 0, 186, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m c; apply ulist_unique_key.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold restrict_code in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (fst (B:=_))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(frequency_list eqA_dec m))) with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (fst (B:=_)) (frequency_list eqA_dec m)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_ulist; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (frequency_list eqA_dec m); simpl in |- *; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "restrict_code_in", "text": "Theorem restrict_code_in :\n forall (m : list A) (a : A) (c : code A),\n In a m -> find_code eqA_dec a c = find_code eqA_dec a (restrict_code m c).\nProof using.\nintros m a c H.\napply sym_equal; apply find_code_correct2; auto.\napply restrict_code_unique_key.\ngeneralize (in_frequency_map _ eqA_dec m a H).\nunfold restrict_code in |- *; elim (frequency_list eqA_dec m); simpl in |- *;\n auto with datatypes.\nintros a0; case a0; simpl in |- *; auto with datatypes.\nintros a1 n l H0 [H1| H1]; try rewrite H1; auto.\nQed.\n", "definition": "\n forall (m : list A) (a : A) (c : code A),\n In a m -> find_code eqA_dec a c = find_code eqA_dec a (restrict_code m c).", "proof": "\nProof using.\nintros m a c H.\napply sym_equal; apply find_code_correct2; auto.\napply restrict_code_unique_key.\ngeneralize (in_frequency_map _ eqA_dec m a H).\nunfold restrict_code in |- *; elim (frequency_list eqA_dec m); simpl in |- *;\n auto with datatypes.\nintros a0; case a0; simpl in |- *; auto with datatypes.\nintros a1 n l H0 [H1| H1]; try rewrite H1; auto.\n", "def_ranges": [188, 0, 190, 75], "proof_ranges": [191, 0, 200, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m a c H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sym_equal; apply find_code_correct2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply restrict_code_unique_key.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (in_frequency_map _ eqA_dec m a H).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold restrict_code in |- *; elim (frequency_list eqA_dec m); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0; case a0; simpl in |- *; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a1 n l H0 [H1| H1]; try rewrite H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "restrict_code_encode_length_inc", "text": "Theorem restrict_code_encode_length_inc :\n forall (m m1 : list A) (c : code A),\n incl m1 m -> encode eqA_dec c m1 = encode eqA_dec (restrict_code m c) m1.\nProof using.\nintros m m1 c; elim m1; simpl in |- *; auto.\nintros a l H H0.\napply f_equal2 with (f := app (A:=bool)); auto with datatypes.\napply restrict_code_in; auto with datatypes.\napply H; apply incl_tran with (2 := H0); auto with datatypes.\nQed.\n", "definition": "\n forall (m m1 : list A) (c : code A),\n incl m1 m -> encode eqA_dec c m1 = encode eqA_dec (restrict_code m c) m1.", "proof": "\nProof using.\nintros m m1 c; elim m1; simpl in |- *; auto.\nintros a l H H0.\napply f_equal2 with (f := app (A:=bool)); auto with datatypes.\napply restrict_code_in; auto with datatypes.\napply H; apply incl_tran with (2 := H0); auto with datatypes.\n", "def_ranges": [202, 0, 204, 74], "proof_ranges": [205, 0, 211, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m m1 c; elim m1; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l H H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := app (A:=bool)); auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply restrict_code_in; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H; apply incl_tran with (2 := H0); auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Weight.v", "name": "restrict_code_encode_length", "text": "Theorem restrict_code_encode_length :\n forall (m : list A) (c : code A),\n encode eqA_dec c m = encode eqA_dec (restrict_code m c) m.\nProof using.\nintros m c; apply restrict_code_encode_length_inc; auto with datatypes.\nQed.\n", "definition": "\n forall (m : list A) (c : code A),\n encode eqA_dec c m = encode eqA_dec (restrict_code m c) m.", "proof": "\nProof using.\nintros m c; apply restrict_code_encode_length_inc; auto with datatypes.\n", "def_ranges": [213, 0, 215, 59], "proof_ranges": [216, 0, 218, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m c; apply restrict_code_encode_length_inc; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Ordered.v", "name": "ordered_inv_order", "text": "Theorem ordered_inv_order :\n forall (a b : A) (l : list A), ordered (a :: b :: l) -> order a b.\nProof using.\nintros a b l H; inversion H; auto.\nQed.\n", "definition": "\n forall (a b : A) (l : list A), ordered (a :: b :: l) -> order a b.", "proof": "\nProof using.\nintros a b l H; inversion H; auto.\n", "def_ranges": [43, 0, 44, 67], "proof_ranges": [45, 0, 47, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a b : A) (l : list A), ordered (a :: b :: l) -> order a b"], "goal_after": ["forall (a b : A) (l : list A), ordered (a :: b :: l) -> order a b"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a b l H; inversion H; auto.", "goal_before": ["forall (a b : A) (l : list A), ordered (a :: b :: l) -> order a b"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a b : A) (l : list A) (H : ordered (a :: b :: l)) =>\n let H0 : a :: b :: l = a :: b :: l -> order a b :=\n   match H in (ordered l0) return (l0 = a :: b :: l -> order a b) with\n   | ordered_nil =>\n       fun H0 : nil = a :: b :: l =>\n       (fun H1 : nil = a :: b :: l =>\n        let H2 : False :=\n          eq_ind nil\n            (fun e : list A =>\n             match e with\n             | nil => True\n             | _ :: _ => False\n             end) I (a :: b :: l) H1 in\n        False_ind (order a b) H2) H0\n   | ordered_one a0 =>\n       (fun (a1 : A) (H0 : a1 :: nil = a :: b :: l) =>\n        (fun H1 : a1 :: nil = a :: b :: l =>\n         let H2 : False :=\n           eq_ind (a1 :: nil)\n             (fun e : list A =>\n              match e with\n              | _ :: nil => True\n              | _ => False\n              end) I (a :: b :: l) H1 in\n         False_ind (order a b) H2) H0) a0\n   | ordered_cons a0 b0 l0 x x0 =>\n       (fun (a1 b1 : A) (l1 : list A) (H0 : order a1 b1)\n          (H1 : ordered (b1 :: l1)) (H2 : a1 :: b1 :: l1 = a :: b :: l) =>\n        (fun H3 : a1 :: b1 :: l1 = a :: b :: l =>\n         let H4 : l1 = l :=\n           f_equal\n             (fun e : list A =>\n              match e with\n              | _ :: _ :: l3 => l3\n              | _ => l1\n              end) H3 in\n         (let H5 : b1 = b :=\n            f_equal\n              (fun e : list A =>\n               match e with\n               | _ :: a3 :: _ => a3\n               | _ => b1\n               end) H3 in\n          (let H6 : a1 = a :=\n             f_equal\n               (fun e : list A =>\n                match e with\n                | nil => a1\n                | a2 :: _ => a2\n                end) H3 in\n           (fun H7 : a1 = a =>\n            let H8 : a1 = a := H7 in\n            eq_ind_r\n              (fun a2 : A =>\n               b1 = b ->\n               l1 = l -> order a2 b1 -> ordered (b1 :: l1) -> order a b)\n              (fun H9 : b1 = b =>\n               let H10 : b1 = b := H9 in\n               eq_ind_r\n                 (fun a2 : A =>\n                  l1 = l -> order a a2 -> ordered (a2 :: l1) -> order a b)\n                 (fun H11 : l1 = l =>\n                  let H12 : l1 = l := H11 in\n                  eq_ind_r\n                    (fun l2 : list A =>\n                     order a b -> ordered (b :: l2) -> order a b)\n                    (fun (H13 : order a b) (_ : ordered (b :: l)) => H13) H12)\n                 H10) H8) H6) H5) H4) H2 H0 H1) a0 b0 l0 x x0\n   end in\n H0 eq_refl)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : A) (l : list A) (H : ordered (a :: b :: l)) =>\n let H0 : a :: b :: l = a :: b :: l -> order a b :=\n   match H in (ordered l0) return (l0 = a :: b :: l -> order a b) with\n   | ordered_nil =>\n       fun H0 : nil = a :: b :: l =>\n       (fun H1 : nil = a :: b :: l =>\n        let H2 : False :=\n          eq_ind nil\n            (fun e : list A =>\n             match e with\n             | nil => True\n             | _ :: _ => False\n             end) I (a :: b :: l) H1 in\n        False_ind (order a b) H2) H0\n   | ordered_one a0 =>\n       (fun (a1 : A) (H0 : a1 :: nil = a :: b :: l) =>\n        (fun H1 : a1 :: nil = a :: b :: l =>\n         let H2 : False :=\n           eq_ind (a1 :: nil)\n             (fun e : list A =>\n              match e with\n              | _ :: nil => True\n              | _ => False\n              end) I (a :: b :: l) H1 in\n         False_ind (order a b) H2) H0) a0\n   | ordered_cons a0 b0 l0 x x0 =>\n       (fun (a1 b1 : A) (l1 : list A) (H0 : order a1 b1)\n          (H1 : ordered (b1 :: l1)) (H2 : a1 :: b1 :: l1 = a :: b :: l) =>\n        (fun H3 : a1 :: b1 :: l1 = a :: b :: l =>\n         let H4 : l1 = l :=\n           f_equal\n             (fun e : list A =>\n              match e with\n              | _ :: _ :: l3 => l3\n              | _ => l1\n              end) H3 in\n         (let H5 : b1 = b :=\n            f_equal\n              (fun e : list A =>\n               match e with\n               | _ :: a3 :: _ => a3\n               | _ => b1\n               end) H3 in\n          (let H6 : a1 = a :=\n             f_equal\n               (fun e : list A =>\n                match e with\n                | nil => a1\n                | a2 :: _ => a2\n                end) H3 in\n           (fun H7 : a1 = a =>\n            let H8 : a1 = a := H7 in\n            eq_ind_r\n              (fun a2 : A =>\n               b1 = b ->\n               l1 = l -> order a2 b1 -> ordered (b1 :: l1) -> order a b)\n              (fun H9 : b1 = b =>\n               let H10 : b1 = b := H9 in\n               eq_ind_r\n                 (fun a2 : A =>\n                  l1 = l -> order a a2 -> ordered (a2 :: l1) -> order a b)\n                 (fun H11 : l1 = l =>\n                  let H12 : l1 = l := H11 in\n                  eq_ind_r\n                    (fun l2 : list A =>\n                     order a b -> ordered (b :: l2) -> order a b)\n                    (fun (H13 : order a b) (_ : ordered (b :: l)) => H13) H12)\n                 H10) H8) H6) H5) H4) H2 H0 H1) a0 b0 l0 x x0\n   end in\n H0 eq_refl)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Ordered.v", "name": "ordered_inv", "text": "Theorem ordered_inv :\n forall (a : A) (l : list A), ordered (a :: l) -> ordered l.\nProof using.\nintros a l H; inversion H; auto.\nQed.\n", "definition": "\n forall (a : A) (l : list A), ordered (a :: l) -> ordered l.", "proof": "\nProof using.\nintros a l H; inversion H; auto.\n", "def_ranges": [50, 0, 51, 60], "proof_ranges": [52, 0, 54, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l : list A), ordered (a :: l) -> ordered l"], "goal_after": ["forall (a : A) (l : list A), ordered (a :: l) -> ordered l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l H; inversion H; auto.", "goal_before": ["forall (a : A) (l : list A), ordered (a :: l) -> ordered l"], "goal_after": ["ordered nil"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l : list A) (H : ordered (a :: l)) =>\n let H0 : a :: l = a :: l -> ordered l :=\n   match H in (ordered l0) return (l0 = a :: l -> ordered l) with\n   | ordered_nil =>\n       fun H0 : nil = a :: l =>\n       (fun H1 : nil = a :: l =>\n        let H2 : False :=\n          eq_ind nil\n            (fun e : list A =>\n             match e with\n             | nil => True\n             | _ :: _ => False\n             end) I (a :: l) H1 in\n        False_ind (ordered l) H2) H0\n   | ordered_one a0 =>\n       (fun (a1 : A) (H0 : a1 :: nil = a :: l) =>\n        (fun H1 : a1 :: nil = a :: l =>\n         let H2 : nil = l :=\n           f_equal\n             (fun e : list A => match e with\n                                | nil => nil\n                                | _ :: l0 => l0\n                                end) H1 in\n         (let H3 : a1 = a :=\n            f_equal\n              (fun e : list A => match e with\n                                 | nil => a1\n                                 | a2 :: _ => a2\n                                 end) H1 in\n          (fun H4 : a1 = a =>\n           let H5 : a1 = a := H4 in\n           eq_ind_r (fun _ : A => nil = l -> ordered l)\n             (fun H6 : nil = l =>\n              let H7 : nil = l := H6 in\n              eq_ind nil (fun l0 : list A => ordered l0)\n                ?Goal@{a0:=a1; H1:=H4; H2:=H6} l H7) H5) H3) H2) H0) a0\n   | ordered_cons a0 b l0 x x0 =>\n       (fun (a1 b0 : A) (l1 : list A) (H0 : order a1 b0)\n          (H1 : ordered (b0 :: l1)) (H2 : a1 :: b0 :: l1 = a :: l) =>\n        (fun H3 : a1 :: b0 :: l1 = a :: l =>\n         let H4 : b0 :: l1 = l :=\n           f_equal\n             (fun e : list A =>\n              match e with\n              | nil => b0 :: l1\n              | _ :: l2 => l2\n              end) H3 in\n         (let H5 : a1 = a :=\n            f_equal\n              (fun e : list A => match e with\n                                 | nil => a1\n                                 | a2 :: _ => a2\n                                 end) H3 in\n          (fun H6 : a1 = a =>\n           let H7 : a1 = a := H6 in\n           eq_ind_r\n             (fun a2 : A =>\n              b0 :: l1 = l -> order a2 b0 -> ordered (b0 :: l1) -> ordered l)\n             (fun H8 : b0 :: l1 = l =>\n              let H9 : b0 :: l1 = l := H8 in\n              eq_ind (b0 :: l1)\n                (fun l2 : list A =>\n                 order a b0 -> ordered (b0 :: l1) -> ordered l2)\n                (fun (_ : order a b0) (H11 : ordered (b0 :: l1)) => H11) l H9)\n             H7) H5) H4) H2 H0 H1) a0 b l0 x x0\n   end in\n H0 eq_refl)"]}, {"text": "Qed.", "goal_before": ["ordered nil"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l : list A) (H : ordered (a :: l)) =>\n let H0 : a :: l = a :: l -> ordered l :=\n   match H in (ordered l0) return (l0 = a :: l -> ordered l) with\n   | ordered_nil =>\n       fun H0 : nil = a :: l =>\n       (fun H1 : nil = a :: l =>\n        let H2 : False :=\n          eq_ind nil\n            (fun e : list A =>\n             match e with\n             | nil => True\n             | _ :: _ => False\n             end) I (a :: l) H1 in\n        False_ind (ordered l) H2) H0\n   | ordered_one a0 =>\n       (fun (a1 : A) (H0 : a1 :: nil = a :: l) =>\n        (fun H1 : a1 :: nil = a :: l =>\n         let H2 : nil = l :=\n           f_equal\n             (fun e : list A => match e with\n                                | nil => nil\n                                | _ :: l0 => l0\n                                end) H1 in\n         (let H3 : a1 = a :=\n            f_equal\n              (fun e : list A => match e with\n                                 | nil => a1\n                                 | a2 :: _ => a2\n                                 end) H1 in\n          (fun H4 : a1 = a =>\n           let H5 : a1 = a := H4 in\n           eq_ind_r (fun _ : A => nil = l -> ordered l)\n             (fun H6 : nil = l =>\n              let H7 : nil = l := H6 in\n              eq_ind nil (fun l0 : list A => ordered l0)\n                ?Goal@{a0:=a1; H1:=H4; H2:=H6} l H7) H5) H3) H2) H0) a0\n   | ordered_cons a0 b l0 x x0 =>\n       (fun (a1 b0 : A) (l1 : list A) (H0 : order a1 b0)\n          (H1 : ordered (b0 :: l1)) (H2 : a1 :: b0 :: l1 = a :: l) =>\n        (fun H3 : a1 :: b0 :: l1 = a :: l =>\n         let H4 : b0 :: l1 = l :=\n           f_equal\n             (fun e : list A =>\n              match e with\n              | nil => b0 :: l1\n              | _ :: l2 => l2\n              end) H3 in\n         (let H5 : a1 = a :=\n            f_equal\n              (fun e : list A => match e with\n                                 | nil => a1\n                                 | a2 :: _ => a2\n                                 end) H3 in\n          (fun H6 : a1 = a =>\n           let H7 : a1 = a := H6 in\n           eq_ind_r\n             (fun a2 : A =>\n              b0 :: l1 = l -> order a2 b0 -> ordered (b0 :: l1) -> ordered l)\n             (fun H8 : b0 :: l1 = l =>\n              let H9 : b0 :: l1 = l := H8 in\n              eq_ind (b0 :: l1)\n                (fun l2 : list A =>\n                 order a b0 -> ordered (b0 :: l1) -> ordered l2)\n                (fun (_ : order a b0) (H11 : ordered (b0 :: l1)) => H11) l H9)\n             H7) H5) H4) H2 H0 H1) a0 b l0 x x0\n   end in\n H0 eq_refl)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Ordered.v", "name": "ordered_skip", "text": "Theorem ordered_skip :\n forall (a b : A) (l : list A), ordered (a :: b :: l) -> ordered (a :: l).\nProof using A order order_trans.\nintros a b l; case l; clear l; auto.\nintros c l H; apply ordered_cons.\napply order_trans with (b := b); auto.\napply ordered_inv_order with (1 := H).\napply ordered_inv_order with (1 := ordered_inv _ _ H).\napply ordered_inv with (1 := ordered_inv _ _ H).\nQed.\n", "definition": "\n forall (a b : A) (l : list A), ordered (a :: b :: l) -> ordered (a :: l).", "proof": "\nProof using A order order_trans.\nintros a b l; case l; clear l; auto.\nintros c l H; apply ordered_cons.\napply order_trans with (b := b); auto.\napply ordered_inv_order with (1 := H).\napply ordered_inv_order with (1 := ordered_inv _ _ H).\napply ordered_inv with (1 := ordered_inv _ _ H).\n", "def_ranges": [57, 0, 58, 74], "proof_ranges": [59, 0, 66, 4], "proof_steps": [{"text": "Proof using A order order_trans.", "goal_before": ["forall (a b : A) (l : list A), ordered (a :: b :: l) -> ordered (a :: l)"], "goal_after": ["forall (a b : A) (l : list A), ordered (a :: b :: l) -> ordered (a :: l)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a b l; case l; clear l; auto.", "goal_before": ["forall (a b : A) (l : list A), ordered (a :: b :: l) -> ordered (a :: l)"], "goal_after": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"]}, {"text": "intros c l H; apply ordered_cons.", "goal_before": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "goal_after": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"]}, {"text": "apply order_trans with (b := b); auto.", "goal_before": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "goal_after": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"]}, {"text": "apply ordered_inv_order with (1 := H).", "goal_before": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "goal_after": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"]}, {"text": "apply ordered_inv_order with (1 := ordered_inv _ _ H).", "goal_before": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "goal_after": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"]}, {"text": "apply ordered_inv with (1 := ordered_inv _ _ H).", "goal_before": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "goal_after": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"]}, {"text": "Qed.", "goal_before": ["ordered (a :: b :: nil) -> ordered (a :: nil)", "forall (a0 : A) (l : list A),\nordered (a :: b :: a0 :: l) -> ordered (a :: a0 :: l)"], "goal_after": [], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n match l as l0 return (ordered (a :: b :: l0) -> ordered (a :: l0)) with\n | nil => ?Goal\n | a0 :: l0 => ?Goal0 a0 l0\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Ordered.v", "name": "ordered_trans", "text": "Theorem ordered_trans :\n forall (a b : A) (l : list A), ordered (a :: l) -> In b l -> order a b.\nProof using A order order_trans.\nintros a b l; generalize a b; elim l; clear l a b.\nintros a b H H2; inversion H2.\nsimpl in |- *; intros c l H a b H0 [H1| H1].\nrewrite <- H1; apply ordered_inv_order with (1 := H0).\napply order_trans with (b := c); auto.\napply ordered_inv_order with (1 := H0).\napply H; auto.\napply ordered_inv with (1 := H0).\nQed.\n", "definition": "\n forall (a b : A) (l : list A), ordered (a :: l) -> In b l -> order a b.", "proof": "\nProof using A order order_trans.\nintros a b l; generalize a b; elim l; clear l a b.\nintros a b H H2; inversion H2.\nsimpl in |- *; intros c l H a b H0 [H1| H1].\nrewrite <- H1; apply ordered_inv_order with (1 := H0).\napply order_trans with (b := c); auto.\napply ordered_inv_order with (1 := H0).\napply H; auto.\napply ordered_inv with (1 := H0).\n", "def_ranges": [69, 0, 70, 72], "proof_ranges": [71, 0, 80, 4], "proof_steps": [{"text": "Proof using A order order_trans.", "goal_before": ["forall (a b : A) (l : list A), ordered (a :: l) -> In b l -> order a b"], "goal_after": ["forall (a b : A) (l : list A), ordered (a :: l) -> In b l -> order a b"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a b l; generalize a b; elim l; clear l a b.", "goal_before": ["forall (a b : A) (l : list A), ordered (a :: l) -> In b l -> order a b"], "goal_after": ["forall a b : A, ordered (a :: nil) -> In b nil -> order a b", "forall (a : A) (l : list A),\n(forall a0 b : A, ordered (a0 :: l) -> In b l -> order a0 b) ->\nforall a0 b : A, ordered (a0 :: a :: l) -> In b (a :: l) -> order a0 b"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0) \n   ?Goal ?Goal0 l a b)"]}, {"text": "intros a b H H2; inversion H2.", "goal_before": ["forall a b : A, ordered (a :: nil) -> In b nil -> order a b", "forall (a : A) (l : list A),\n(forall a0 b : A, ordered (a0 :: l) -> In b l -> order a0 b) ->\nforall a0 b : A, ordered (a0 :: a :: l) -> In b (a :: l) -> order a0 b"], "goal_after": ["forall (a : A) (l : list A),\n(forall a0 b : A, ordered (a0 :: l) -> In b l -> order a0 b) ->\nforall a0 b : A, ordered (a0 :: a :: l) -> In b (a :: l) -> order a0 b"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0) \n   ?Goal ?Goal0 l a b)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0) ?Goal l a b)"]}, {"text": "simpl in |- *; intros c l H a b H0 [H1| H1].", "goal_before": ["forall (a : A) (l : list A),\n(forall a0 b : A, ordered (a0 :: l) -> In b l -> order a0 b) ->\nforall a0 b : A, ordered (a0 :: a :: l) -> In b (a :: l) -> order a0 b"], "goal_after": ["order a b", "order a b"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0) ?Goal l a b)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x => (fun H1 : c = b0 => ?Goal@{l:=l0; a:=a0; b:=b0}) x\n     | or_intror x => (fun H1 : In b0 l0 => ?Goal0@{l:=l0; a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"]}, {"text": "rewrite <- H1; apply ordered_inv_order with (1 := H0).", "goal_before": ["order a b", "order a b"], "goal_after": ["order a b"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x => (fun H1 : c = b0 => ?Goal@{l:=l0; a:=a0; b:=b0}) x\n     | or_intror x => (fun H1 : In b0 l0 => ?Goal0@{l:=l0; a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x => (fun H1 : In b0 l0 => ?Goal@{l:=l0; a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"]}, {"text": "apply order_trans with (b := c); auto.", "goal_before": ["order a b"], "goal_after": ["order a c", "order c b"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x => (fun H1 : In b0 l0 => ?Goal@{l:=l0; a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x =>\n         (fun H1 : In b0 l0 =>\n          order_trans a0 c b0 ?Goal@{l:=l0; a:=a0; b:=b0}\n            ?Goal0@{l:=l0; a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"]}, {"text": "apply ordered_inv_order with (1 := H0).", "goal_before": ["order a c", "order c b"], "goal_after": ["order c b"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x =>\n         (fun H1 : In b0 l0 =>\n          order_trans a0 c b0 ?Goal@{l:=l0; a:=a0; b:=b0}\n            ?Goal0@{l:=l0; a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x =>\n         (fun H1 : In b0 l0 =>\n          order_trans a0 c b0 (ordered_inv_order a0 c l0 H0)\n            ?Goal@{l:=l0; a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"]}, {"text": "apply H; auto.", "goal_before": ["order c b"], "goal_after": ["ordered (c :: l)"], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x =>\n         (fun H1 : In b0 l0 =>\n          order_trans a0 c b0 (ordered_inv_order a0 c l0 H0)\n            ?Goal@{l:=l0; a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x =>\n         (fun H1 : In b0 l0 =>\n          order_trans a0 c b0 (ordered_inv_order a0 c l0 H0)\n            (H c b0 ?Goal@{l:=l0; a:=a0; b:=b0} H1)) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"]}, {"text": "apply ordered_inv with (1 := H0).", "goal_before": ["ordered (c :: l)"], "goal_after": [], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x =>\n         (fun H1 : In b0 l0 =>\n          order_trans a0 c b0 (ordered_inv_order a0 c l0 H0)\n            (H c b0 ?Goal@{l:=l0; a:=a0; b:=b0} H1)) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"], "proof_term_after": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x =>\n         (fun H1 : In b0 l0 =>\n          order_trans a0 c b0 (ordered_inv_order a0 c l0 H0)\n            (H c b0 (ordered_inv a0 (c :: l0) H0) H1)) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n   (fun (a0 b0 : A) (_ : ordered (a0 :: nil)) (H2 : In b0 nil) =>\n    let H0 : order a0 b0 := match H2 return (order a0 b0) with\n                            end in H0)\n   ((fun (c : A) (l0 : list A)\n       (H : forall a0 b0 : A, ordered (a0 :: l0) -> In b0 l0 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (a0 :: c :: l0)) \n       (H2 : c = b0 \\/ In b0 l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : c = b0 =>\n          eq_ind c (fun b1 : A => order a0 b1) (ordered_inv_order a0 c l0 H0)\n            b0 H1) x\n     | or_intror x =>\n         (fun H1 : In b0 l0 =>\n          order_trans a0 c b0 (ordered_inv_order a0 c l0 H0)\n            (H c b0 (ordered_inv a0 (c :: l0) H0) H1)) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (forall a1 b0 : A, ordered (a1 :: l0) -> In b0 l0 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered (a1 :: a0 :: l0) -> In b0 (a0 :: l0) -> order a1 b0) l a b)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Ordered.v", "name": "ordered_trans_app", "text": "Theorem ordered_trans_app :\n forall (a b : A) (l1 l2 : list A),\n ordered (l1 ++ l2) -> In a l1 -> In b l2 -> order a b.\nProof using A order order_trans.\nintros a b l1 l2; generalize a b; elim l1; simpl in |- *; clear l1 a b.\nintros a b H H1; case H1.\nintros c l H a b H0 [H1| H1] H2.\nrewrite <- H1; apply ordered_trans with (1 := H0); auto with datatypes.\napply H; auto.\napply ordered_inv with (1 := H0); auto.\nQed.\n", "definition": "\n forall (a b : A) (l1 l2 : list A),\n ordered (l1 ++ l2) -> In a l1 -> In b l2 -> order a b.", "proof": "\nProof using A order order_trans.\nintros a b l1 l2; generalize a b; elim l1; simpl in |- *; clear l1 a b.\nintros a b H H1; case H1.\nintros c l H a b H0 [H1| H1] H2.\nrewrite <- H1; apply ordered_trans with (1 := H0); auto with datatypes.\napply H; auto.\napply ordered_inv with (1 := H0); auto.\n", "def_ranges": [86, 0, 88, 55], "proof_ranges": [89, 0, 96, 4], "proof_steps": [{"text": "Proof using A order order_trans.", "goal_before": ["forall (a b : A) (l1 l2 : list A),\nordered (l1 ++ l2) -> In a l1 -> In b l2 -> order a b"], "goal_after": ["forall (a b : A) (l1 l2 : list A),\nordered (l1 ++ l2) -> In a l1 -> In b l2 -> order a b"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a b l1 l2; generalize a b; elim l1; simpl in |- *; clear l1 a b.", "goal_before": ["forall (a b : A) (l1 l2 : list A),\nordered (l1 ++ l2) -> In a l1 -> In b l2 -> order a b"], "goal_after": ["forall a b : A, ordered l2 -> False -> In b l2 -> order a b", "forall (a : A) (l : list A),\n(forall a0 b : A, ordered (l ++ l2) -> In a0 l -> In b l2 -> order a0 b) ->\nforall a0 b : A,\nordered (a :: l ++ l2) -> a = a0 \\/ In a0 l -> In b l2 -> order a0 b"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   (?Goal\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   (?Goal0\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"]}, {"text": "intros a b H H1; case H1.", "goal_before": ["forall a b : A, ordered l2 -> False -> In b l2 -> order a b", "forall (a : A) (l : list A),\n(forall a0 b : A, ordered (l ++ l2) -> In a0 l -> In b l2 -> order a0 b) ->\nforall a0 b : A,\nordered (a :: l ++ l2) -> a = a0 \\/ In a0 l -> In b l2 -> order a0 b"], "goal_after": ["forall (a : A) (l : list A),\n(forall a0 b : A, ordered (l ++ l2) -> In a0 l -> In b l2 -> order a0 b) ->\nforall a0 b : A,\nordered (a :: l ++ l2) -> a = a0 \\/ In a0 l -> In b l2 -> order a0 b"], "proof_term_before": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   (?Goal\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   (?Goal0\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"], "proof_term_after": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"]}, {"text": "intros c l H a b H0 [H1| H1] H2.", "goal_before": ["forall (a : A) (l : list A),\n(forall a0 b : A, ordered (l ++ l2) -> In a0 l -> In b l2 -> order a0 b) ->\nforall a0 b : A,\nordered (a :: l ++ l2) -> a = a0 \\/ In a0 l -> In b l2 -> order a0 b"], "goal_after": ["order a b", "order a b"], "proof_term_before": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"], "proof_term_after": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   ((fun (c : A) (l : list A)\n       (H : forall a0 b0 : A,\n            ordered (l ++ l2) -> In a0 l -> In b0 l2 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (c :: l ++ l2)) (H3 : c = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : c = a0) (H2 : In b0 l2) => ?Goal@{a:=a0; b:=b0}) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In b0 l2) => ?Goal0@{a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"]}, {"text": "rewrite <- H1; apply ordered_trans with (1 := H0); auto with datatypes.", "goal_before": ["order a b", "order a b"], "goal_after": ["order a b"], "proof_term_before": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   ((fun (c : A) (l : list A)\n       (H : forall a0 b0 : A,\n            ordered (l ++ l2) -> In a0 l -> In b0 l2 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (c :: l ++ l2)) (H3 : c = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : c = a0) (H2 : In b0 l2) => ?Goal@{a:=a0; b:=b0}) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In b0 l2) => ?Goal0@{a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"], "proof_term_after": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   ((fun (c : A) (l : list A)\n       (H : forall a0 b0 : A,\n            ordered (l ++ l2) -> In a0 l -> In b0 l2 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (c :: l ++ l2)) (H3 : c = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : c = a0) (H2 : In b0 l2) =>\n          eq_ind c (fun a1 : A => order a1 b0)\n            (ordered_trans c b0 (l ++ l2) H0\n               (in_or_app l l2 b0 (or_intror H2))) a0 H1) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In b0 l2) => ?Goal@{a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"]}, {"text": "apply H; auto.", "goal_before": ["order a b"], "goal_after": ["ordered (l ++ l2)"], "proof_term_before": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   ((fun (c : A) (l : list A)\n       (H : forall a0 b0 : A,\n            ordered (l ++ l2) -> In a0 l -> In b0 l2 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (c :: l ++ l2)) (H3 : c = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : c = a0) (H2 : In b0 l2) =>\n          eq_ind c (fun a1 : A => order a1 b0)\n            (ordered_trans c b0 (l ++ l2) H0\n               (in_or_app l l2 b0 (or_intror H2))) a0 H1) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In b0 l2) => ?Goal@{a:=a0; b:=b0}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"], "proof_term_after": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   ((fun (c : A) (l : list A)\n       (H : forall a0 b0 : A,\n            ordered (l ++ l2) -> In a0 l -> In b0 l2 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (c :: l ++ l2)) (H3 : c = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : c = a0) (H2 : In b0 l2) =>\n          eq_ind c (fun a1 : A => order a1 b0)\n            (ordered_trans c b0 (l ++ l2) H0\n               (in_or_app l l2 b0 (or_intror H2))) a0 H1) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In b0 l2) =>\n          H a0 b0 ?Goal@{a:=a0; b:=b0} H1 H2) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"]}, {"text": "apply ordered_inv with (1 := H0); auto.", "goal_before": ["ordered (l ++ l2)"], "goal_after": [], "proof_term_before": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   ((fun (c : A) (l : list A)\n       (H : forall a0 b0 : A,\n            ordered (l ++ l2) -> In a0 l -> In b0 l2 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (c :: l ++ l2)) (H3 : c = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : c = a0) (H2 : In b0 l2) =>\n          eq_ind c (fun a1 : A => order a1 b0)\n            (ordered_trans c b0 (l ++ l2) H0\n               (in_or_app l l2 b0 (or_intror H2))) a0 H1) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In b0 l2) =>\n          H a0 b0 ?Goal@{a:=a0; b:=b0} H1 H2) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"], "proof_term_after": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   ((fun (c : A) (l : list A)\n       (H : forall a0 b0 : A,\n            ordered (l ++ l2) -> In a0 l -> In b0 l2 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (c :: l ++ l2)) (H3 : c = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : c = a0) (H2 : In b0 l2) =>\n          eq_ind c (fun a1 : A => order a1 b0)\n            (ordered_trans c b0 (l ++ l2) H0\n               (in_or_app l l2 b0 (or_intror H2))) a0 H1) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In b0 l2) =>\n          H a0 b0 (ordered_inv c (l ++ l2) H0) H1 H2) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall a0 b0 : A,\n    ordered (l3 ++ l2) -> In a0 l3 -> In b0 l2 -> order a0 b0)\n   ((fun (a0 b0 : A) (_ : ordered l2) (H1 : False) =>\n     match H1 return (In b0 l2 -> order a0 b0) with\n     end)\n    :\n    forall a0 b0 : A,\n    ordered (nil ++ l2) -> In a0 nil -> In b0 l2 -> order a0 b0)\n   ((fun (c : A) (l : list A)\n       (H : forall a0 b0 : A,\n            ordered (l ++ l2) -> In a0 l -> In b0 l2 -> order a0 b0)\n       (a0 b0 : A) (H0 : ordered (c :: l ++ l2)) (H3 : c = a0 \\/ In a0 l) =>\n     match H3 with\n     | or_introl x =>\n         (fun (H1 : c = a0) (H2 : In b0 l2) =>\n          eq_ind c (fun a1 : A => order a1 b0)\n            (ordered_trans c b0 (l ++ l2) H0\n               (in_or_app l l2 b0 (or_intror H2))) a0 H1) x\n     | or_intror x =>\n         (fun (H1 : In a0 l) (H2 : In b0 l2) =>\n          H a0 b0 (ordered_inv c (l ++ l2) H0) H1 H2) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 b0 : A,\n     ordered (l ++ l2) -> In a1 l -> In b0 l2 -> order a1 b0) ->\n    forall a1 b0 : A,\n    ordered ((a0 :: l) ++ l2) -> In a1 (a0 :: l) -> In b0 l2 -> order a1 b0)\n   l1 a b)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Ordered.v", "name": "ordered_perm_antisym_eq", "text": "Theorem ordered_perm_antisym_eq :\n (forall a b : A, order a b -> order b a -> a = b) ->\n forall l1 l2 : list A,\n permutation l1 l2 -> ordered l1 -> ordered l2 -> l1 = l2.\nProof using A order order_trans.\nintros antisym l1; elim l1; clear l1; simpl in |- *; auto.\nintros l2 H1 H2 H3; apply sym_equal; apply permutation_nil_inv.\napply permutation_sym; auto.\nintros a l1 Rec l2; case l2; simpl in |- *.\nintros H; absurd (length (a :: l1) = length (A:=A) nil).\nsimpl in |- *; red in |- *; intros; discriminate.\napply permutation_length; auto.\nintros a0 l H H0 H1.\ncut (a = a0).\nintros H3; apply f_equal2 with (f := cons (A:=A)); auto.\napply Rec; auto.\napply permutation_inv with (a := a); auto.\npattern a at 2 in |- *; rewrite H3; auto.\napply ordered_inv with (1 := H0); auto.\napply ordered_inv with (1 := H1); auto.\ngeneralize (permutation_in _ a _ _ H); simpl in |- *;\n (intros H2; case H2; auto; clear H2; intros H2).\ngeneralize (permutation_in _ a0 _ _ (permutation_sym _ _ _ H)); simpl in |- *;\n (intros H3; case H3; auto; clear H3; intros H3).\napply antisym.\napply ordered_trans with (1 := H0); auto.\napply ordered_trans with (1 := H1); auto.\nQed.\n", "definition": "\n (forall a b : A, order a b -> order b a -> a = b) ->\n forall l1 l2 : list A,\n permutation l1 l2 -> ordered l1 -> ordered l2 -> l1 = l2.", "proof": "\nProof using A order order_trans.\nintros antisym l1; elim l1; clear l1; simpl in |- *; auto.\nintros l2 H1 H2 H3; apply sym_equal; apply permutation_nil_inv.\napply permutation_sym; auto.\nintros a l1 Rec l2; case l2; simpl in |- *.\nintros H; absurd (length (a :: l1) = length (A:=A) nil).\nsimpl in |- *; red in |- *; intros; discriminate.\napply permutation_length; auto.\nintros a0 l H H0 H1.\ncut (a = a0).\nintros H3; apply f_equal2 with (f := cons (A:=A)); auto.\napply Rec; auto.\napply permutation_inv with (a := a); auto.\npattern a at 2 in |- *; rewrite H3; auto.\napply ordered_inv with (1 := H0); auto.\napply ordered_inv with (1 := H1); auto.\ngeneralize (permutation_in _ a _ _ H); simpl in |- *;\n (intros H2; case H2; auto; clear H2; intros H2).\ngeneralize (permutation_in _ a0 _ _ (permutation_sym _ _ _ H)); simpl in |- *;\n (intros H3; case H3; auto; clear H3; intros H3).\napply antisym.\napply ordered_trans with (1 := H0); auto.\napply ordered_trans with (1 := H1); auto.\n", "def_ranges": [99, 0, 102, 58], "proof_ranges": [103, 0, 126, 4], "proof_steps": [{"text": "Proof using A order order_trans.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros antisym l1; elim l1; clear l1; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l2 H1 H2 H3; apply sym_equal; apply permutation_nil_inv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_sym; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l1 Rec l2; case l2; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H; absurd (length (a :: l1) = length (A:=A) nil).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; red in |- *; intros; discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_length; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 l H H0 H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a = a0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H3; apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rec; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_inv with (a := a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern a at 2 in |- *; rewrite H3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_inv with (1 := H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_inv with (1 := H1); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (permutation_in _ a _ _ H); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(intros H2; case H2; auto; clear H2; intros H2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (permutation_in _ a0 _ _ (permutation_sym _ _ _ H)); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(intros H3; case H3; auto; clear H3; intros H3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply antisym.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_trans with (1 := H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_trans with (1 := H1); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Ordered.v", "name": "ordered_map_inv", "text": "Theorem ordered_map_inv :\n forall (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B),\n ordered (fun x y => order (g x) (g y)) l -> ordered order (map g l).\nProof using.\nintros A B order g l; elim l; simpl in |- *; auto.\nintros a1 l1; case l1; simpl in |- *; auto.\nintros b l0 H H0; inversion H0; auto.\nQed.\n", "definition": "\n forall (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B),\n ordered (fun x y => order (g x) (g y)) l -> ordered order (map g l).", "proof": "\nProof using.\nintros A B order g l; elim l; simpl in |- *; auto.\nintros a1 l1; case l1; simpl in |- *; auto.\nintros b l0 H H0; inversion H0; auto.\n", "def_ranges": [133, 0, 135, 69], "proof_ranges": [136, 0, 140, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B),\nordered (fun x y : B => order (g x) (g y)) l -> ordered order (map g l)"], "goal_after": ["forall (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B),\nordered (fun x y : B => order (g x) (g y)) l -> ordered order (map g l)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros A B order g l; elim l; simpl in |- *; auto.", "goal_before": ["forall (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B),\nordered (fun x y : B => order (g x) (g y)) l -> ordered order (map g l)"], "goal_after": ["ordered (fun x y : B => order (g x) (g y)) nil -> ordered order nil", "forall (a : B) (l0 : list B),\n(ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0)) ->\nordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\nordered order (g a :: map g l0)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B) =>\n list_ind\n   (fun l0 : list B =>\n    ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0))\n   (?Goal\n    :\n    ordered (fun x y : B => order (g x) (g y)) nil ->\n    ordered order (map g nil))\n   (?Goal0\n    :\n    forall (a : B) (l0 : list B),\n    (ordered (fun x y : B => order (g x) (g y)) l0 ->\n     ordered order (map g l0)) ->\n    ordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\n    ordered order (map g (a :: l0))) l)"]}, {"text": "intros a1 l1; case l1; simpl in |- *; auto.", "goal_before": ["ordered (fun x y : B => order (g x) (g y)) nil -> ordered order nil", "forall (a : B) (l0 : list B),\n(ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0)) ->\nordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\nordered order (g a :: map g l0)"], "goal_after": ["ordered (fun x y : B => order (g x) (g y)) nil -> ordered order nil", "forall (a : B) (l0 : list B),\n(ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0)) ->\nordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\nordered order (g a :: map g l0)"], "proof_term_before": ["(fun (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B) =>\n list_ind\n   (fun l0 : list B =>\n    ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0))\n   (?Goal\n    :\n    ordered (fun x y : B => order (g x) (g y)) nil ->\n    ordered order (map g nil))\n   (?Goal0\n    :\n    forall (a : B) (l0 : list B),\n    (ordered (fun x y : B => order (g x) (g y)) l0 ->\n     ordered order (map g l0)) ->\n    ordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\n    ordered order (map g (a :: l0))) l)"], "proof_term_after": ["(fun (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B) =>\n list_ind\n   (fun l0 : list B =>\n    ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0))\n   (?Goal\n    :\n    ordered (fun x y : B => order (g x) (g y)) nil ->\n    ordered order (map g nil))\n   (?Goal0\n    :\n    forall (a : B) (l0 : list B),\n    (ordered (fun x y : B => order (g x) (g y)) l0 ->\n     ordered order (map g l0)) ->\n    ordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\n    ordered order (map g (a :: l0))) l)"]}, {"text": "intros b l0 H H0; inversion H0; auto.", "goal_before": ["ordered (fun x y : B => order (g x) (g y)) nil -> ordered order nil", "forall (a : B) (l0 : list B),\n(ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0)) ->\nordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\nordered order (g a :: map g l0)"], "goal_after": ["ordered (fun x y : B => order (g x) (g y)) nil -> ordered order nil", "forall (a : B) (l0 : list B),\n(ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0)) ->\nordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\nordered order (g a :: map g l0)"], "proof_term_before": ["(fun (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B) =>\n list_ind\n   (fun l0 : list B =>\n    ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0))\n   (?Goal\n    :\n    ordered (fun x y : B => order (g x) (g y)) nil ->\n    ordered order (map g nil))\n   (?Goal0\n    :\n    forall (a : B) (l0 : list B),\n    (ordered (fun x y : B => order (g x) (g y)) l0 ->\n     ordered order (map g l0)) ->\n    ordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\n    ordered order (map g (a :: l0))) l)"], "proof_term_after": ["(fun (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B) =>\n list_ind\n   (fun l0 : list B =>\n    ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0))\n   (?Goal\n    :\n    ordered (fun x y : B => order (g x) (g y)) nil ->\n    ordered order (map g nil))\n   (?Goal0\n    :\n    forall (a : B) (l0 : list B),\n    (ordered (fun x y : B => order (g x) (g y)) l0 ->\n     ordered order (map g l0)) ->\n    ordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\n    ordered order (map g (a :: l0))) l)"]}, {"text": "Qed.", "goal_before": ["ordered (fun x y : B => order (g x) (g y)) nil -> ordered order nil", "forall (a : B) (l0 : list B),\n(ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0)) ->\nordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\nordered order (g a :: map g l0)"], "goal_after": [], "proof_term_before": ["(fun (A B : Type) (order : A -> A -> Prop) (g : B -> A) (l : list B) =>\n list_ind\n   (fun l0 : list B =>\n    ordered (fun x y : B => order (g x) (g y)) l0 -> ordered order (map g l0))\n   (?Goal\n    :\n    ordered (fun x y : B => order (g x) (g y)) nil ->\n    ordered order (map g nil))\n   (?Goal0\n    :\n    forall (a : B) (l0 : list B),\n    (ordered (fun x y : B => order (g x) (g y)) l0 ->\n     ordered order (map g l0)) ->\n    ordered (fun x y : B => order (g x) (g y)) (a :: l0) ->\n    ordered order (map g (a :: l0))) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "add_frequency_list_perm", "text": "Theorem add_frequency_list_perm :\n forall (a : A) l,\n permutation (a :: flat_map (fun p => id_list (fst p) (snd p)) l)\n   (flat_map (fun p => id_list (fst p) (snd p)) (add_frequency_list a l)).\nProof using.\nintros a l; generalize a; elim l; simpl in |- *; clear a l; auto.\nintros (a, n) l H b.\ncase (eqA_dec b a); auto.\nintros e; simpl in |- *; rewrite e; auto.\nsimpl in |- *.\nintros e;\n apply\n  permutation_trans\n   with\n     (id_list a n ++\n      (b :: nil) ++ flat_map (fun p => id_list (fst p) (snd p)) l);\n [ idtac | simpl in |- *; auto ].\nchange\n  (permutation\n     ((b :: nil) ++\n      id_list a n ++ flat_map (fun p => id_list (fst p) (snd p)) l)\n     (id_list a n ++\n      (b :: nil) ++ flat_map (fun p => id_list (fst p) (snd p)) l)) \n in |- *.\nrepeat rewrite <- app_ass; auto.\nQed.\n", "definition": "\n forall (a : A) l,\n permutation (a :: flat_map (fun p => id_list (fst p) (snd p)) l)\n   (flat_map (fun p => id_list (fst p) (snd p)) (add_frequency_list a l)).", "proof": "\nProof using.\nintros a l; generalize a; elim l; simpl in |- *; clear a l; auto.\nintros (a, n) l H b.\ncase (eqA_dec b a); auto.\nintros e; simpl in |- *; rewrite e; auto.\nsimpl in |- *.\nintros e;\n apply\n  permutation_trans\n   with\n     (id_list a n ++\n      (b :: nil) ++ flat_map (fun p => id_list (fst p) (snd p)) l);\n [ idtac | simpl in |- *; auto ].\nchange\n  (permutation\n     ((b :: nil) ++\n      id_list a n ++ flat_map (fun p => id_list (fst p) (snd p)) l)\n     (id_list a n ++\n      (b :: nil) ++ flat_map (fun p => id_list (fst p) (snd p)) l)) \n in |- *.\nrepeat rewrite <- app_ass; auto.\n", "def_ranges": [57, 0, 60, 74], "proof_ranges": [61, 0, 82, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l; generalize a; elim l; simpl in |- *; clear a l; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a, n) l H b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (eqA_dec b a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e; simpl in |- *; rewrite e; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "permutation_trans", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(id_list a n ++", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(b :: nil) ++ flat_map (fun p => id_list (fst p) (snd p)) l);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ idtac | simpl in |- *; auto ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(permutation", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((b :: nil) ++", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "add_frequency_list_in_inv", "text": "Theorem add_frequency_list_in_inv :\n forall (a1 a2 : A) (b1 : nat) l,\n In (a1, b1) (add_frequency_list a2 l) -> a1 = a2 \\/ In (a1, b1) l.\nProof using.\nintros a1 a2 b1 l; elim l; simpl in |- *; auto.\nintros [H1| H1]; auto; injection H1; auto.\nintros (a3, b3) l1 Rec; simpl in |- *; auto.\ncase (eqA_dec a2 a3); simpl in |- *; auto.\nintros e H; cut (In (a1, b1) ((a2, S b3) :: l1)); auto.\nsimpl in |- *; intros [H1| H1]; auto.\ninjection H1; auto.\nintuition.\nQed.\n", "definition": "\n forall (a1 a2 : A) (b1 : nat) l,\n In (a1, b1) (add_frequency_list a2 l) -> a1 = a2 \\/ In (a1, b1) l.", "proof": "\nProof using.\nintros a1 a2 b1 l; elim l; simpl in |- *; auto.\nintros [H1| H1]; auto; injection H1; auto.\nintros (a3, b3) l1 Rec; simpl in |- *; auto.\ncase (eqA_dec a2 a3); simpl in |- *; auto.\nintros e H; cut (In (a1, b1) ((a2, S b3) :: l1)); auto.\nsimpl in |- *; intros [H1| H1]; auto.\ninjection H1; auto.\nintuition.\n", "def_ranges": [85, 0, 87, 67], "proof_ranges": [88, 0, 97, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a1 a2 : A) (b1 : nat) (l : list (A * nat)),\nIn (a1, b1) (add_frequency_list a2 l) -> a1 = a2 \\/ In (a1, b1) l"], "goal_after": ["forall (a1 a2 : A) (b1 : nat) (l : list (A * nat)),\nIn (a1, b1) (add_frequency_list a2 l) -> a1 = a2 \\/ In (a1, b1) l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a1 a2 b1 l; elim l; simpl in |- *; auto.", "goal_before": ["forall (a1 a2 : A) (b1 : nat) (l : list (A * nat)),\nIn (a1, b1) (add_frequency_list a2 l) -> a1 = a2 \\/ In (a1, b1) l"], "goal_after": ["(a2, 1) = (a1, b1) \\/ False -> a1 = a2 \\/ False", "forall (a : A * nat) (l0 : list (A * nat)),\n(In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\nIn (a1, b1)\n  (let (b, n) := a in\n   if eqA_dec a2 b\n   then (a2, S n) :: l0\n   else (b, n) :: add_frequency_list a2 l0) ->\na1 = a2 \\/ a = (a1, b1) \\/ In (a1, b1) l0"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   (?Goal\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   (?Goal0\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"]}, {"text": "intros [H1| H1]; auto; injection H1; auto.", "goal_before": ["(a2, 1) = (a1, b1) \\/ False -> a1 = a2 \\/ False", "forall (a : A * nat) (l0 : list (A * nat)),\n(In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\nIn (a1, b1)\n  (let (b, n) := a in\n   if eqA_dec a2 b\n   then (a2, S n) :: l0\n   else (b, n) :: add_frequency_list a2 l0) ->\na1 = a2 \\/ a = (a1, b1) \\/ In (a1, b1) l0"], "goal_after": ["forall (a : A * nat) (l0 : list (A * nat)),\n(In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\nIn (a1, b1)\n  (let (b, n) := a in\n   if eqA_dec a2 b\n   then (a2, S n) :: l0\n   else (b, n) :: add_frequency_list a2 l0) ->\na1 = a2 \\/ a = (a1, b1) \\/ In (a1, b1) l0"], "proof_term_before": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   (?Goal\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   (?Goal0\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"], "proof_term_after": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   (?Goal\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"]}, {"text": "intros (a3, b3) l1 Rec; simpl in |- *; auto.", "goal_before": ["forall (a : A * nat) (l0 : list (A * nat)),\n(In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\nIn (a1, b1)\n  (let (b, n) := a in\n   if eqA_dec a2 b\n   then (a2, S n) :: l0\n   else (b, n) :: add_frequency_list a2 l0) ->\na1 = a2 \\/ a = (a1, b1) \\/ In (a1, b1) l0"], "goal_after": ["In (a1, b1)\n  (if eqA_dec a2 a3\n   then (a2, S b3) :: l1\n   else (a3, b3) :: add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "proof_term_before": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   (?Goal\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"], "proof_term_after": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      ?Goal\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"]}, {"text": "case (eqA_dec a2 a3); simpl in |- *; auto.", "goal_before": ["In (a1, b1)\n  (if eqA_dec a2 a3\n   then (a2, S b3) :: l1\n   else (a3, b3) :: add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "goal_after": ["a2 = a3 ->\n(a2, S b3) = (a1, b1) \\/ In (a1, b1) l1 ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1", "a2 <> a3 ->\n(a3, b3) = (a1, b1) \\/ In (a1, b1) (add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "proof_term_before": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      ?Goal\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"], "proof_term_after": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          (?Goal\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          (?Goal0\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"]}, {"text": "intros e H; cut (In (a1, b1) ((a2, S b3) :: l1)); auto.", "goal_before": ["a2 = a3 ->\n(a2, S b3) = (a1, b1) \\/ In (a1, b1) l1 ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1", "a2 <> a3 ->\n(a3, b3) = (a1, b1) \\/ In (a1, b1) (add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "goal_after": ["In (a1, b1) ((a2, S b3) :: l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1", "a2 <> a3 ->\n(a3, b3) = (a1, b1) \\/ In (a1, b1) (add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "proof_term_before": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          (?Goal\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          (?Goal0\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"], "proof_term_after": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          ((fun (e : a2 = a3) (H : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1)\n            => let H0 : In (a1, b1) ((a2, S b3) :: l1) := H in ?Goal0 H0)\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          (?Goal\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"]}, {"text": "simpl in |- *; intros [H1| H1]; auto.", "goal_before": ["In (a1, b1) ((a2, S b3) :: l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1", "a2 <> a3 ->\n(a3, b3) = (a1, b1) \\/ In (a1, b1) (add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "goal_after": ["a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1", "a2 <> a3 ->\n(a3, b3) = (a1, b1) \\/ In (a1, b1) (add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "proof_term_before": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          ((fun (e : a2 = a3) (H : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1)\n            => let H0 : In (a1, b1) ((a2, S b3) :: l1) := H in ?Goal0 H0)\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          (?Goal\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"], "proof_term_after": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          ((fun (e : a2 = a3) (H : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1)\n            =>\n            let H0 : In (a1, b1) ((a2, S b3) :: l1) := H in\n            ((fun H1 : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1 =>\n              match H1 with\n              | or_introl x =>\n                  (fun H2 : (a2, S b3) = (a1, b1) => ?Goal0@{H1:=H2}) x\n              | or_intror x =>\n                  (fun H2 : In (a1, b1) l1 => or_intror (or_intror H2)) x\n              end)\n             :\n             In (a1, b1) ((a2, S b3) :: l1) ->\n             a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) H0)\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          (?Goal\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"]}, {"text": "injection H1; auto.", "goal_before": ["a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1", "a2 <> a3 ->\n(a3, b3) = (a1, b1) \\/ In (a1, b1) (add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "goal_after": ["a2 <> a3 ->\n(a3, b3) = (a1, b1) \\/ In (a1, b1) (add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "proof_term_before": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          ((fun (e : a2 = a3) (H : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1)\n            =>\n            let H0 : In (a1, b1) ((a2, S b3) :: l1) := H in\n            ((fun H1 : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1 =>\n              match H1 with\n              | or_introl x =>\n                  (fun H2 : (a2, S b3) = (a1, b1) => ?Goal0@{H1:=H2}) x\n              | or_intror x =>\n                  (fun H2 : In (a1, b1) l1 => or_intror (or_intror H2)) x\n              end)\n             :\n             In (a1, b1) ((a2, S b3) :: l1) ->\n             a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) H0)\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          (?Goal\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"], "proof_term_after": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          ((fun (_ : a2 = a3) (H : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1)\n            =>\n            let H0 : In (a1, b1) ((a2, S b3) :: l1) := H in\n            ((fun H1 : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1 =>\n              match H1 with\n              | or_introl x =>\n                  (fun H2 : (a2, S b3) = (a1, b1) =>\n                   let H3 : a2 = a1 :=\n                     f_equal (fun e0 : A * nat => let (a5, _) := e0 in a5) H2\n                     in\n                   (let H4 : S b3 = b1 :=\n                      f_equal (fun e0 : A * nat => let (_, n) := e0 in n) H2\n                      in\n                    (fun (_ : S b3 = b1) (H6 : a2 = a1) =>\n                     or_introl (eq_sym H6)) H4) H3) x\n              | or_intror x =>\n                  (fun H2 : In (a1, b1) l1 => or_intror (or_intror H2)) x\n              end)\n             :\n             In (a1, b1) ((a2, S b3) :: l1) ->\n             a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) H0)\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          (?Goal\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"]}, {"text": "intuition.", "goal_before": ["a2 <> a3 ->\n(a3, b3) = (a1, b1) \\/ In (a1, b1) (add_frequency_list a2 l1) ->\na1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1"], "goal_after": [], "proof_term_before": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          ((fun (_ : a2 = a3) (H : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1)\n            =>\n            let H0 : In (a1, b1) ((a2, S b3) :: l1) := H in\n            ((fun H1 : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1 =>\n              match H1 with\n              | or_introl x =>\n                  (fun H2 : (a2, S b3) = (a1, b1) =>\n                   let H3 : a2 = a1 :=\n                     f_equal (fun e0 : A * nat => let (a5, _) := e0 in a5) H2\n                     in\n                   (let H4 : S b3 = b1 :=\n                      f_equal (fun e0 : A * nat => let (_, n) := e0 in n) H2\n                      in\n                    (fun (_ : S b3 = b1) (H6 : a2 = a1) =>\n                     or_introl (eq_sym H6)) H4) H3) x\n              | or_intror x =>\n                  (fun H2 : In (a1, b1) l1 => or_intror (or_intror H2)) x\n              end)\n             :\n             In (a1, b1) ((a2, S b3) :: l1) ->\n             a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) H0)\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          (?Goal\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"], "proof_term_after": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          ((fun (_ : a2 = a3) (H : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1)\n            =>\n            let H0 : In (a1, b1) ((a2, S b3) :: l1) := H in\n            ((fun H1 : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1 =>\n              match H1 with\n              | or_introl x =>\n                  (fun H2 : (a2, S b3) = (a1, b1) =>\n                   let H3 : a2 = a1 :=\n                     f_equal (fun e0 : A * nat => let (a5, _) := e0 in a5) H2\n                     in\n                   (let H4 : S b3 = b1 :=\n                      f_equal (fun e0 : A * nat => let (_, n) := e0 in n) H2\n                      in\n                    (fun (_ : S b3 = b1) (H6 : a2 = a1) =>\n                     or_introl (eq_sym H6)) H4) H3) x\n              | or_intror x =>\n                  (fun H2 : In (a1, b1) l1 => or_intror (or_intror H2)) x\n              end)\n             :\n             In (a1, b1) ((a2, S b3) :: l1) ->\n             a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) H0)\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          ((fun (_ : a2 <> a3)\n              (H : (a3, b3) = (a1, b1) \\/\n                   In (a1, b1) (add_frequency_list a2 l1)) =>\n            or_ind (fun H0 : (a3, b3) = (a1, b1) => or_intror (or_introl H0))\n              (fun H0 : In (a1, b1) (add_frequency_list a2 l1) =>\n               let H1 : a1 = a2 \\/ In (a1, b1) l1 := Rec H0 in\n               or_ind (fun H2 : a1 = a2 => or_introl H2)\n                 (fun H2 : In (a1, b1) l1 => or_intror (or_intror H2)) H1) H)\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a1 a2 : A) (b1 : nat) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0)\n   ((fun H : (a2, 1) = (a1, b1) \\/ False =>\n     match H with\n     | or_introl x =>\n         (fun H1 : (a2, 1) = (a1, b1) =>\n          let H0 : a2 = a1 :=\n            f_equal (fun e : A * nat => let (a, _) := e in a) H1 in\n          (let H2 : 1 = b1 :=\n             f_equal (fun e : A * nat => let (_, n) := e in n) H1 in\n           (fun (_ : 1 = b1) (H4 : a2 = a1) => or_introl (eq_sym H4)) H2) H0)\n           x\n     | or_intror x => (fun H1 : False => or_intror H1) x\n     end)\n    :\n    In (a1, b1) (add_frequency_list a2 nil) -> a1 = a2 \\/ In (a1, b1) nil)\n   ((fun a : A * nat =>\n     let\n       (a0, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (In (a1, b1) (add_frequency_list a2 l0) ->\n            a1 = a2 \\/ In (a1, b1) l0) ->\n           In (a1, b1)\n             (let (b, n) := p in\n              if eqA_dec a2 b\n              then (a2, S n) :: l0\n              else (b, n) :: add_frequency_list a2 l0) ->\n           a1 = a2 \\/ p = (a1, b1) \\/ In (a1, b1) l0) := a in\n     (fun (a3 : A) (b3 : nat) (l1 : list (A * nat))\n        (Rec : In (a1, b1) (add_frequency_list a2 l1) ->\n               a1 = a2 \\/ In (a1, b1) l1) =>\n      match\n        eqA_dec a2 a3 as s\n        return\n          (In (a1, b1)\n             (if s\n              then (a2, S b3) :: l1\n              else (a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1)\n      with\n      | left a4 =>\n          ((fun (_ : a2 = a3) (H : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1)\n            =>\n            let H0 : In (a1, b1) ((a2, S b3) :: l1) := H in\n            ((fun H1 : (a2, S b3) = (a1, b1) \\/ In (a1, b1) l1 =>\n              match H1 with\n              | or_introl x =>\n                  (fun H2 : (a2, S b3) = (a1, b1) =>\n                   let H3 : a2 = a1 :=\n                     f_equal (fun e0 : A * nat => let (a5, _) := e0 in a5) H2\n                     in\n                   (let H4 : S b3 = b1 :=\n                      f_equal (fun e0 : A * nat => let (_, n) := e0 in n) H2\n                      in\n                    (fun (_ : S b3 = b1) (H6 : a2 = a1) =>\n                     or_introl (eq_sym H6)) H4) H3) x\n              | or_intror x =>\n                  (fun H2 : In (a1, b1) l1 => or_intror (or_intror H2)) x\n              end)\n             :\n             In (a1, b1) ((a2, S b3) :: l1) ->\n             a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) H0)\n           :\n           a2 = a3 ->\n           In (a1, b1) ((a2, S b3) :: l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a4\n      | right b0 =>\n          ((fun (_ : a2 <> a3)\n              (H : (a3, b3) = (a1, b1) \\/\n                   In (a1, b1) (add_frequency_list a2 l1)) =>\n            or_ind (fun H0 : (a3, b3) = (a1, b1) => or_intror (or_introl H0))\n              (fun H0 : In (a1, b1) (add_frequency_list a2 l1) =>\n               let H1 : a1 = a2 \\/ In (a1, b1) l1 := Rec H0 in\n               or_ind (fun H2 : a1 = a2 => or_introl H2)\n                 (fun H2 : In (a1, b1) l1 => or_intror (or_intror H2)) H1) H)\n           :\n           a2 <> a3 ->\n           In (a1, b1) ((a3, b3) :: add_frequency_list a2 l1) ->\n           a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) b0\n      end\n      :\n      In (a1, b1)\n        (if eqA_dec a2 a3\n         then (a2, S b3) :: l1\n         else (a3, b3) :: add_frequency_list a2 l1) ->\n      a1 = a2 \\/ (a3, b3) = (a1, b1) \\/ In (a1, b1) l1) a0 b)\n    :\n    forall (a : A * nat) (l0 : list (A * nat)),\n    (In (a1, b1) (add_frequency_list a2 l0) -> a1 = a2 \\/ In (a1, b1) l0) ->\n    In (a1, b1) (add_frequency_list a2 (a :: l0)) ->\n    a1 = a2 \\/ In (a1, b1) (a :: l0)) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "add_frequency_list_unique_key", "text": "Theorem add_frequency_list_unique_key :\n forall (a : A) l, unique_key l -> unique_key (add_frequency_list a l).\nProof using.\nintros a l; elim l; simpl in |- *; auto.\nintros (a1, n1) l1 Rec H; case (eqA_dec a a1).\nintros e; apply unique_key_perm with (l1 := (a, S n1) :: l1); auto.\napply unique_key_cons; auto.\nintros b; red in |- *; intros H0; case (unique_key_in _ _ _ _ b _ H); auto.\nrewrite <- e; auto.\napply unique_key_inv with (1 := H); auto.\nintros n; apply unique_key_cons; auto.\nintros b; red in |- *; intros H0;\n case add_frequency_list_in_inv with (1 := H0); auto.\nintros H2; case (unique_key_in _ _ _ _ b _ H); auto.\napply Rec; apply unique_key_inv with (1 := H); auto.\nQed.\n", "definition": "\n forall (a : A) l, unique_key l -> unique_key (add_frequency_list a l).", "proof": "\nProof using.\nintros a l; elim l; simpl in |- *; auto.\nintros (a1, n1) l1 Rec H; case (eqA_dec a a1).\nintros e; apply unique_key_perm with (l1 := (a, S n1) :: l1); auto.\napply unique_key_cons; auto.\nintros b; red in |- *; intros H0; case (unique_key_in _ _ _ _ b _ H); auto.\nrewrite <- e; auto.\napply unique_key_inv with (1 := H); auto.\nintros n; apply unique_key_cons; auto.\nintros b; red in |- *; intros H0;\n case add_frequency_list_in_inv with (1 := H0); auto.\nintros H2; case (unique_key_in _ _ _ _ b _ H); auto.\napply Rec; apply unique_key_inv with (1 := H); auto.\n", "def_ranges": [100, 0, 101, 71], "proof_ranges": [102, 0, 115, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l; elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a1, n1) l1 Rec H; case (eqA_dec a a1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e; apply unique_key_perm with (l1 := (a, S n1) :: l1); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b; red in |- *; intros H0; case (unique_key_in _ _ _ _ b _ H); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- e; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_inv with (1 := H); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n; apply unique_key_cons; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b; red in |- *; intros H0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case add_frequency_list_in_inv with (1 := H0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H2; case (unique_key_in _ _ _ _ b _ H); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rec; apply unique_key_inv with (1 := H); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "add_frequency_list_1", "text": "Theorem add_frequency_list_1 :\n forall a l,\n (forall ca, ~ In (a, ca) l) -> In (a, 1) (add_frequency_list a l).\nProof using.\nintros a l; generalize a; elim l; clear a l; simpl in |- *; auto.\nintros (a1, l1) l0 H a H0.\ncase (eqA_dec a a1); auto.\nintros H1; case (H0 l1); left;\n apply f_equal2 with (f := pair (A:=A) (B:=nat)); auto.\nintros n; apply in_cons; auto; apply H; auto.\nintros ca; red in |- *; intros H1; case (H0 ca); auto.\nQed.\n", "definition": "\n forall a l,\n (forall ca, ~ In (a, ca) l) -> In (a, 1) (add_frequency_list a l).", "proof": "\nProof using.\nintros a l; generalize a; elim l; clear a l; simpl in |- *; auto.\nintros (a1, l1) l0 H a H0.\ncase (eqA_dec a a1); auto.\nintros H1; case (H0 l1); left;\n apply f_equal2 with (f := pair (A:=A) (B:=nat)); auto.\nintros n; apply in_cons; auto; apply H; auto.\nintros ca; red in |- *; intros H1; case (H0 ca); auto.\n", "def_ranges": [118, 0, 120, 67], "proof_ranges": [121, 0, 129, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l : list (A * nat)),\n(forall ca : nat, ~ In (a, ca) l) -> In (a, 1) (add_frequency_list a l)"], "goal_after": ["forall (a : A) (l : list (A * nat)),\n(forall ca : nat, ~ In (a, ca) l) -> In (a, 1) (add_frequency_list a l)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l; generalize a; elim l; clear a l; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l : list (A * nat)),\n(forall ca : nat, ~ In (a, ca) l) -> In (a, 1) (add_frequency_list a l)"], "goal_after": ["forall (a : A * nat) (l : list (A * nat)),\n(forall a0 : A,\n (forall ca : nat, ~ In (a0, ca) l) -> In (a0, 1) (add_frequency_list a0 l)) ->\nforall a0 : A,\n(forall ca : nat, ~ (a = (a0, ca) \\/ In (a0, ca) l)) ->\nIn (a0, 1)\n  (let (b, n) := a in\n   if eqA_dec a0 b then (a0, S n) :: l else (b, n) :: add_frequency_list a0 l)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) l0) ->\n    In (a0, 1) (add_frequency_list a0 l0))\n   ((fun (a0 : A) (_ : nat -> ~ False) => or_introl eq_refl)\n    :\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) nil) ->\n    In (a0, 1) (add_frequency_list a0 nil))\n   (?Goal\n    :\n    forall (a0 : A * nat) (l0 : list (A * nat)),\n    (forall a1 : A,\n     (forall ca : nat, ~ In (a1, ca) l0) ->\n     In (a1, 1) (add_frequency_list a1 l0)) ->\n    forall a1 : A,\n    (forall ca : nat, ~ In (a1, ca) (a0 :: l0)) ->\n    In (a1, 1) (add_frequency_list a1 (a0 :: l0))) l a)"]}, {"text": "intros (a1, l1) l0 H a H0.", "goal_before": ["forall (a : A * nat) (l : list (A * nat)),\n(forall a0 : A,\n (forall ca : nat, ~ In (a0, ca) l) -> In (a0, 1) (add_frequency_list a0 l)) ->\nforall a0 : A,\n(forall ca : nat, ~ (a = (a0, ca) \\/ In (a0, ca) l)) ->\nIn (a0, 1)\n  (let (b, n) := a in\n   if eqA_dec a0 b then (a0, S n) :: l else (b, n) :: add_frequency_list a0 l)"], "goal_after": ["In (a, 1)\n  (if eqA_dec a a1\n   then (a, S l1) :: l0\n   else (a1, l1) :: add_frequency_list a l0)"], "proof_term_before": ["(fun (a : A) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) l0) ->\n    In (a0, 1) (add_frequency_list a0 l0))\n   ((fun (a0 : A) (_ : nat -> ~ False) => or_introl eq_refl)\n    :\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) nil) ->\n    In (a0, 1) (add_frequency_list a0 nil))\n   (?Goal\n    :\n    forall (a0 : A * nat) (l0 : list (A * nat)),\n    (forall a1 : A,\n     (forall ca : nat, ~ In (a1, ca) l0) ->\n     In (a1, 1) (add_frequency_list a1 l0)) ->\n    forall a1 : A,\n    (forall ca : nat, ~ In (a1, ca) (a0 :: l0)) ->\n    In (a1, 1) (add_frequency_list a1 (a0 :: l0))) l a)"], "proof_term_after": ["(fun (a : A) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) l0) ->\n    In (a0, 1) (add_frequency_list a0 l0))\n   ((fun (a0 : A) (_ : nat -> ~ False) => or_introl eq_refl)\n    :\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) nil) ->\n    In (a0, 1) (add_frequency_list a0 nil))\n   ((fun a0 : A * nat =>\n     let\n       (a1, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (forall a1 : A,\n            (forall ca : nat, ~ In (a1, ca) l0) ->\n            In (a1, 1) (add_frequency_list a1 l0)) ->\n           forall a1 : A,\n           (forall ca : nat, ~ (p = (a1, ca) \\/ In (a1, ca) l0)) ->\n           In (a1, 1)\n             (let (b, n) := p in\n              if eqA_dec a1 b\n              then (a1, S n) :: l0\n              else (b, n) :: add_frequency_list a1 l0)) := a0 in\n     (fun (a2 : A) (l1 : nat) (l0 : list (A * nat))\n        (H : forall a3 : A,\n             (forall ca : nat, ~ In (a3, ca) l0) ->\n             In (a3, 1) (add_frequency_list a3 l0)) \n        (a3 : A)\n        (H0 : forall ca : nat, ~ ((a2, l1) = (a3, ca) \\/ In (a3, ca) l0)) =>\n      ?Goal@{a1:=a2; a:=a3}) a1 b)\n    :\n    forall (a0 : A * nat) (l0 : list (A * nat)),\n    (forall a1 : A,\n     (forall ca : nat, ~ In (a1, ca) l0) ->\n     In (a1, 1) (add_frequency_list a1 l0)) ->\n    forall a1 : A,\n    (forall ca : nat, ~ In (a1, ca) (a0 :: l0)) ->\n    In (a1, 1) (add_frequency_list a1 (a0 :: l0))) l a)"]}, {"text": "case (eqA_dec a a1); auto.", "goal_before": ["In (a, 1)\n  (if eqA_dec a a1\n   then (a, S l1) :: l0\n   else (a1, l1) :: add_frequency_list a l0)"], "goal_after": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "proof_term_before": ["(fun (a : A) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) l0) ->\n    In (a0, 1) (add_frequency_list a0 l0))\n   ((fun (a0 : A) (_ : nat -> ~ False) => or_introl eq_refl)\n    :\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) nil) ->\n    In (a0, 1) (add_frequency_list a0 nil))\n   ((fun a0 : A * nat =>\n     let\n       (a1, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (forall a1 : A,\n            (forall ca : nat, ~ In (a1, ca) l0) ->\n            In (a1, 1) (add_frequency_list a1 l0)) ->\n           forall a1 : A,\n           (forall ca : nat, ~ (p = (a1, ca) \\/ In (a1, ca) l0)) ->\n           In (a1, 1)\n             (let (b, n) := p in\n              if eqA_dec a1 b\n              then (a1, S n) :: l0\n              else (b, n) :: add_frequency_list a1 l0)) := a0 in\n     (fun (a2 : A) (l1 : nat) (l0 : list (A * nat))\n        (H : forall a3 : A,\n             (forall ca : nat, ~ In (a3, ca) l0) ->\n             In (a3, 1) (add_frequency_list a3 l0)) \n        (a3 : A)\n        (H0 : forall ca : nat, ~ ((a2, l1) = (a3, ca) \\/ In (a3, ca) l0)) =>\n      ?Goal@{a1:=a2; a:=a3}) a1 b)\n    :\n    forall (a0 : A * nat) (l0 : list (A * nat)),\n    (forall a1 : A,\n     (forall ca : nat, ~ In (a1, ca) l0) ->\n     In (a1, 1) (add_frequency_list a1 l0)) ->\n    forall a1 : A,\n    (forall ca : nat, ~ In (a1, ca) (a0 :: l0)) ->\n    In (a1, 1) (add_frequency_list a1 (a0 :: l0))) l a)"], "proof_term_after": ["(fun (a : A) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) l0) ->\n    In (a0, 1) (add_frequency_list a0 l0))\n   ((fun (a0 : A) (_ : nat -> ~ False) => or_introl eq_refl)\n    :\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) nil) ->\n    In (a0, 1) (add_frequency_list a0 nil))\n   ((fun a0 : A * nat =>\n     let\n       (a1, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (forall a1 : A,\n            (forall ca : nat, ~ In (a1, ca) l0) ->\n            In (a1, 1) (add_frequency_list a1 l0)) ->\n           forall a1 : A,\n           (forall ca : nat, ~ (p = (a1, ca) \\/ In (a1, ca) l0)) ->\n           In (a1, 1)\n             (let (b, n) := p in\n              if eqA_dec a1 b\n              then (a1, S n) :: l0\n              else (b, n) :: add_frequency_list a1 l0)) := a0 in\n     (fun (a2 : A) (l1 : nat) (l0 : list (A * nat))\n        (H : forall a3 : A,\n             (forall ca : nat, ~ In (a3, ca) l0) ->\n             In (a3, 1) (add_frequency_list a3 l0)) \n        (a3 : A)\n        (H0 : forall ca : nat, ~ ((a2, l1) = (a3, ca) \\/ In (a3, ca) l0)) =>\n      match\n        eqA_dec a3 a2 as s\n        return\n          (In (a3, 1)\n             (if s\n              then (a3, S l1) :: l0\n              else (a2, l1) :: add_frequency_list a3 l0))\n      with\n      | left a4 => ?Goal@{a1:=a2; a:=a3} a4\n      | right b0 => ?Goal0@{a1:=a2; a:=a3} b0\n      end) a1 b)\n    :\n    forall (a0 : A * nat) (l0 : list (A * nat)),\n    (forall a1 : A,\n     (forall ca : nat, ~ In (a1, ca) l0) ->\n     In (a1, 1) (add_frequency_list a1 l0)) ->\n    forall a1 : A,\n    (forall ca : nat, ~ In (a1, ca) (a0 :: l0)) ->\n    In (a1, 1) (add_frequency_list a1 (a0 :: l0))) l a)"]}, {"text": "intros H1; case (H0 l1); left;", "goal_before": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "goal_after": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "proof_term_before": ["(fun (a : A) (l : list (A * nat)) =>\n list_ind\n   (fun l0 : list (A * nat) =>\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) l0) ->\n    In (a0, 1) (add_frequency_list a0 l0))\n   ((fun (a0 : A) (_ : nat -> ~ False) => or_introl eq_refl)\n    :\n    forall a0 : A,\n    (forall ca : nat, ~ In (a0, ca) nil) ->\n    In (a0, 1) (add_frequency_list a0 nil))\n   ((fun a0 : A * nat =>\n     let\n       (a1, b) as p\n        return\n          (forall l0 : list (A * nat),\n           (forall a1 : A,\n            (forall ca : nat, ~ In (a1, ca) l0) ->\n            In (a1, 1) (add_frequency_list a1 l0)) ->\n           forall a1 : A,\n           (forall ca : nat, ~ (p = (a1, ca) \\/ In (a1, ca) l0)) ->\n           In (a1, 1)\n             (let (b, n) := p in\n              if eqA_dec a1 b\n              then (a1, S n) :: l0\n              else (b, n) :: add_frequency_list a1 l0)) := a0 in\n     (fun (a2 : A) (l1 : nat) (l0 : list (A * nat))\n        (H : forall a3 : A,\n             (forall ca : nat, ~ In (a3, ca) l0) ->\n             In (a3, 1) (add_frequency_list a3 l0)) \n        (a3 : A)\n        (H0 : forall ca : nat, ~ ((a2, l1) = (a3, ca) \\/ In (a3, ca) l0)) =>\n      match\n        eqA_dec a3 a2 as s\n        return\n          (In (a3, 1)\n             (if s\n              then (a3, S l1) :: l0\n              else (a2, l1) :: add_frequency_list a3 l0))\n      with\n      | left a4 => ?Goal@{a1:=a2; a:=a3} a4\n      | right b0 => ?Goal0@{a1:=a2; a:=a3} b0\n      end) a1 b)\n    :\n    forall (a0 : A * nat) (l0 : list (A * nat)),\n    (forall a1 : A,\n     (forall ca : nat, ~ In (a1, ca) l0) ->\n     In (a1, 1) (add_frequency_list a1 l0)) ->\n    forall a1 : A,\n    (forall ca : nat, ~ In (a1, ca) (a0 :: l0)) ->\n    In (a1, 1) (add_frequency_list a1 (a0 :: l0))) l a)"], "proof_term_after": []}, {"text": "apply f_equal2 with (f := pair (A:=A) (B:=nat)); auto.", "goal_before": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "goal_after": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n; apply in_cons; auto; apply H; auto.", "goal_before": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "goal_after": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros ca; red in |- *; intros H1; case (H0 ca); auto.", "goal_before": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "goal_after": ["a = a1 -> In (a, 1) ((a, S l1) :: l0)", "a <> a1 -> In (a, 1) ((a1, l1) :: add_frequency_list a l0)"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "add_frequency_list_in", "text": "Theorem add_frequency_list_in :\n forall m a n,\n unique_key m -> In (a, n) m -> In (a, S n) (add_frequency_list a m).\nProof using.\nintros m; elim m; clear m; simpl in |- *; auto.\nintros (a1, l1) l Rec a n H H1; case (eqA_dec a a1); simpl in |- *; auto.\nintros H2; case H1; auto.\nintros H3; left; apply f_equal2 with (f := pair (A:=A) (B:=nat));\n injection H3; auto.\nrewrite H2; intros H3; case unique_key_in with (1 := H) (b2 := n); auto.\nintros n0; right; apply Rec.\napply unique_key_inv with (1 := H); auto.\ncase H1; auto.\nintros H0; case n0; injection H0; auto.\nQed.\n", "definition": "\n forall m a n,\n unique_key m -> In (a, n) m -> In (a, S n) (add_frequency_list a m).", "proof": "\nProof using.\nintros m; elim m; clear m; simpl in |- *; auto.\nintros (a1, l1) l Rec a n H H1; case (eqA_dec a a1); simpl in |- *; auto.\nintros H2; case H1; auto.\nintros H3; left; apply f_equal2 with (f := pair (A:=A) (B:=nat));\n injection H3; auto.\nrewrite H2; intros H3; case unique_key_in with (1 := H) (b2 := n); auto.\nintros n0; right; apply Rec.\napply unique_key_inv with (1 := H); auto.\ncase H1; auto.\nintros H0; case n0; injection H0; auto.\n", "def_ranges": [132, 0, 134, 69], "proof_ranges": [135, 0, 146, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m; elim m; clear m; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (a1, l1) l Rec a n H H1; case (eqA_dec a a1); simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H2; case H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H3; left; apply f_equal2 with (f := pair (A:=A) (B:=nat));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H2; intros H3; case unique_key_in with (1 := H) (b2 := n); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n0; right; apply Rec.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_inv with (1 := H); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H0; case n0; injection H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "add_frequency_list_not_in", "text": "Theorem add_frequency_list_not_in :\n forall m a b n, a <> b -> In (a, n) m -> In (a, n) (add_frequency_list b m).\nProof using.\nintros m; elim m; clear m; simpl in |- *; auto.\nintros (a1, l1) l H a0 b n H0 [H1| H1]; case (eqA_dec b a1); simpl in |- *;\n auto.\nintros H2; case H0; injection H1; auto.\nintros; apply trans_equal with (2 := sym_equal H2); auto.\nQed.\n", "definition": "\n forall m a b n, a <> b -> In (a, n) m -> In (a, n) (add_frequency_list b m).", "proof": "\nProof using.\nintros m; elim m; clear m; simpl in |- *; auto.\nintros (a1, l1) l H a0 b n H0 [H1| H1]; case (eqA_dec b a1); simpl in |- *;\n auto.\nintros H2; case H0; injection H1; auto.\nintros; apply trans_equal with (2 := sym_equal H2); auto.\n", "def_ranges": [149, 0, 150, 77], "proof_ranges": [151, 0, 157, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (m : list (A * nat)) (a b : A) (n : nat),\na <> b -> In (a, n) m -> In (a, n) (add_frequency_list b m)"], "goal_after": ["forall (m : list (A * nat)) (a b : A) (n : nat),\na <> b -> In (a, n) m -> In (a, n) (add_frequency_list b m)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros m; elim m; clear m; simpl in |- *; auto.", "goal_before": ["forall (m : list (A * nat)) (a b : A) (n : nat),\na <> b -> In (a, n) m -> In (a, n) (add_frequency_list b m)"], "goal_after": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun m : list (A * nat) =>\n list_ind\n   (fun m0 : list (A * nat) =>\n    forall (a b : A) (n : nat),\n    a <> b -> In (a, n) m0 -> In (a, n) (add_frequency_list b m0))\n   ((fun (a b : A) (n : nat) (_ : a <> b) (H0 : False) => or_intror H0)\n    :\n    forall (a b : A) (n : nat),\n    a <> b -> In (a, n) nil -> In (a, n) (add_frequency_list b nil))\n   (?Goal\n    :\n    forall (a : A * nat) (l : list (A * nat)),\n    (forall (a0 b : A) (n : nat),\n     a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\n    forall (a0 b : A) (n : nat),\n    a0 <> b ->\n    In (a0, n) (a :: l) -> In (a0, n) (add_frequency_list b (a :: l))) m)"]}, {"text": "intros (a1, l1) l H a0 b n H0 [H1| H1]; case (eqA_dec b a1); simpl in |- *;", "goal_before": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "goal_after": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "proof_term_before": ["(fun m : list (A * nat) =>\n list_ind\n   (fun m0 : list (A * nat) =>\n    forall (a b : A) (n : nat),\n    a <> b -> In (a, n) m0 -> In (a, n) (add_frequency_list b m0))\n   ((fun (a b : A) (n : nat) (_ : a <> b) (H0 : False) => or_intror H0)\n    :\n    forall (a b : A) (n : nat),\n    a <> b -> In (a, n) nil -> In (a, n) (add_frequency_list b nil))\n   (?Goal\n    :\n    forall (a : A * nat) (l : list (A * nat)),\n    (forall (a0 b : A) (n : nat),\n     a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\n    forall (a0 b : A) (n : nat),\n    a0 <> b ->\n    In (a0, n) (a :: l) -> In (a0, n) (add_frequency_list b (a :: l))) m)"], "proof_term_after": []}, {"text": "auto.", "goal_before": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "goal_after": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H2; case H0; injection H1; auto.", "goal_before": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "goal_after": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; apply trans_equal with (2 := sym_equal H2); auto.", "goal_before": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "goal_after": ["forall (a : A * nat) (l : list (A * nat)),\n(forall (a0 b : A) (n : nat),\n a0 <> b -> In (a0, n) l -> In (a0, n) (add_frequency_list b l)) ->\nforall (a0 b : A) (n : nat),\na0 <> b ->\na = (a0, n) \\/ In (a0, n) l ->\nIn (a0, n)\n  (let (b0, n0) := a in\n   if eqA_dec b b0\n   then (b, S n0) :: l\n   else (b0, n0) :: add_frequency_list b l)"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "frequency_list_in", "text": "Theorem frequency_list_in :\n forall a n m, In (a, n) (frequency_list m) -> In a m.\nProof using.\nintros a n m; generalize n; elim m; clear m n; simpl in |- *; auto.\nintros a0 l H n H0; case add_frequency_list_in_inv with (1 := H0); auto.\nintros H1; right; apply (H n); auto.\nQed.\n", "definition": "\n forall a n m, In (a, n) (frequency_list m) -> In a m.", "proof": "\nProof using.\nintros a n m; generalize n; elim m; clear m n; simpl in |- *; auto.\nintros a0 l H n H0; case add_frequency_list_in_inv with (1 := H0); auto.\nintros H1; right; apply (H n); auto.\n", "def_ranges": [167, 0, 168, 54], "proof_ranges": [169, 0, 173, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (n : nat) (m : list A), In (a, n) (frequency_list m) -> In a m"], "goal_after": ["forall (a : A) (n : nat) (m : list A), In (a, n) (frequency_list m) -> In a m"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a n m; generalize n; elim m; clear m n; simpl in |- *; auto.", "goal_before": ["forall (a : A) (n : nat) (m : list A), In (a, n) (frequency_list m) -> In a m"], "goal_after": ["forall (a0 : A) (l : list A),\n(forall n : nat, In (a, n) (frequency_list l) -> In a l) ->\nforall n : nat,\nIn (a, n) (add_frequency_list a0 (frequency_list l)) -> a0 = a \\/ In a l"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (n : nat) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall n0 : nat, In (a, n0) (frequency_list m0) -> In a m0)\n   ((fun (_ : nat) (H : False) => H)\n    :\n    forall n0 : nat, In (a, n0) (frequency_list nil) -> In a nil)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall n0 : nat, In (a, n0) (frequency_list l) -> In a l) ->\n    forall n0 : nat, In (a, n0) (frequency_list (a0 :: l)) -> In a (a0 :: l))\n   m n)"]}, {"text": "intros a0 l H n H0; case add_frequency_list_in_inv with (1 := H0); auto.", "goal_before": ["forall (a0 : A) (l : list A),\n(forall n : nat, In (a, n) (frequency_list l) -> In a l) ->\nforall n : nat,\nIn (a, n) (add_frequency_list a0 (frequency_list l)) -> a0 = a \\/ In a l"], "goal_after": ["In (a, n) (frequency_list l) -> a0 = a \\/ In a l"], "proof_term_before": ["(fun (a : A) (n : nat) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall n0 : nat, In (a, n0) (frequency_list m0) -> In a m0)\n   ((fun (_ : nat) (H : False) => H)\n    :\n    forall n0 : nat, In (a, n0) (frequency_list nil) -> In a nil)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall n0 : nat, In (a, n0) (frequency_list l) -> In a l) ->\n    forall n0 : nat, In (a, n0) (frequency_list (a0 :: l)) -> In a (a0 :: l))\n   m n)"], "proof_term_after": ["(fun (a : A) (n : nat) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall n0 : nat, In (a, n0) (frequency_list m0) -> In a m0)\n   ((fun (_ : nat) (H : False) => H)\n    :\n    forall n0 : nat, In (a, n0) (frequency_list nil) -> In a nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall n0 : nat, In (a, n0) (frequency_list l) -> In a l)\n       (n0 : nat)\n       (H0 : In (a, n0) (add_frequency_list a0 (frequency_list l))) =>\n     match add_frequency_list_in_inv a a0 n0 (frequency_list l) H0 with\n     | or_introl x => (fun H1 : a = a0 => or_introl (eq_sym H1)) x\n     | or_intror x => ?Goal@{n:=n0} x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall n0 : nat, In (a, n0) (frequency_list l) -> In a l) ->\n    forall n0 : nat, In (a, n0) (frequency_list (a0 :: l)) -> In a (a0 :: l))\n   m n)"]}, {"text": "intros H1; right; apply (H n); auto.", "goal_before": ["In (a, n) (frequency_list l) -> a0 = a \\/ In a l"], "goal_after": [], "proof_term_before": ["(fun (a : A) (n : nat) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall n0 : nat, In (a, n0) (frequency_list m0) -> In a m0)\n   ((fun (_ : nat) (H : False) => H)\n    :\n    forall n0 : nat, In (a, n0) (frequency_list nil) -> In a nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall n0 : nat, In (a, n0) (frequency_list l) -> In a l)\n       (n0 : nat)\n       (H0 : In (a, n0) (add_frequency_list a0 (frequency_list l))) =>\n     match add_frequency_list_in_inv a a0 n0 (frequency_list l) H0 with\n     | or_introl x => (fun H1 : a = a0 => or_introl (eq_sym H1)) x\n     | or_intror x => ?Goal@{n:=n0} x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall n0 : nat, In (a, n0) (frequency_list l) -> In a l) ->\n    forall n0 : nat, In (a, n0) (frequency_list (a0 :: l)) -> In a (a0 :: l))\n   m n)"], "proof_term_after": ["(fun (a : A) (n : nat) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall n0 : nat, In (a, n0) (frequency_list m0) -> In a m0)\n   ((fun (_ : nat) (H : False) => H)\n    :\n    forall n0 : nat, In (a, n0) (frequency_list nil) -> In a nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall n0 : nat, In (a, n0) (frequency_list l) -> In a l)\n       (n0 : nat)\n       (H0 : In (a, n0) (add_frequency_list a0 (frequency_list l))) =>\n     match add_frequency_list_in_inv a a0 n0 (frequency_list l) H0 with\n     | or_introl x => (fun H1 : a = a0 => or_introl (eq_sym H1)) x\n     | or_intror x =>\n         (fun H1 : In (a, n0) (frequency_list l) => or_intror (H n0 H1)) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall n0 : nat, In (a, n0) (frequency_list l) -> In a l) ->\n    forall n0 : nat, In (a, n0) (frequency_list (a0 :: l)) -> In a (a0 :: l))\n   m n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (n : nat) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall n0 : nat, In (a, n0) (frequency_list m0) -> In a m0)\n   ((fun (_ : nat) (H : False) => H)\n    :\n    forall n0 : nat, In (a, n0) (frequency_list nil) -> In a nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall n0 : nat, In (a, n0) (frequency_list l) -> In a l)\n       (n0 : nat)\n       (H0 : In (a, n0) (add_frequency_list a0 (frequency_list l))) =>\n     match add_frequency_list_in_inv a a0 n0 (frequency_list l) H0 with\n     | or_introl x => (fun H1 : a = a0 => or_introl (eq_sym H1)) x\n     | or_intror x =>\n         (fun H1 : In (a, n0) (frequency_list l) => or_intror (H n0 H1)) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall n0 : nat, In (a, n0) (frequency_list l) -> In a l) ->\n    forall n0 : nat, In (a, n0) (frequency_list (a0 :: l)) -> In a (a0 :: l))\n   m n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "frequency_list_perm", "text": "Theorem frequency_list_perm :\n forall l : list A,\n permutation l\n   (flat_map (fun p => id_list (fst p) (snd p)) (frequency_list l)).\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H.\napply\n permutation_trans with (2 := add_frequency_list_perm a (frequency_list l0));\n auto.\nQed.\n", "definition": "\n forall l : list A,\n permutation l\n   (flat_map (fun p => id_list (fst p) (snd p)) (frequency_list l)).", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H.\napply\n permutation_trans with (2 := add_frequency_list_perm a (frequency_list l0));\n auto.\n", "def_ranges": [176, 0, 179, 68], "proof_ranges": [180, 0, 186, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l0 H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "permutation_trans with (2 := add_frequency_list_perm a (frequency_list l0));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "frequency_list_unique", "text": "Theorem frequency_list_unique :\n forall l : list A, unique_key (frequency_list l).\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H; apply add_frequency_list_unique_key; auto.\nQed.\n", "definition": "\n forall l : list A, unique_key (frequency_list l).", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H; apply add_frequency_list_unique_key; auto.\n", "def_ranges": [188, 0, 189, 50], "proof_ranges": [190, 0, 193, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l0 H; apply add_frequency_list_unique_key; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "in_frequency_map", "text": "Theorem in_frequency_map :\n forall l a, In a l -> In a (map fst (frequency_list l)).\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H a0 [H0| H0]; auto.\nrewrite H0; elim (frequency_list l0); simpl in |- *; auto.\nintros (a1, l1) l2; simpl in |- *; auto.\ncase (eqA_dec a0 a1); simpl in |- *; auto.\ncut (In a0 (map (fst (A:=A) (B:=nat)) (frequency_list l0))); auto.\nelim (frequency_list l0); simpl in |- *; auto.\nintros (a1, l1) l2; simpl in |- *; auto.\ncase (eqA_dec a a1); simpl in |- *; auto.\nintros e H1 [H2| H2]; auto; left; rewrite <- H2; auto.\nintros e H1 [H2| H2]; auto.\nQed.\n", "definition": "\n forall l a, In a l -> In a (map fst (frequency_list l)).", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H a0 [H0| H0]; auto.\nrewrite H0; elim (frequency_list l0); simpl in |- *; auto.\nintros (a1, l1) l2; simpl in |- *; auto.\ncase (eqA_dec a0 a1); simpl in |- *; auto.\ncut (In a0 (map (fst (A:=A) (B:=nat)) (frequency_list l0))); auto.\nelim (frequency_list l0); simpl in |- *; auto.\nintros (a1, l1) l2; simpl in |- *; auto.\ncase (eqA_dec a a1); simpl in |- *; auto.\nintros e H1 [H2| H2]; auto; left; rewrite <- H2; auto.\nintros e H1 [H2| H2]; auto.\n", "def_ranges": [197, 0, 198, 57], "proof_ranges": [199, 0, 211, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l : list A) (a : A), In a l -> In a (map fst (frequency_list l))"], "goal_after": ["forall (l : list A) (a : A), In a l -> In a (map fst (frequency_list l))"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall (l : list A) (a : A), In a l -> In a (map fst (frequency_list l))"], "goal_after": ["forall (a : A) (l0 : list A),\n(forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\nforall a0 : A,\na = a0 \\/ In a0 l0 ->\nIn a0 (map fst (add_frequency_list a (frequency_list l0)))"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "intros a l0 H a0 [H0| H0]; auto.", "goal_before": ["forall (a : A) (l0 : list A),\n(forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\nforall a0 : A,\na = a0 \\/ In a0 l0 ->\nIn a0 (map fst (add_frequency_list a (frequency_list l0)))"], "goal_after": ["In a0 (map fst (add_frequency_list a (frequency_list l0)))", "In a0 (map fst (add_frequency_list a (frequency_list l0)))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x => (fun H0 : a = a0 => ?Goal) x\n     | or_intror x => (fun H0 : In a0 l0 => ?Goal0) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "rewrite H0; elim (frequency_list l0); simpl in |- *; auto.", "goal_before": ["In a0 (map fst (add_frequency_list a (frequency_list l0)))", "In a0 (map fst (add_frequency_list a (frequency_list l0)))"], "goal_after": ["forall (a1 : A * nat) (l1 : list (A * nat)),\nIn a0 (map fst (add_frequency_list a0 l1)) ->\nIn a0\n  (map fst\n     (let (b, n) := a1 in\n      if eqA_dec a0 b\n      then (a0, S n) :: l1\n      else (b, n) :: add_frequency_list a0 l1))", "In a0 (map fst (add_frequency_list a (frequency_list l0)))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x => (fun H0 : a = a0 => ?Goal) x\n     | or_intror x => (fun H0 : In a0 l0 => ?Goal0) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               (?Goal0\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x => (fun H0 : In a0 l0 => ?Goal) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "intros (a1, l1) l2; simpl in |- *; auto.", "goal_before": ["forall (a1 : A * nat) (l1 : list (A * nat)),\nIn a0 (map fst (add_frequency_list a0 l1)) ->\nIn a0\n  (map fst\n     (let (b, n) := a1 in\n      if eqA_dec a0 b\n      then (a0, S n) :: l1\n      else (b, n) :: add_frequency_list a0 l1))", "In a0 (map fst (add_frequency_list a (frequency_list l0)))"], "goal_after": ["In a0 (map fst (add_frequency_list a0 l2)) ->\nIn a0\n  (map fst\n     (if eqA_dec a0 a1\n      then (a0, S l1) :: l2\n      else (a1, l1) :: add_frequency_list a0 l2))", "In a0 (map fst (add_frequency_list a (frequency_list l0)))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               (?Goal0\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x => (fun H0 : In a0 l0 => ?Goal) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  ?Goal0@{a1:=a3}\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x => (fun H0 : In a0 l0 => ?Goal) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "case (eqA_dec a0 a1); simpl in |- *; auto.", "goal_before": ["In a0 (map fst (add_frequency_list a0 l2)) ->\nIn a0\n  (map fst\n     (if eqA_dec a0 a1\n      then (a0, S l1) :: l2\n      else (a1, l1) :: add_frequency_list a0 l2))", "In a0 (map fst (add_frequency_list a (frequency_list l0)))"], "goal_after": ["In a0 (map fst (add_frequency_list a (frequency_list l0)))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  ?Goal0@{a1:=a3}\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x => (fun H0 : In a0 l0 => ?Goal) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x => (fun H0 : In a0 l0 => ?Goal) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "cut (In a0 (map (fst (A:=A) (B:=nat)) (frequency_list l0))); auto.", "goal_before": ["In a0 (map fst (add_frequency_list a (frequency_list l0)))"], "goal_after": ["In a0 (map fst (frequency_list l0)) ->\nIn a0 (map fst (add_frequency_list a (frequency_list l0)))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x => (fun H0 : In a0 l0 => ?Goal) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in ?Goal H2)\n           x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "elim (frequency_list l0); simpl in |- *; auto.", "goal_before": ["In a0 (map fst (frequency_list l0)) ->\nIn a0 (map fst (add_frequency_list a (frequency_list l0)))"], "goal_after": ["forall (a1 : A * nat) (l1 : list (A * nat)),\n(In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\nfst a1 = a0 \\/ In a0 (map fst l1) ->\nIn a0\n  (map fst\n     (let (b, n) := a1 in\n      if eqA_dec a b\n      then (a, S n) :: l1\n      else (b, n) :: add_frequency_list a l1))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in ?Goal H2)\n           x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            (?Goal\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "intros (a1, l1) l2; simpl in |- *; auto.", "goal_before": ["forall (a1 : A * nat) (l1 : list (A * nat)),\n(In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\nfst a1 = a0 \\/ In a0 (map fst l1) ->\nIn a0\n  (map fst\n     (let (b, n) := a1 in\n      if eqA_dec a b\n      then (a, S n) :: l1\n      else (b, n) :: add_frequency_list a l1))"], "goal_after": ["(In a0 (map fst l2) -> In a0 (map fst (add_frequency_list a l2))) ->\na1 = a0 \\/ In a0 (map fst l2) ->\nIn a0\n  (map fst\n     (if eqA_dec a a1\n      then (a, S l1) :: l2\n      else (a1, l1) :: add_frequency_list a l2))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            (?Goal\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            ((fun a2 : A * nat =>\n              let\n                (a1, b) as p\n                 return\n                   (forall l1 : list (A * nat),\n                    (In a0 (map fst l1) ->\n                     In a0 (map fst (add_frequency_list a l1))) ->\n                    fst p = a0 \\/ In a0 (map fst l1) ->\n                    In a0\n                      (map fst\n                         (let (b, n) := p in\n                          if eqA_dec a b\n                          then (a, S n) :: l1\n                          else (b, n) :: add_frequency_list a l1))) := a2 in\n              (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n               ?Goal@{a1:=a3}\n               :\n               (In a0 (map fst l2) ->\n                In a0 (map fst (add_frequency_list a l2))) ->\n               fst (a3, l1) = a0 \\/ In a0 (map fst l2) ->\n               In a0\n                 (map fst\n                    (if eqA_dec a a3\n                     then (a, S l1) :: l2\n                     else (a3, l1) :: add_frequency_list a l2))) a1 b)\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "case (eqA_dec a a1); simpl in |- *; auto.", "goal_before": ["(In a0 (map fst l2) -> In a0 (map fst (add_frequency_list a l2))) ->\na1 = a0 \\/ In a0 (map fst l2) ->\nIn a0\n  (map fst\n     (if eqA_dec a a1\n      then (a, S l1) :: l2\n      else (a1, l1) :: add_frequency_list a l2))"], "goal_after": ["a = a1 ->\n(In a0 (map fst l2) -> In a0 (map fst (add_frequency_list a l2))) ->\na1 = a0 \\/ In a0 (map fst l2) -> a = a0 \\/ In a0 (map fst l2)", "a <> a1 ->\n(In a0 (map fst l2) -> In a0 (map fst (add_frequency_list a l2))) ->\na1 = a0 \\/ In a0 (map fst l2) ->\na1 = a0 \\/ In a0 (map fst (add_frequency_list a l2))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            ((fun a2 : A * nat =>\n              let\n                (a1, b) as p\n                 return\n                   (forall l1 : list (A * nat),\n                    (In a0 (map fst l1) ->\n                     In a0 (map fst (add_frequency_list a l1))) ->\n                    fst p = a0 \\/ In a0 (map fst l1) ->\n                    In a0\n                      (map fst\n                         (let (b, n) := p in\n                          if eqA_dec a b\n                          then (a, S n) :: l1\n                          else (b, n) :: add_frequency_list a l1))) := a2 in\n              (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n               ?Goal@{a1:=a3}\n               :\n               (In a0 (map fst l2) ->\n                In a0 (map fst (add_frequency_list a l2))) ->\n               fst (a3, l1) = a0 \\/ In a0 (map fst l2) ->\n               In a0\n                 (map fst\n                    (if eqA_dec a a3\n                     then (a, S l1) :: l2\n                     else (a3, l1) :: add_frequency_list a l2))) a1 b)\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            ((fun a2 : A * nat =>\n              let\n                (a1, b) as p\n                 return\n                   (forall l1 : list (A * nat),\n                    (In a0 (map fst l1) ->\n                     In a0 (map fst (add_frequency_list a l1))) ->\n                    fst p = a0 \\/ In a0 (map fst l1) ->\n                    In a0\n                      (map fst\n                         (let (b, n) := p in\n                          if eqA_dec a b\n                          then (a, S n) :: l1\n                          else (b, n) :: add_frequency_list a l1))) := a2 in\n              (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n               match\n                 eqA_dec a a3 as s\n                 return\n                   ((In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0\n                      (map fst\n                         (if s\n                          then (a, S l1) :: l2\n                          else (a3, l1) :: add_frequency_list a l2)))\n               with\n               | left a4 =>\n                   (?Goal@{a1:=a3}\n                    :\n                    a = a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a, S l1) :: l2))) a4\n               | right b0 =>\n                   (?Goal0@{a1:=a3}\n                    :\n                    a <> a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a3, l1) :: add_frequency_list a l2))) b0\n               end\n               :\n               (In a0 (map fst l2) ->\n                In a0 (map fst (add_frequency_list a l2))) ->\n               fst (a3, l1) = a0 \\/ In a0 (map fst l2) ->\n               In a0\n                 (map fst\n                    (if eqA_dec a a3\n                     then (a, S l1) :: l2\n                     else (a3, l1) :: add_frequency_list a l2))) a1 b)\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "intros e H1 [H2| H2]; auto; left; rewrite <- H2; auto.", "goal_before": ["a = a1 ->\n(In a0 (map fst l2) -> In a0 (map fst (add_frequency_list a l2))) ->\na1 = a0 \\/ In a0 (map fst l2) -> a = a0 \\/ In a0 (map fst l2)", "a <> a1 ->\n(In a0 (map fst l2) -> In a0 (map fst (add_frequency_list a l2))) ->\na1 = a0 \\/ In a0 (map fst l2) ->\na1 = a0 \\/ In a0 (map fst (add_frequency_list a l2))"], "goal_after": ["a <> a1 ->\n(In a0 (map fst l2) -> In a0 (map fst (add_frequency_list a l2))) ->\na1 = a0 \\/ In a0 (map fst l2) ->\na1 = a0 \\/ In a0 (map fst (add_frequency_list a l2))"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            ((fun a2 : A * nat =>\n              let\n                (a1, b) as p\n                 return\n                   (forall l1 : list (A * nat),\n                    (In a0 (map fst l1) ->\n                     In a0 (map fst (add_frequency_list a l1))) ->\n                    fst p = a0 \\/ In a0 (map fst l1) ->\n                    In a0\n                      (map fst\n                         (let (b, n) := p in\n                          if eqA_dec a b\n                          then (a, S n) :: l1\n                          else (b, n) :: add_frequency_list a l1))) := a2 in\n              (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n               match\n                 eqA_dec a a3 as s\n                 return\n                   ((In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0\n                      (map fst\n                         (if s\n                          then (a, S l1) :: l2\n                          else (a3, l1) :: add_frequency_list a l2)))\n               with\n               | left a4 =>\n                   (?Goal@{a1:=a3}\n                    :\n                    a = a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a, S l1) :: l2))) a4\n               | right b0 =>\n                   (?Goal0@{a1:=a3}\n                    :\n                    a <> a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a3, l1) :: add_frequency_list a l2))) b0\n               end\n               :\n               (In a0 (map fst l2) ->\n                In a0 (map fst (add_frequency_list a l2))) ->\n               fst (a3, l1) = a0 \\/ In a0 (map fst l2) ->\n               In a0\n                 (map fst\n                    (if eqA_dec a a3\n                     then (a, S l1) :: l2\n                     else (a3, l1) :: add_frequency_list a l2))) a1 b)\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            ((fun a2 : A * nat =>\n              let\n                (a1, b) as p\n                 return\n                   (forall l1 : list (A * nat),\n                    (In a0 (map fst l1) ->\n                     In a0 (map fst (add_frequency_list a l1))) ->\n                    fst p = a0 \\/ In a0 (map fst l1) ->\n                    In a0\n                      (map fst\n                         (let (b, n) := p in\n                          if eqA_dec a b\n                          then (a, S n) :: l1\n                          else (b, n) :: add_frequency_list a l1))) := a2 in\n              (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n               match\n                 eqA_dec a a3 as s\n                 return\n                   ((In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0\n                      (map fst\n                         (if s\n                          then (a, S l1) :: l2\n                          else (a3, l1) :: add_frequency_list a l2)))\n               with\n               | left a4 =>\n                   ((fun (e : a = a3)\n                       (_ : In a0 (map fst l2) ->\n                            In a0 (map fst (add_frequency_list a l2)))\n                       (H4 : a3 = a0 \\/ In a0 (map fst l2)) =>\n                     match H4 with\n                     | or_introl x0 =>\n                         (fun H5 : a3 = a0 =>\n                          or_introl\n                            (eq_ind a3 (fun a5 : A => a = a5) e a0 H5)) x0\n                     | or_intror x0 =>\n                         (fun H5 : In a0 (map fst l2) => or_intror H5) x0\n                     end)\n                    :\n                    a = a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a, S l1) :: l2))) a4\n               | right b0 =>\n                   (?Goal@{a1:=a3}\n                    :\n                    a <> a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a3, l1) :: add_frequency_list a l2))) b0\n               end\n               :\n               (In a0 (map fst l2) ->\n                In a0 (map fst (add_frequency_list a l2))) ->\n               fst (a3, l1) = a0 \\/ In a0 (map fst l2) ->\n               In a0\n                 (map fst\n                    (if eqA_dec a a3\n                     then (a, S l1) :: l2\n                     else (a3, l1) :: add_frequency_list a l2))) a1 b)\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "intros e H1 [H2| H2]; auto.", "goal_before": ["a <> a1 ->\n(In a0 (map fst l2) -> In a0 (map fst (add_frequency_list a l2))) ->\na1 = a0 \\/ In a0 (map fst l2) ->\na1 = a0 \\/ In a0 (map fst (add_frequency_list a l2))"], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            ((fun a2 : A * nat =>\n              let\n                (a1, b) as p\n                 return\n                   (forall l1 : list (A * nat),\n                    (In a0 (map fst l1) ->\n                     In a0 (map fst (add_frequency_list a l1))) ->\n                    fst p = a0 \\/ In a0 (map fst l1) ->\n                    In a0\n                      (map fst\n                         (let (b, n) := p in\n                          if eqA_dec a b\n                          then (a, S n) :: l1\n                          else (b, n) :: add_frequency_list a l1))) := a2 in\n              (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n               match\n                 eqA_dec a a3 as s\n                 return\n                   ((In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0\n                      (map fst\n                         (if s\n                          then (a, S l1) :: l2\n                          else (a3, l1) :: add_frequency_list a l2)))\n               with\n               | left a4 =>\n                   ((fun (e : a = a3)\n                       (_ : In a0 (map fst l2) ->\n                            In a0 (map fst (add_frequency_list a l2)))\n                       (H4 : a3 = a0 \\/ In a0 (map fst l2)) =>\n                     match H4 with\n                     | or_introl x0 =>\n                         (fun H5 : a3 = a0 =>\n                          or_introl\n                            (eq_ind a3 (fun a5 : A => a = a5) e a0 H5)) x0\n                     | or_intror x0 =>\n                         (fun H5 : In a0 (map fst l2) => or_intror H5) x0\n                     end)\n                    :\n                    a = a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a, S l1) :: l2))) a4\n               | right b0 =>\n                   (?Goal@{a1:=a3}\n                    :\n                    a <> a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a3, l1) :: add_frequency_list a l2))) b0\n               end\n               :\n               (In a0 (map fst l2) ->\n                In a0 (map fst (add_frequency_list a l2))) ->\n               fst (a3, l1) = a0 \\/ In a0 (map fst l2) ->\n               In a0\n                 (map fst\n                    (if eqA_dec a a3\n                     then (a, S l1) :: l2\n                     else (a3, l1) :: add_frequency_list a l2))) a1 b)\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            ((fun a2 : A * nat =>\n              let\n                (a1, b) as p\n                 return\n                   (forall l1 : list (A * nat),\n                    (In a0 (map fst l1) ->\n                     In a0 (map fst (add_frequency_list a l1))) ->\n                    fst p = a0 \\/ In a0 (map fst l1) ->\n                    In a0\n                      (map fst\n                         (let (b, n) := p in\n                          if eqA_dec a b\n                          then (a, S n) :: l1\n                          else (b, n) :: add_frequency_list a l1))) := a2 in\n              (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n               match\n                 eqA_dec a a3 as s\n                 return\n                   ((In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0\n                      (map fst\n                         (if s\n                          then (a, S l1) :: l2\n                          else (a3, l1) :: add_frequency_list a l2)))\n               with\n               | left a4 =>\n                   ((fun (e : a = a3)\n                       (_ : In a0 (map fst l2) ->\n                            In a0 (map fst (add_frequency_list a l2)))\n                       (H4 : a3 = a0 \\/ In a0 (map fst l2)) =>\n                     match H4 with\n                     | or_introl x0 =>\n                         (fun H5 : a3 = a0 =>\n                          or_introl\n                            (eq_ind a3 (fun a5 : A => a = a5) e a0 H5)) x0\n                     | or_intror x0 =>\n                         (fun H5 : In a0 (map fst l2) => or_intror H5) x0\n                     end)\n                    :\n                    a = a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a, S l1) :: l2))) a4\n               | right b0 =>\n                   ((fun (_ : a <> a3)\n                       (H3 : In a0 (map fst l2) ->\n                             In a0 (map fst (add_frequency_list a l2)))\n                       (H4 : a3 = a0 \\/ In a0 (map fst l2)) =>\n                     match H4 with\n                     | or_introl x0 => (fun H5 : a3 = a0 => or_introl H5) x0\n                     | or_intror x0 =>\n                         (fun H5 : In a0 (map fst l2) => or_intror (H3 H5))\n                           x0\n                     end)\n                    :\n                    a <> a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a3, l1) :: add_frequency_list a l2))) b0\n               end\n               :\n               (In a0 (map fst l2) ->\n                In a0 (map fst (add_frequency_list a l2))) ->\n               fst (a3, l1) = a0 \\/ In a0 (map fst l2) ->\n               In a0\n                 (map fst\n                    (if eqA_dec a a3\n                     then (a, S l1) :: l2\n                     else (a3, l1) :: add_frequency_list a l2))) a1 b)\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall a : A, In a l0 -> In a (map fst (frequency_list l0)))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a : A, In a nil -> In a (map fst (frequency_list nil)))\n   ((fun (a : A) (l0 : list A)\n       (H : forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0)))\n       (a0 : A) (H1 : a = a0 \\/ In a0 l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a = a0 =>\n          eq_ind_r\n            (fun a1 : A =>\n             In a0 (map fst (add_frequency_list a1 (frequency_list l0))))\n            (list_ind\n               (fun l1 : list (A * nat) =>\n                In a0 (map fst (add_frequency_list a0 l1)))\n               (or_introl eq_refl\n                :\n                In a0 (map fst (add_frequency_list a0 nil)))\n               ((fun a2 : A * nat =>\n                 let\n                   (a1, b) as p\n                    return\n                      (forall l1 : list (A * nat),\n                       In a0 (map fst (add_frequency_list a0 l1)) ->\n                       In a0\n                         (map fst\n                            (let (b, n) := p in\n                             if eqA_dec a0 b\n                             then (a0, S n) :: l1\n                             else (b, n) :: add_frequency_list a0 l1))) :=\n                   a2 in\n                 (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n                  match\n                    eqA_dec a0 a3 as s\n                    return\n                      (In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0\n                         (map fst\n                            (if s\n                             then (a0, S l1) :: l2\n                             else (a3, l1) :: add_frequency_list a0 l2)))\n                  with\n                  | left a4 =>\n                      ((fun (_ : a0 = a3)\n                          (_ : In a0 (map fst (add_frequency_list a0 l2))) =>\n                        or_introl eq_refl)\n                       :\n                       a0 = a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a0, S l1) :: l2))) a4\n                  | right b0 =>\n                      ((fun (_ : a0 <> a3)\n                          (H2 : In a0 (map fst (add_frequency_list a0 l2)))\n                        => or_intror H2)\n                       :\n                       a0 <> a3 ->\n                       In a0 (map fst (add_frequency_list a0 l2)) ->\n                       In a0 (map fst ((a3, l1) :: add_frequency_list a0 l2)))\n                        b0\n                  end\n                  :\n                  In a0 (map fst (add_frequency_list a0 l2)) ->\n                  In a0\n                    (map fst\n                       (if eqA_dec a0 a3\n                        then (a0, S l1) :: l2\n                        else (a3, l1) :: add_frequency_list a0 l2))) a1 b)\n                :\n                forall (a1 : A * nat) (l1 : list (A * nat)),\n                In a0 (map fst (add_frequency_list a0 l1)) ->\n                In a0 (map fst (add_frequency_list a0 (a1 :: l1))))\n               (frequency_list l0)) H0) x\n     | or_intror x =>\n         (fun H0 : In a0 l0 =>\n          let H2 : In a0 (map fst (frequency_list l0)) := H a0 H0 in\n          list_ind\n            (fun l1 : list (A * nat) =>\n             In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1)))\n            ((fun H3 : False => or_intror H3)\n             :\n             In a0 (map fst nil) ->\n             In a0 (map fst (add_frequency_list a nil)))\n            ((fun a2 : A * nat =>\n              let\n                (a1, b) as p\n                 return\n                   (forall l1 : list (A * nat),\n                    (In a0 (map fst l1) ->\n                     In a0 (map fst (add_frequency_list a l1))) ->\n                    fst p = a0 \\/ In a0 (map fst l1) ->\n                    In a0\n                      (map fst\n                         (let (b, n) := p in\n                          if eqA_dec a b\n                          then (a, S n) :: l1\n                          else (b, n) :: add_frequency_list a l1))) := a2 in\n              (fun (a3 : A) (l1 : nat) (l2 : list (A * nat)) =>\n               match\n                 eqA_dec a a3 as s\n                 return\n                   ((In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0\n                      (map fst\n                         (if s\n                          then (a, S l1) :: l2\n                          else (a3, l1) :: add_frequency_list a l2)))\n               with\n               | left a4 =>\n                   ((fun (e : a = a3)\n                       (_ : In a0 (map fst l2) ->\n                            In a0 (map fst (add_frequency_list a l2)))\n                       (H4 : a3 = a0 \\/ In a0 (map fst l2)) =>\n                     match H4 with\n                     | or_introl x0 =>\n                         (fun H5 : a3 = a0 =>\n                          or_introl\n                            (eq_ind a3 (fun a5 : A => a = a5) e a0 H5)) x0\n                     | or_intror x0 =>\n                         (fun H5 : In a0 (map fst l2) => or_intror H5) x0\n                     end)\n                    :\n                    a = a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a, S l1) :: l2))) a4\n               | right b0 =>\n                   ((fun (_ : a <> a3)\n                       (H3 : In a0 (map fst l2) ->\n                             In a0 (map fst (add_frequency_list a l2)))\n                       (H4 : a3 = a0 \\/ In a0 (map fst l2)) =>\n                     match H4 with\n                     | or_introl x0 => (fun H5 : a3 = a0 => or_introl H5) x0\n                     | or_intror x0 =>\n                         (fun H5 : In a0 (map fst l2) => or_intror (H3 H5))\n                           x0\n                     end)\n                    :\n                    a <> a3 ->\n                    (In a0 (map fst l2) ->\n                     In a0 (map fst (add_frequency_list a l2))) ->\n                    a3 = a0 \\/ In a0 (map fst l2) ->\n                    In a0 (map fst ((a3, l1) :: add_frequency_list a l2))) b0\n               end\n               :\n               (In a0 (map fst l2) ->\n                In a0 (map fst (add_frequency_list a l2))) ->\n               fst (a3, l1) = a0 \\/ In a0 (map fst l2) ->\n               In a0\n                 (map fst\n                    (if eqA_dec a a3\n                     then (a, S l1) :: l2\n                     else (a3, l1) :: add_frequency_list a l2))) a1 b)\n             :\n             forall (a1 : A * nat) (l1 : list (A * nat)),\n             (In a0 (map fst l1) -> In a0 (map fst (add_frequency_list a l1))) ->\n             In a0 (map fst (a1 :: l1)) ->\n             In a0 (map fst (add_frequency_list a (a1 :: l1))))\n            (frequency_list l0) H2) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (forall a0 : A, In a0 l0 -> In a0 (map fst (frequency_list l0))) ->\n    forall a0 : A,\n    In a0 (a :: l0) -> In a0 (map fst (frequency_list (a :: l0)))) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "in_frequency_map_inv", "text": "Theorem in_frequency_map_inv :\n forall l a, In a (map (fst (B:=_)) (frequency_list l)) -> In a l.\nProof using.\nintros l a H; case in_map_inv with (1 := H); auto.\nintros (a1, l1) (Hl1, Hl2); simpl in |- *.\nrewrite Hl2; apply frequency_list_in with (1 := Hl1).\nQed.\n", "definition": "\n forall l a, In a (map (fst (B:=_)) (frequency_list l)) -> In a l.", "proof": "\nProof using.\nintros l a H; case in_map_inv with (1 := H); auto.\nintros (a1, l1) (Hl1, Hl2); simpl in |- *.\nrewrite Hl2; apply frequency_list_in with (1 := Hl1).\n", "def_ranges": [215, 0, 216, 66], "proof_ranges": [217, 0, 221, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "goal_after": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l a H; case in_map_inv with (1 := H); auto.", "goal_before": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "goal_after": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "proof_term_before": ["?Goal"], "proof_term_after": ["?Goal"]}, {"text": "intros (a1, l1) (Hl1, Hl2); simpl in |- *.", "goal_before": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "goal_after": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "proof_term_before": ["?Goal"], "proof_term_after": ["?Goal"]}, {"text": "rewrite Hl2; apply frequency_list_in with (1 := Hl1).", "goal_before": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "goal_after": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "proof_term_before": ["?Goal"], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall (l : list A) (a : A), In a (map fst (frequency_list l)) -> In a l"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "number_of_occurrences_O", "text": "Theorem number_of_occurrences_O :\n forall a l, ~ In a l -> number_of_occurrences a l = 0.\nProof using.\nintros a l; elim l; simpl in |- *; auto.\nintros a0 l0 H H0; case (eqA_dec a a0); auto.\nintros H1; case H0; auto.\nQed.\n", "definition": "\n forall a l, ~ In a l -> number_of_occurrences a l = 0.", "proof": "\nProof using.\nintros a l; elim l; simpl in |- *; auto.\nintros a0 l0 H H0; case (eqA_dec a a0); auto.\nintros H1; case H0; auto.\n", "def_ranges": [235, 0, 236, 55], "proof_ranges": [237, 0, 241, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l : list A), ~ In a l -> number_of_occurrences a l = 0"], "goal_after": ["forall (a : A) (l : list A), ~ In a l -> number_of_occurrences a l = 0"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l; elim l; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l : list A), ~ In a l -> number_of_occurrences a l = 0"], "goal_after": ["forall (a0 : A) (l0 : list A),\n(~ In a l0 -> number_of_occurrences a l0 = 0) ->\n~ (a0 = a \\/ In a l0) ->\n(if eqA_dec a a0\n then S (number_of_occurrences a l0)\n else number_of_occurrences a l0) = 0"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind (fun l0 : list A => ~ In a l0 -> number_of_occurrences a l0 = 0)\n   ((fun _ : ~ False => eq_refl)\n    :\n    ~ In a nil -> number_of_occurrences a nil = 0)\n   (?Goal\n    :\n    forall (a0 : A) (l0 : list A),\n    (~ In a l0 -> number_of_occurrences a l0 = 0) ->\n    ~ In a (a0 :: l0) -> number_of_occurrences a (a0 :: l0) = 0) l)"]}, {"text": "intros a0 l0 H H0; case (eqA_dec a a0); auto.", "goal_before": ["forall (a0 : A) (l0 : list A),\n(~ In a l0 -> number_of_occurrences a l0 = 0) ->\n~ (a0 = a \\/ In a l0) ->\n(if eqA_dec a a0\n then S (number_of_occurrences a l0)\n else number_of_occurrences a l0) = 0"], "goal_after": ["a = a0 -> S (number_of_occurrences a l0) = 0"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind (fun l0 : list A => ~ In a l0 -> number_of_occurrences a l0 = 0)\n   ((fun _ : ~ False => eq_refl)\n    :\n    ~ In a nil -> number_of_occurrences a nil = 0)\n   (?Goal\n    :\n    forall (a0 : A) (l0 : list A),\n    (~ In a l0 -> number_of_occurrences a l0 = 0) ->\n    ~ In a (a0 :: l0) -> number_of_occurrences a (a0 :: l0) = 0) l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind (fun l0 : list A => ~ In a l0 -> number_of_occurrences a l0 = 0)\n   ((fun _ : ~ False => eq_refl)\n    :\n    ~ In a nil -> number_of_occurrences a nil = 0)\n   ((fun (a0 : A) (l0 : list A)\n       (H : ~ In a l0 -> number_of_occurrences a l0 = 0)\n       (H0 : ~ (a0 = a \\/ In a l0)) =>\n     match\n       eqA_dec a a0 as s\n       return\n         ((if s\n           then S (number_of_occurrences a l0)\n           else number_of_occurrences a l0) = 0)\n     with\n     | left a1 => ?Goal a1\n     | right b =>\n         (fun _ : a <> a0 =>\n          H ((fun H1 : In a l0 => H0 (or_intror H1)) : ~ In a l0)) b\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (~ In a l0 -> number_of_occurrences a l0 = 0) ->\n    ~ In a (a0 :: l0) -> number_of_occurrences a (a0 :: l0) = 0) l)"]}, {"text": "intros H1; case H0; auto.", "goal_before": ["a = a0 -> S (number_of_occurrences a l0) = 0"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind (fun l0 : list A => ~ In a l0 -> number_of_occurrences a l0 = 0)\n   ((fun _ : ~ False => eq_refl)\n    :\n    ~ In a nil -> number_of_occurrences a nil = 0)\n   ((fun (a0 : A) (l0 : list A)\n       (H : ~ In a l0 -> number_of_occurrences a l0 = 0)\n       (H0 : ~ (a0 = a \\/ In a l0)) =>\n     match\n       eqA_dec a a0 as s\n       return\n         ((if s\n           then S (number_of_occurrences a l0)\n           else number_of_occurrences a l0) = 0)\n     with\n     | left a1 => ?Goal a1\n     | right b =>\n         (fun _ : a <> a0 =>\n          H ((fun H1 : In a l0 => H0 (or_intror H1)) : ~ In a l0)) b\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (~ In a l0 -> number_of_occurrences a l0 = 0) ->\n    ~ In a (a0 :: l0) -> number_of_occurrences a (a0 :: l0) = 0) l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind (fun l0 : list A => ~ In a l0 -> number_of_occurrences a l0 = 0)\n   ((fun _ : ~ False => eq_refl)\n    :\n    ~ In a nil -> number_of_occurrences a nil = 0)\n   ((fun (a0 : A) (l0 : list A)\n       (H : ~ In a l0 -> number_of_occurrences a l0 = 0)\n       (H0 : ~ (a0 = a \\/ In a l0)) =>\n     match\n       eqA_dec a a0 as s\n       return\n         ((if s\n           then S (number_of_occurrences a l0)\n           else number_of_occurrences a l0) = 0)\n     with\n     | left a1 =>\n         (fun H1 : a = a0 =>\n          match\n            H0 (or_introl (eq_sym H1))\n            return (S (number_of_occurrences a l0) = 0)\n          with\n          end) a1\n     | right b =>\n         (fun _ : a <> a0 =>\n          H ((fun H1 : In a l0 => H0 (or_intror H1)) : ~ In a l0)) b\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (~ In a l0 -> number_of_occurrences a l0 = 0) ->\n    ~ In a (a0 :: l0) -> number_of_occurrences a (a0 :: l0) = 0) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind (fun l0 : list A => ~ In a l0 -> number_of_occurrences a l0 = 0)\n   ((fun _ : ~ False => eq_refl)\n    :\n    ~ In a nil -> number_of_occurrences a nil = 0)\n   ((fun (a0 : A) (l0 : list A)\n       (H : ~ In a l0 -> number_of_occurrences a l0 = 0)\n       (H0 : ~ (a0 = a \\/ In a l0)) =>\n     match\n       eqA_dec a a0 as s\n       return\n         ((if s\n           then S (number_of_occurrences a l0)\n           else number_of_occurrences a l0) = 0)\n     with\n     | left a1 =>\n         (fun H1 : a = a0 =>\n          match\n            H0 (or_introl (eq_sym H1))\n            return (S (number_of_occurrences a l0) = 0)\n          with\n          end) a1\n     | right b =>\n         (fun _ : a <> a0 =>\n          H ((fun H1 : In a l0 => H0 (or_intror H1)) : ~ In a l0)) b\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (~ In a l0 -> number_of_occurrences a l0 = 0) ->\n    ~ In a (a0 :: l0) -> number_of_occurrences a (a0 :: l0) = 0) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "number_of_occurrences_permutation_ex", "text": "Theorem number_of_occurrences_permutation_ex :\n forall (m : list A) (a : A),\n exists m1 : list A,\n   permutation m (id_list a (number_of_occurrences a m) ++ m1) /\\ ~ In a m1.\nProof using.\nintros m; elim m; simpl in |- *; auto.\nintros a; exists (nil (A:=A)); split; auto with datatypes.\nintros a l H a0.\ncase (eqA_dec a0 a); simpl in |- *; intros H1.\ncase (H a0); intros m1 (H2, H3).\nexists m1; split; auto.\npattern a0 at 1 in |- *; rewrite H1; auto.\ncase (H a0); intros m1 (H2, H3).\nexists (a :: m1); split; auto.\napply\n permutation_trans\n  with ((a :: m1) ++ id_list a0 (number_of_occurrences a0 l)); \n auto.\nsimpl in |- *; apply permutation_skip; auto.\napply permutation_trans with (1 := H2); auto.\nsimpl in |- *; Contradict H3; case H3; intros H4; auto; case H1; auto.\nQed.\n", "definition": "\n forall (m : list A) (a : A),\n exists m1 : list A,\n   permutation m (id_list a (number_of_occurrences a m) ++ m1) /\\ ~ In a m1.", "proof": "\nProof using.\nintros m; elim m; simpl in |- *; auto.\nintros a; exists (nil (A:=A)); split; auto with datatypes.\nintros a l H a0.\ncase (eqA_dec a0 a); simpl in |- *; intros H1.\ncase (H a0); intros m1 (H2, H3).\nexists m1; split; auto.\npattern a0 at 1 in |- *; rewrite H1; auto.\ncase (H a0); intros m1 (H2, H3).\nexists (a :: m1); split; auto.\napply\n permutation_trans\n  with ((a :: m1) ++ id_list a0 (number_of_occurrences a0 l)); \n auto.\nsimpl in |- *; apply permutation_skip; auto.\napply permutation_trans with (1 := H2); auto.\nsimpl in |- *; Contradict H3; case H3; intros H4; auto; case H1; auto.\n", "def_ranges": [244, 0, 247, 76], "proof_ranges": [248, 0, 265, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m; elim m; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a; exists (nil (A:=A)); split; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l H a0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (eqA_dec a0 a); simpl in |- *; intros H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H a0); intros m1 (H2, H3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists m1; split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern a0 at 1 in |- *; rewrite H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (H a0); intros m1 (H2, H3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (a :: m1); split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "permutation_trans", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with ((a :: m1) ++ id_list a0 (number_of_occurrences a0 l));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; apply permutation_skip; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (1 := H2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "number_of_occurrences_app", "text": "Theorem number_of_occurrences_app :\n forall l1 l2 a,\n number_of_occurrences a (l1 ++ l2) =\n number_of_occurrences a l1 + number_of_occurrences a l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 a0; case (eqA_dec a0 a); intros H1; simpl in |- *; auto.\nQed.\n", "definition": "\n forall l1 l2 a,\n number_of_occurrences a (l1 ++ l2) =\n number_of_occurrences a l1 + number_of_occurrences a l2.", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 a0; case (eqA_dec a0 a); intros H1; simpl in |- *; auto.\n", "def_ranges": [268, 0, 271, 57], "proof_ranges": [272, 0, 275, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l1 l2 : list A) (a : A),\nnumber_of_occurrences a (l1 ++ l2) =\nnumber_of_occurrences a l1 + number_of_occurrences a l2"], "goal_after": ["forall (l1 l2 : list A) (a : A),\nnumber_of_occurrences a (l1 ++ l2) =\nnumber_of_occurrences a l1 + number_of_occurrences a l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall (l1 l2 : list A) (a : A),\nnumber_of_occurrences a (l1 ++ l2) =\nnumber_of_occurrences a l1 + number_of_occurrences a l2"], "goal_after": ["forall (a : A) (l : list A),\n(forall (l2 : list A) (a0 : A),\n number_of_occurrences a0 (l ++ l2) =\n number_of_occurrences a0 l + number_of_occurrences a0 l2) ->\nforall (l2 : list A) (a0 : A),\n(if eqA_dec a0 a\n then S (number_of_occurrences a0 (l ++ l2))\n else number_of_occurrences a0 (l ++ l2)) =\n(if eqA_dec a0 a\n then S (number_of_occurrences a0 l)\n else number_of_occurrences a0 l) + number_of_occurrences a0 l2"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    number_of_occurrences a (l2 ++ l3) =\n    number_of_occurrences a l2 + number_of_occurrences a l3)\n   ((fun (l2 : list A) (a : A) => eq_refl)\n    :\n    forall (l2 : list A) (a : A),\n    number_of_occurrences a (nil ++ l2) =\n    number_of_occurrences a nil + number_of_occurrences a l2)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     number_of_occurrences a0 (l ++ l2) =\n     number_of_occurrences a0 l + number_of_occurrences a0 l2) ->\n    forall (l2 : list A) (a0 : A),\n    number_of_occurrences a0 ((a :: l) ++ l2) =\n    number_of_occurrences a0 (a :: l) + number_of_occurrences a0 l2) l1)"]}, {"text": "intros a l H l2 a0; case (eqA_dec a0 a); intros H1; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l : list A),\n(forall (l2 : list A) (a0 : A),\n number_of_occurrences a0 (l ++ l2) =\n number_of_occurrences a0 l + number_of_occurrences a0 l2) ->\nforall (l2 : list A) (a0 : A),\n(if eqA_dec a0 a\n then S (number_of_occurrences a0 (l ++ l2))\n else number_of_occurrences a0 (l ++ l2)) =\n(if eqA_dec a0 a\n then S (number_of_occurrences a0 l)\n else number_of_occurrences a0 l) + number_of_occurrences a0 l2"], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    number_of_occurrences a (l2 ++ l3) =\n    number_of_occurrences a l2 + number_of_occurrences a l3)\n   ((fun (l2 : list A) (a : A) => eq_refl)\n    :\n    forall (l2 : list A) (a : A),\n    number_of_occurrences a (nil ++ l2) =\n    number_of_occurrences a nil + number_of_occurrences a l2)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     number_of_occurrences a0 (l ++ l2) =\n     number_of_occurrences a0 l + number_of_occurrences a0 l2) ->\n    forall (l2 : list A) (a0 : A),\n    number_of_occurrences a0 ((a :: l) ++ l2) =\n    number_of_occurrences a0 (a :: l) + number_of_occurrences a0 l2) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    number_of_occurrences a (l2 ++ l3) =\n    number_of_occurrences a l2 + number_of_occurrences a l3)\n   ((fun (l2 : list A) (a : A) => eq_refl)\n    :\n    forall (l2 : list A) (a : A),\n    number_of_occurrences a (nil ++ l2) =\n    number_of_occurrences a nil + number_of_occurrences a l2)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            number_of_occurrences a0 (l ++ l2) =\n            number_of_occurrences a0 l + number_of_occurrences a0 l2)\n       (l2 : list A) (a0 : A) =>\n     match\n       eqA_dec a0 a as s\n       return\n         ((if s\n           then S (number_of_occurrences a0 (l ++ l2))\n           else number_of_occurrences a0 (l ++ l2)) =\n          (if s\n           then S (number_of_occurrences a0 l)\n           else number_of_occurrences a0 l) + number_of_occurrences a0 l2)\n     with\n     | left a1 =>\n         (fun _ : a0 = a =>\n          f_equal_nat nat S (number_of_occurrences a0 (l ++ l2))\n            (number_of_occurrences a0 l + number_of_occurrences a0 l2)\n            (H l2 a0)\n          :\n          S (number_of_occurrences a0 (l ++ l2)) =\n          S (number_of_occurrences a0 l) + number_of_occurrences a0 l2) a1\n     | right b =>\n         (fun _ : a0 <> a =>\n          H l2 a0\n          :\n          number_of_occurrences a0 (l ++ l2) =\n          number_of_occurrences a0 l + number_of_occurrences a0 l2) b\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     number_of_occurrences a0 (l ++ l2) =\n     number_of_occurrences a0 l + number_of_occurrences a0 l2) ->\n    forall (l2 : list A) (a0 : A),\n    number_of_occurrences a0 ((a :: l) ++ l2) =\n    number_of_occurrences a0 (a :: l) + number_of_occurrences a0 l2) l1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (a : A),\n    number_of_occurrences a (l2 ++ l3) =\n    number_of_occurrences a l2 + number_of_occurrences a l3)\n   ((fun (l2 : list A) (a : A) => eq_refl)\n    :\n    forall (l2 : list A) (a : A),\n    number_of_occurrences a (nil ++ l2) =\n    number_of_occurrences a nil + number_of_occurrences a l2)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 : list A) (a0 : A),\n            number_of_occurrences a0 (l ++ l2) =\n            number_of_occurrences a0 l + number_of_occurrences a0 l2)\n       (l2 : list A) (a0 : A) =>\n     match\n       eqA_dec a0 a as s\n       return\n         ((if s\n           then S (number_of_occurrences a0 (l ++ l2))\n           else number_of_occurrences a0 (l ++ l2)) =\n          (if s\n           then S (number_of_occurrences a0 l)\n           else number_of_occurrences a0 l) + number_of_occurrences a0 l2)\n     with\n     | left a1 =>\n         (fun _ : a0 = a =>\n          f_equal_nat nat S (number_of_occurrences a0 (l ++ l2))\n            (number_of_occurrences a0 l + number_of_occurrences a0 l2)\n            (H l2 a0)\n          :\n          S (number_of_occurrences a0 (l ++ l2)) =\n          S (number_of_occurrences a0 l) + number_of_occurrences a0 l2) a1\n     | right b =>\n         (fun _ : a0 <> a =>\n          H l2 a0\n          :\n          number_of_occurrences a0 (l ++ l2) =\n          number_of_occurrences a0 l + number_of_occurrences a0 l2) b\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 : list A) (a0 : A),\n     number_of_occurrences a0 (l ++ l2) =\n     number_of_occurrences a0 l + number_of_occurrences a0 l2) ->\n    forall (l2 : list A) (a0 : A),\n    number_of_occurrences a0 ((a :: l) ++ l2) =\n    number_of_occurrences a0 (a :: l) + number_of_occurrences a0 l2) l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "number_of_occurrences_permutation", "text": "Theorem number_of_occurrences_permutation :\n forall l1 l2 a,\n permutation l1 l2 -> number_of_occurrences a l1 = number_of_occurrences a l2.\nProof using.\nintros l1 l2 a H; generalize a; elim H; clear H a l1 l2; simpl in |- *; auto.\nintros a L1 L2 H H0 a0; case (eqA_dec a a0); simpl in |- *; auto;\n case (eqA_dec a0 a); simpl in |- *; auto.\nintros a b L a0; case (eqA_dec a0 a); simpl in |- *; auto;\n case (eqA_dec a0 b); simpl in |- *; auto.\nintros L1 L2 L3 H H0 H1 H2 a; apply trans_equal with (1 := H0 a); auto.\nQed.\n", "definition": "\n forall l1 l2 a,\n permutation l1 l2 -> number_of_occurrences a l1 = number_of_occurrences a l2.", "proof": "\nProof using.\nintros l1 l2 a H; generalize a; elim H; clear H a l1 l2; simpl in |- *; auto.\nintros a L1 L2 H H0 a0; case (eqA_dec a a0); simpl in |- *; auto;\n case (eqA_dec a0 a); simpl in |- *; auto.\nintros a b L a0; case (eqA_dec a0 a); simpl in |- *; auto;\n case (eqA_dec a0 b); simpl in |- *; auto.\nintros L1 L2 L3 H H0 H1 H2 a; apply trans_equal with (1 := H0 a); auto.\n", "def_ranges": [278, 0, 280, 78], "proof_ranges": [281, 0, 288, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 a H; generalize a; elim H; clear H a l1 l2; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a L1 L2 H H0 a0; case (eqA_dec a a0); simpl in |- *; auto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (eqA_dec a0 a); simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b L a0; case (eqA_dec a0 a); simpl in |- *; auto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (eqA_dec a0 b); simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros L1 L2 L3 H H0 H1 H2 a; apply trans_equal with (1 := H0 a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Frequency.v", "name": "frequency_number_of_occurrences", "text": "Theorem frequency_number_of_occurrences :\n forall a m, In a m -> In (a, number_of_occurrences a m) (frequency_list m).\nProof using.\nintros a m; generalize a; elim m; clear m a; simpl in |- *; auto.\nintros a l H a0 H0; case (eqA_dec a0 a); simpl in |- *; auto.\nintros e; case (In_dec eqA_dec a0 l).\nintros H1; rewrite e; apply add_frequency_list_in; auto.\napply (H a); rewrite <- e; auto.\nintros H1; rewrite number_of_occurrences_O; auto.\nrewrite e; apply add_frequency_list_1.\nintros ca; Contradict H1; auto.\nrewrite e; apply frequency_list_in with (1 := H1).\nintros H1; case H0; auto.\nintros H2; case H1; auto.\nintros H3; apply add_frequency_list_not_in; auto.\nQed.\n", "definition": "\n forall a m, In a m -> In (a, number_of_occurrences a m) (frequency_list m).", "proof": "\nProof using.\nintros a m; generalize a; elim m; clear m a; simpl in |- *; auto.\nintros a l H a0 H0; case (eqA_dec a0 a); simpl in |- *; auto.\nintros e; case (In_dec eqA_dec a0 l).\nintros H1; rewrite e; apply add_frequency_list_in; auto.\napply (H a); rewrite <- e; auto.\nintros H1; rewrite number_of_occurrences_O; auto.\nrewrite e; apply add_frequency_list_1.\nintros ca; Contradict H1; auto.\nrewrite e; apply frequency_list_in with (1 := H1).\nintros H1; case H0; auto.\nintros H2; case H1; auto.\nintros H3; apply add_frequency_list_not_in; auto.\n", "def_ranges": [291, 0, 292, 76], "proof_ranges": [293, 0, 306, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (m : list A),\nIn a m -> In (a, number_of_occurrences a m) (frequency_list m)"], "goal_after": ["forall (a : A) (m : list A),\nIn a m -> In (a, number_of_occurrences a m) (frequency_list m)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a m; generalize a; elim m; clear m a; simpl in |- *; auto.", "goal_before": ["forall (a : A) (m : list A),\nIn a m -> In (a, number_of_occurrences a m) (frequency_list m)"], "goal_after": ["forall (a : A) (l : list A),\n(forall a0 : A,\n In a0 l -> In (a0, number_of_occurrences a0 l) (frequency_list l)) ->\nforall a0 : A,\na = a0 \\/ In a0 l ->\nIn\n  (a0,\n   if eqA_dec a0 a\n   then S (number_of_occurrences a0 l)\n   else number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "intros a l H a0 H0; case (eqA_dec a0 a); simpl in |- *; auto.", "goal_before": ["forall (a : A) (l : list A),\n(forall a0 : A,\n In a0 l -> In (a0, number_of_occurrences a0 l) (frequency_list l)) ->\nforall a0 : A,\na = a0 \\/ In a0 l ->\nIn\n  (a0,\n   if eqA_dec a0 a\n   then S (number_of_occurrences a0 l)\n   else number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["a0 = a ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal0@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "intros e; case (In_dec eqA_dec a0 l).", "goal_before": ["a0 = a ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal0@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 => ?Goal0@{a:=a0; a0:=a1} a3\n           | right b => ?Goal1@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "intros H1; rewrite e; apply add_frequency_list_in; auto.", "goal_before": ["In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 => ?Goal0@{a:=a0; a0:=a1} a3\n           | right b => ?Goal1@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 => ?Goal0@{a:=a0; a0:=a1} a3\n           | right b => ?Goal1@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "apply (H a); rewrite <- e; auto.", "goal_before": ["In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 => ?Goal0@{a:=a0; a0:=a1} a3\n           | right b => ?Goal1@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 => ?Goal0@{a:=a0; a0:=a1} a3\n           | right b => ?Goal1@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "intros H1; rewrite number_of_occurrences_O; auto.", "goal_before": ["In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["In (a0, 1) (add_frequency_list a (frequency_list l))", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 => ?Goal0@{a:=a0; a0:=a1} a3\n           | right b => ?Goal1@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  ?Goal1@{a:=a0; a0:=a1}\n                  (number_of_occurrences_O a1 l ?Goal2@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "rewrite e; apply add_frequency_list_1.", "goal_before": ["In (a0, 1) (add_frequency_list a (frequency_list l))", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  ?Goal1@{a:=a0; a0:=a1}\n                  (number_of_occurrences_O a1 l ?Goal2@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "intros ca; Contradict H1; auto.", "goal_before": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "rewrite e; apply frequency_list_in with (1 := H1).", "goal_before": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "intros H1; case H0; auto.", "goal_before": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "intros H2; case H1; auto.", "goal_before": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "intros H3; apply add_frequency_list_not_in; auto.", "goal_before": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"]}, {"text": "Qed.", "goal_before": ["forall ca : nat, ~ In (a, ca) (frequency_list l)", "~ In a0 l", "~ In a0 l ->\nIn (a0, S (number_of_occurrences a0 l))\n  (add_frequency_list a (frequency_list l))", "a0 <> a ->\nIn (a0, number_of_occurrences a0 l) (add_frequency_list a (frequency_list l))"], "goal_after": [], "proof_term_before": ["(fun (a : A) (m : list A) =>\n list_ind\n   (fun m0 : list A =>\n    forall a0 : A,\n    In a0 m0 -> In (a0, number_of_occurrences a0 m0) (frequency_list m0))\n   ((fun (_ : A) (H : False) => H)\n    :\n    forall a0 : A,\n    In a0 nil -> In (a0, number_of_occurrences a0 nil) (frequency_list nil))\n   ((fun (a0 : A) (l : list A)\n       (H : forall a1 : A,\n            In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l))\n       (a1 : A) (H0 : a0 = a1 \\/ In a1 l) =>\n     match\n       eqA_dec a1 a0 as s\n       return\n         (In\n            (a1,\n             if s\n             then S (number_of_occurrences a1 l)\n             else number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l)))\n     with\n     | left a2 =>\n         ((fun e : a1 = a0 =>\n           match in_dec eqA_dec a1 l with\n           | left a3 =>\n               (fun H1 : In a1 l =>\n                eq_ind_r\n                  (fun n : nat =>\n                   In (a1, S n) (add_frequency_list a0 (frequency_list l)))\n                  (eq_ind_r\n                     (fun a4 : A =>\n                      In (a4, 1) (add_frequency_list a0 (frequency_list l)))\n                     (add_frequency_list_1 a0 (frequency_list l)\n                        ?Goal2@{a:=a0; a0:=a1}) e)\n                  (number_of_occurrences_O a1 l ?Goal1@{a:=a0; a0:=a1})) a3\n           | right b => ?Goal0@{a:=a0; a0:=a1} b\n           end)\n          :\n          a1 = a0 ->\n          In (a1, S (number_of_occurrences a1 l))\n            (add_frequency_list a0 (frequency_list l))) a2\n     | right b =>\n         (?Goal@{a:=a0; a0:=a1}\n          :\n          a1 <> a0 ->\n          In (a1, number_of_occurrences a1 l)\n            (add_frequency_list a0 (frequency_list l))) b\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall a1 : A,\n     In a1 l -> In (a1, number_of_occurrences a1 l) (frequency_list l)) ->\n    forall a1 : A,\n    In a1 (a0 :: l) ->\n    In (a1, number_of_occurrences a1 (a0 :: l)) (frequency_list (a0 :: l))) m\n   a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Restrict.v", "name": "restrict_code_unique_key", "text": "Theorem restrict_code_unique_key :\n forall c : code A, unique_key (restrict_code m c).\nProof using.\nintros c; apply ulist_unique_key.\nunfold restrict_code in |- *.\nreplace\n (map (fst (B:=_))\n    (map (fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))\n       (frequency_list eqA_dec m))) with\n (map (fst (B:=_)) (frequency_list eqA_dec m)).\napply unique_key_ulist; auto.\nelim (frequency_list eqA_dec m); simpl in |- *; auto with datatypes.\nintros a l H; apply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n", "definition": "\n forall c : code A, unique_key (restrict_code m c).", "proof": "\nProof using.\nintros c; apply ulist_unique_key.\nunfold restrict_code in |- *.\nreplace\n (map (fst (B:=_))\n    (map (fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))\n       (frequency_list eqA_dec m))) with\n (map (fst (B:=_)) (frequency_list eqA_dec m)).\napply unique_key_ulist; auto.\nelim (frequency_list eqA_dec m); simpl in |- *; auto with datatypes.\nintros a l H; apply f_equal2 with (f := cons (A:=A)); auto.\n", "def_ranges": [46, 0, 47, 51], "proof_ranges": [48, 0, 59, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c; apply ulist_unique_key.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold restrict_code in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (fst (B:=_))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(frequency_list eqA_dec m))) with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(map (fst (B:=_)) (frequency_list eqA_dec m)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_ulist; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (frequency_list eqA_dec m); simpl in |- *; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Restrict.v", "name": "restrict_code_in", "text": "Theorem restrict_code_in :\n forall (a : A) (c : code A),\n In a m -> find_code eqA_dec a c = find_code eqA_dec a (restrict_code m c).\nProof using.\nintros a c H.\napply sym_equal; apply find_code_correct2; auto.\napply restrict_code_unique_key.\ngeneralize (in_frequency_map _ eqA_dec m a H).\nunfold restrict_code in |- *; elim (frequency_list eqA_dec m); simpl in |- *;\n auto with datatypes.\nintros a0; case a0; simpl in |- *; auto with datatypes.\nintros a1 n l H0 [H1| H1]; try rewrite H1; auto.\nQed.\n", "definition": "\n forall (a : A) (c : code A),\n In a m -> find_code eqA_dec a c = find_code eqA_dec a (restrict_code m c).", "proof": "\nProof using.\nintros a c H.\napply sym_equal; apply find_code_correct2; auto.\napply restrict_code_unique_key.\ngeneralize (in_frequency_map _ eqA_dec m a H).\nunfold restrict_code in |- *; elim (frequency_list eqA_dec m); simpl in |- *;\n auto with datatypes.\nintros a0; case a0; simpl in |- *; auto with datatypes.\nintros a1 n l H0 [H1| H1]; try rewrite H1; auto.\n", "def_ranges": [62, 0, 64, 75], "proof_ranges": [65, 0, 74, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a c H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sym_equal; apply find_code_correct2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply restrict_code_unique_key.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (in_frequency_map _ eqA_dec m a H).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold restrict_code in |- *; elim (frequency_list eqA_dec m); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0; case a0; simpl in |- *; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a1 n l H0 [H1| H1]; try rewrite H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Restrict.v", "name": "restrict_code_encode_incl", "text": "Theorem restrict_code_encode_incl :\n forall (m1 : list A) (c : code A),\n incl m1 m -> encode eqA_dec c m1 = encode eqA_dec (restrict_code m c) m1.\nProof using.\nintros m1 c; elim m1; simpl in |- *; auto.\nintros a l H H0.\napply f_equal2 with (f := app (A:=bool)); auto with datatypes.\napply restrict_code_in; auto with datatypes.\napply H; apply incl_tran with (2 := H0); auto with datatypes.\nQed.\n", "definition": "\n forall (m1 : list A) (c : code A),\n incl m1 m -> encode eqA_dec c m1 = encode eqA_dec (restrict_code m c) m1.", "proof": "\nProof using.\nintros m1 c; elim m1; simpl in |- *; auto.\nintros a l H H0.\napply f_equal2 with (f := app (A:=bool)); auto with datatypes.\napply restrict_code_in; auto with datatypes.\napply H; apply incl_tran with (2 := H0); auto with datatypes.\n", "def_ranges": [80, 0, 82, 74], "proof_ranges": [83, 0, 89, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros m1 c; elim m1; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a l H H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := app (A:=bool)); auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply restrict_code_in; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H; apply incl_tran with (2 := H0); auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Restrict.v", "name": "restrict_code_encode", "text": "Theorem restrict_code_encode :\n forall c : code A, encode eqA_dec c m = encode eqA_dec (restrict_code m c) m.\nProof using.\nintros c; apply restrict_code_encode_incl; auto with datatypes.\nQed.\n", "definition": "\n forall c : code A, encode eqA_dec c m = encode eqA_dec (restrict_code m c) m.", "proof": "\nProof using.\nintros c; apply restrict_code_encode_incl; auto with datatypes.\n", "def_ranges": [92, 0, 93, 78], "proof_ranges": [94, 0, 96, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c; apply restrict_code_encode_incl; auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Restrict.v", "name": "restrict_unique_prefix", "text": "Theorem restrict_unique_prefix :\n forall c : code A,\n not_null c ->\n in_alphabet m c -> unique_prefix c -> unique_prefix (restrict_code m c).\nProof using.\nintros c HH HH0 (HH1, HH2); split.\nintros a1 a2 lb1 lb2 H0 H1 H2; apply HH1 with (lb1 := lb1) (lb2 := lb2); auto.\nunfold restrict_code in H0.\ncase in_map_inv with (1 := H0).\nintros x; case x; simpl in |- *.\nintros a0 n (HP1, HP2).\nrewrite HP2.\ncase (HH0 a0); auto.\napply frequency_list_in with (1 := HP1).\nintros x0 H; rewrite find_code_correct2 with (2 := H); auto.\nunfold restrict_code in H1.\ncase in_map_inv with (1 := H1).\nintros x; case x; simpl in |- *.\nintros a0 n (HP1, HP2).\nrewrite HP2.\ncase (HH0 a0); auto.\napply frequency_list_in with (1 := HP1).\nintros x0 H; rewrite find_code_correct2 with (2 := H); auto.\nunfold restrict_code in |- *.\napply unique_key_map; auto.\nQed.\n", "definition": "\n forall c : code A,\n not_null c ->\n in_alphabet m c -> unique_prefix c -> unique_prefix (restrict_code m c).", "proof": "\nProof using.\nintros c HH HH0 (HH1, HH2); split.\nintros a1 a2 lb1 lb2 H0 H1 H2; apply HH1 with (lb1 := lb1) (lb2 := lb2); auto.\nunfold restrict_code in H0.\ncase in_map_inv with (1 := H0).\nintros x; case x; simpl in |- *.\nintros a0 n (HP1, HP2).\nrewrite HP2.\ncase (HH0 a0); auto.\napply frequency_list_in with (1 := HP1).\nintros x0 H; rewrite find_code_correct2 with (2 := H); auto.\nunfold restrict_code in H1.\ncase in_map_inv with (1 := H1).\nintros x; case x; simpl in |- *.\nintros a0 n (HP1, HP2).\nrewrite HP2.\ncase (HH0 a0); auto.\napply frequency_list_in with (1 := HP1).\nintros x0 H; rewrite find_code_correct2 with (2 := H); auto.\nunfold restrict_code in |- *.\napply unique_key_map; auto.\n", "def_ranges": [102, 0, 105, 73], "proof_ranges": [106, 0, 127, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c HH HH0 (HH1, HH2); split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a1 a2 lb1 lb2 H0 H1 H2; apply HH1 with (lb1 := lb1) (lb2 := lb2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold restrict_code in H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case in_map_inv with (1 := H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x; case x; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 n (HP1, HP2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HP2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (HH0 a0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply frequency_list_in with (1 := HP1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H; rewrite find_code_correct2 with (2 := H); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold restrict_code in H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case in_map_inv with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x; case x; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 n (HP1, HP2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite HP2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (HH0 a0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply frequency_list_in with (1 := HP1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H; rewrite find_code_correct2 with (2 := H); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold restrict_code in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unique_key_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Restrict.v", "name": "frequency_list_restric_code_map", "text": "Theorem frequency_list_restric_code_map :\n forall c,\n map (fst (B:=_)) (frequency_list eqA_dec m) =\n map (fst (B:=_)) (restrict_code m c).\nProof using.\nintros c; unfold restrict_code in |- *; elim (frequency_list eqA_dec m);\n simpl in |- *; auto.\nintros a0 l H; apply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n", "definition": "\n forall c,\n map (fst (B:=_)) (frequency_list eqA_dec m) =\n map (fst (B:=_)) (restrict_code m c).", "proof": "\nProof using.\nintros c; unfold restrict_code in |- *; elim (frequency_list eqA_dec m);\n simpl in |- *; auto.\nintros a0 l H; apply f_equal2 with (f := cons (A:=A)); auto.\n", "def_ranges": [130, 0, 133, 38], "proof_ranges": [134, 0, 138, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c; unfold restrict_code in |- *; elim (frequency_list eqA_dec m);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 l H; apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Restrict.v", "name": "restrict_not_null", "text": "Theorem restrict_not_null : forall c, m <> nil -> restrict_code m c <> nil.\nProof using.\ncase m; simpl in |- *; auto.\nunfold restrict_code in |- *.\nintros a0 l c H H1.\nabsurd\n (In\n    ((fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))\n       (a0, number_of_occurrences eqA_dec a0 (a0 :: l))) nil);\n auto with datatypes.\nrewrite <- H1.\napply\n in_map with (f := fun x : A * nat => (fst x, find_code eqA_dec (fst x) c)).\napply frequency_number_of_occurrences; auto with datatypes.\nQed.\n", "definition": " forall c, m <> nil -> restrict_code m c <> nil.", "proof": "\nProof using.\ncase m; simpl in |- *; auto.\nunfold restrict_code in |- *.\nintros a0 l c H H1.\nabsurd\n (In\n    ((fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))\n       (a0, number_of_occurrences eqA_dec a0 (a0 :: l))) nil);\n auto with datatypes.\nrewrite <- H1.\napply\n in_map with (f := fun x : A * nat => (fst x, find_code eqA_dec (fst x) c)).\napply frequency_number_of_occurrences; auto with datatypes.\n", "def_ranges": [141, 0, 141, 75], "proof_ranges": [142, 0, 155, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case m; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold restrict_code in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 l c H H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "absurd", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(In", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((fun x : A * nat => (fst x, find_code eqA_dec (fst x) c))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(a0, number_of_occurrences eqA_dec a0 (a0 :: l))) nil);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with datatypes.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Restrict.v", "name": "restrict_code_pbbuild", "text": "Theorem restrict_code_pbbuild :\n forall c : code A,\n not_null c ->\n unique_prefix c ->\n in_alphabet m c ->\n m <> nil ->\n permutation (map fst (frequency_list eqA_dec m))\n   (all_pbleaves (pbbuild empty (restrict_code m c))).\nProof using.\nintros c H H0 H1 H2.\nrewrite frequency_list_restric_code_map with (c := c).\napply all_pbleaves_pbbuild; auto.\napply restrict_not_null; auto.\napply restrict_unique_prefix; auto.\nQed.\n", "definition": "\n forall c : code A,\n not_null c ->\n unique_prefix c ->\n in_alphabet m c ->\n m <> nil ->\n permutation (map fst (frequency_list eqA_dec m))\n   (all_pbleaves (pbbuild empty (restrict_code m c))).", "proof": "\nProof using.\nintros c H H0 H1 H2.\nrewrite frequency_list_restric_code_map with (c := c).\napply all_pbleaves_pbbuild; auto.\napply restrict_not_null; auto.\napply restrict_unique_prefix; auto.\n", "def_ranges": [161, 0, 168, 54], "proof_ranges": [169, 0, 175, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c H H0 H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite frequency_list_restric_code_map with (c := c).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply all_pbleaves_pbbuild; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply restrict_not_null; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply restrict_unique_prefix; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/SameSumLeaves.v", "name": "same_sum_leaves_length", "text": "Theorem same_sum_leaves_length :\n forall l1 l2 : list (btree A),\n same_sum_leaves l1 l2 -> length l1 = length l2.\nProof using.\nintros l1 l2 (l3, (l4, (H0, (H1, H2)))).\nrewrite (permutation_length _ _ _ H0).\nrewrite (permutation_length _ _ _ H1).\nrepeat rewrite <- (length_map _ _ (sum_leaves f)); auto.\napply f_equal with (f := length (A:=nat)); auto.\nQed.\n", "definition": "\n forall l1 l2 : list (btree A),\n same_sum_leaves l1 l2 -> length l1 = length l2.", "proof": "\nProof using.\nintros l1 l2 (l3, (l4, (H0, (H1, H2)))).\nrewrite (permutation_length _ _ _ H0).\nrewrite (permutation_length _ _ _ H1).\nrepeat rewrite <- (length_map _ _ (sum_leaves f)); auto.\napply f_equal with (f := length (A:=nat)); auto.\n", "def_ranges": [40, 0, 42, 48], "proof_ranges": [43, 0, 49, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 (l3, (l4, (H0, (H1, H2)))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (permutation_length _ _ _ H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (permutation_length _ _ _ H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite <- (length_map _ _ (sum_leaves f)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal with (f := length (A:=nat)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_refl", "text": "Theorem permutation_refl : forall l : list A, permutation l l.\nProof using.  \nsimple induction l.\napply permutation_nil.\nintros a l1 H.\napply permutation_skip with (1 := H).\nQed.\n", "definition": " forall l : list A, permutation l l.", "proof": "\nProof using.  \nsimple induction l.\napply permutation_nil.\nintros a l1 H.\napply permutation_skip with (1 := H).\n", "def_ranges": [46, 0, 46, 62], "proof_ranges": [47, 0, 52, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l : list A, permutation l l"], "goal_after": ["forall l : list A, permutation l l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "simple induction l.", "goal_before": ["forall l : list A, permutation l l"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 : list A),\npermutation l0 l0 -> permutation (a :: l0) (a :: l0)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list A =>\n list_ind (fun l0 : list A => permutation l0 l0) ?Goal ?Goal0 l)"]}, {"text": "apply permutation_nil.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 : list A),\npermutation l0 l0 -> permutation (a :: l0) (a :: l0)"], "goal_after": ["forall (a : A) (l0 : list A),\npermutation l0 l0 -> permutation (a :: l0) (a :: l0)"], "proof_term_before": ["(fun l : list A =>\n list_ind (fun l0 : list A => permutation l0 l0) ?Goal ?Goal0 l)"], "proof_term_after": ["(fun l : list A =>\n list_ind (fun l0 : list A => permutation l0 l0) permutation_nil ?Goal l)"]}, {"text": "intros a l1 H.", "goal_before": ["forall (a : A) (l0 : list A),\npermutation l0 l0 -> permutation (a :: l0) (a :: l0)"], "goal_after": ["permutation (a :: l1) (a :: l1)"], "proof_term_before": ["(fun l : list A =>\n list_ind (fun l0 : list A => permutation l0 l0) permutation_nil ?Goal l)"], "proof_term_after": ["(fun l : list A =>\n list_ind (fun l0 : list A => permutation l0 l0) permutation_nil\n   (fun (a : A) (l1 : list A) (H : permutation l1 l1) => ?Goal) l)"]}, {"text": "apply permutation_skip with (1 := H).", "goal_before": ["permutation (a :: l1) (a :: l1)"], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind (fun l0 : list A => permutation l0 l0) permutation_nil\n   (fun (a : A) (l1 : list A) (H : permutation l1 l1) => ?Goal) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind (fun l0 : list A => permutation l0 l0) permutation_nil\n   (fun (a : A) (l1 : list A) (H : permutation l1 l1) =>\n    permutation_skip a l1 l1 H) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind (fun l0 : list A => permutation l0 l0) permutation_nil\n   (fun (a : A) (l1 : list A) (H : permutation l1 l1) =>\n    permutation_skip a l1 l1 H) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_sym", "text": "Theorem permutation_sym :\n forall l m : list A, permutation l m -> permutation m l.\nProof using.\nintros l1 l2 H'; elim H'.\napply permutation_nil.\nintros a l1' l2' H1 H2.\napply permutation_skip with (1 := H2).\nintros a b l1'.\napply permutation_swap.\nintros l1' l2' l3' H1 H2 H3 H4.\napply permutation_trans with (1 := H4) (2 := H2).\nQed.\n", "definition": "\n forall l m : list A, permutation l m -> permutation m l.", "proof": "\nProof using.\nintros l1 l2 H'; elim H'.\napply permutation_nil.\nintros a l1' l2' H1 H2.\napply permutation_skip with (1 := H2).\nintros a b l1'.\napply permutation_swap.\nintros l1' l2' l3' H1 H2 H3 H4.\napply permutation_trans with (1 := H4) (2 := H2).\n", "def_ranges": [56, 0, 57, 57], "proof_ranges": [58, 0, 67, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l m : list A, permutation l m -> permutation m l"], "goal_after": ["forall l m : list A, permutation l m -> permutation m l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1 l2 H'; elim H'.", "goal_before": ["forall l m : list A, permutation l m -> permutation m l"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 -> permutation l0 l3 -> permutation (a :: l0) (a :: l3)", "forall (a b : A) (l : list A), permutation (b :: a :: l) (a :: b :: l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) \n   ?Goal ?Goal0 ?Goal1 ?Goal2 l1 l2 H')"]}, {"text": "apply permutation_nil.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 -> permutation l0 l3 -> permutation (a :: l0) (a :: l3)", "forall (a b : A) (l : list A), permutation (b :: a :: l) (a :: b :: l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "goal_after": ["forall (a : A) (l0 l3 : list A),\npermutation l3 l0 -> permutation l0 l3 -> permutation (a :: l0) (a :: l3)", "forall (a b : A) (l : list A), permutation (b :: a :: l) (a :: b :: l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "proof_term_before": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) \n   ?Goal ?Goal0 ?Goal1 ?Goal2 l1 l2 H')"], "proof_term_after": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   ?Goal ?Goal0 ?Goal1 l1 l2 H')"]}, {"text": "intros a l1' l2' H1 H2.", "goal_before": ["forall (a : A) (l0 l3 : list A),\npermutation l3 l0 -> permutation l0 l3 -> permutation (a :: l0) (a :: l3)", "forall (a b : A) (l : list A), permutation (b :: a :: l) (a :: b :: l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "goal_after": ["permutation (a :: l1') (a :: l2')", "forall (a b : A) (l : list A), permutation (b :: a :: l) (a :: b :: l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "proof_term_before": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   ?Goal ?Goal0 ?Goal1 l1 l2 H')"], "proof_term_after": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (H1 : permutation l2' l1')\n      (H2 : permutation l1' l2') => ?Goal1) ?Goal \n   ?Goal0 l1 l2 H')"]}, {"text": "apply permutation_skip with (1 := H2).", "goal_before": ["permutation (a :: l1') (a :: l2')", "forall (a b : A) (l : list A), permutation (b :: a :: l) (a :: b :: l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "goal_after": ["forall (a b : A) (l : list A), permutation (b :: a :: l) (a :: b :: l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "proof_term_before": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (H1 : permutation l2' l1')\n      (H2 : permutation l1' l2') => ?Goal1) ?Goal \n   ?Goal0 l1 l2 H')"], "proof_term_after": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2) \n   ?Goal ?Goal0 l1 l2 H')"]}, {"text": "intros a b l1'.", "goal_before": ["forall (a b : A) (l : list A), permutation (b :: a :: l) (a :: b :: l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "goal_after": ["permutation (b :: a :: l1') (a :: b :: l1')", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "proof_term_before": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2) \n   ?Goal ?Goal0 l1 l2 H')"], "proof_term_after": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2)\n   (fun (a b : A) (l1' : list A) => ?Goal0) ?Goal l1 l2 H')"]}, {"text": "apply permutation_swap.", "goal_before": ["permutation (b :: a :: l1') (a :: b :: l1')", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "goal_after": ["forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "proof_term_before": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2)\n   (fun (a b : A) (l1' : list A) => ?Goal0) ?Goal l1 l2 H')"], "proof_term_after": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2)\n   (fun (a b : A) (l1' : list A) => permutation_swap b a l1') \n   ?Goal l1 l2 H')"]}, {"text": "intros l1' l2' l3' H1 H2 H3 H4.", "goal_before": ["forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation l3 l0 ->\npermutation l3 l4 -> permutation l4 l3 -> permutation l4 l0"], "goal_after": ["permutation l3' l1'"], "proof_term_before": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2)\n   (fun (a b : A) (l1' : list A) => permutation_swap b a l1') \n   ?Goal l1 l2 H')"], "proof_term_after": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2)\n   (fun (a b : A) (l1' : list A) => permutation_swap b a l1')\n   (fun (l1' l2' l3' : list A) (H1 : permutation l1' l2')\n      (H2 : permutation l2' l1') (H3 : permutation l2' l3')\n      (H4 : permutation l3' l2') => ?Goal) l1 l2 H')"]}, {"text": "apply permutation_trans with (1 := H4) (2 := H2).", "goal_before": ["permutation l3' l1'"], "goal_after": [], "proof_term_before": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2)\n   (fun (a b : A) (l1' : list A) => permutation_swap b a l1')\n   (fun (l1' l2' l3' : list A) (H1 : permutation l1' l2')\n      (H2 : permutation l2' l1') (H3 : permutation l2' l3')\n      (H4 : permutation l3' l2') => ?Goal) l1 l2 H')"], "proof_term_after": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2)\n   (fun (a b : A) (l1' : list A) => permutation_swap b a l1')\n   (fun (l1' l2' l3' : list A) (_ : permutation l1' l2')\n      (H2 : permutation l2' l1') (_ : permutation l2' l3')\n      (H4 : permutation l3' l2') => permutation_trans l3' l2' l1' H4 H2) l1\n   l2 H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l1 l2 : list A) (H' : permutation l1 l2) =>\n permutation_ind (fun l3 l4 : list A => permutation l4 l3) permutation_nil\n   (fun (a : A) (l1' l2' : list A) (_ : permutation l2' l1')\n      (H2 : permutation l1' l2') => permutation_skip a l2' l1' H2)\n   (fun (a b : A) (l1' : list A) => permutation_swap b a l1')\n   (fun (l1' l2' l3' : list A) (_ : permutation l1' l2')\n      (H2 : permutation l2' l1') (_ : permutation l2' l3')\n      (H4 : permutation l3' l2') => permutation_trans l3' l2' l1' H4 H2) l1\n   l2 H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_length", "text": "Theorem permutation_length :\n forall l m : list A, permutation l m -> length l = length m.\nProof using.\nintros l m H'; elim H'; simpl in |- *; auto.\nintros l1 l2 l3 H'0 H'1 H'2 H'3.\nrewrite <- H'3; auto.\nQed.\n", "definition": "\n forall l m : list A, permutation l m -> length l = length m.", "proof": "\nProof using.\nintros l m H'; elim H'; simpl in |- *; auto.\nintros l1 l2 l3 H'0 H'1 H'2 H'3.\nrewrite <- H'3; auto.\n", "def_ranges": [70, 0, 71, 61], "proof_ranges": [72, 0, 76, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l m : list A, permutation l m -> length l = length m"], "goal_after": ["forall l m : list A, permutation l m -> length l = length m"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l m H'; elim H'; simpl in |- *; auto.", "goal_before": ["forall l m : list A, permutation l m -> length l = length m"], "goal_after": ["forall l1 l2 l3 : list A,\npermutation l1 l2 ->\nlength l1 = length l2 ->\npermutation l2 l3 -> length l2 = length l3 -> length l1 = length l3"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (l m : list A) (H' : permutation l m) =>\n permutation_ind (fun l0 m0 : list A => length l0 = length m0)\n   (eq_refl : length nil = length nil)\n   ((fun (_ : A) (l1 l2 : list A) (_ : permutation l2 l1)\n       (H0 : length l2 = length l1) =>\n     f_equal_nat nat S (length l2) (length l1) H0)\n    :\n    forall (a : A) (l1 l2 : list A),\n    permutation l2 l1 ->\n    length l2 = length l1 -> length (a :: l2) = length (a :: l1))\n   ((fun (_ _ : A) (l0 : list A) => eq_refl)\n    :\n    forall (a b : A) (l0 : list A),\n    length (a :: b :: l0) = length (b :: a :: l0))\n   (?Goal\n    :\n    forall l1 l2 l3 : list A,\n    permutation l1 l2 ->\n    length l1 = length l2 ->\n    permutation l2 l3 -> length l2 = length l3 -> length l1 = length l3) l m\n   H')"]}, {"text": "intros l1 l2 l3 H'0 H'1 H'2 H'3.", "goal_before": ["forall l1 l2 l3 : list A,\npermutation l1 l2 ->\nlength l1 = length l2 ->\npermutation l2 l3 -> length l2 = length l3 -> length l1 = length l3"], "goal_after": ["length l1 = length l3"], "proof_term_before": ["(fun (l m : list A) (H' : permutation l m) =>\n permutation_ind (fun l0 m0 : list A => length l0 = length m0)\n   (eq_refl : length nil = length nil)\n   ((fun (_ : A) (l1 l2 : list A) (_ : permutation l2 l1)\n       (H0 : length l2 = length l1) =>\n     f_equal_nat nat S (length l2) (length l1) H0)\n    :\n    forall (a : A) (l1 l2 : list A),\n    permutation l2 l1 ->\n    length l2 = length l1 -> length (a :: l2) = length (a :: l1))\n   ((fun (_ _ : A) (l0 : list A) => eq_refl)\n    :\n    forall (a b : A) (l0 : list A),\n    length (a :: b :: l0) = length (b :: a :: l0))\n   (?Goal\n    :\n    forall l1 l2 l3 : list A,\n    permutation l1 l2 ->\n    length l1 = length l2 ->\n    permutation l2 l3 -> length l2 = length l3 -> length l1 = length l3) l m\n   H')"], "proof_term_after": ["(fun (l m : list A) (H' : permutation l m) =>\n permutation_ind (fun l0 m0 : list A => length l0 = length m0)\n   (eq_refl : length nil = length nil)\n   ((fun (_ : A) (l1 l2 : list A) (_ : permutation l2 l1)\n       (H0 : length l2 = length l1) =>\n     f_equal_nat nat S (length l2) (length l1) H0)\n    :\n    forall (a : A) (l1 l2 : list A),\n    permutation l2 l1 ->\n    length l2 = length l1 -> length (a :: l2) = length (a :: l1))\n   ((fun (_ _ : A) (l0 : list A) => eq_refl)\n    :\n    forall (a b : A) (l0 : list A),\n    length (a :: b :: l0) = length (b :: a :: l0))\n   ((fun (l1 l2 l3 : list A) (H'0 : permutation l1 l2)\n       (H'1 : length l1 = length l2) (H'2 : permutation l2 l3)\n       (H'3 : length l2 = length l3) => ?Goal)\n    :\n    forall l1 l2 l3 : list A,\n    permutation l1 l2 ->\n    length l1 = length l2 ->\n    permutation l2 l3 -> length l2 = length l3 -> length l1 = length l3) l m\n   H')"]}, {"text": "rewrite <- H'3; auto.", "goal_before": ["length l1 = length l3"], "goal_after": [], "proof_term_before": ["(fun (l m : list A) (H' : permutation l m) =>\n permutation_ind (fun l0 m0 : list A => length l0 = length m0)\n   (eq_refl : length nil = length nil)\n   ((fun (_ : A) (l1 l2 : list A) (_ : permutation l2 l1)\n       (H0 : length l2 = length l1) =>\n     f_equal_nat nat S (length l2) (length l1) H0)\n    :\n    forall (a : A) (l1 l2 : list A),\n    permutation l2 l1 ->\n    length l2 = length l1 -> length (a :: l2) = length (a :: l1))\n   ((fun (_ _ : A) (l0 : list A) => eq_refl)\n    :\n    forall (a b : A) (l0 : list A),\n    length (a :: b :: l0) = length (b :: a :: l0))\n   ((fun (l1 l2 l3 : list A) (H'0 : permutation l1 l2)\n       (H'1 : length l1 = length l2) (H'2 : permutation l2 l3)\n       (H'3 : length l2 = length l3) => ?Goal)\n    :\n    forall l1 l2 l3 : list A,\n    permutation l1 l2 ->\n    length l1 = length l2 ->\n    permutation l2 l3 -> length l2 = length l3 -> length l1 = length l3) l m\n   H')"], "proof_term_after": ["(fun (l m : list A) (H' : permutation l m) =>\n permutation_ind (fun l0 m0 : list A => length l0 = length m0)\n   (eq_refl : length nil = length nil)\n   ((fun (_ : A) (l1 l2 : list A) (_ : permutation l2 l1)\n       (H0 : length l2 = length l1) =>\n     f_equal_nat nat S (length l2) (length l1) H0)\n    :\n    forall (a : A) (l1 l2 : list A),\n    permutation l2 l1 ->\n    length l2 = length l1 -> length (a :: l2) = length (a :: l1))\n   ((fun (_ _ : A) (l0 : list A) => eq_refl)\n    :\n    forall (a b : A) (l0 : list A),\n    length (a :: b :: l0) = length (b :: a :: l0))\n   ((fun (l1 l2 l3 : list A) (_ : permutation l1 l2)\n       (H'1 : length l1 = length l2) (_ : permutation l2 l3)\n       (H'3 : length l2 = length l3) =>\n     eq_ind (length l2) (fun n : nat => length l1 = n) H'1 (length l3) H'3)\n    :\n    forall l1 l2 l3 : list A,\n    permutation l1 l2 ->\n    length l1 = length l2 ->\n    permutation l2 l3 -> length l2 = length l3 -> length l1 = length l3) l m\n   H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m : list A) (H' : permutation l m) =>\n permutation_ind (fun l0 m0 : list A => length l0 = length m0)\n   (eq_refl : length nil = length nil)\n   ((fun (_ : A) (l1 l2 : list A) (_ : permutation l2 l1)\n       (H0 : length l2 = length l1) =>\n     f_equal_nat nat S (length l2) (length l1) H0)\n    :\n    forall (a : A) (l1 l2 : list A),\n    permutation l2 l1 ->\n    length l2 = length l1 -> length (a :: l2) = length (a :: l1))\n   ((fun (_ _ : A) (l0 : list A) => eq_refl)\n    :\n    forall (a b : A) (l0 : list A),\n    length (a :: b :: l0) = length (b :: a :: l0))\n   ((fun (l1 l2 l3 : list A) (_ : permutation l1 l2)\n       (H'1 : length l1 = length l2) (_ : permutation l2 l3)\n       (H'3 : length l2 = length l3) =>\n     eq_ind (length l2) (fun n : nat => length l1 = n) H'1 (length l3) H'3)\n    :\n    forall l1 l2 l3 : list A,\n    permutation l1 l2 ->\n    length l1 = length l2 ->\n    permutation l2 l3 -> length l2 = length l3 -> length l1 = length l3) l m\n   H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_nil_inv", "text": "Theorem permutation_nil_inv : forall l : list A, permutation l nil -> l = nil.\nProof using.\nintros l H; generalize (permutation_length _ _ H); case l; simpl in |- *;\n auto.\nintros; discriminate.\nQed.\n", "definition": " forall l : list A, permutation l nil -> l = nil.", "proof": "\nProof using.\nintros l H; generalize (permutation_length _ _ H); case l; simpl in |- *;\n auto.\nintros; discriminate.\n", "def_ranges": [79, 0, 79, 78], "proof_ranges": [80, 0, 84, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l : list A, permutation l nil -> l = nil"], "goal_after": ["forall l : list A, permutation l nil -> l = nil"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l H; generalize (permutation_length _ _ H); case l; simpl in |- *;", "goal_before": ["forall l : list A, permutation l nil -> l = nil"], "goal_after": ["forall l : list A, permutation l nil -> l = nil"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "auto.", "goal_before": ["forall l : list A, permutation l nil -> l = nil"], "goal_after": ["forall l : list A, permutation l nil -> l = nil"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; discriminate.", "goal_before": ["forall l : list A, permutation l nil -> l = nil"], "goal_after": ["forall l : list A, permutation l nil -> l = nil"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_one_inv", "text": "Theorem permutation_one_inv :\n forall (a : A) (l : list A), permutation (a :: nil) l -> l = a :: nil.\nProof using.\nintros a l H; apply permutation_one_inv_aux with (l1 := a :: nil); auto.\nQed.\n", "definition": "\n forall (a : A) (l : list A), permutation (a :: nil) l -> l = a :: nil.", "proof": "\nProof using.\nintros a l H; apply permutation_one_inv_aux with (l1 := a :: nil); auto.\n", "def_ranges": [101, 0, 102, 71], "proof_ranges": [103, 0, 105, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l : list A), permutation (a :: nil) l -> l = a :: nil"], "goal_after": ["forall (a : A) (l : list A), permutation (a :: nil) l -> l = a :: nil"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l H; apply permutation_one_inv_aux with (l1 := a :: nil); auto.", "goal_before": ["forall (a : A) (l : list A), permutation (a :: nil) l -> l = a :: nil"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l : list A) (H : permutation (a :: nil) l) =>\n permutation_one_inv_aux (a :: nil) l H a eq_refl)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (l : list A) (H : permutation (a :: nil) l) =>\n permutation_one_inv_aux (a :: nil) l H a eq_refl)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_in", "text": "Theorem permutation_in :\n forall (a : A) (l m : list A), permutation l m -> In a l -> In a m.\nProof using.\nintros a l m H; elim H; simpl in |- *; auto; intuition.\nQed.\n", "definition": "\n forall (a : A) (l m : list A), permutation l m -> In a l -> In a m.", "proof": "\nProof using.\nintros a l m H; elim H; simpl in |- *; auto; intuition.\n", "def_ranges": [108, 0, 109, 68], "proof_ranges": [110, 0, 112, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l m : list A), permutation l m -> In a l -> In a m"], "goal_after": ["forall (a : A) (l m : list A), permutation l m -> In a l -> In a m"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l m H; elim H; simpl in |- *; auto; intuition.", "goal_before": ["forall (a : A) (l m : list A), permutation l m -> In a l -> In a m"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l m : list A) (H : permutation l m) =>\n permutation_ind (fun l0 m0 : list A => In a l0 -> In a m0)\n   ((fun H0 : False => H0) : In a nil -> In a nil)\n   ((fun (a0 : A) (l1 l2 : list A) (_ : permutation l2 l1)\n       (H1 : In a l2 -> In a l1) (H2 : a0 = a \\/ In a l2) =>\n     or_ind (fun H3 : a0 = a => or_introl H3)\n       (fun H3 : In a l2 => let H4 : In a l1 := H1 H3 in or_intror H4) H2)\n    :\n    forall (a0 : A) (l1 l2 : list A),\n    permutation l2 l1 ->\n    (In a l2 -> In a l1) -> In a (a0 :: l2) -> In a (a0 :: l1))\n   ((fun (a0 b : A) (l0 : list A) (H0 : a0 = a \\/ b = a \\/ In a l0) =>\n     or_ind (fun H1 : a0 = a => or_intror (or_introl H1))\n       (fun H1 : b = a \\/ In a l0 =>\n        or_ind (fun H2 : b = a => or_introl H2)\n          (fun H2 : In a l0 => or_intror (or_intror H2)) H1) H0)\n    :\n    forall (a0 b : A) (l0 : list A),\n    In a (a0 :: b :: l0) -> In a (b :: a0 :: l0))\n   ((fun (l1 l2 l3 : list A) (_ : permutation l1 l2)\n       (H1 : In a l1 -> In a l2) (_ : permutation l2 l3)\n       (H3 : In a l2 -> In a l3) (H4 : In a l1) => \n     H3 (H1 H4))\n    :\n    forall l1 l2 l3 : list A,\n    permutation l1 l2 ->\n    (In a l1 -> In a l2) ->\n    permutation l2 l3 -> (In a l2 -> In a l3) -> In a l1 -> In a l3) l m H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (l m : list A) (H : permutation l m) =>\n permutation_ind (fun l0 m0 : list A => In a l0 -> In a m0)\n   ((fun H0 : False => H0) : In a nil -> In a nil)\n   ((fun (a0 : A) (l1 l2 : list A) (_ : permutation l2 l1)\n       (H1 : In a l2 -> In a l1) (H2 : a0 = a \\/ In a l2) =>\n     or_ind (fun H3 : a0 = a => or_introl H3)\n       (fun H3 : In a l2 => let H4 : In a l1 := H1 H3 in or_intror H4) H2)\n    :\n    forall (a0 : A) (l1 l2 : list A),\n    permutation l2 l1 ->\n    (In a l2 -> In a l1) -> In a (a0 :: l2) -> In a (a0 :: l1))\n   ((fun (a0 b : A) (l0 : list A) (H0 : a0 = a \\/ b = a \\/ In a l0) =>\n     or_ind (fun H1 : a0 = a => or_intror (or_introl H1))\n       (fun H1 : b = a \\/ In a l0 =>\n        or_ind (fun H2 : b = a => or_introl H2)\n          (fun H2 : In a l0 => or_intror (or_intror H2)) H1) H0)\n    :\n    forall (a0 b : A) (l0 : list A),\n    In a (a0 :: b :: l0) -> In a (b :: a0 :: l0))\n   ((fun (l1 l2 l3 : list A) (_ : permutation l1 l2)\n       (H1 : In a l1 -> In a l2) (_ : permutation l2 l3)\n       (H3 : In a l2 -> In a l3) (H4 : In a l1) => \n     H3 (H1 H4))\n    :\n    forall l1 l2 l3 : list A,\n    permutation l1 l2 ->\n    (In a l1 -> In a l2) ->\n    permutation l2 l3 -> (In a l2 -> In a l3) -> In a l1 -> In a l3) l m H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_app_comp", "text": "Theorem permutation_app_comp :\n forall l1 l2 l3 l4,\n permutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4).\nProof using.\nintros l1 l2 l3 l4 H1; generalize l3 l4; elim H1; clear H1 l1 l2 l3 l4;\n simpl in |- *; auto.\nintros a b l l3 l4 H.\ncut (permutation (l ++ l3) (l ++ l4)); auto.\nintros; apply permutation_trans with (a :: b :: l ++ l4); auto.\nelim l; simpl in |- *; auto.\nintros l1 l2 l3 H H0 H1 H2 l4 l5 H3.\napply permutation_trans with (l2 ++ l4); auto.\nQed.\n", "definition": "\n forall l1 l2 l3 l4,\n permutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4).", "proof": "\nProof using.\nintros l1 l2 l3 l4 H1; generalize l3 l4; elim H1; clear H1 l1 l2 l3 l4;\n simpl in |- *; auto.\nintros a b l l3 l4 H.\ncut (permutation (l ++ l3) (l ++ l4)); auto.\nintros; apply permutation_trans with (a :: b :: l ++ l4); auto.\nelim l; simpl in |- *; auto.\nintros l1 l2 l3 H H0 H1 H2 l4 l5 H3.\napply permutation_trans with (l2 ++ l4); auto.\n", "def_ranges": [115, 0, 117, 77], "proof_ranges": [118, 0, 127, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 l3 l4 : list A,\npermutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4)"], "goal_after": ["forall l1 l2 l3 l4 : list A,\npermutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1 l2 l3 l4 H1; generalize l3 l4; elim H1; clear H1 l1 l2 l3 l4;", "goal_before": ["forall l1 l2 l3 l4 : list A,\npermutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4)"], "goal_after": ["forall l1 l2 l3 l4 : list A,\npermutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4)"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": ["forall l1 l2 l3 l4 : list A,\npermutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4)"], "goal_after": ["forall l1 l2 l3 l4 : list A,\npermutation l1 l2 -> permutation l3 l4 -> permutation (l1 ++ l3) (l2 ++ l4)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b l l3 l4 H.", "goal_before": ["permutation (a ++ l) (b ++ l3)"], "goal_after": ["permutation (a ++ l) (b ++ l3)"], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (permutation (l ++ l3) (l ++ l4)); auto.", "goal_before": ["permutation (a ++ l) (b ++ l3)"], "goal_after": ["permutation (a ++ l) (b ++ l3)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; apply permutation_trans with (a :: b :: l ++ l4); auto.", "goal_before": ["permutation (a ++ l) (b ++ l3)"], "goal_after": ["permutation (a ++ l) (b ++ l3)"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim l; simpl in |- *; auto.", "goal_before": ["permutation (a ++ nil) (b ++ l3)", "forall (a0 : A) (l0 : list A),\npermutation (a ++ l0) (b ++ l3) -> permutation (a ++ a0 :: l0) (b ++ l3)"], "goal_after": ["permutation (a ++ nil) (b ++ l3)", "forall (a0 : A) (l0 : list A),\npermutation (a ++ l0) (b ++ l3) -> permutation (a ++ a0 :: l0) (b ++ l3)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 l3 H H0 H1 H2 l4 l5 H3.", "goal_before": ["permutation (a ++ nil) (b ++ l3)", "forall (a0 : A) (l0 : list A),\npermutation (a ++ l0) (b ++ l3) -> permutation (a ++ a0 :: l0) (b ++ l3)"], "goal_after": ["permutation (a ++ nil) (b ++ l3)", "forall (a0 : A) (l0 : list A),\npermutation (a ++ l0) (b ++ l3) -> permutation (a ++ a0 :: l0) (b ++ l3)"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_trans with (l2 ++ l4); auto.", "goal_before": ["permutation (a ++ nil) (b ++ l3)", "forall (a0 : A) (l0 : list A),\npermutation (a ++ l0) (b ++ l3) -> permutation (a ++ a0 :: l0) (b ++ l3)"], "goal_after": ["permutation (a ++ nil) (b ++ l3)", "forall (a0 : A) (l0 : list A),\npermutation (a ++ l0) (b ++ l3) -> permutation (a ++ a0 :: l0) (b ++ l3)"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_app_swap", "text": "Theorem permutation_app_swap :\n forall l1 l2, permutation (l1 ++ l2) (l2 ++ l1).\nProof using.\nintros l1; elim l1; auto.\nintros; rewrite <- app_nil_end; auto.\nintros a l H l2.\nreplace (l2 ++ a :: l) with ((l2 ++ a :: nil) ++ l).\napply permutation_trans with (l ++ l2 ++ a :: nil); auto.\napply permutation_trans with (((a :: nil) ++ l2) ++ l); auto.\nsimpl in |- *; auto.\napply permutation_trans with (l ++ (a :: nil) ++ l2); auto.\napply permutation_sym; auto.\nreplace (l2 ++ a :: l) with ((l2 ++ a :: nil) ++ l).\napply permutation_app_comp; auto.\nelim l2; simpl in |- *; auto.\nintros a0 l0 H0.\napply permutation_trans with (a0 :: a :: l0); auto.\napply (app_ass l2 (a :: nil) l).\napply (app_ass l2 (a :: nil) l).\nQed.\n", "definition": "\n forall l1 l2, permutation (l1 ++ l2) (l2 ++ l1).", "proof": "\nProof using.\nintros l1; elim l1; auto.\nintros; rewrite <- app_nil_end; auto.\nintros a l H l2.\nreplace (l2 ++ a :: l) with ((l2 ++ a :: nil) ++ l).\napply permutation_trans with (l ++ l2 ++ a :: nil); auto.\napply permutation_trans with (((a :: nil) ++ l2) ++ l); auto.\nsimpl in |- *; auto.\napply permutation_trans with (l ++ (a :: nil) ++ l2); auto.\napply permutation_sym; auto.\nreplace (l2 ++ a :: l) with ((l2 ++ a :: nil) ++ l).\napply permutation_app_comp; auto.\nelim l2; simpl in |- *; auto.\nintros a0 l0 H0.\napply permutation_trans with (a0 :: a :: l0); auto.\napply (app_ass l2 (a :: nil) l).\napply (app_ass l2 (a :: nil) l).\n", "def_ranges": [131, 0, 132, 49], "proof_ranges": [133, 0, 150, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 : list A, permutation (l1 ++ l2) (l2 ++ l1)"], "goal_after": ["forall l1 l2 : list A, permutation (l1 ++ l2) (l2 ++ l1)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; auto.", "goal_before": ["forall l1 l2 : list A, permutation (l1 ++ l2) (l2 ++ l1)"], "goal_after": ["forall l2 : list A, permutation (nil ++ l2) (l2 ++ nil)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   ?Goal ?Goal0 l1)"]}, {"text": "intros; rewrite <- app_nil_end; auto.", "goal_before": ["forall l2 : list A, permutation (nil ++ l2) (l2 ++ nil)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   ?Goal ?Goal0 l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"]}, {"text": "intros a l H l2.", "goal_before": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"]}, {"text": "replace (l2 ++ a :: l) with ((l2 ++ a :: nil) ++ l).", "goal_before": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"]}, {"text": "apply permutation_trans with (l ++ l2 ++ a :: nil); auto.", "goal_before": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"]}, {"text": "apply permutation_trans with (((a :: nil) ++ l2) ++ l); auto.", "goal_before": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"]}, {"text": "simpl in |- *; auto.", "goal_before": ["permutation (nil ++ l2) l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l) \n      ?Goal0 (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (?Goal0 : permutation (nil ++ l2) l2) (l2 ++ nil) \n      (app_nil_end l2)) ?Goal l1)"]}, {"text": "apply permutation_trans with (l ++ (a :: nil) ++ l2); auto.", "goal_before": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (?Goal0 : permutation (nil ++ l2) l2) (l2 ++ nil) \n      (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (?Goal0 : permutation (nil ++ l2) l2) (l2 ++ nil) \n      (app_nil_end l2)) ?Goal l1)"]}, {"text": "apply permutation_sym; auto.", "goal_before": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (?Goal0 : permutation (nil ++ l2) l2) (l2 ++ nil) \n      (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2 ?Goal0 : permutation (nil ++ l2) l2) \n      (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"]}, {"text": "replace (l2 ++ a :: l) with ((l2 ++ a :: nil) ++ l).", "goal_before": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2 ?Goal0 : permutation (nil ++ l2) l2) \n      (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2 ?Goal0 : permutation (nil ++ l2) l2) \n      (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"]}, {"text": "apply permutation_app_comp; auto.", "goal_before": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2 ?Goal0 : permutation (nil ++ l2) l2) \n      (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2 ?Goal0 : permutation (nil ++ l2) l2) \n      (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"]}, {"text": "elim l2; simpl in |- *; auto.", "goal_before": ["permutation l2 l2", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2 ?Goal0 : permutation (nil ++ l2) l2) \n      (l2 ++ nil) (app_nil_end l2)) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"]}, {"text": "intros a0 l0 H0.", "goal_before": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"]}, {"text": "apply permutation_trans with (a0 :: a :: l0); auto.", "goal_before": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"]}, {"text": "apply (app_ass l2 (a :: nil) l).", "goal_before": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"]}, {"text": "apply (app_ass l2 (a :: nil) l).", "goal_before": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"]}, {"text": "Qed.", "goal_before": ["permutation nil nil", "forall (a : A) (l : list A), permutation l l -> permutation (a :: l) (a :: l)", "forall (a : A) (l : list A),\n(forall l2 : list A, permutation (l ++ l2) (l2 ++ l)) ->\nforall l2 : list A, permutation ((a :: l) ++ l2) (l2 ++ a :: l)"], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 : list A, permutation (l2 ++ l3) (l3 ++ l2))\n   (fun l2 : list A =>\n    eq_ind l2 (fun l : list A => permutation (nil ++ l2) l)\n      (permutation_sym l2 l2\n         (list_ind (fun l3 : list A => permutation l3 l3)\n            (?Goal0 : permutation nil nil)\n            (?Goal1\n             :\n             forall (a : A) (l : list A),\n             permutation l l -> permutation (a :: l) (a :: l)) l2)\n       :\n       permutation (nil ++ l2) l2) (l2 ++ nil) (app_nil_end l2)) \n   ?Goal l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_transposition", "text": "Theorem permutation_transposition :\n forall a b l1 l2 l3,\n permutation (l1 ++ a :: l2 ++ b :: l3) (l1 ++ b :: l2 ++ a :: l3).\nProof using.\nintros a b l1 l2 l3.\napply permutation_app_comp; auto.\nchange\n  (permutation ((a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n     ((b :: nil) ++ l2 ++ (a :: nil) ++ l3)) in |- *.\nrepeat rewrite <- app_ass.\napply permutation_app_comp; auto.\napply permutation_trans with ((b :: nil) ++ (a :: nil) ++ l2); auto.\napply permutation_app_swap; auto.\nrepeat rewrite app_ass.\napply permutation_app_comp; auto.\napply permutation_app_swap; auto.\nQed.\n", "definition": "\n forall a b l1 l2 l3,\n permutation (l1 ++ a :: l2 ++ b :: l3) (l1 ++ b :: l2 ++ a :: l3).", "proof": "\nProof using.\nintros a b l1 l2 l3.\napply permutation_app_comp; auto.\nchange\n  (permutation ((a :: nil) ++ l2 ++ (b :: nil) ++ l3)\n     ((b :: nil) ++ l2 ++ (a :: nil) ++ l3)) in |- *.\nrepeat rewrite <- app_ass.\napply permutation_app_comp; auto.\napply permutation_trans with ((b :: nil) ++ (a :: nil) ++ l2); auto.\napply permutation_app_swap; auto.\nrepeat rewrite app_ass.\napply permutation_app_comp; auto.\napply permutation_app_swap; auto.\n", "def_ranges": [153, 0, 155, 67], "proof_ranges": [156, 0, 169, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a b : A) (l1 l2 l3 : list A),\npermutation (l1 ++ a :: l2 ++ b :: l3) (l1 ++ b :: l2 ++ a :: l3)"], "goal_after": ["forall (a b : A) (l1 l2 l3 : list A),\npermutation (l1 ++ a :: l2 ++ b :: l3) (l1 ++ b :: l2 ++ a :: l3)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a b l1 l2 l3.", "goal_before": ["forall (a b : A) (l1 l2 l3 : list A),\npermutation (l1 ++ a :: l2 ++ b :: l3) (l1 ++ b :: l2 ++ a :: l3)"], "goal_after": ["permutation (l1 ++ a :: l2 ++ b :: l3) (l1 ++ b :: l2 ++ a :: l3)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) => ?Goal)"]}, {"text": "apply permutation_app_comp; auto.", "goal_before": ["permutation (l1 ++ a :: l2 ++ b :: l3) (l1 ++ b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) => ?Goal)"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3) \n   ?Goal ?Goal0)"]}, {"text": "change", "goal_before": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3) \n   ?Goal ?Goal0)"], "proof_term_after": []}, {"text": "(permutation ((a :: nil) ++ l2 ++ (b :: nil) ++ l3)", "goal_before": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": [], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3) \n   ?Goal ?Goal0)"]}, {"text": "((b :: nil) ++ l2 ++ (a :: nil) ++ l3)) in |- *.", "goal_before": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3) \n   ?Goal ?Goal0)"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3) \n   ?Goal ?Goal0)"]}, {"text": "repeat rewrite <- app_ass.", "goal_before": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3) \n   ?Goal ?Goal0)"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3) \n   ?Goal ?Goal0)"]}, {"text": "apply permutation_app_comp; auto.", "goal_before": ["permutation l1 l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3) \n   ?Goal ?Goal0)"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"]}, {"text": "apply permutation_trans with ((b :: nil) ++ (a :: nil) ++ l2); auto.", "goal_before": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"]}, {"text": "apply permutation_app_swap; auto.", "goal_before": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"]}, {"text": "repeat rewrite app_ass.", "goal_before": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"]}, {"text": "apply permutation_app_comp; auto.", "goal_before": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"], "proof_term_after": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"]}, {"text": "apply permutation_app_swap; auto.", "goal_before": ["permutation l1 ((b :: nil) ++ (a :: nil) ++ l2)", "permutation ((b :: nil) ++ (a :: nil) ++ l2) l1", "permutation (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)"], "goal_after": [], "proof_term_before": ["(fun (a b : A) (l1 l2 l3 : list A) =>\n permutation_app_comp l1 l1 (a :: l2 ++ b :: l3) (b :: l2 ++ a :: l3)\n   (permutation_trans l1 ((b :: nil) ++ (a :: nil) ++ l2) l1 ?Goal0 ?Goal1)\n   ?Goal)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "in_permutation_ex", "text": "Theorem in_permutation_ex :\n forall a l, In a l -> exists l1 : list A, permutation (a :: l1) l.\nProof using.\nintros a l; elim l; simpl in |- *; auto.\nintros H; case H; auto.\nintros a0 l0 H [H0| H0].\nexists l0; rewrite H0; auto.\ncase H; auto; intros l1 Hl1; exists (a0 :: l1).\napply permutation_trans with (a0 :: a :: l1); auto.\nQed.\n", "definition": "\n forall a l, In a l -> exists l1 : list A, permutation (a :: l1) l.", "proof": "\nProof using.\nintros a l; elim l; simpl in |- *; auto.\nintros H; case H; auto.\nintros a0 l0 H [H0| H0].\nexists l0; rewrite H0; auto.\ncase H; auto; intros l1 Hl1; exists (a0 :: l1).\napply permutation_trans with (a0 :: a :: l1); auto.\n", "def_ranges": [172, 0, 173, 67], "proof_ranges": [174, 0, 181, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l : list A),\nIn a l -> exists l1 : list A, permutation (a :: l1) l"], "goal_after": ["forall (a : A) (l : list A),\nIn a l -> exists l1 : list A, permutation (a :: l1) l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l; elim l; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l : list A),\nIn a l -> exists l1 : list A, permutation (a :: l1) l"], "goal_after": ["False -> exists l1 : list A, permutation (a :: l1) nil", "forall (a0 : A) (l0 : list A),\n(In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\na0 = a \\/ In a l0 -> exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   (?Goal : In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   (?Goal0\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"]}, {"text": "intros H; case H; auto.", "goal_before": ["False -> exists l1 : list A, permutation (a :: l1) nil", "forall (a0 : A) (l0 : list A),\n(In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\na0 = a \\/ In a l0 -> exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "goal_after": ["forall (a0 : A) (l0 : list A),\n(In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\na0 = a \\/ In a l0 -> exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   (?Goal : In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   (?Goal0\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   (?Goal\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"]}, {"text": "intros a0 l0 H [H0| H0].", "goal_before": ["forall (a0 : A) (l0 : list A),\n(In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\na0 = a \\/ In a l0 -> exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "goal_after": ["exists l1 : list A, permutation (a :: l1) (a0 :: l0)", "exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   (?Goal\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n       (H1 : a0 = a \\/ In a l0) =>\n     match H1 with\n     | or_introl x => (fun H0 : a0 = a => ?Goal) x\n     | or_intror x => (fun H0 : In a l0 => ?Goal0) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"]}, {"text": "exists l0; rewrite H0; auto.", "goal_before": ["exists l1 : list A, permutation (a :: l1) (a0 :: l0)", "exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "goal_after": ["permutation (a :: l0) (a :: l0)", "exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n       (H1 : a0 = a \\/ In a l0) =>\n     match H1 with\n     | or_introl x => (fun H0 : a0 = a => ?Goal) x\n     | or_intror x => (fun H0 : In a l0 => ?Goal0) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n       (H1 : a0 = a \\/ In a l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro (fun l1 : list A => permutation (a :: l1) (a0 :: l0)) l0\n            (eq_ind_r (fun a1 : A => permutation (a :: l0) (a1 :: l0)) \n               ?Goal0 H0)) x\n     | or_intror x => (fun H0 : In a l0 => ?Goal) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"]}, {"text": "case H; auto; intros l1 Hl1; exists (a0 :: l1).", "goal_before": ["permutation (a :: l0) (a :: l0)", "exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "goal_after": ["permutation (a :: l0) (a :: l0)", "exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n       (H1 : a0 = a \\/ In a l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro (fun l1 : list A => permutation (a :: l1) (a0 :: l0)) l0\n            (eq_ind_r (fun a1 : A => permutation (a :: l0) (a1 :: l0)) \n               ?Goal0 H0)) x\n     | or_intror x => (fun H0 : In a l0 => ?Goal) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n       (H1 : a0 = a \\/ In a l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro (fun l1 : list A => permutation (a :: l1) (a0 :: l0)) l0\n            (eq_ind_r (fun a1 : A => permutation (a :: l0) (a1 :: l0)) \n               ?Goal0 H0)) x\n     | or_intror x => (fun H0 : In a l0 => ?Goal) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"]}, {"text": "apply permutation_trans with (a0 :: a :: l1); auto.", "goal_before": ["permutation (a :: l0) (a :: l0)", "exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "goal_after": ["permutation (a :: l0) (a :: l0)", "exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n       (H1 : a0 = a \\/ In a l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro (fun l1 : list A => permutation (a :: l1) (a0 :: l0)) l0\n            (eq_ind_r (fun a1 : A => permutation (a :: l0) (a1 :: l0)) \n               ?Goal0 H0)) x\n     | or_intror x => (fun H0 : In a l0 => ?Goal) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n       (H1 : a0 = a \\/ In a l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro (fun l1 : list A => permutation (a :: l1) (a0 :: l0)) l0\n            (eq_ind_r (fun a1 : A => permutation (a :: l0) (a1 :: l0)) \n               ?Goal0 H0)) x\n     | or_intror x => (fun H0 : In a l0 => ?Goal) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"]}, {"text": "Qed.", "goal_before": ["permutation (a :: l0) (a :: l0)", "exists l1 : list A, permutation (a :: l1) (a0 :: l0)"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A =>\n    In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n   ((fun H : False =>\n     match H return (exists l1 : list A, permutation (a :: l1) nil) with\n     end)\n    :\n    In a nil -> exists l1 : list A, permutation (a :: l1) nil)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 : list A, permutation (a :: l1) l0)\n       (H1 : a0 = a \\/ In a l0) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro (fun l1 : list A => permutation (a :: l1) (a0 :: l0)) l0\n            (eq_ind_r (fun a1 : A => permutation (a :: l0) (a1 :: l0)) \n               ?Goal0 H0)) x\n     | or_intror x => (fun H0 : In a l0 => ?Goal) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 : list A, permutation (a :: l1) l0) ->\n    In a (a0 :: l0) -> exists l1 : list A, permutation (a :: l1) (a0 :: l0))\n   l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_cons_ex", "text": "Theorem permutation_cons_ex :\n forall (a : A) (l1 l2 : list A),\n permutation (a :: l1) l2 ->\n exists l3 : list A,\n   (exists l4 : list A, l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)).\nProof using.  \nintros a l1 l2 H.\napply (permutation_cons_ex_aux a (a :: l1) l2 H nil l1); simpl in |- *; auto.\nQed.\n", "definition": "\n forall (a : A) (l1 l2 : list A),\n permutation (a :: l1) l2 ->\n exists l3 : list A,\n   (exists l4 : list A, l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)).", "proof": "\nProof using.  \nintros a l1 l2 H.\napply (permutation_cons_ex_aux a (a :: l1) l2 H nil l1); simpl in |- *; auto.\n", "def_ranges": [227, 0, 231, 73], "proof_ranges": [232, 0, 235, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l1 l2 : list A),\npermutation (a :: l1) l2 ->\nexists l3 l4 : list A, l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)"], "goal_after": ["forall (a : A) (l1 l2 : list A),\npermutation (a :: l1) l2 ->\nexists l3 l4 : list A, l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l1 l2 H.", "goal_before": ["forall (a : A) (l1 l2 : list A),\npermutation (a :: l1) l2 ->\nexists l3 l4 : list A, l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)"], "goal_after": ["exists l3 l4 : list A, l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) l2) => ?Goal)"]}, {"text": "apply (permutation_cons_ex_aux a (a :: l1) l2 H nil l1); simpl in |- *; auto.", "goal_before": ["exists l3 l4 : list A, l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) l2) => ?Goal)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) l2) =>\n permutation_cons_ex_aux a (a :: l1) l2 H nil l1\n   (eq_refl : a :: l1 = nil ++ a :: l1))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) l2) =>\n permutation_cons_ex_aux a (a :: l1) l2 H nil l1\n   (eq_refl : a :: l1 = nil ++ a :: l1))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_inv", "text": "Theorem permutation_inv :\n forall (a : A) (l1 l2 : list A),\n permutation (a :: l1) (a :: l2) -> permutation l1 l2.\nProof using.\nintros a l1 l2 H; case permutation_cons_ex with (1 := H).\nintros l3 (l4, (Hl1, Hl2)).\napply permutation_trans with (1 := Hl2).\ngeneralize Hl1; case l3; simpl in |- *; auto.\nintros H1; injection H1; intros H2; rewrite H2; auto.\nintros a0 l5 H1; injection H1; intros H2 H3; rewrite H2; rewrite H3; auto.\napply permutation_trans with (a0 :: l4 ++ l5); auto.\napply permutation_skip; apply permutation_app_swap.\napply (permutation_app_swap (a0 :: l4) l5).\nQed.\n", "definition": "\n forall (a : A) (l1 l2 : list A),\n permutation (a :: l1) (a :: l2) -> permutation l1 l2.", "proof": "\nProof using.\nintros a l1 l2 H; case permutation_cons_ex with (1 := H).\nintros l3 (l4, (Hl1, Hl2)).\napply permutation_trans with (1 := Hl2).\ngeneralize Hl1; case l3; simpl in |- *; auto.\nintros H1; injection H1; intros H2; rewrite H2; auto.\nintros a0 l5 H1; injection H1; intros H2 H3; rewrite H2; rewrite H3; auto.\napply permutation_trans with (a0 :: l4 ++ l5); auto.\napply permutation_skip; apply permutation_app_swap.\napply (permutation_app_swap (a0 :: l4) l5).\n", "def_ranges": [238, 0, 240, 54], "proof_ranges": [241, 0, 251, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l1 l2 : list A),\npermutation (a :: l1) (a :: l2) -> permutation l1 l2"], "goal_after": ["forall (a : A) (l1 l2 : list A),\npermutation (a :: l1) (a :: l2) -> permutation l1 l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l1 l2 H; case permutation_cons_ex with (1 := H).", "goal_before": ["forall (a : A) (l1 l2 : list A),\npermutation (a :: l1) (a :: l2) -> permutation l1 l2"], "goal_after": ["forall x : list A,\n(exists l4 : list A, a :: l2 = x ++ a :: l4 /\\ permutation l1 (x ++ l4)) ->\npermutation l1 l2"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 => ?Goal x x0\n end)"]}, {"text": "intros l3 (l4, (Hl1, Hl2)).", "goal_before": ["forall x : list A,\n(exists l4 : list A, a :: l2 = x ++ a :: l4 /\\ permutation l1 (x ++ l4)) ->\npermutation l1 l2"], "goal_after": ["permutation l1 l2"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 => ?Goal x x0\n end)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) => \n                ?Goal) x3 x4\n           end) x1 x2\n      end) x x0\n end)"]}, {"text": "apply permutation_trans with (1 := Hl2).", "goal_before": ["permutation l1 l2"], "goal_after": ["permutation (l3 ++ l4) l2"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) => \n                ?Goal) x3 x4\n           end) x1 x2\n      end) x x0\n end)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2 ?Goal) x3 x4\n           end) x1 x2\n      end) x x0\n end)"]}, {"text": "generalize Hl1; case l3; simpl in |- *; auto.", "goal_before": ["permutation (l3 ++ l4) l2"], "goal_after": ["a :: l2 = a :: l4 -> permutation l4 l2", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2 ?Goal) x3 x4\n           end) x1 x2\n      end) x x0\n end)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       ?Goal\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal0\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"]}, {"text": "intros H1; injection H1; intros H2; rewrite H2; auto.", "goal_before": ["a :: l2 = a :: l4 -> permutation l4 l2", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "goal_after": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       ?Goal\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal0\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"]}, {"text": "intros a0 l5 H1; injection H1; intros H2 H3; rewrite H2; rewrite H3; auto.", "goal_before": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "goal_after": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"]}, {"text": "apply permutation_trans with (a0 :: l4 ++ l5); auto.", "goal_before": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "goal_after": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"]}, {"text": "apply permutation_skip; apply permutation_app_swap.", "goal_before": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "goal_after": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"]}, {"text": "apply (permutation_app_swap (a0 :: l4) l5).", "goal_before": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "goal_after": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"]}, {"text": "Qed.", "goal_before": ["permutation l4 l4", "forall (a0 : A) (l : list A),\na :: l2 = a0 :: l ++ a :: l4 -> permutation (a0 :: l ++ l4) l2"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) (H : permutation (a :: l1) (a :: l2)) =>\n match permutation_cons_ex a l1 (a :: l2) H with\n | ex_intro _ x x0 =>\n     (fun (l3 : list A)\n        (H0 : exists l4 : list A,\n                a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n      match H0 with\n      | ex_intro _ x1 x2 =>\n          (fun (l4 : list A)\n             (H1 : a :: l2 = l3 ++ a :: l4 /\\ permutation l1 (l3 ++ l4)) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (Hl1 : a :: l2 = l3 ++ a :: l4)\n                  (Hl2 : permutation l1 (l3 ++ l4)) =>\n                permutation_trans l1 (l3 ++ l4) l2 Hl2\n                  (match\n                     l3 as l\n                     return\n                       (a :: l2 = l ++ a :: l4 -> permutation (l ++ l4) l2)\n                   with\n                   | nil =>\n                       (fun H2 : a :: l2 = a :: l4 =>\n                        let H3 : l2 = l4 :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | nil => l2\n                             | _ :: l => l\n                             end) H2 in\n                        (fun H4 : l2 = l4 =>\n                         eq_ind_r (fun l5 : list A => permutation l4 l5)\n                           ?Goal0@{H1:=H2; H2:=H4} H4) H3)\n                       :\n                       a :: l2 = nil ++ a :: l4 -> permutation (nil ++ l4) l2\n                   | a0 :: l =>\n                       (?Goal\n                        :\n                        forall (a1 : A) (l0 : list A),\n                        a :: l2 = (a1 :: l0) ++ a :: l4 ->\n                        permutation ((a1 :: l0) ++ l4) l2) a0 l\n                   end Hl1)) x3 x4\n           end) x1 x2\n      end) x x0\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "split_one_permutation", "text": "Theorem split_one_permutation :\n forall (a : A) (l1 l2 : list A),\n In (a, l1) (split_one l2) -> permutation (a :: l1) l2.\nProof using.\nintros a l1 l2; generalize a l1; elim l2; clear a l1 l2; simpl in |- *; auto.\nintros a l1 H1; case H1.\nintros a l H a0 l1 [H0| H0].\ninjection H0; intros H1 H2; rewrite H2; rewrite H1; auto.\ngeneralize H H0; elim (split_one l); simpl in |- *; auto.\nintros H1 H2; case H2.\nintros a1 l0 H1 H2 [H3| H3]; auto.\ninjection H3; intros H4 H5; (rewrite <- H4; rewrite <- H5).\napply permutation_trans with (a :: fst a1 :: snd a1); auto.\napply permutation_skip.\napply H2; auto.\ncase a1; simpl in |- *; auto.\nQed.\n", "definition": "\n forall (a : A) (l1 l2 : list A),\n In (a, l1) (split_one l2) -> permutation (a :: l1) l2.", "proof": "\nProof using.\nintros a l1 l2; generalize a l1; elim l2; clear a l1 l2; simpl in |- *; auto.\nintros a l1 H1; case H1.\nintros a l H a0 l1 [H0| H0].\ninjection H0; intros H1 H2; rewrite H2; rewrite H1; auto.\ngeneralize H H0; elim (split_one l); simpl in |- *; auto.\nintros H1 H2; case H2.\nintros a1 l0 H1 H2 [H3| H3]; auto.\ninjection H3; intros H4 H5; (rewrite <- H4; rewrite <- H5).\napply permutation_trans with (a :: fst a1 :: snd a1); auto.\napply permutation_skip.\napply H2; auto.\ncase a1; simpl in |- *; auto.\n", "def_ranges": [263, 0, 265, 55], "proof_ranges": [266, 0, 279, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l1 l2 : list A),\nIn (a, l1) (split_one l2) -> permutation (a :: l1) l2"], "goal_after": ["forall (a : A) (l1 l2 : list A),\nIn (a, l1) (split_one l2) -> permutation (a :: l1) l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l1 l2; generalize a l1; elim l2; clear a l1 l2; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l1 l2 : list A),\nIn (a, l1) (split_one l2) -> permutation (a :: l1) l2"], "goal_after": ["forall (a : A) (l1 : list A), False -> permutation (a :: l1) nil", "forall (a : A) (l : list A),\n(forall (a0 : A) (l1 : list A),\n In (a0, l1) (split_one l) -> permutation (a0 :: l1) l) ->\nforall (a0 : A) (l1 : list A),\n(a, l) = (a0, l1) \\/\nIn (a0, l1) (map (fun p : A * list A => (fst p, a :: snd p)) (split_one l)) ->\npermutation (a0 :: l1) (a :: l)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   (?Goal\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   (?Goal0\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "intros a l1 H1; case H1.", "goal_before": ["forall (a : A) (l1 : list A), False -> permutation (a :: l1) nil", "forall (a : A) (l : list A),\n(forall (a0 : A) (l1 : list A),\n In (a0, l1) (split_one l) -> permutation (a0 :: l1) l) ->\nforall (a0 : A) (l1 : list A),\n(a, l) = (a0, l1) \\/\nIn (a0, l1) (map (fun p : A * list A => (fst p, a :: snd p)) (split_one l)) ->\npermutation (a0 :: l1) (a :: l)"], "goal_after": ["forall (a : A) (l : list A),\n(forall (a0 : A) (l1 : list A),\n In (a0, l1) (split_one l) -> permutation (a0 :: l1) l) ->\nforall (a0 : A) (l1 : list A),\n(a, l) = (a0, l1) \\/\nIn (a0, l1) (map (fun p : A * list A => (fst p, a :: snd p)) (split_one l)) ->\npermutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   (?Goal\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   (?Goal0\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "intros a l H a0 l1 [H0| H0].", "goal_before": ["forall (a : A) (l : list A),\n(forall (a0 : A) (l1 : list A),\n In (a0, l1) (split_one l) -> permutation (a0 :: l1) l) ->\nforall (a0 : A) (l1 : list A),\n(a, l) = (a0, l1) \\/\nIn (a0, l1) (map (fun p : A * list A => (fst p, a :: snd p)) (split_one l)) ->\npermutation (a0 :: l1) (a :: l)"], "goal_after": ["permutation (a0 :: l1) (a :: l)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal0@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "injection H0; intros H1 H2; rewrite H2; rewrite H1; auto.", "goal_before": ["permutation (a0 :: l1) (a :: l)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal0@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 ?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5} H4) H5) H3)\n            H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "generalize H H0; elim (split_one l); simpl in |- *; auto.", "goal_before": ["permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 ?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5} H4) H5) H3)\n            H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "intros H1 H2; case H2.", "goal_before": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "intros a1 l0 H1 H2 [H3| H3]; auto.", "goal_before": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "injection H3; intros H4 H5; (rewrite <- H4; rewrite <- H5).", "goal_before": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "apply permutation_trans with (a :: fst a1 :: snd a1); auto.", "goal_before": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "apply permutation_skip.", "goal_before": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "apply H2; auto.", "goal_before": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "case a1; simpl in |- *; auto.", "goal_before": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"]}, {"text": "Qed.", "goal_before": ["(forall (a1 : A) (l2 : list A), False -> permutation (a1 :: l2) l) ->\n(a, l) = (a0, l1) -> permutation (a0 :: l1) (a0 :: l1)", "permutation (a0 :: l1) (a :: l)"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 l2 : list A) =>\n list_ind\n   (fun l3 : list A =>\n    forall (a0 : A) (l4 : list A),\n    In (a0, l4) (split_one l3) -> permutation (a0 :: l4) l3)\n   ((fun (a0 : A) (l3 : list A) (H1 : False) =>\n     match H1 return (permutation (a0 :: l3) nil) with\n     end)\n    :\n    forall (a0 : A) (l3 : list A),\n    In (a0, l3) (split_one nil) -> permutation (a0 :: l3) nil)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (a1 : A) (l3 : list A),\n            In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) \n       (a1 : A) (l3 : list A)\n       (H1 : (a0, l) = (a1, l3) \\/\n             In (a1, l3)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : (a0, l) = (a1, l3) =>\n          let H2 : a0 = a1 :=\n            f_equal (fun e : A * list A => let (a2, _) := e in a2) H0 in\n          (let H3 : l = l3 :=\n             f_equal (fun e : A * list A => let (_, l0) := e in l0) H0 in\n           (fun (H4 : l = l3) (H5 : a0 = a1) =>\n            eq_ind_r (fun a2 : A => permutation (a1 :: l3) (a2 :: l))\n              (eq_ind_r\n                 (fun l0 : list A => permutation (a1 :: l3) (a1 :: l0))\n                 (list_ind\n                    (fun l0 : list (A * list A) =>\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) l0 -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (?Goal0@{a:=a0; a0:=a1; l1:=l3; H1:=H4; H2:=H5}\n                     :\n                     (forall (a2 : A) (l4 : list A),\n                      In (a2, l4) nil -> permutation (a2 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    ((fun (a2 : A * list A) (l0 : list (A * list A))\n                        (H6 : (forall (a3 : A) (l4 : list A),\n                               In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                              (a0, l) = (a1, l3) ->\n                              permutation (a1 :: l3) (a1 :: l3))\n                        (H7 : forall (a3 : A) (l4 : list A),\n                              a2 = (a3, l4) \\/ In (a3, l4) l0 ->\n                              permutation (a3 :: l4) l)\n                        (H8 : (a0, l) = (a1, l3)) =>\n                      H6\n                        (fun (a3 : A) (l4 : list A) (H9 : In (a3, l4) l0) =>\n                         H7 a3 l4 (or_intror H9)) H8)\n                     :\n                     forall (a2 : A * list A) (l0 : list (A * list A)),\n                     ((forall (a3 : A) (l4 : list A),\n                       In (a3, l4) l0 -> permutation (a3 :: l4) l) ->\n                      (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3)) ->\n                     (forall (a3 : A) (l4 : list A),\n                      In (a3, l4) (a2 :: l0) -> permutation (a3 :: l4) l) ->\n                     (a0, l) = (a1, l3) -> permutation (a1 :: l3) (a1 :: l3))\n                    (split_one l) H H0) H4) H5) H3) H2) x\n     | or_intror x =>\n         (fun\n            H0 : In (a1, l3)\n                   (map (fun p : A * list A => (fst p, a0 :: snd p))\n                      (split_one l)) => ?Goal@{a:=a0; a0:=a1; l1:=l3}) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (a1 : A) (l3 : list A),\n     In (a1, l3) (split_one l) -> permutation (a1 :: l3) l) ->\n    forall (a1 : A) (l3 : list A),\n    In (a1, l3) (split_one (a0 :: l)) -> permutation (a1 :: l3) (a0 :: l)) l2\n   a l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "split_one_in_ex", "text": "Theorem split_one_in_ex :\n forall (a : A) (l1 : list A),\n In a l1 -> exists l2 : list A, In (a, l2) (split_one l1).\nProof using.\nintros a l1; elim l1; simpl in |- *; auto.\nintros H; case H.\nintros a0 l H [H0| H0]; auto.\nexists l; left; apply f_equal2 with (f := pair (A:=A) (B:=list A)); auto.\ncase H; auto.\nintros x H1; exists (a0 :: x); right; auto.\napply\n (in_map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l) (a, x));\n auto.\nQed.\n", "definition": "\n forall (a : A) (l1 : list A),\n In a l1 -> exists l2 : list A, In (a, l2) (split_one l1).", "proof": "\nProof using.\nintros a l1; elim l1; simpl in |- *; auto.\nintros H; case H.\nintros a0 l H [H0| H0]; auto.\nexists l; left; apply f_equal2 with (f := pair (A:=A) (B:=list A)); auto.\ncase H; auto.\nintros x H1; exists (a0 :: x); right; auto.\napply\n (in_map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l) (a, x));\n auto.\n", "def_ranges": [282, 0, 284, 58], "proof_ranges": [285, 0, 295, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l1 : list A),\nIn a l1 -> exists l2 : list A, In (a, l2) (split_one l1)"], "goal_after": ["forall (a : A) (l1 : list A),\nIn a l1 -> exists l2 : list A, In (a, l2) (split_one l1)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l1 : list A),\nIn a l1 -> exists l2 : list A, In (a, l2) (split_one l1)"], "goal_after": ["False -> exists _ : list A, False", "forall (a0 : A) (l : list A),\n(In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\na0 = a \\/ In a l ->\nexists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   (?Goal : In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   (?Goal0\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"]}, {"text": "intros H; case H.", "goal_before": ["False -> exists _ : list A, False", "forall (a0 : A) (l : list A),\n(In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\na0 = a \\/ In a l ->\nexists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "goal_after": ["forall (a0 : A) (l : list A),\n(In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\na0 = a \\/ In a l ->\nexists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   (?Goal : In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   (?Goal0\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"]}, {"text": "intros a0 l H [H0| H0]; auto.", "goal_before": ["forall (a0 : A) (l : list A),\n(In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\na0 = a \\/ In a l ->\nexists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "goal_after": ["exists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))", "exists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x => (fun H0 : a0 = a => ?Goal) x\n     | or_intror x => (fun H0 : In a l => ?Goal0) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"]}, {"text": "exists l; left; apply f_equal2 with (f := pair (A:=A) (B:=list A)); auto.", "goal_before": ["exists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))", "exists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "goal_after": ["exists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x => (fun H0 : a0 = a => ?Goal) x\n     | or_intror x => (fun H0 : In a l => ?Goal0) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro\n            (fun l2 : list A =>\n             (a0, l) = (a, l2) \\/\n             In (a, l2)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) l (or_introl (f_equal2 pair H0 eq_refl))) x\n     | or_intror x => (fun H0 : In a l => ?Goal) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"]}, {"text": "case H; auto.", "goal_before": ["exists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "goal_after": ["forall x : list A,\nIn (a, x) (split_one l) ->\nexists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro\n            (fun l2 : list A =>\n             (a0, l) = (a, l2) \\/\n             In (a, l2)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) l (or_introl (f_equal2 pair H0 eq_refl))) x\n     | or_intror x => (fun H0 : In a l => ?Goal) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro\n            (fun l2 : list A =>\n             (a0, l) = (a, l2) \\/\n             In (a, l2)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) l (or_introl (f_equal2 pair H0 eq_refl))) x\n     | or_intror x =>\n         (fun H0 : In a l =>\n          match H H0 with\n          | ex_intro _ x0 x1 => ?Goal x0 x1\n          end) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"]}, {"text": "intros x H1; exists (a0 :: x); right; auto.", "goal_before": ["forall x : list A,\nIn (a, x) (split_one l) ->\nexists l2 : list A,\n  (a0, l) = (a, l2) \\/\n  In (a, l2) (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "goal_after": ["In (a, a0 :: x)\n  (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro\n            (fun l2 : list A =>\n             (a0, l) = (a, l2) \\/\n             In (a, l2)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) l (or_introl (f_equal2 pair H0 eq_refl))) x\n     | or_intror x =>\n         (fun H0 : In a l =>\n          match H H0 with\n          | ex_intro _ x0 x1 => ?Goal x0 x1\n          end) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro\n            (fun l2 : list A =>\n             (a0, l) = (a, l2) \\/\n             In (a, l2)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) l (or_introl (f_equal2 pair H0 eq_refl))) x\n     | or_intror x =>\n         (fun H0 : In a l =>\n          match H H0 with\n          | ex_intro _ x0 x1 =>\n              (fun (x2 : list A) (H2 : In (a, x2) (split_one l)) =>\n               ex_intro\n                 (fun l2 : list A =>\n                  (a0, l) = (a, l2) \\/\n                  In (a, l2)\n                    (map (fun p : A * list A => (fst p, a0 :: snd p))\n                       (split_one l))) (a0 :: x2)\n                 (or_intror ?Goal@{x:=x2; H1:=H2})) x0 x1\n          end) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"]}, {"text": "apply", "goal_before": ["In (a, a0 :: x)\n  (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "goal_after": ["In (a, a0 :: x)\n  (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro\n            (fun l2 : list A =>\n             (a0, l) = (a, l2) \\/\n             In (a, l2)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) l (or_introl (f_equal2 pair H0 eq_refl))) x\n     | or_intror x =>\n         (fun H0 : In a l =>\n          match H H0 with\n          | ex_intro _ x0 x1 =>\n              (fun (x2 : list A) (H2 : In (a, x2) (split_one l)) =>\n               ex_intro\n                 (fun l2 : list A =>\n                  (a0, l) = (a, l2) \\/\n                  In (a, l2)\n                    (map (fun p : A * list A => (fst p, a0 :: snd p))\n                       (split_one l))) (a0 :: x2)\n                 (or_intror ?Goal@{x:=x2; H1:=H2})) x0 x1\n          end) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"], "proof_term_after": []}, {"text": "(in_map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l) (a, x));", "goal_before": ["In (a, a0 :: x)\n  (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "goal_after": ["In (a, a0 :: x)\n  (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "proof_term_before": [], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro\n            (fun l2 : list A =>\n             (a0, l) = (a, l2) \\/\n             In (a, l2)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) l (or_introl (f_equal2 pair H0 eq_refl))) x\n     | or_intror x =>\n         (fun H0 : In a l =>\n          match H H0 with\n          | ex_intro _ x0 x1 =>\n              (fun (x2 : list A) (H2 : In (a, x2) (split_one l)) =>\n               ex_intro\n                 (fun l2 : list A =>\n                  (a0, l) = (a, l2) \\/\n                  In (a, l2)\n                    (map (fun p : A * list A => (fst p, a0 :: snd p))\n                       (split_one l))) (a0 :: x2)\n                 (or_intror ?Goal@{x:=x2; H1:=H2})) x0 x1\n          end) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"]}, {"text": "auto.", "goal_before": ["In (a, a0 :: x)\n  (map (fun p : A * list A => (fst p, a0 :: snd p)) (split_one l))"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    In a l2 -> exists l3 : list A, In (a, l3) (split_one l2))\n   ((fun H : False => match H return (exists _ : list A, False) with\n                      end)\n    :\n    In a nil -> exists l2 : list A, In (a, l2) (split_one nil))\n   ((fun (a0 : A) (l : list A)\n       (H : In a l -> exists l2 : list A, In (a, l2) (split_one l))\n       (H1 : a0 = a \\/ In a l) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : a0 = a =>\n          ex_intro\n            (fun l2 : list A =>\n             (a0, l) = (a, l2) \\/\n             In (a, l2)\n               (map (fun p : A * list A => (fst p, a0 :: snd p))\n                  (split_one l))) l (or_introl (f_equal2 pair H0 eq_refl))) x\n     | or_intror x =>\n         (fun H0 : In a l =>\n          match H H0 with\n          | ex_intro _ x0 x1 =>\n              (fun (x2 : list A) (H2 : In (a, x2) (split_one l)) =>\n               ex_intro\n                 (fun l2 : list A =>\n                  (a0, l) = (a, l2) \\/\n                  In (a, l2)\n                    (map (fun p : A * list A => (fst p, a0 :: snd p))\n                       (split_one l))) (a0 :: x2)\n                 (or_intror ?Goal@{x:=x2; H1:=H2})) x0 x1\n          end) x\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (In a l -> exists l2 : list A, In (a, l2) (split_one l)) ->\n    In a (a0 :: l) -> exists l2 : list A, In (a, l2) (split_one (a0 :: l)))\n   l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "all_permutations_permutation", "text": "Theorem all_permutations_permutation :\n forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2.\nProof using.\nintros l1 l2 H; apply all_permutations_aux_permutation with (n := length l2);\n auto.\nQed.\n", "definition": "\n forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2.", "proof": "\nProof using.\nintros l1 l2 H; apply all_permutations_aux_permutation with (n := length l2);\n auto.\n", "def_ranges": [340, 0, 341, 73], "proof_ranges": [342, 0, 345, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2"], "goal_after": ["forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1 l2 H; apply all_permutations_aux_permutation with (n := length l2);", "goal_before": ["forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2"], "goal_after": ["forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "auto.", "goal_before": ["forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2"], "goal_after": ["forall l1 l2 : list A, In l1 (all_permutations l2) -> permutation l1 l2"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_all_permutations", "text": "Theorem permutation_all_permutations :\n forall l1 l2 : list A, permutation l1 l2 -> In l1 (all_permutations l2).\nProof using.\nintros l1 l2 H; unfold all_permutations in |- *;\n apply permutation_all_permutations_aux; auto.\nQed.\n", "definition": "\n forall l1 l2 : list A, permutation l1 l2 -> In l1 (all_permutations l2).", "proof": "\nProof using.\nintros l1 l2 H; unfold all_permutations in |- *;\n apply permutation_all_permutations_aux; auto.\n", "def_ranges": [377, 0, 378, 73], "proof_ranges": [379, 0, 382, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 : list A, permutation l1 l2 -> In l1 (all_permutations l2)"], "goal_after": ["forall l1 l2 : list A, permutation l1 l2 -> In l1 (all_permutations l2)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1 l2 H; unfold all_permutations in |- *;", "goal_before": ["forall l1 l2 : list A, permutation l1 l2 -> In l1 (all_permutations l2)"], "goal_after": ["forall l1 l2 : list A, permutation l1 l2 -> In l1 (all_permutations l2)"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "apply permutation_all_permutations_aux; auto.", "goal_before": ["forall l1 l2 : list A, permutation l1 l2 -> In l1 (all_permutations l2)"], "goal_after": ["forall l1 l2 : list A, permutation l1 l2 -> In l1 (all_permutations l2)"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_map", "text": "Theorem permutation_map :\n forall (A B : Type) (f : A -> B) l1 l2,\n permutation l1 l2 -> permutation (map f l1) (map f l2).\nProof using.\nintros A B f l1 l2 H; elim H; simpl in |- *; auto.\nintros l0 l3 l4 H0 H1 H2 H3; apply permutation_trans with (2 := H3); auto.\nQed.\n", "definition": "\n forall (A B : Type) (f : A -> B) l1 l2,\n permutation l1 l2 -> permutation (map f l1) (map f l2).", "proof": "\nProof using.\nintros A B f l1 l2 H; elim H; simpl in |- *; auto.\nintros l0 l3 l4 H0 H1 H2 H3; apply permutation_trans with (2 := H3); auto.\n", "def_ranges": [409, 0, 411, 56], "proof_ranges": [412, 0, 415, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (A B : Type) (f : A -> B) (l1 l2 : list A),\npermutation l1 l2 -> permutation (map f l1) (map f l2)"], "goal_after": ["forall (A B : Type) (f : A -> B) (l1 l2 : list A),\npermutation l1 l2 -> permutation (map f l1) (map f l2)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros A B f l1 l2 H; elim H; simpl in |- *; auto.", "goal_before": ["forall (A B : Type) (f : A -> B) (l1 l2 : list A),\npermutation l1 l2 -> permutation (map f l1) (map f l2)"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (map f l3) (map f l0) ->\npermutation (f a :: map f l3) (f a :: map f l0)", "forall (a b : A) (l : list A),\npermutation (f a :: f b :: map f l) (f b :: f a :: map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (map f l0) (map f l3) ->\npermutation l3 l4 ->\npermutation (map f l3) (map f l4) -> permutation (map f l0) (map f l4)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (A B : Type) (f : A -> B) (l1 l2 : list A) (H : permutation l1 l2) =>\n permutation_ind A (fun l3 l4 : list A => permutation (map f l3) (map f l4))\n   (?Goal : permutation (map f nil) (map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (map f l4) (map f l3) ->\n    permutation (map f (a :: l4)) (map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (map f (a :: b :: l)) (map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (map f l3) (map f l4) ->\n    permutation l4 l5 ->\n    permutation (map f l4) (map f l5) -> permutation (map f l3) (map f l5))\n   l1 l2 H)"]}, {"text": "intros l0 l3 l4 H0 H1 H2 H3; apply permutation_trans with (2 := H3); auto.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (map f l3) (map f l0) ->\npermutation (f a :: map f l3) (f a :: map f l0)", "forall (a b : A) (l : list A),\npermutation (f a :: f b :: map f l) (f b :: f a :: map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (map f l0) (map f l3) ->\npermutation l3 l4 ->\npermutation (map f l3) (map f l4) -> permutation (map f l0) (map f l4)"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (map f l3) (map f l0) ->\npermutation (f a :: map f l3) (f a :: map f l0)", "forall (a b : A) (l : list A),\npermutation (f a :: f b :: map f l) (f b :: f a :: map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (map f l0) (map f l3) ->\npermutation l3 l4 ->\npermutation (map f l3) (map f l4) -> permutation (map f l0) (map f l4)"], "proof_term_before": ["(fun (A B : Type) (f : A -> B) (l1 l2 : list A) (H : permutation l1 l2) =>\n permutation_ind A (fun l3 l4 : list A => permutation (map f l3) (map f l4))\n   (?Goal : permutation (map f nil) (map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (map f l4) (map f l3) ->\n    permutation (map f (a :: l4)) (map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (map f (a :: b :: l)) (map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (map f l3) (map f l4) ->\n    permutation l4 l5 ->\n    permutation (map f l4) (map f l5) -> permutation (map f l3) (map f l5))\n   l1 l2 H)"], "proof_term_after": ["(fun (A B : Type) (f : A -> B) (l1 l2 : list A) (H : permutation l1 l2) =>\n permutation_ind A (fun l3 l4 : list A => permutation (map f l3) (map f l4))\n   (?Goal : permutation (map f nil) (map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (map f l4) (map f l3) ->\n    permutation (map f (a :: l4)) (map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (map f (a :: b :: l)) (map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (map f l3) (map f l4) ->\n    permutation l4 l5 ->\n    permutation (map f l4) (map f l5) -> permutation (map f l3) (map f l5))\n   l1 l2 H)"]}, {"text": "Qed.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (map f l3) (map f l0) ->\npermutation (f a :: map f l3) (f a :: map f l0)", "forall (a b : A) (l : list A),\npermutation (f a :: f b :: map f l) (f b :: f a :: map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (map f l0) (map f l3) ->\npermutation l3 l4 ->\npermutation (map f l3) (map f l4) -> permutation (map f l0) (map f l4)"], "goal_after": [], "proof_term_before": ["(fun (A B : Type) (f : A -> B) (l1 l2 : list A) (H : permutation l1 l2) =>\n permutation_ind A (fun l3 l4 : list A => permutation (map f l3) (map f l4))\n   (?Goal : permutation (map f nil) (map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (map f l4) (map f l3) ->\n    permutation (map f (a :: l4)) (map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (map f (a :: b :: l)) (map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (map f l3) (map f l4) ->\n    permutation l4 l5 ->\n    permutation (map f l4) (map f l5) -> permutation (map f l3) (map f l5))\n   l1 l2 H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_map_ex", "text": "Theorem permutation_map_ex :\n forall (A B : Type) (f : A -> B) l1 l2,\n permutation (map f l1) l2 ->\n exists l3 : _, permutation l3 l1 /\\ l2 = map f l3.\nProof using.  \nintros A0 B f l1 l2 H; apply permutation_map_ex_aux with (l1 := map f l1);\n auto.\nQed.\n", "definition": "\n forall (A B : Type) (f : A -> B) l1 l2,\n permutation (map f l1) l2 ->\n exists l3 : _, permutation l3 l1 /\\ l2 = map f l3.", "proof": "\nProof using.  \nintros A0 B f l1 l2 H; apply permutation_map_ex_aux with (l1 := map f l1);\n auto.\n", "def_ranges": [448, 0, 451, 51], "proof_ranges": [452, 0, 455, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (A B : Type) (f : A -> B) (l1 : list A) (l2 : list B),\npermutation (map f l1) l2 ->\nexists l3 : list A, permutation l3 l1 /\\ l2 = map f l3"], "goal_after": ["forall (A B : Type) (f : A -> B) (l1 : list A) (l2 : list B),\npermutation (map f l1) l2 ->\nexists l3 : list A, permutation l3 l1 /\\ l2 = map f l3"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros A0 B f l1 l2 H; apply permutation_map_ex_aux with (l1 := map f l1);", "goal_before": ["forall (A B : Type) (f : A -> B) (l1 : list A) (l2 : list B),\npermutation (map f l1) l2 ->\nexists l3 : list A, permutation l3 l1 /\\ l2 = map f l3"], "goal_after": ["forall (A B : Type) (f : A -> B) (l1 : list A) (l2 : list B),\npermutation (map f l1) l2 ->\nexists l3 : list A, permutation l3 l1 /\\ l2 = map f l3"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "auto.", "goal_before": ["forall (A B : Type) (f : A -> B) (l1 : list A) (l2 : list B),\npermutation (map f l1) l2 ->\nexists l3 : list A, permutation l3 l1 /\\ l2 = map f l3"], "goal_after": ["forall (A B : Type) (f : A -> B) (l1 : list A) (l2 : list B),\npermutation (map f l1) l2 ->\nexists l3 : list A, permutation l3 l1 /\\ l2 = map f l3"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "permutation_flat_map", "text": "Theorem permutation_flat_map :\n forall (A B : Type) (f : A -> list B) l1 l2,\n permutation l1 l2 -> permutation (flat_map f l1) (flat_map f l2).\nProof using.\nintros A B f l1 l2 H; elim H; simpl in |- *; auto.\nintros a b l; auto.\nrepeat rewrite <- app_ass.\napply permutation_app_comp; auto.\nintros k3 l4 l5 H0 H1 H2 H3; apply permutation_trans with (1 := H1); auto.\nQed.\n", "definition": "\n forall (A B : Type) (f : A -> list B) l1 l2,\n permutation l1 l2 -> permutation (flat_map f l1) (flat_map f l2).", "proof": "\nProof using.\nintros A B f l1 l2 H; elim H; simpl in |- *; auto.\nintros a b l; auto.\nrepeat rewrite <- app_ass.\napply permutation_app_comp; auto.\nintros k3 l4 l5 H0 H1 H2 H3; apply permutation_trans with (1 := H1); auto.\n", "def_ranges": [458, 0, 460, 66], "proof_ranges": [461, 0, 467, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (A B : Type) (f : A -> list B) (l1 l2 : list A),\npermutation l1 l2 -> permutation (flat_map f l1) (flat_map f l2)"], "goal_after": ["forall (A B : Type) (f : A -> list B) (l1 l2 : list A),\npermutation l1 l2 -> permutation (flat_map f l1) (flat_map f l2)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros A B f l1 l2 H; elim H; simpl in |- *; auto.", "goal_before": ["forall (A B : Type) (f : A -> list B) (l1 l2 : list A),\npermutation l1 l2 -> permutation (flat_map f l1) (flat_map f l2)"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"]}, {"text": "intros a b l; auto.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "proof_term_before": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"], "proof_term_after": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"]}, {"text": "repeat rewrite <- app_ass.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "proof_term_before": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"], "proof_term_after": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"]}, {"text": "apply permutation_app_comp; auto.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "proof_term_before": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"], "proof_term_after": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"]}, {"text": "intros k3 l4 l5 H0 H1 H2 H3; apply permutation_trans with (1 := H1); auto.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "goal_after": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "proof_term_before": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"], "proof_term_after": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"]}, {"text": "Qed.", "goal_before": ["permutation nil nil", "forall (a : A) (l0 l3 : list A),\npermutation l3 l0 ->\npermutation (flat_map f l3) (flat_map f l0) ->\npermutation (f a ++ flat_map f l3) (f a ++ flat_map f l0)", "forall (a b : A) (l : list A),\npermutation (f a ++ f b ++ flat_map f l) (f b ++ f a ++ flat_map f l)", "forall l0 l3 l4 : list A,\npermutation l0 l3 ->\npermutation (flat_map f l0) (flat_map f l3) ->\npermutation l3 l4 ->\npermutation (flat_map f l3) (flat_map f l4) ->\npermutation (flat_map f l0) (flat_map f l4)"], "goal_after": [], "proof_term_before": ["(fun (A B : Type) (f : A -> list B) (l1 l2 : list A) (H : permutation l1 l2)\n =>\n permutation_ind A\n   (fun l3 l4 : list A => permutation (flat_map f l3) (flat_map f l4))\n   (?Goal : permutation (flat_map f nil) (flat_map f nil))\n   (?Goal0\n    :\n    forall (a : A) (l3 l4 : list A),\n    permutation l4 l3 ->\n    permutation (flat_map f l4) (flat_map f l3) ->\n    permutation (flat_map f (a :: l4)) (flat_map f (a :: l3)))\n   (?Goal1\n    :\n    forall (a b : A) (l : list A),\n    permutation (flat_map f (a :: b :: l)) (flat_map f (b :: a :: l)))\n   (?Goal2\n    :\n    forall l3 l4 l5 : list A,\n    permutation l3 l4 ->\n    permutation (flat_map f l3) (flat_map f l4) ->\n    permutation l4 l5 ->\n    permutation (flat_map f l4) (flat_map f l5) ->\n    permutation (flat_map f l3) (flat_map f l5)) l1 l2 H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Permutation.v", "name": "fold_left_permutation", "text": "Theorem fold_left_permutation :\n forall (A B : Type) (f : A -> B -> A),\n (forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\n forall (a : A) (l1 l2 : list B),\n permutation l1 l2 -> fold_left f l1 a = fold_left f l2 a.\nProof using.\nintros A B f Hf a l1 l2 H; generalize a; elim H; clear H a l1 l2;\n simpl in |- *; auto.\nintros a b l a0; rewrite Hf; auto.\nintros l1 l2 l3 H H0 H1 H2 a; apply trans_equal with (1 := H0 a); auto.\nQed.\n", "definition": "\n forall (A B : Type) (f : A -> B -> A),\n (forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\n forall (a : A) (l1 l2 : list B),\n permutation l1 l2 -> fold_left f l1 a = fold_left f l2 a.", "proof": "\nProof using.\nintros A B f Hf a l1 l2 H; generalize a; elim H; clear H a l1 l2;\n simpl in |- *; auto.\nintros a b l a0; rewrite Hf; auto.\nintros l1 l2 l3 H H0 H1 H2 a; apply trans_equal with (1 := H0 a); auto.\n", "def_ranges": [470, 0, 474, 58], "proof_ranges": [475, 0, 480, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "goal_after": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros A B f Hf a l1 l2 H; generalize a; elim H; clear H a l1 l2;", "goal_before": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "goal_after": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "goal_after": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b l a0; rewrite Hf; auto.", "goal_before": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "goal_after": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 l3 H H0 H1 H2 a; apply trans_equal with (1 := H0 a); auto.", "goal_before": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "goal_after": ["forall (A B : Type) (f : A -> B -> A),\n(forall (a : A) (b1 b2 : B), f (f a b1) b2 = f (f a b2) b1) ->\nforall (a : A) (l1 l2 : list B),\npermutation l1 l2 -> fold_left f l1 a = fold_left f l2 a"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/WeightTree.v", "name": "le_sum_correct1", "text": "Theorem le_sum_correct1 :\n forall a b1 : btree A, le_sum a b1 = true -> sum_order a b1.\nProof using.\nintros a b1; apply (le_bool_correct3 (sum_leaves a) (sum_leaves b1)).\nQed.\n", "definition": "\n forall a b1 : btree A, le_sum a b1 = true -> sum_order a b1.", "proof": "\nProof using.\nintros a b1; apply (le_bool_correct3 (sum_leaves a) (sum_leaves b1)).\n", "def_ranges": [40, 0, 41, 61], "proof_ranges": [42, 0, 44, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b1; apply (le_bool_correct3 (sum_leaves a) (sum_leaves b1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/WeightTree.v", "name": "le_sum_correct2", "text": "Theorem le_sum_correct2 :\n forall a b1 : btree A, le_sum a b1 = false -> sum_order b1 a.\nProof using.\nintros a b1; apply (le_bool_correct4 (sum_leaves a) (sum_leaves b1)).\nQed.\n", "definition": "\n forall a b1 : btree A, le_sum a b1 = false -> sum_order b1 a.", "proof": "\nProof using.\nintros a b1; apply (le_bool_correct4 (sum_leaves a) (sum_leaves b1)).\n", "def_ranges": [46, 0, 47, 62], "proof_ranges": [48, 0, 50, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b1; apply (le_bool_correct4 (sum_leaves a) (sum_leaves b1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/WeightTree.v", "name": "weight_tree_list_node", "text": "Theorem weight_tree_list_node :\n forall (t1 t2 : btree A) (l : list (btree A)),\n weight_tree_list (node t1 t2 :: l) =\n sum_leaves t1 + sum_leaves t2 + weight_tree_list (t1 :: t2 :: l).\nProof using.\nintros t1 t2 l; simpl in |- *; ring.\nQed.\n", "definition": "\n forall (t1 t2 : btree A) (l : list (btree A)),\n weight_tree_list (node t1 t2 :: l) =\n sum_leaves t1 + sum_leaves t2 + weight_tree_list (t1 :: t2 :: l).", "proof": "\nProof using.\nintros t1 t2 l; simpl in |- *; ring.\n", "def_ranges": [62, 0, 65, 66], "proof_ranges": [66, 0, 68, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t1 t2 l; simpl in |- *; ring.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/WeightTree.v", "name": "weight_tree_list_permutation", "text": "Theorem weight_tree_list_permutation :\n forall l1 l2 : list (btree A),\n permutation l1 l2 -> weight_tree_list l1 = weight_tree_list l2.\nProof using.\nintros l1 l2 H; elim H; auto.\nsimpl in |- *; auto; intros; ring.\nsimpl in |- *; auto; intros; ring.\nintros l0 l3 l4 H0 H1 H2 H3; apply trans_equal with (1 := H1); auto.\nQed.\n", "definition": "\n forall l1 l2 : list (btree A),\n permutation l1 l2 -> weight_tree_list l1 = weight_tree_list l2.", "proof": "\nProof using.\nintros l1 l2 H; elim H; auto.\nsimpl in |- *; auto; intros; ring.\nsimpl in |- *; auto; intros; ring.\nintros l0 l3 l4 H0 H1 H2 H3; apply trans_equal with (1 := H1); auto.\n", "def_ranges": [70, 0, 72, 64], "proof_ranges": [73, 0, 78, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l1 l2 H; elim H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto; intros; ring.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto; intros; ring.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l0 l3 l4 H0 H1 H2 H3; apply trans_equal with (1 := H1); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/WeightTree.v", "name": "ordered_sum_leaves_eq", "text": "Theorem ordered_sum_leaves_eq :\n forall (A : Type) (f : A -> nat) (l1 l2 : list (btree A)),\n permutation l1 l2 ->\n ordered (sum_order f) l1 ->\n ordered (sum_order f) l2 -> map (sum_leaves f) l1 = map (sum_leaves f) l2.\nProof using.\nintros A f l1 l2 H H0 H1.\napply ordered_perm_antisym_eq with (order := le).\nexact le_trans.\nexact le_antisym.\napply permutation_map; auto.\napply ordered_map_inv; auto.\napply ordered_map_inv; auto.\nQed.\n", "definition": "\n forall (A : Type) (f : A -> nat) (l1 l2 : list (btree A)),\n permutation l1 l2 ->\n ordered (sum_order f) l1 ->\n ordered (sum_order f) l2 -> map (sum_leaves f) l1 = map (sum_leaves f) l2.", "proof": "\nProof using.\nintros A f l1 l2 H H0 H1.\napply ordered_perm_antisym_eq with (order := le).\nexact le_trans.\nexact le_antisym.\napply permutation_map; auto.\napply ordered_map_inv; auto.\napply ordered_map_inv; auto.\n", "def_ranges": [91, 0, 95, 75], "proof_ranges": [96, 0, 104, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A f l1 l2 H H0 H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_perm_antisym_eq with (order := le).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact le_trans.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact le_antisym.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply permutation_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_map_inv; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ordered_map_inv; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/PBTree2BTree.v", "name": "to_btree_inb", "text": "Theorem to_btree_inb :\n forall a b, inpb (pbleaf a) b -> inb (leaf a) (to_btree b).\nProof using.\nintros a b; generalize a; elim b; clear a b; simpl in |- *; auto.\nintros a a0 H; inversion H; auto.\nintros p H a H0; apply H; auto; inversion H0; auto.\nintros p H a H0; apply H; auto; inversion H0; auto.\nintros p H p0 H0 a H1; inversion H1; auto.\nQed.\n", "definition": "\n forall a b, inpb (pbleaf a) b -> inb (leaf a) (to_btree b).", "proof": "\nProof using.\nintros a b; generalize a; elim b; clear a b; simpl in |- *; auto.\nintros a a0 H; inversion H; auto.\nintros p H a H0; apply H; auto; inversion H0; auto.\nintros p H a H0; apply H; auto; inversion H0; auto.\nintros p H p0 H0 a H1; inversion H1; auto.\n", "def_ranges": [50, 0, 51, 60], "proof_ranges": [52, 0, 58, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b; generalize a; elim b; clear a b; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a a0 H; inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p H a H0; apply H; auto; inversion H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p H a H0; apply H; auto; inversion H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p H p0 H0 a H1; inversion H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/PBTree2BTree.v", "name": "to_btree_inpb", "text": "Theorem to_btree_inpb :\n forall a b, inb (leaf a) (to_btree b) -> inpb (pbleaf a) b.\nProof using.\nintros a b; generalize a; elim b; clear a b; simpl in |- *; auto.\nintros a a0 H; inversion H; auto.\nintros p H p0 H0 a H1.\ninversion H1; auto.\nQed.\n", "definition": "\n forall a b, inb (leaf a) (to_btree b) -> inpb (pbleaf a) b.", "proof": "\nProof using.\nintros a b; generalize a; elim b; clear a b; simpl in |- *; auto.\nintros a a0 H; inversion H; auto.\nintros p H p0 H0 a H1.\ninversion H1; auto.\n", "def_ranges": [61, 0, 62, 60], "proof_ranges": [63, 0, 68, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b; generalize a; elim b; clear a b; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a a0 H; inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p H p0 H0 a H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/PBTree2BTree.v", "name": "to_btree_all_leaves", "text": "Theorem to_btree_all_leaves :\n forall t, all_leaves (to_btree t) = all_pbleaves t.\nProof using.\nintros t; elim t; simpl in |- *; auto.\nintros p H p0 H0; apply f_equal2 with (f := app (A:=A)); auto.\nQed.\n", "definition": "\n forall t, all_leaves (to_btree t) = all_pbleaves t.", "proof": "\nProof using.\nintros t; elim t; simpl in |- *; auto.\nintros p H p0 H0; apply f_equal2 with (f := app (A:=A)); auto.\n", "def_ranges": [71, 0, 72, 52], "proof_ranges": [73, 0, 76, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t; elim t; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p H p0 H0; apply f_equal2 with (f := app (A:=A)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/PBTree2BTree.v", "name": "to_btree_distinct_leaves", "text": "Theorem to_btree_distinct_leaves :\n forall a : pbtree A, distinct_pbleaves a -> distinct_leaves (to_btree a).\nProof using.\nintros a H.\napply all_leaves_unique.\nrewrite to_btree_all_leaves.\napply all_pbleaves_ulist; auto.\nQed.\n", "definition": "\n forall a : pbtree A, distinct_pbleaves a -> distinct_leaves (to_btree a).", "proof": "\nProof using.\nintros a H.\napply all_leaves_unique.\nrewrite to_btree_all_leaves.\napply all_pbleaves_ulist; auto.\n", "def_ranges": [79, 0, 80, 74], "proof_ranges": [81, 0, 86, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply all_leaves_unique.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite to_btree_all_leaves.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply all_pbleaves_ulist; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/PBTree2BTree.v", "name": "to_btree_distinct_pbleaves", "text": "Theorem to_btree_distinct_pbleaves :\n forall a : pbtree A, distinct_leaves (to_btree a) -> distinct_pbleaves a.\nProof using.\nintros a H.\napply all_pbleaves_unique.\nrewrite <- to_btree_all_leaves.\napply all_leaves_ulist; auto.\nQed.\n", "definition": "\n forall a : pbtree A, distinct_leaves (to_btree a) -> distinct_pbleaves a.", "proof": "\nProof using.\nintros a H.\napply all_pbleaves_unique.\nrewrite <- to_btree_all_leaves.\napply all_leaves_ulist; auto.\n", "def_ranges": [89, 0, 90, 74], "proof_ranges": [91, 0, 96, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply all_pbleaves_unique.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- to_btree_all_leaves.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply all_leaves_ulist; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/PBTree2BTree.v", "name": "to_btree_smaller", "text": "Theorem to_btree_smaller :\n forall t a,\n length (find_code eqA_dec a (compute_code (to_btree t))) <=\n length (find_code eqA_dec a (compute_pbcode t)).\nProof using.\nintros t; elim t; simpl in |- *; auto.\nintros p H a.\napply le_trans with (1 := H a); auto.\ncase (inpb_dec eqA_dec (pbleaf a) p); intros H1.\ncase inpb_compute_ex with (1 := H1).\nintros x Hx; rewrite in_find_map with (l := x); simpl in |- *; auto.\nrewrite not_in_find_map; simpl in |- *; auto.\nrewrite not_in_find_code; simpl in |- *; auto.\nintros p1; Contradict H1; auto.\napply in_pbcompute_inpb with (1 := H1).\nintros p1; Contradict H1; auto.\napply in_pbcompute_inpb with (1 := H1).\nintros p H a.\napply le_trans with (1 := H a); auto.\ncase (inpb_dec eqA_dec (pbleaf a) p); intros H1.\ncase inpb_compute_ex with (1 := H1).\nintros x Hx; rewrite in_find_map with (l := x); simpl in |- *; auto.\nrewrite not_in_find_map; simpl in |- *; auto.\nrewrite not_in_find_code; simpl in |- *; auto.\nintros p1; Contradict H1; auto.\napply in_pbcompute_inpb with (1 := H1).\nintros p1; Contradict H1; auto.\napply in_pbcompute_inpb with (1 := H1).\nintros p H p0 H0 a.\nsimpl in |- *; repeat rewrite find_code_app; auto.\ncase (inpb_dec eqA_dec (pbleaf a) p); intros H1.\ncase inpb_compute_ex with (1 := H1).\nintros x Hx; repeat rewrite in_find_map with (1 := Hx); simpl in |- *;\n auto with arith.\ncase inb_compute_ex with (a := a) (p := to_btree p); auto.\napply to_btree_inb; auto.\nintros x1 Hx1; repeat rewrite in_find_map with (1 := Hx1); simpl in |- *;\n auto with arith.\nrewrite not_in_find_map with (p := compute_code (to_btree p)); simpl in |- *;\n auto with arith.\nrewrite not_in_find_map with (p := compute_pbcode p); simpl in |- *;\n auto with arith.\ncase (inpb_dec eqA_dec (pbleaf a) p0); intros H2.\ncase inpb_compute_ex with (1 := H2).\nintros x Hx; repeat rewrite in_find_map with (1 := Hx); simpl in |- *;\n auto with arith.\ncase inb_compute_ex with (a := a) (p := to_btree p0); auto.\napply to_btree_inb; auto.\nintros x1 Hx1; repeat rewrite in_find_map with (1 := Hx1); simpl in |- *;\n auto with arith.\nrewrite not_in_find_map with (p := compute_pbcode p0); simpl in |- *;\n auto with arith.\nrewrite not_in_find_map with (p := compute_code (to_btree p0)); simpl in |- *;\n auto with arith.\nintros l; Contradict H2; apply to_btree_inpb;\n apply inCompute_inb with (1 := H2); auto.\nintros l; Contradict H2; apply in_pbcompute_inpb with (1 := H2).\nintros l; Contradict H1; apply in_pbcompute_inpb with (1 := H1).\nintros l; Contradict H1; apply to_btree_inpb;\n apply inCompute_inb with (1 := H1); auto.\nQed.\n", "definition": "\n forall t a,\n length (find_code eqA_dec a (compute_code (to_btree t))) <=\n length (find_code eqA_dec a (compute_pbcode t)).", "proof": "\nProof using.\nintros t; elim t; simpl in |- *; auto.\nintros p H a.\napply le_trans with (1 := H a); auto.\ncase (inpb_dec eqA_dec (pbleaf a) p); intros H1.\ncase inpb_compute_ex with (1 := H1).\nintros x Hx; rewrite in_find_map with (l := x); simpl in |- *; auto.\nrewrite not_in_find_map; simpl in |- *; auto.\nrewrite not_in_find_code; simpl in |- *; auto.\nintros p1; Contradict H1; auto.\napply in_pbcompute_inpb with (1 := H1).\nintros p1; Contradict H1; auto.\napply in_pbcompute_inpb with (1 := H1).\nintros p H a.\napply le_trans with (1 := H a); auto.\ncase (inpb_dec eqA_dec (pbleaf a) p); intros H1.\ncase inpb_compute_ex with (1 := H1).\nintros x Hx; rewrite in_find_map with (l := x); simpl in |- *; auto.\nrewrite not_in_find_map; simpl in |- *; auto.\nrewrite not_in_find_code; simpl in |- *; auto.\nintros p1; Contradict H1; auto.\napply in_pbcompute_inpb with (1 := H1).\nintros p1; Contradict H1; auto.\napply in_pbcompute_inpb with (1 := H1).\nintros p H p0 H0 a.\nsimpl in |- *; repeat rewrite find_code_app; auto.\ncase (inpb_dec eqA_dec (pbleaf a) p); intros H1.\ncase inpb_compute_ex with (1 := H1).\nintros x Hx; repeat rewrite in_find_map with (1 := Hx); simpl in |- *;\n auto with arith.\ncase inb_compute_ex with (a := a) (p := to_btree p); auto.\napply to_btree_inb; auto.\nintros x1 Hx1; repeat rewrite in_find_map with (1 := Hx1); simpl in |- *;\n auto with arith.\nrewrite not_in_find_map with (p := compute_code (to_btree p)); simpl in |- *;\n auto with arith.\nrewrite not_in_find_map with (p := compute_pbcode p); simpl in |- *;\n auto with arith.\ncase (inpb_dec eqA_dec (pbleaf a) p0); intros H2.\ncase inpb_compute_ex with (1 := H2).\nintros x Hx; repeat rewrite in_find_map with (1 := Hx); simpl in |- *;\n auto with arith.\ncase inb_compute_ex with (a := a) (p := to_btree p0); auto.\napply to_btree_inb; auto.\nintros x1 Hx1; repeat rewrite in_find_map with (1 := Hx1); simpl in |- *;\n auto with arith.\nrewrite not_in_find_map with (p := compute_pbcode p0); simpl in |- *;\n auto with arith.\nrewrite not_in_find_map with (p := compute_code (to_btree p0)); simpl in |- *;\n auto with arith.\nintros l; Contradict H2; apply to_btree_inpb;\n apply inCompute_inb with (1 := H2); auto.\nintros l; Contradict H2; apply in_pbcompute_inpb with (1 := H2).\nintros l; Contradict H1; apply in_pbcompute_inpb with (1 := H1).\nintros l; Contradict H1; apply to_btree_inpb;\n apply inCompute_inb with (1 := H1); auto.\n", "def_ranges": [99, 0, 102, 49], "proof_ranges": [103, 0, 159, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros t; elim t; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p H a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply le_trans with (1 := H a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (inpb_dec eqA_dec (pbleaf a) p); intros H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case inpb_compute_ex with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x Hx; rewrite in_find_map with (l := x); simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite not_in_find_map; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite not_in_find_code; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p1; Contradict H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply in_pbcompute_inpb with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p1; Contradict H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply in_pbcompute_inpb with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p H a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply le_trans with (1 := H a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (inpb_dec eqA_dec (pbleaf a) p); intros H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case inpb_compute_ex with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x Hx; rewrite in_find_map with (l := x); simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite not_in_find_map; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite not_in_find_code; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p1; Contradict H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply in_pbcompute_inpb with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p1; Contradict H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply in_pbcompute_inpb with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros p H p0 H0 a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; repeat rewrite find_code_app; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (inpb_dec eqA_dec (pbleaf a) p); intros H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case inpb_compute_ex with (1 := H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x Hx; repeat rewrite in_find_map with (1 := Hx); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case inb_compute_ex with (a := a) (p := to_btree p); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply to_btree_inb; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 Hx1; repeat rewrite in_find_map with (1 := Hx1); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite not_in_find_map with (p := compute_code (to_btree p)); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite not_in_find_map with (p := compute_pbcode p); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (inpb_dec eqA_dec (pbleaf a) p0); intros H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case inpb_compute_ex with (1 := H2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x Hx; repeat rewrite in_find_map with (1 := Hx); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case inb_compute_ex with (a := a) (p := to_btree p0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply to_btree_inb; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 Hx1; repeat rewrite in_find_map with (1 := Hx1); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite not_in_find_map with (p := compute_pbcode p0); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite not_in_find_map with (p := compute_code (to_btree p0)); simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros l; Contradict H2; apply to_btree_inpb;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply inCompute_inb with (1 := H2); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "lt_minus_O", "text": "Theorem lt_minus_O : forall n m, m < n -> 0 < n - m.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\nQed.\n", "definition": " forall n m, m < n -> 0 < n - m.", "proof": "\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros m H1; Contradict H1; auto with arith.\nintros n1 Rec m; case m; simpl in |- *; auto.\nintros m1 H1; apply Rec; apply lt_S_n; auto.\n", "def_ranges": [38, 0, 38, 52], "proof_ranges": [39, 0, 44, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall n m : nat, m < n -> 0 < n - m"], "goal_after": ["forall n m : nat, m < n -> 0 < n - m"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros n; elim n; simpl in |- *; auto.", "goal_before": ["forall n m : nat, m < n -> 0 < n - m"], "goal_after": ["forall m : nat, m < 0 -> 0 < 0", "forall n0 : nat,\n(forall m : nat, m < n0 -> 0 < n0 - m) ->\nforall m : nat, m < S n0 -> 0 < match m with\n                                | 0 => S n0\n                                | S l => n0 - l\n                                end"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, m < n0 -> 0 < n0 - m)\n   (?Goal : forall m : nat, m < 0 -> 0 < 0 - m)\n   (?Goal0\n    :\n    forall n0 : nat,\n    (forall m : nat, m < n0 -> 0 < n0 - m) ->\n    forall m : nat, m < S n0 -> 0 < S n0 - m) n)"]}, {"text": "intros m H1; Contradict H1; auto with arith.", "goal_before": ["forall m : nat, m < 0 -> 0 < 0", "forall n0 : nat,\n(forall m : nat, m < n0 -> 0 < n0 - m) ->\nforall m : nat, m < S n0 -> 0 < match m with\n                                | 0 => S n0\n                                | S l => n0 - l\n                                end"], "goal_after": ["forall n0 : nat,\n(forall m : nat, m < n0 -> 0 < n0 - m) ->\nforall m : nat, m < S n0 -> 0 < match m with\n                                | 0 => S n0\n                                | S l => n0 - l\n                                end"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, m < n0 -> 0 < n0 - m)\n   (?Goal : forall m : nat, m < 0 -> 0 < 0 - m)\n   (?Goal0\n    :\n    forall n0 : nat,\n    (forall m : nat, m < n0 -> 0 < n0 - m) ->\n    forall m : nat, m < S n0 -> 0 < S n0 - m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, m < n0 -> 0 < n0 - m)\n   ((fun (m : nat) (H1 : m < 0) =>\n     Contradict2 (0 < 0) (m < 0) H1 (Nat.nlt_0_r m))\n    :\n    forall m : nat, m < 0 -> 0 < 0 - m)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall m : nat, m < n0 -> 0 < n0 - m) ->\n    forall m : nat, m < S n0 -> 0 < S n0 - m) n)"]}, {"text": "intros n1 Rec m; case m; simpl in |- *; auto.", "goal_before": ["forall n0 : nat,\n(forall m : nat, m < n0 -> 0 < n0 - m) ->\nforall m : nat, m < S n0 -> 0 < match m with\n                                | 0 => S n0\n                                | S l => n0 - l\n                                end"], "goal_after": ["forall n0 : nat, S n0 < S n1 -> 0 < n1 - n0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, m < n0 -> 0 < n0 - m)\n   ((fun (m : nat) (H1 : m < 0) =>\n     Contradict2 (0 < 0) (m < 0) H1 (Nat.nlt_0_r m))\n    :\n    forall m : nat, m < 0 -> 0 < 0 - m)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall m : nat, m < n0 -> 0 < n0 - m) ->\n    forall m : nat, m < S n0 -> 0 < S n0 - m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, m < n0 -> 0 < n0 - m)\n   ((fun (m : nat) (H1 : m < 0) =>\n     Contradict2 (0 < 0) (m < 0) H1 (Nat.nlt_0_r m))\n    :\n    forall m : nat, m < 0 -> 0 < 0 - m)\n   ((fun (n1 : nat) (Rec : forall m : nat, m < n1 -> 0 < n1 - m) (m : nat) =>\n     match\n       m as n0\n       return\n         (n0 < S n1 -> 0 < match n0 with\n                           | 0 => S n1\n                           | S l => n1 - l\n                           end)\n     with\n     | 0 => (fun H : 0 < S n1 => H) : 0 < S n1 -> 0 < S n1\n     | S n0 => (?Goal : forall n2 : nat, S n2 < S n1 -> 0 < n1 - n2) n0\n     end)\n    :\n    forall n0 : nat,\n    (forall m : nat, m < n0 -> 0 < n0 - m) ->\n    forall m : nat, m < S n0 -> 0 < S n0 - m) n)"]}, {"text": "intros m1 H1; apply Rec; apply lt_S_n; auto.", "goal_before": ["forall n0 : nat, S n0 < S n1 -> 0 < n1 - n0"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, m < n0 -> 0 < n0 - m)\n   ((fun (m : nat) (H1 : m < 0) =>\n     Contradict2 (0 < 0) (m < 0) H1 (Nat.nlt_0_r m))\n    :\n    forall m : nat, m < 0 -> 0 < 0 - m)\n   ((fun (n1 : nat) (Rec : forall m : nat, m < n1 -> 0 < n1 - m) (m : nat) =>\n     match\n       m as n0\n       return\n         (n0 < S n1 -> 0 < match n0 with\n                           | 0 => S n1\n                           | S l => n1 - l\n                           end)\n     with\n     | 0 => (fun H : 0 < S n1 => H) : 0 < S n1 -> 0 < S n1\n     | S n0 => (?Goal : forall n2 : nat, S n2 < S n1 -> 0 < n1 - n2) n0\n     end)\n    :\n    forall n0 : nat,\n    (forall m : nat, m < n0 -> 0 < n0 - m) ->\n    forall m : nat, m < S n0 -> 0 < S n0 - m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, m < n0 -> 0 < n0 - m)\n   ((fun (m : nat) (H1 : m < 0) =>\n     Contradict2 (0 < 0) (m < 0) H1 (Nat.nlt_0_r m))\n    :\n    forall m : nat, m < 0 -> 0 < 0 - m)\n   ((fun (n1 : nat) (Rec : forall m : nat, m < n1 -> 0 < n1 - m) (m : nat) =>\n     match\n       m as n0\n       return\n         (n0 < S n1 -> 0 < match n0 with\n                           | 0 => S n1\n                           | S l => n1 - l\n                           end)\n     with\n     | 0 => (fun H : 0 < S n1 => H) : 0 < S n1 -> 0 < S n1\n     | S n0 =>\n         ((fun (m1 : nat) (H1 : S m1 < S n1) => Rec m1 (lt_S_n m1 n1 H1))\n          :\n          forall n2 : nat, S n2 < S n1 -> 0 < n1 - n2) n0\n     end)\n    :\n    forall n0 : nat,\n    (forall m : nat, m < n0 -> 0 < n0 - m) ->\n    forall m : nat, m < S n0 -> 0 < S n0 - m) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, m < n0 -> 0 < n0 - m)\n   ((fun (m : nat) (H1 : m < 0) =>\n     Contradict2 (0 < 0) (m < 0) H1 (Nat.nlt_0_r m))\n    :\n    forall m : nat, m < 0 -> 0 < 0 - m)\n   ((fun (n1 : nat) (Rec : forall m : nat, m < n1 -> 0 < n1 - m) (m : nat) =>\n     match\n       m as n0\n       return\n         (n0 < S n1 -> 0 < match n0 with\n                           | 0 => S n1\n                           | S l => n1 - l\n                           end)\n     with\n     | 0 => (fun H : 0 < S n1 => H) : 0 < S n1 -> 0 < S n1\n     | S n0 =>\n         ((fun (m1 : nat) (H1 : S m1 < S n1) => Rec m1 (lt_S_n m1 n1 H1))\n          :\n          forall n2 : nat, S n2 < S n1 -> 0 < n1 - n2) n0\n     end)\n    :\n    forall n0 : nat,\n    (forall m : nat, m < n0 -> 0 < n0 - m) ->\n    forall m : nat, m < S n0 -> 0 < S n0 - m) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "le_minus", "text": "Theorem le_minus : forall a b : nat, a - b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\nQed.\n", "definition": " forall a b : nat, a - b <= a.", "proof": "\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *; auto.\n", "def_ranges": [46, 0, 46, 48], "proof_ranges": [47, 0, 50, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall a b : nat, a - b <= a"], "goal_after": ["forall a b : nat, a - b <= a"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a; elim a; simpl in |- *; auto.", "goal_before": ["forall a b : nat, a - b <= a"], "goal_after": ["forall n : nat,\n(forall b : nat, n - b <= n) ->\nforall b : nat, match b with\n                | 0 => S n\n                | S l => n - l\n                end <= S n"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 - b <= a0)\n   ((fun _ : nat => le_n 0) : forall b : nat, 0 - b <= 0)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, n - b <= n) -> forall b : nat, S n - b <= S n) a)"]}, {"text": "intros n H b; case b; simpl in |- *; auto.", "goal_before": ["forall n : nat,\n(forall b : nat, n - b <= n) ->\nforall b : nat, match b with\n                | 0 => S n\n                | S l => n - l\n                end <= S n"], "goal_after": [], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 - b <= a0)\n   ((fun _ : nat => le_n 0) : forall b : nat, 0 - b <= 0)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, n - b <= n) -> forall b : nat, S n - b <= S n) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 - b <= a0)\n   ((fun _ : nat => le_n 0) : forall b : nat, 0 - b <= 0)\n   ((fun (n : nat) (H : forall b : nat, n - b <= n) (b : nat) =>\n     match\n       b as n0 return (match n0 with\n                       | 0 => S n\n                       | S l => n - l\n                       end <= S n)\n     with\n     | 0 => le_n (S n) : S n <= S n\n     | S n0 =>\n         ((fun n1 : nat => le_S (n - n1) n (H n1))\n          :\n          forall n1 : nat, n - n1 <= S n) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n - b <= n) -> forall b : nat, S n - b <= S n) a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 - b <= a0)\n   ((fun _ : nat => le_n 0) : forall b : nat, 0 - b <= 0)\n   ((fun (n : nat) (H : forall b : nat, n - b <= n) (b : nat) =>\n     match\n       b as n0 return (match n0 with\n                       | 0 => S n\n                       | S l => n - l\n                       end <= S n)\n     with\n     | 0 => le_n (S n) : S n <= S n\n     | S n0 =>\n         ((fun n1 : nat => le_S (n - n1) n (H n1))\n          :\n          forall n1 : nat, n - n1 <= S n) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n - b <= n) -> forall b : nat, S n - b <= S n) a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "minus_minus_simpl4", "text": "Theorem minus_minus_simpl4 :\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\nQed.\n", "definition": "\n forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b.", "proof": "\nProof using.\nintros a b c H H0.\napply plus_minus; auto with arith.\nrewrite minus_plus_simpl_l_reverse with (p := b + c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite plus_assoc.\nrewrite (plus_comm b c).\nrepeat rewrite plus_assoc_reverse.\nrewrite <- le_plus_minus; auto with arith.\nrepeat rewrite (fun x => plus_comm x a).\nrewrite <- minus_plus_simpl_l_reverse; auto with arith.\napply le_trans with (1 := H); auto.\n", "def_ranges": [52, 0, 53, 65], "proof_ranges": [54, 0, 67, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b"], "goal_after": ["forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a b c H H0.", "goal_before": ["forall a b c : nat, b <= c -> c <= a -> a - b - (a - c) = c - b"], "goal_after": ["a - b - (a - c) = c - b"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) => ?Goal)"]}, {"text": "apply plus_minus; auto with arith.", "goal_before": ["a - b - (a - c) = c - b"], "goal_after": ["c = b + (a - b - (a - c))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) => ?Goal)"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c)) ?Goal)"]}, {"text": "rewrite minus_plus_simpl_l_reverse with (p := b + c).", "goal_before": ["c = b + (a - b - (a - c))"], "goal_after": ["c = b + (b + c + (a - b) - (b + c + (a - c)))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c)) ?Goal)"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n) ?Goal\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "repeat rewrite plus_assoc_reverse.", "goal_before": ["c = b + (b + c + (a - b) - (b + c + (a - c)))"], "goal_after": ["c = b + (b + (c + (a - b)) - (b + (c + (a - c))))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n) ?Goal\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n)) \n            ?Goal (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "rewrite <- le_plus_minus; auto with arith.", "goal_before": ["c = b + (b + (c + (a - b)) - (b + (c + (a - c))))"], "goal_after": ["c = b + (b + (c + (a - b)) - (b + a))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n)) \n            ?Goal (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               ?Goal (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "repeat rewrite plus_assoc.", "goal_before": ["c = b + (b + (c + (a - b)) - (b + a))"], "goal_after": ["c = b + (b + c + (a - b) - (b + a))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               ?Goal (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a))) \n                  ?Goal (Nat.add_assoc b c (a - b))) \n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "rewrite (plus_comm b c).", "goal_before": ["c = b + (b + c + (a - b) - (b + a))"], "goal_after": ["c = b + (c + b + (a - b) - (b + a))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a))) \n                  ?Goal (Nat.add_assoc b c (a - b))) \n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     ?Goal (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "repeat rewrite plus_assoc_reverse.", "goal_before": ["c = b + (c + b + (a - b) - (b + a))"], "goal_after": ["c = b + (c + (b + (a - b)) - (b + a))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     ?Goal (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a))) \n                        ?Goal (plus_assoc_reverse c b (a - b)))\n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "rewrite <- le_plus_minus; auto with arith.", "goal_before": ["c = b + (c + (b + (a - b)) - (b + a))"], "goal_after": ["c = b + (c + a - (b + a))", "b <= a"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a))) \n                        ?Goal (plus_assoc_reverse c b (a - b)))\n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                        (eq_ind a (fun n : nat => c = b + (c + n - (b + a)))\n                           ?Goal (b + (a - b)) (le_plus_minus b a ?Goal0))\n                        (plus_assoc_reverse c b (a - b))) \n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "repeat rewrite (fun x => plus_comm x a).", "goal_before": ["c = b + (c + a - (b + a))", "b <= a"], "goal_after": ["c = b + (a + c - (a + b))", "b <= a"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                        (eq_ind a (fun n : nat => c = b + (c + n - (b + a)))\n                           ?Goal (b + (a - b)) (le_plus_minus b a ?Goal0))\n                        (plus_assoc_reverse c b (a - b))) \n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                        (eq_ind a (fun n : nat => c = b + (c + n - (b + a)))\n                           (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                              (eq_ind_r (fun n : nat => c = b + (a + c - n))\n                                 ?Goal0 (Nat.add_comm b a))\n                              (Nat.add_comm c a)) \n                           (b + (a - b)) (le_plus_minus b a ?Goal))\n                        (plus_assoc_reverse c b (a - b))) \n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "rewrite <- minus_plus_simpl_l_reverse; auto with arith.", "goal_before": ["c = b + (a + c - (a + b))", "b <= a"], "goal_after": ["b <= a"], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                        (eq_ind a (fun n : nat => c = b + (c + n - (b + a)))\n                           (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                              (eq_ind_r (fun n : nat => c = b + (a + c - n))\n                                 ?Goal0 (Nat.add_comm b a))\n                              (Nat.add_comm c a)) \n                           (b + (a - b)) (le_plus_minus b a ?Goal))\n                        (plus_assoc_reverse c b (a - b))) \n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                        (eq_ind a (fun n : nat => c = b + (c + n - (b + a)))\n                           (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                              (eq_ind_r (fun n : nat => c = b + (a + c - n))\n                                 (eq_ind (c - b) (fun n : nat => c = b + n)\n                                    (le_plus_minus b c H) \n                                    (a + c - (a + b))\n                                    (minus_plus_simpl_l_reverse c b a))\n                                 (Nat.add_comm b a)) \n                              (Nat.add_comm c a)) \n                           (b + (a - b)) (le_plus_minus b a ?Goal))\n                        (plus_assoc_reverse c b (a - b))) \n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "apply le_trans with (1 := H); auto.", "goal_before": ["b <= a"], "goal_after": [], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                        (eq_ind a (fun n : nat => c = b + (c + n - (b + a)))\n                           (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                              (eq_ind_r (fun n : nat => c = b + (a + c - n))\n                                 (eq_ind (c - b) (fun n : nat => c = b + n)\n                                    (le_plus_minus b c H) \n                                    (a + c - (a + b))\n                                    (minus_plus_simpl_l_reverse c b a))\n                                 (Nat.add_comm b a)) \n                              (Nat.add_comm c a)) \n                           (b + (a - b)) (le_plus_minus b a ?Goal))\n                        (plus_assoc_reverse c b (a - b))) \n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                        (eq_ind a (fun n : nat => c = b + (c + n - (b + a)))\n                           (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                              (eq_ind_r (fun n : nat => c = b + (a + c - n))\n                                 (eq_ind (c - b) (fun n : nat => c = b + n)\n                                    (le_plus_minus b c H) \n                                    (a + c - (a + b))\n                                    (minus_plus_simpl_l_reverse c b a))\n                                 (Nat.add_comm b a)) \n                              (Nat.add_comm c a)) \n                           (b + (a - b))\n                           (le_plus_minus b a (Nat.le_trans b c a H H0)))\n                        (plus_assoc_reverse c b (a - b))) \n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b c : nat) (H : b <= c) (H0 : c <= a) =>\n plus_minus c b (a - b - (a - c))\n   (eq_ind_r (fun n : nat => c = b + n)\n      (eq_ind_r (fun n : nat => c = b + (n - (b + c + (a - c))))\n         (eq_ind_r (fun n : nat => c = b + (b + (c + (a - b)) - n))\n            (eq_ind a (fun n : nat => c = b + (b + (c + (a - b)) - (b + n)))\n               (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                  (eq_ind_r (fun n : nat => c = b + (n + (a - b) - (b + a)))\n                     (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                        (eq_ind a (fun n : nat => c = b + (c + n - (b + a)))\n                           (eq_ind_r (fun n : nat => c = b + (n - (b + a)))\n                              (eq_ind_r (fun n : nat => c = b + (a + c - n))\n                                 (eq_ind (c - b) (fun n : nat => c = b + n)\n                                    (le_plus_minus b c H) \n                                    (a + c - (a + b))\n                                    (minus_plus_simpl_l_reverse c b a))\n                                 (Nat.add_comm b a)) \n                              (Nat.add_comm c a)) \n                           (b + (a - b))\n                           (le_plus_minus b a (Nat.le_trans b c a H H0)))\n                        (plus_assoc_reverse c b (a - b))) \n                     (Nat.add_comm b c)) (Nat.add_assoc b c (a - b)))\n               (c + (a - c)) (le_plus_minus c a H0))\n            (plus_assoc_reverse b c (a - c)))\n         (plus_assoc_reverse b c (a - b)))\n      (minus_plus_simpl_l_reverse (a - b) (a - c) (b + c))))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "plus_minus_simpl4", "text": "Theorem plus_minus_simpl4 :\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\nQed.\n", "definition": "\n forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c.", "proof": "\nProof using.\nintros a b c H H0.\napply plus_minus.\nrewrite (fun x y => plus_comm (x - y)).\nrewrite plus_assoc.\nrewrite <- le_plus_minus; auto.\nrewrite <- le_plus_minus; auto.\n", "def_ranges": [69, 0, 70, 65], "proof_ranges": [71, 0, 78, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c"], "goal_after": ["forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a b c H H0.", "goal_before": ["forall a b c : nat, b <= a -> c <= b -> a - b + (b - c) = a - c"], "goal_after": ["a - b + (b - c) = a - c"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) => ?Goal)"]}, {"text": "apply plus_minus.", "goal_before": ["a - b + (b - c) = a - c"], "goal_after": ["a = c + (a - b + (b - c))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) => ?Goal)"], "proof_term_after": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c)) ?Goal)"]}, {"text": "rewrite (fun x y => plus_comm (x - y)).", "goal_before": ["a = c + (a - b + (b - c))"], "goal_after": ["a = c + (b - c + (a - b))"], "proof_term_before": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c)) ?Goal)"], "proof_term_after": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c))\n   (eq_ind_r (fun n : nat => a = c + n) ?Goal (Nat.add_comm (a - b) (b - c))))"]}, {"text": "rewrite plus_assoc.", "goal_before": ["a = c + (b - c + (a - b))"], "goal_after": ["a = c + (b - c) + (a - b)"], "proof_term_before": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c))\n   (eq_ind_r (fun n : nat => a = c + n) ?Goal (Nat.add_comm (a - b) (b - c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c))\n   (eq_ind_r (fun n : nat => a = c + n)\n      (eq_ind_r (fun n : nat => a = n) ?Goal\n         (Nat.add_assoc c (b - c) (a - b))) (Nat.add_comm (a - b) (b - c))))"]}, {"text": "rewrite <- le_plus_minus; auto.", "goal_before": ["a = c + (b - c) + (a - b)"], "goal_after": ["a = b + (a - b)"], "proof_term_before": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c))\n   (eq_ind_r (fun n : nat => a = c + n)\n      (eq_ind_r (fun n : nat => a = n) ?Goal\n         (Nat.add_assoc c (b - c) (a - b))) (Nat.add_comm (a - b) (b - c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c))\n   (eq_ind_r (fun n : nat => a = c + n)\n      (eq_ind_r (fun n : nat => a = n)\n         (eq_ind b (fun n : nat => a = n + (a - b)) \n            ?Goal (c + (b - c)) (le_plus_minus c b H0))\n         (Nat.add_assoc c (b - c) (a - b))) (Nat.add_comm (a - b) (b - c))))"]}, {"text": "rewrite <- le_plus_minus; auto.", "goal_before": ["a = b + (a - b)"], "goal_after": [], "proof_term_before": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c))\n   (eq_ind_r (fun n : nat => a = c + n)\n      (eq_ind_r (fun n : nat => a = n)\n         (eq_ind b (fun n : nat => a = n + (a - b)) \n            ?Goal (c + (b - c)) (le_plus_minus c b H0))\n         (Nat.add_assoc c (b - c) (a - b))) (Nat.add_comm (a - b) (b - c))))"], "proof_term_after": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c))\n   (eq_ind_r (fun n : nat => a = c + n)\n      (eq_ind_r (fun n : nat => a = n)\n         (eq_ind b (fun n : nat => a = n + (a - b))\n            (eq_ind a (fun n : nat => a = n) eq_refl \n               (b + (a - b)) (le_plus_minus b a H)) \n            (c + (b - c)) (le_plus_minus c b H0))\n         (Nat.add_assoc c (b - c) (a - b))) (Nat.add_comm (a - b) (b - c))))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b c : nat) (H : b <= a) (H0 : c <= b) =>\n plus_minus a c (a - b + (b - c))\n   (eq_ind_r (fun n : nat => a = c + n)\n      (eq_ind_r (fun n : nat => a = n)\n         (eq_ind b (fun n : nat => a = n + (a - b))\n            (eq_ind a (fun n : nat => a = n) eq_refl \n               (b + (a - b)) (le_plus_minus b a H)) \n            (c + (b - c)) (le_plus_minus c b H0))\n         (Nat.add_assoc c (b - c) (a - b))) (Nat.add_comm (a - b) (b - c))))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "le_bool_correct1", "text": "Theorem le_bool_correct1 : forall a b : nat, a <= b -> le_bool a b = true.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\nQed.\n", "definition": " forall a b : nat, a <= b -> le_bool a b = true.", "proof": "\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto.\nintros n H b; case b; simpl in |- *.\nintros H1; inversion H1.\nintros n0 H0; apply H.\napply le_S_n; auto.\n", "def_ranges": [103, 0, 103, 74], "proof_ranges": [104, 0, 111, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall a b : nat, a <= b -> le_bool a b = true"], "goal_after": ["forall a b : nat, a <= b -> le_bool a b = true"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a; elim a; simpl in |- *; auto.", "goal_before": ["forall a b : nat, a <= b -> le_bool a b = true"], "goal_after": ["forall b : nat, 0 <= b -> le_bool 0 b = true", "forall n : nat,\n(forall b : nat, n <= b -> le_bool n b = true) ->\nforall b : nat, S n <= b -> le_bool (S n) b = true"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   (?Goal : forall b : nat, 0 <= b -> le_bool 0 b = true)\n   (?Goal0\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"]}, {"text": "intros b; case b; simpl in |- *; auto.", "goal_before": ["forall b : nat, 0 <= b -> le_bool 0 b = true", "forall n : nat,\n(forall b : nat, n <= b -> le_bool n b = true) ->\nforall b : nat, S n <= b -> le_bool (S n) b = true"], "goal_after": ["forall n : nat,\n(forall b : nat, n <= b -> le_bool n b = true) ->\nforall b : nat, S n <= b -> le_bool (S n) b = true"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   (?Goal : forall b : nat, 0 <= b -> le_bool 0 b = true)\n   (?Goal0\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"]}, {"text": "intros n H b; case b; simpl in |- *.", "goal_before": ["forall n : nat,\n(forall b : nat, n <= b -> le_bool n b = true) ->\nforall b : nat, S n <= b -> le_bool (S n) b = true"], "goal_after": ["S n <= 0 -> false = true", "forall n0 : nat, S n <= S n0 -> le_bool n n0 = true"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   ((fun (n : nat) (H : forall b : nat, n <= b -> le_bool n b = true)\n       (b : nat) =>\n     match b as n0 return (S n <= n0 -> le_bool (S n) n0 = true) with\n     | 0 => ?Goal : S n <= 0 -> le_bool (S n) 0 = true\n     | S n0 =>\n         (?Goal0\n          :\n          forall n1 : nat, S n <= S n1 -> le_bool (S n) (S n1) = true) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"]}, {"text": "intros H1; inversion H1.", "goal_before": ["S n <= 0 -> false = true", "forall n0 : nat, S n <= S n0 -> le_bool n n0 = true"], "goal_after": ["forall n0 : nat, S n <= S n0 -> le_bool n n0 = true"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   ((fun (n : nat) (H : forall b : nat, n <= b -> le_bool n b = true)\n       (b : nat) =>\n     match b as n0 return (S n <= n0 -> le_bool (S n) n0 = true) with\n     | 0 => ?Goal : S n <= 0 -> le_bool (S n) 0 = true\n     | S n0 =>\n         (?Goal0\n          :\n          forall n1 : nat, S n <= S n1 -> le_bool (S n) (S n1) = true) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   ((fun (n : nat) (H : forall b : nat, n <= b -> le_bool n b = true)\n       (b : nat) =>\n     match b as n0 return (S n <= n0 -> le_bool (S n) n0 = true) with\n     | 0 =>\n         (fun H1 : S n <= 0 =>\n          let H0 : 0 = 0 -> false = true :=\n            match H1 in (_ <= n0) return (n0 = 0 -> false = true) with\n            | le_n _ =>\n                fun H0 : S n = 0 =>\n                (fun H2 : S n = 0 =>\n                 let H3 : False :=\n                   eq_ind (S n)\n                     (fun e : nat =>\n                      match e with\n                      | 0 => False\n                      | S _ => True\n                      end) I 0 H2 in\n                 False_ind (false = true) H3) H0\n            | le_S _ m x =>\n                (fun (m0 : nat) (H0 : S n <= m0) (H2 : S m0 = 0) =>\n                 (fun H3 : S m0 = 0 =>\n                  let H4 : False :=\n                    eq_ind (S m0)\n                      (fun e : nat =>\n                       match e with\n                       | 0 => False\n                       | S _ => True\n                       end) I 0 H3 in\n                  False_ind (S n <= m0 -> false = true) H4) H2 H0) m x\n            end in\n          H0 eq_refl)\n         :\n         S n <= 0 -> le_bool (S n) 0 = true\n     | S n0 =>\n         (?Goal : forall n1 : nat, S n <= S n1 -> le_bool (S n) (S n1) = true)\n           n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"]}, {"text": "intros n0 H0; apply H.", "goal_before": ["forall n0 : nat, S n <= S n0 -> le_bool n n0 = true"], "goal_after": ["n <= n0"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   ((fun (n : nat) (H : forall b : nat, n <= b -> le_bool n b = true)\n       (b : nat) =>\n     match b as n0 return (S n <= n0 -> le_bool (S n) n0 = true) with\n     | 0 =>\n         (fun H1 : S n <= 0 =>\n          let H0 : 0 = 0 -> false = true :=\n            match H1 in (_ <= n0) return (n0 = 0 -> false = true) with\n            | le_n _ =>\n                fun H0 : S n = 0 =>\n                (fun H2 : S n = 0 =>\n                 let H3 : False :=\n                   eq_ind (S n)\n                     (fun e : nat =>\n                      match e with\n                      | 0 => False\n                      | S _ => True\n                      end) I 0 H2 in\n                 False_ind (false = true) H3) H0\n            | le_S _ m x =>\n                (fun (m0 : nat) (H0 : S n <= m0) (H2 : S m0 = 0) =>\n                 (fun H3 : S m0 = 0 =>\n                  let H4 : False :=\n                    eq_ind (S m0)\n                      (fun e : nat =>\n                       match e with\n                       | 0 => False\n                       | S _ => True\n                       end) I 0 H3 in\n                  False_ind (S n <= m0 -> false = true) H4) H2 H0) m x\n            end in\n          H0 eq_refl)\n         :\n         S n <= 0 -> le_bool (S n) 0 = true\n     | S n0 =>\n         (?Goal : forall n1 : nat, S n <= S n1 -> le_bool (S n) (S n1) = true)\n           n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   ((fun (n : nat) (H : forall b : nat, n <= b -> le_bool n b = true)\n       (b : nat) =>\n     match b as n0 return (S n <= n0 -> le_bool (S n) n0 = true) with\n     | 0 =>\n         (fun H1 : S n <= 0 =>\n          let H0 : 0 = 0 -> false = true :=\n            match H1 in (_ <= n0) return (n0 = 0 -> false = true) with\n            | le_n _ =>\n                fun H0 : S n = 0 =>\n                (fun H2 : S n = 0 =>\n                 let H3 : False :=\n                   eq_ind (S n)\n                     (fun e : nat =>\n                      match e with\n                      | 0 => False\n                      | S _ => True\n                      end) I 0 H2 in\n                 False_ind (false = true) H3) H0\n            | le_S _ m x =>\n                (fun (m0 : nat) (H0 : S n <= m0) (H2 : S m0 = 0) =>\n                 (fun H3 : S m0 = 0 =>\n                  let H4 : False :=\n                    eq_ind (S m0)\n                      (fun e : nat =>\n                       match e with\n                       | 0 => False\n                       | S _ => True\n                       end) I 0 H3 in\n                  False_ind (S n <= m0 -> false = true) H4) H2 H0) m x\n            end in\n          H0 eq_refl)\n         :\n         S n <= 0 -> le_bool (S n) 0 = true\n     | S n0 =>\n         ((fun (n1 : nat) (H0 : S n <= S n1) => H n1 ?Goal@{n0:=n1})\n          :\n          forall n1 : nat, S n <= S n1 -> le_bool (S n) (S n1) = true) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"]}, {"text": "apply le_S_n; auto.", "goal_before": ["n <= n0"], "goal_after": [], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   ((fun (n : nat) (H : forall b : nat, n <= b -> le_bool n b = true)\n       (b : nat) =>\n     match b as n0 return (S n <= n0 -> le_bool (S n) n0 = true) with\n     | 0 =>\n         (fun H1 : S n <= 0 =>\n          let H0 : 0 = 0 -> false = true :=\n            match H1 in (_ <= n0) return (n0 = 0 -> false = true) with\n            | le_n _ =>\n                fun H0 : S n = 0 =>\n                (fun H2 : S n = 0 =>\n                 let H3 : False :=\n                   eq_ind (S n)\n                     (fun e : nat =>\n                      match e with\n                      | 0 => False\n                      | S _ => True\n                      end) I 0 H2 in\n                 False_ind (false = true) H3) H0\n            | le_S _ m x =>\n                (fun (m0 : nat) (H0 : S n <= m0) (H2 : S m0 = 0) =>\n                 (fun H3 : S m0 = 0 =>\n                  let H4 : False :=\n                    eq_ind (S m0)\n                      (fun e : nat =>\n                       match e with\n                       | 0 => False\n                       | S _ => True\n                       end) I 0 H3 in\n                  False_ind (S n <= m0 -> false = true) H4) H2 H0) m x\n            end in\n          H0 eq_refl)\n         :\n         S n <= 0 -> le_bool (S n) 0 = true\n     | S n0 =>\n         ((fun (n1 : nat) (H0 : S n <= S n1) => H n1 ?Goal@{n0:=n1})\n          :\n          forall n1 : nat, S n <= S n1 -> le_bool (S n) (S n1) = true) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   ((fun (n : nat) (H : forall b : nat, n <= b -> le_bool n b = true)\n       (b : nat) =>\n     match b as n0 return (S n <= n0 -> le_bool (S n) n0 = true) with\n     | 0 =>\n         (fun H1 : S n <= 0 =>\n          let H0 : 0 = 0 -> false = true :=\n            match H1 in (_ <= n0) return (n0 = 0 -> false = true) with\n            | le_n _ =>\n                fun H0 : S n = 0 =>\n                (fun H2 : S n = 0 =>\n                 let H3 : False :=\n                   eq_ind (S n)\n                     (fun e : nat =>\n                      match e with\n                      | 0 => False\n                      | S _ => True\n                      end) I 0 H2 in\n                 False_ind (false = true) H3) H0\n            | le_S _ m x =>\n                (fun (m0 : nat) (H0 : S n <= m0) (H2 : S m0 = 0) =>\n                 (fun H3 : S m0 = 0 =>\n                  let H4 : False :=\n                    eq_ind (S m0)\n                      (fun e : nat =>\n                       match e with\n                       | 0 => False\n                       | S _ => True\n                       end) I 0 H3 in\n                  False_ind (S n <= m0 -> false = true) H4) H2 H0) m x\n            end in\n          H0 eq_refl)\n         :\n         S n <= 0 -> le_bool (S n) 0 = true\n     | S n0 =>\n         ((fun (n1 : nat) (H0 : S n <= S n1) => H n1 (le_S_n n n1 H0))\n          :\n          forall n1 : nat, S n <= S n1 -> le_bool (S n) (S n1) = true) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, a0 <= b -> le_bool a0 b = true)\n   ((fun b : nat =>\n     match b as n return (0 <= n -> le_bool 0 n = true) with\n     | 0 => (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> le_bool 0 0 = true\n     | S n =>\n         ((fun (n0 : nat) (_ : 0 <= S n0) => eq_refl)\n          :\n          forall n0 : nat, 0 <= S n0 -> le_bool 0 (S n0) = true) n\n     end)\n    :\n    forall b : nat, 0 <= b -> le_bool 0 b = true)\n   ((fun (n : nat) (H : forall b : nat, n <= b -> le_bool n b = true)\n       (b : nat) =>\n     match b as n0 return (S n <= n0 -> le_bool (S n) n0 = true) with\n     | 0 =>\n         (fun H1 : S n <= 0 =>\n          let H0 : 0 = 0 -> false = true :=\n            match H1 in (_ <= n0) return (n0 = 0 -> false = true) with\n            | le_n _ =>\n                fun H0 : S n = 0 =>\n                (fun H2 : S n = 0 =>\n                 let H3 : False :=\n                   eq_ind (S n)\n                     (fun e : nat =>\n                      match e with\n                      | 0 => False\n                      | S _ => True\n                      end) I 0 H2 in\n                 False_ind (false = true) H3) H0\n            | le_S _ m x =>\n                (fun (m0 : nat) (H0 : S n <= m0) (H2 : S m0 = 0) =>\n                 (fun H3 : S m0 = 0 =>\n                  let H4 : False :=\n                    eq_ind (S m0)\n                      (fun e : nat =>\n                       match e with\n                       | 0 => False\n                       | S _ => True\n                       end) I 0 H3 in\n                  False_ind (S n <= m0 -> false = true) H4) H2 H0) m x\n            end in\n          H0 eq_refl)\n         :\n         S n <= 0 -> le_bool (S n) 0 = true\n     | S n0 =>\n         ((fun (n1 : nat) (H0 : S n <= S n1) => H n1 (le_S_n n n1 H0))\n          :\n          forall n1 : nat, S n <= S n1 -> le_bool (S n) (S n1) = true) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, n <= b -> le_bool n b = true) ->\n    forall b : nat, S n <= b -> le_bool (S n) b = true) a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "le_bool_correct2", "text": "Theorem le_bool_correct2 : forall a b : nat, b < a -> le_bool a b = false.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\nQed.\n", "definition": " forall a b : nat, b < a -> le_bool a b = false.", "proof": "\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b H1; inversion H1.\nintros n H b; case b; simpl in |- *; auto.\nintros n0 H0; apply H.\napply lt_S_n; auto.\n", "def_ranges": [113, 0, 113, 74], "proof_ranges": [114, 0, 120, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall a b : nat, b < a -> le_bool a b = false"], "goal_after": ["forall a b : nat, b < a -> le_bool a b = false"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a; elim a; simpl in |- *; auto.", "goal_before": ["forall a b : nat, b < a -> le_bool a b = false"], "goal_after": ["forall b : nat, b < 0 -> le_bool 0 b = false", "forall n : nat,\n(forall b : nat, b < n -> le_bool n b = false) ->\nforall b : nat, b < S n -> le_bool (S n) b = false"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   (?Goal : forall b : nat, b < 0 -> le_bool 0 b = false)\n   (?Goal0\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"]}, {"text": "intros b H1; inversion H1.", "goal_before": ["forall b : nat, b < 0 -> le_bool 0 b = false", "forall n : nat,\n(forall b : nat, b < n -> le_bool n b = false) ->\nforall b : nat, b < S n -> le_bool (S n) b = false"], "goal_after": ["forall n : nat,\n(forall b : nat, b < n -> le_bool n b = false) ->\nforall b : nat, b < S n -> le_bool (S n) b = false"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   (?Goal : forall b : nat, b < 0 -> le_bool 0 b = false)\n   (?Goal0\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   ((fun (b : nat) (H1 : b < 0) =>\n     let H : 0 = 0 -> le_bool 0 b = false :=\n       match H1 in (_ <= n0) return (n0 = 0 -> le_bool 0 b = false) with\n       | le_n _ =>\n           fun H : S b = 0 =>\n           (fun H0 : S b = 0 =>\n            let H2 : False :=\n              eq_ind (S b)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (le_bool 0 b = false) H2) H\n       | le_S _ m x =>\n           (fun (m0 : nat) (H : S b <= m0) (H0 : S m0 = 0) =>\n            (fun H2 : S m0 = 0 =>\n             let H3 : False :=\n               eq_ind (S m0)\n                 (fun e : nat => match e with\n                                 | 0 => False\n                                 | S _ => True\n                                 end) I 0 H2 in\n             False_ind (S b <= m0 -> le_bool 0 b = false) H3) H0 H) m x\n       end in\n     H eq_refl)\n    :\n    forall b : nat, b < 0 -> le_bool 0 b = false)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"]}, {"text": "intros n H b; case b; simpl in |- *; auto.", "goal_before": ["forall n : nat,\n(forall b : nat, b < n -> le_bool n b = false) ->\nforall b : nat, b < S n -> le_bool (S n) b = false"], "goal_after": ["forall n0 : nat, S n0 < S n -> le_bool n n0 = false"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   ((fun (b : nat) (H1 : b < 0) =>\n     let H : 0 = 0 -> le_bool 0 b = false :=\n       match H1 in (_ <= n0) return (n0 = 0 -> le_bool 0 b = false) with\n       | le_n _ =>\n           fun H : S b = 0 =>\n           (fun H0 : S b = 0 =>\n            let H2 : False :=\n              eq_ind (S b)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (le_bool 0 b = false) H2) H\n       | le_S _ m x =>\n           (fun (m0 : nat) (H : S b <= m0) (H0 : S m0 = 0) =>\n            (fun H2 : S m0 = 0 =>\n             let H3 : False :=\n               eq_ind (S m0)\n                 (fun e : nat => match e with\n                                 | 0 => False\n                                 | S _ => True\n                                 end) I 0 H2 in\n             False_ind (S b <= m0 -> le_bool 0 b = false) H3) H0 H) m x\n       end in\n     H eq_refl)\n    :\n    forall b : nat, b < 0 -> le_bool 0 b = false)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   ((fun (b : nat) (H1 : b < 0) =>\n     let H : 0 = 0 -> le_bool 0 b = false :=\n       match H1 in (_ <= n0) return (n0 = 0 -> le_bool 0 b = false) with\n       | le_n _ =>\n           fun H : S b = 0 =>\n           (fun H0 : S b = 0 =>\n            let H2 : False :=\n              eq_ind (S b)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (le_bool 0 b = false) H2) H\n       | le_S _ m x =>\n           (fun (m0 : nat) (H : S b <= m0) (H0 : S m0 = 0) =>\n            (fun H2 : S m0 = 0 =>\n             let H3 : False :=\n               eq_ind (S m0)\n                 (fun e : nat => match e with\n                                 | 0 => False\n                                 | S _ => True\n                                 end) I 0 H2 in\n             False_ind (S b <= m0 -> le_bool 0 b = false) H3) H0 H) m x\n       end in\n     H eq_refl)\n    :\n    forall b : nat, b < 0 -> le_bool 0 b = false)\n   ((fun (n : nat) (H : forall b : nat, b < n -> le_bool n b = false)\n       (b : nat) =>\n     match b as n0 return (n0 < S n -> le_bool (S n) n0 = false) with\n     | 0 => (fun _ : 0 < S n => eq_refl) : 0 < S n -> le_bool (S n) 0 = false\n     | S n0 =>\n         (?Goal : forall n1 : nat, S n1 < S n -> le_bool (S n) (S n1) = false)\n           n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"]}, {"text": "intros n0 H0; apply H.", "goal_before": ["forall n0 : nat, S n0 < S n -> le_bool n n0 = false"], "goal_after": ["n0 < n"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   ((fun (b : nat) (H1 : b < 0) =>\n     let H : 0 = 0 -> le_bool 0 b = false :=\n       match H1 in (_ <= n0) return (n0 = 0 -> le_bool 0 b = false) with\n       | le_n _ =>\n           fun H : S b = 0 =>\n           (fun H0 : S b = 0 =>\n            let H2 : False :=\n              eq_ind (S b)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (le_bool 0 b = false) H2) H\n       | le_S _ m x =>\n           (fun (m0 : nat) (H : S b <= m0) (H0 : S m0 = 0) =>\n            (fun H2 : S m0 = 0 =>\n             let H3 : False :=\n               eq_ind (S m0)\n                 (fun e : nat => match e with\n                                 | 0 => False\n                                 | S _ => True\n                                 end) I 0 H2 in\n             False_ind (S b <= m0 -> le_bool 0 b = false) H3) H0 H) m x\n       end in\n     H eq_refl)\n    :\n    forall b : nat, b < 0 -> le_bool 0 b = false)\n   ((fun (n : nat) (H : forall b : nat, b < n -> le_bool n b = false)\n       (b : nat) =>\n     match b as n0 return (n0 < S n -> le_bool (S n) n0 = false) with\n     | 0 => (fun _ : 0 < S n => eq_refl) : 0 < S n -> le_bool (S n) 0 = false\n     | S n0 =>\n         (?Goal : forall n1 : nat, S n1 < S n -> le_bool (S n) (S n1) = false)\n           n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   ((fun (b : nat) (H1 : b < 0) =>\n     let H : 0 = 0 -> le_bool 0 b = false :=\n       match H1 in (_ <= n0) return (n0 = 0 -> le_bool 0 b = false) with\n       | le_n _ =>\n           fun H : S b = 0 =>\n           (fun H0 : S b = 0 =>\n            let H2 : False :=\n              eq_ind (S b)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (le_bool 0 b = false) H2) H\n       | le_S _ m x =>\n           (fun (m0 : nat) (H : S b <= m0) (H0 : S m0 = 0) =>\n            (fun H2 : S m0 = 0 =>\n             let H3 : False :=\n               eq_ind (S m0)\n                 (fun e : nat => match e with\n                                 | 0 => False\n                                 | S _ => True\n                                 end) I 0 H2 in\n             False_ind (S b <= m0 -> le_bool 0 b = false) H3) H0 H) m x\n       end in\n     H eq_refl)\n    :\n    forall b : nat, b < 0 -> le_bool 0 b = false)\n   ((fun (n : nat) (H : forall b : nat, b < n -> le_bool n b = false)\n       (b : nat) =>\n     match b as n0 return (n0 < S n -> le_bool (S n) n0 = false) with\n     | 0 => (fun _ : 0 < S n => eq_refl) : 0 < S n -> le_bool (S n) 0 = false\n     | S n0 =>\n         ((fun (n1 : nat) (H0 : S n1 < S n) => H n1 ?Goal@{n0:=n1})\n          :\n          forall n1 : nat, S n1 < S n -> le_bool (S n) (S n1) = false) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"]}, {"text": "apply lt_S_n; auto.", "goal_before": ["n0 < n"], "goal_after": [], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   ((fun (b : nat) (H1 : b < 0) =>\n     let H : 0 = 0 -> le_bool 0 b = false :=\n       match H1 in (_ <= n0) return (n0 = 0 -> le_bool 0 b = false) with\n       | le_n _ =>\n           fun H : S b = 0 =>\n           (fun H0 : S b = 0 =>\n            let H2 : False :=\n              eq_ind (S b)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (le_bool 0 b = false) H2) H\n       | le_S _ m x =>\n           (fun (m0 : nat) (H : S b <= m0) (H0 : S m0 = 0) =>\n            (fun H2 : S m0 = 0 =>\n             let H3 : False :=\n               eq_ind (S m0)\n                 (fun e : nat => match e with\n                                 | 0 => False\n                                 | S _ => True\n                                 end) I 0 H2 in\n             False_ind (S b <= m0 -> le_bool 0 b = false) H3) H0 H) m x\n       end in\n     H eq_refl)\n    :\n    forall b : nat, b < 0 -> le_bool 0 b = false)\n   ((fun (n : nat) (H : forall b : nat, b < n -> le_bool n b = false)\n       (b : nat) =>\n     match b as n0 return (n0 < S n -> le_bool (S n) n0 = false) with\n     | 0 => (fun _ : 0 < S n => eq_refl) : 0 < S n -> le_bool (S n) 0 = false\n     | S n0 =>\n         ((fun (n1 : nat) (H0 : S n1 < S n) => H n1 ?Goal@{n0:=n1})\n          :\n          forall n1 : nat, S n1 < S n -> le_bool (S n) (S n1) = false) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   ((fun (b : nat) (H1 : b < 0) =>\n     let H : 0 = 0 -> le_bool 0 b = false :=\n       match H1 in (_ <= n0) return (n0 = 0 -> le_bool 0 b = false) with\n       | le_n _ =>\n           fun H : S b = 0 =>\n           (fun H0 : S b = 0 =>\n            let H2 : False :=\n              eq_ind (S b)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (le_bool 0 b = false) H2) H\n       | le_S _ m x =>\n           (fun (m0 : nat) (H : S b <= m0) (H0 : S m0 = 0) =>\n            (fun H2 : S m0 = 0 =>\n             let H3 : False :=\n               eq_ind (S m0)\n                 (fun e : nat => match e with\n                                 | 0 => False\n                                 | S _ => True\n                                 end) I 0 H2 in\n             False_ind (S b <= m0 -> le_bool 0 b = false) H3) H0 H) m x\n       end in\n     H eq_refl)\n    :\n    forall b : nat, b < 0 -> le_bool 0 b = false)\n   ((fun (n : nat) (H : forall b : nat, b < n -> le_bool n b = false)\n       (b : nat) =>\n     match b as n0 return (n0 < S n -> le_bool (S n) n0 = false) with\n     | 0 => (fun _ : 0 < S n => eq_refl) : 0 < S n -> le_bool (S n) 0 = false\n     | S n0 =>\n         ((fun (n1 : nat) (H0 : S n1 < S n) => H n1 (lt_S_n n1 n H0))\n          :\n          forall n1 : nat, S n1 < S n -> le_bool (S n) (S n1) = false) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, b < a0 -> le_bool a0 b = false)\n   ((fun (b : nat) (H1 : b < 0) =>\n     let H : 0 = 0 -> le_bool 0 b = false :=\n       match H1 in (_ <= n0) return (n0 = 0 -> le_bool 0 b = false) with\n       | le_n _ =>\n           fun H : S b = 0 =>\n           (fun H0 : S b = 0 =>\n            let H2 : False :=\n              eq_ind (S b)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (le_bool 0 b = false) H2) H\n       | le_S _ m x =>\n           (fun (m0 : nat) (H : S b <= m0) (H0 : S m0 = 0) =>\n            (fun H2 : S m0 = 0 =>\n             let H3 : False :=\n               eq_ind (S m0)\n                 (fun e : nat => match e with\n                                 | 0 => False\n                                 | S _ => True\n                                 end) I 0 H2 in\n             False_ind (S b <= m0 -> le_bool 0 b = false) H3) H0 H) m x\n       end in\n     H eq_refl)\n    :\n    forall b : nat, b < 0 -> le_bool 0 b = false)\n   ((fun (n : nat) (H : forall b : nat, b < n -> le_bool n b = false)\n       (b : nat) =>\n     match b as n0 return (n0 < S n -> le_bool (S n) n0 = false) with\n     | 0 => (fun _ : 0 < S n => eq_refl) : 0 < S n -> le_bool (S n) 0 = false\n     | S n0 =>\n         ((fun (n1 : nat) (H0 : S n1 < S n) => H n1 (lt_S_n n1 n H0))\n          :\n          forall n1 : nat, S n1 < S n -> le_bool (S n) (S n1) = false) n0\n     end)\n    :\n    forall n : nat,\n    (forall b : nat, b < n -> le_bool n b = false) ->\n    forall b : nat, b < S n -> le_bool (S n) b = false) a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "le_bool_correct3", "text": "Theorem le_bool_correct3 : forall a b : nat, le_bool a b = true -> a <= b.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate);\n auto with arith.\nQed.\n", "definition": " forall a b : nat, le_bool a b = true -> a <= b.", "proof": "\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate);\n auto with arith.\n", "def_ranges": [122, 0, 122, 74], "proof_ranges": [123, 0, 128, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall a b : nat, le_bool a b = true -> a <= b"], "goal_after": ["forall a b : nat, le_bool a b = true -> a <= b"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a; elim a; simpl in |- *; auto.", "goal_before": ["forall a b : nat, le_bool a b = true -> a <= b"], "goal_after": ["forall b : nat, le_bool 0 b = true -> 0 <= b", "forall n : nat,\n(forall b : nat, le_bool n b = true -> n <= b) ->\nforall b : nat, le_bool (S n) b = true -> S n <= b"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, le_bool a0 b = true -> a0 <= b)\n   (?Goal : forall b : nat, le_bool 0 b = true -> 0 <= b)\n   (?Goal0\n    :\n    forall n : nat,\n    (forall b : nat, le_bool n b = true -> n <= b) ->\n    forall b : nat, le_bool (S n) b = true -> S n <= b) a)"]}, {"text": "intros b; case b; simpl in |- *; auto with arith.", "goal_before": ["forall b : nat, le_bool 0 b = true -> 0 <= b", "forall n : nat,\n(forall b : nat, le_bool n b = true -> n <= b) ->\nforall b : nat, le_bool (S n) b = true -> S n <= b"], "goal_after": ["forall n : nat,\n(forall b : nat, le_bool n b = true -> n <= b) ->\nforall b : nat, le_bool (S n) b = true -> S n <= b"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, le_bool a0 b = true -> a0 <= b)\n   (?Goal : forall b : nat, le_bool 0 b = true -> 0 <= b)\n   (?Goal0\n    :\n    forall n : nat,\n    (forall b : nat, le_bool n b = true -> n <= b) ->\n    forall b : nat, le_bool (S n) b = true -> S n <= b) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, le_bool a0 b = true -> a0 <= b)\n   ((fun b : nat =>\n     match b as n return (le_bool 0 n = true -> 0 <= n) with\n     | 0 => (fun _ : true = true => le_n 0) : le_bool 0 0 = true -> 0 <= 0\n     | S n =>\n         ((fun (n0 : nat) (_ : true = true) => le_S 0 n0 (Nat.le_0_l n0))\n          :\n          forall n0 : nat, le_bool 0 (S n0) = true -> 0 <= S n0) n\n     end)\n    :\n    forall b : nat, le_bool 0 b = true -> 0 <= b)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, le_bool n b = true -> n <= b) ->\n    forall b : nat, le_bool (S n) b = true -> S n <= b) a)"]}, {"text": "intros n H b; case b; simpl in |- *; try (intros; discriminate);", "goal_before": ["forall n : nat,\n(forall b : nat, le_bool n b = true -> n <= b) ->\nforall b : nat, le_bool (S n) b = true -> S n <= b"], "goal_after": ["forall n : nat,\n(forall b : nat, le_bool n b = true -> n <= b) ->\nforall b : nat, le_bool (S n) b = true -> S n <= b"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, le_bool a0 b = true -> a0 <= b)\n   ((fun b : nat =>\n     match b as n return (le_bool 0 n = true -> 0 <= n) with\n     | 0 => (fun _ : true = true => le_n 0) : le_bool 0 0 = true -> 0 <= 0\n     | S n =>\n         ((fun (n0 : nat) (_ : true = true) => le_S 0 n0 (Nat.le_0_l n0))\n          :\n          forall n0 : nat, le_bool 0 (S n0) = true -> 0 <= S n0) n\n     end)\n    :\n    forall b : nat, le_bool 0 b = true -> 0 <= b)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, le_bool n b = true -> n <= b) ->\n    forall b : nat, le_bool (S n) b = true -> S n <= b) a)"], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": ["forall n : nat,\n(forall b : nat, le_bool n b = true -> n <= b) ->\nforall b : nat, le_bool (S n) b = true -> S n <= b"], "goal_after": ["forall n : nat,\n(forall b : nat, le_bool n b = true -> n <= b) ->\nforall b : nat, le_bool (S n) b = true -> S n <= b"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "le_bool_correct4", "text": "Theorem le_bool_correct4 : forall a b : nat, le_bool a b = false -> b <= a.\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate);\n auto with arith.\nQed.\n", "definition": " forall a b : nat, le_bool a b = false -> b <= a.", "proof": "\nProof using.\nintros a; elim a; simpl in |- *; auto.\nintros b; case b; simpl in |- *; try (intros; discriminate); auto with arith.\nintros n H b; case b; simpl in |- *; try (intros; discriminate);\n auto with arith.\n", "def_ranges": [130, 0, 130, 75], "proof_ranges": [131, 0, 136, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall a b : nat, le_bool a b = false -> b <= a"], "goal_after": ["forall a b : nat, le_bool a b = false -> b <= a"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a; elim a; simpl in |- *; auto.", "goal_before": ["forall a b : nat, le_bool a b = false -> b <= a"], "goal_after": ["forall b : nat, le_bool 0 b = false -> b <= 0", "forall n : nat,\n(forall b : nat, le_bool n b = false -> b <= n) ->\nforall b : nat, le_bool (S n) b = false -> b <= S n"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, le_bool a0 b = false -> b <= a0)\n   (?Goal : forall b : nat, le_bool 0 b = false -> b <= 0)\n   (?Goal0\n    :\n    forall n : nat,\n    (forall b : nat, le_bool n b = false -> b <= n) ->\n    forall b : nat, le_bool (S n) b = false -> b <= S n) a)"]}, {"text": "intros b; case b; simpl in |- *; try (intros; discriminate); auto with arith.", "goal_before": ["forall b : nat, le_bool 0 b = false -> b <= 0", "forall n : nat,\n(forall b : nat, le_bool n b = false -> b <= n) ->\nforall b : nat, le_bool (S n) b = false -> b <= S n"], "goal_after": ["forall n : nat,\n(forall b : nat, le_bool n b = false -> b <= n) ->\nforall b : nat, le_bool (S n) b = false -> b <= S n"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, le_bool a0 b = false -> b <= a0)\n   (?Goal : forall b : nat, le_bool 0 b = false -> b <= 0)\n   (?Goal0\n    :\n    forall n : nat,\n    (forall b : nat, le_bool n b = false -> b <= n) ->\n    forall b : nat, le_bool (S n) b = false -> b <= S n) a)"], "proof_term_after": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, le_bool a0 b = false -> b <= a0)\n   ((fun b : nat =>\n     match b as n return (le_bool 0 n = false -> n <= 0) with\n     | 0 =>\n         (fun H : true = false =>\n          let H0 : False :=\n            eq_ind true (fun e : bool => if e then True else False) I false H\n            in\n          False_ind (0 <= 0) H0)\n         :\n         le_bool 0 0 = false -> 0 <= 0\n     | S n =>\n         ((fun (n0 : nat) (H : true = false) =>\n           let H0 : False :=\n             eq_ind true (fun e : bool => if e then True else False) I false\n               H in\n           False_ind (S n0 <= 0) H0)\n          :\n          forall n0 : nat, le_bool 0 (S n0) = false -> S n0 <= 0) n\n     end)\n    :\n    forall b : nat, le_bool 0 b = false -> b <= 0)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, le_bool n b = false -> b <= n) ->\n    forall b : nat, le_bool (S n) b = false -> b <= S n) a)"]}, {"text": "intros n H b; case b; simpl in |- *; try (intros; discriminate);", "goal_before": ["forall n : nat,\n(forall b : nat, le_bool n b = false -> b <= n) ->\nforall b : nat, le_bool (S n) b = false -> b <= S n"], "goal_after": ["forall n : nat,\n(forall b : nat, le_bool n b = false -> b <= n) ->\nforall b : nat, le_bool (S n) b = false -> b <= S n"], "proof_term_before": ["(fun a : nat =>\n nat_ind (fun a0 : nat => forall b : nat, le_bool a0 b = false -> b <= a0)\n   ((fun b : nat =>\n     match b as n return (le_bool 0 n = false -> n <= 0) with\n     | 0 =>\n         (fun H : true = false =>\n          let H0 : False :=\n            eq_ind true (fun e : bool => if e then True else False) I false H\n            in\n          False_ind (0 <= 0) H0)\n         :\n         le_bool 0 0 = false -> 0 <= 0\n     | S n =>\n         ((fun (n0 : nat) (H : true = false) =>\n           let H0 : False :=\n             eq_ind true (fun e : bool => if e then True else False) I false\n               H in\n           False_ind (S n0 <= 0) H0)\n          :\n          forall n0 : nat, le_bool 0 (S n0) = false -> S n0 <= 0) n\n     end)\n    :\n    forall b : nat, le_bool 0 b = false -> b <= 0)\n   (?Goal\n    :\n    forall n : nat,\n    (forall b : nat, le_bool n b = false -> b <= n) ->\n    forall b : nat, le_bool (S n) b = false -> b <= S n) a)"], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": ["forall n : nat,\n(forall b : nat, le_bool n b = false -> b <= n) ->\nforall b : nat, le_bool (S n) b = false -> b <= S n"], "goal_after": ["forall n : nat,\n(forall b : nat, le_bool n b = false -> b <= n) ->\nforall b : nat, le_bool (S n) b = false -> b <= S n"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "fold_left_app", "text": "Theorem fold_left_app :\n forall a l1 l2, fold_left f (l1 ++ l2) a = fold_left f l2 (fold_left f l1 a).\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nQed.\n", "definition": "\n forall a l1 l2, fold_left f (l1 ++ l2) a = fold_left f l2 (fold_left f l1 a).", "proof": "\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\n", "def_ranges": [148, 0, 149, 78], "proof_ranges": [150, 0, 152, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l1 l2 : list B),\nfold_left f (l1 ++ l2) a = fold_left f l2 (fold_left f l1 a)"], "goal_after": ["forall (a : A) (l1 l2 : list B),\nfold_left f (l1 ++ l2) a = fold_left f l2 (fold_left f l1 a)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.", "goal_before": ["forall (a : A) (l1 l2 : list B),\nfold_left f (l1 ++ l2) a = fold_left f l2 (fold_left f l1 a)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l1 : list B) =>\n list_ind\n   (fun l2 : list B =>\n    forall (a0 : A) (l3 : list B),\n    fold_left f (l2 ++ l3) a0 = fold_left f l3 (fold_left f l2 a0))\n   ((fun (a0 : A) (l2 : list B) => eq_refl)\n    :\n    forall (a0 : A) (l2 : list B),\n    fold_left f (nil ++ l2) a0 = fold_left f l2 (fold_left f nil a0))\n   ((fun (a0 : B) (l : list B)\n       (H : forall (a1 : A) (l2 : list B),\n            fold_left f (l ++ l2) a1 = fold_left f l2 (fold_left f l a1))\n       (a1 : A) (l2 : list B) => H (f a1 a0) l2)\n    :\n    forall (a0 : B) (l : list B),\n    (forall (a1 : A) (l2 : list B),\n     fold_left f (l ++ l2) a1 = fold_left f l2 (fold_left f l a1)) ->\n    forall (a1 : A) (l2 : list B),\n    fold_left f ((a0 :: l) ++ l2) a1 =\n    fold_left f l2 (fold_left f (a0 :: l) a1)) l1 a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 : list B) =>\n list_ind\n   (fun l2 : list B =>\n    forall (a0 : A) (l3 : list B),\n    fold_left f (l2 ++ l3) a0 = fold_left f l3 (fold_left f l2 a0))\n   ((fun (a0 : A) (l2 : list B) => eq_refl)\n    :\n    forall (a0 : A) (l2 : list B),\n    fold_left f (nil ++ l2) a0 = fold_left f l2 (fold_left f nil a0))\n   ((fun (a0 : B) (l : list B)\n       (H : forall (a1 : A) (l2 : list B),\n            fold_left f (l ++ l2) a1 = fold_left f l2 (fold_left f l a1))\n       (a1 : A) (l2 : list B) => H (f a1 a0) l2)\n    :\n    forall (a0 : B) (l : list B),\n    (forall (a1 : A) (l2 : list B),\n     fold_left f (l ++ l2) a1 = fold_left f l2 (fold_left f l a1)) ->\n    forall (a1 : A) (l2 : list B),\n    fold_left f ((a0 :: l) ++ l2) a1 =\n    fold_left f l2 (fold_left f (a0 :: l) a1)) l1 a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "fold_left_eta", "text": "Theorem fold_left_eta :\n forall l a f1,\n (forall a b, In b l -> f a b = f1 a b) -> fold_left f l a = fold_left f1 l a.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H a0 f1 H0.\nrewrite H0; auto.\nQed.\n", "definition": "\n forall l a f1,\n (forall a b, In b l -> f a b = f1 a b) -> fold_left f l a = fold_left f1 l a.", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H a0 f1 H0.\nrewrite H0; auto.\n", "def_ranges": [154, 0, 156, 78], "proof_ranges": [157, 0, 161, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l : list B) (a : A) (f1 : A -> B -> A),\n(forall (a0 : A) (b : B), In b l -> f a0 b = f1 a0 b) ->\nfold_left f l a = fold_left f1 l a"], "goal_after": ["forall (l : list B) (a : A) (f1 : A -> B -> A),\n(forall (a0 : A) (b : B), In b l -> f a0 b = f1 a0 b) ->\nfold_left f l a = fold_left f1 l a"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall (l : list B) (a : A) (f1 : A -> B -> A),\n(forall (a0 : A) (b : B), In b l -> f a0 b = f1 a0 b) ->\nfold_left f l a = fold_left f1 l a"], "goal_after": ["forall (a : B) (l0 : list B),\n(forall (a0 : A) (f1 : A -> B -> A),\n (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n fold_left f l0 a0 = fold_left f1 l0 a0) ->\nforall (a0 : A) (f1 : A -> B -> A),\n(forall (a1 : A) (b : B), a = b \\/ In b l0 -> f a1 b = f1 a1 b) ->\nfold_left f l0 (f a0 a) = fold_left f1 l0 (f1 a0 a)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list B =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b l0 -> f a0 b = f1 a0 b) ->\n    fold_left f l0 a = fold_left f1 l0 a)\n   ((fun (a : A) (f1 : A -> B -> A)\n       (_ : forall (a0 : A) (b : B), False -> f a0 b = f1 a0 b) => eq_refl)\n    :\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b nil -> f a0 b = f1 a0 b) ->\n    fold_left f nil a = fold_left f1 nil a)\n   (?Goal\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : A) (f1 : A -> B -> A),\n     (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n     fold_left f l0 a0 = fold_left f1 l0 a0) ->\n    forall (a0 : A) (f1 : A -> B -> A),\n    (forall (a1 : A) (b : B), In b (a :: l0) -> f a1 b = f1 a1 b) ->\n    fold_left f (a :: l0) a0 = fold_left f1 (a :: l0) a0) l)"]}, {"text": "intros a l0 H a0 f1 H0.", "goal_before": ["forall (a : B) (l0 : list B),\n(forall (a0 : A) (f1 : A -> B -> A),\n (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n fold_left f l0 a0 = fold_left f1 l0 a0) ->\nforall (a0 : A) (f1 : A -> B -> A),\n(forall (a1 : A) (b : B), a = b \\/ In b l0 -> f a1 b = f1 a1 b) ->\nfold_left f l0 (f a0 a) = fold_left f1 l0 (f1 a0 a)"], "goal_after": ["fold_left f l0 (f a0 a) = fold_left f1 l0 (f1 a0 a)"], "proof_term_before": ["(fun l : list B =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b l0 -> f a0 b = f1 a0 b) ->\n    fold_left f l0 a = fold_left f1 l0 a)\n   ((fun (a : A) (f1 : A -> B -> A)\n       (_ : forall (a0 : A) (b : B), False -> f a0 b = f1 a0 b) => eq_refl)\n    :\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b nil -> f a0 b = f1 a0 b) ->\n    fold_left f nil a = fold_left f1 nil a)\n   (?Goal\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : A) (f1 : A -> B -> A),\n     (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n     fold_left f l0 a0 = fold_left f1 l0 a0) ->\n    forall (a0 : A) (f1 : A -> B -> A),\n    (forall (a1 : A) (b : B), In b (a :: l0) -> f a1 b = f1 a1 b) ->\n    fold_left f (a :: l0) a0 = fold_left f1 (a :: l0) a0) l)"], "proof_term_after": ["(fun l : list B =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b l0 -> f a0 b = f1 a0 b) ->\n    fold_left f l0 a = fold_left f1 l0 a)\n   ((fun (a : A) (f1 : A -> B -> A)\n       (_ : forall (a0 : A) (b : B), False -> f a0 b = f1 a0 b) => eq_refl)\n    :\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b nil -> f a0 b = f1 a0 b) ->\n    fold_left f nil a = fold_left f1 nil a)\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : A) (f1 : A -> B -> A),\n            (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n            fold_left f l0 a0 = fold_left f1 l0 a0) \n       (a0 : A) (f1 : A -> B -> A)\n       (H0 : forall (a1 : A) (b : B), a = b \\/ In b l0 -> f a1 b = f1 a1 b)\n     => ?Goal)\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : A) (f1 : A -> B -> A),\n     (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n     fold_left f l0 a0 = fold_left f1 l0 a0) ->\n    forall (a0 : A) (f1 : A -> B -> A),\n    (forall (a1 : A) (b : B), In b (a :: l0) -> f a1 b = f1 a1 b) ->\n    fold_left f (a :: l0) a0 = fold_left f1 (a :: l0) a0) l)"]}, {"text": "rewrite H0; auto.", "goal_before": ["fold_left f l0 (f a0 a) = fold_left f1 l0 (f1 a0 a)"], "goal_after": [], "proof_term_before": ["(fun l : list B =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b l0 -> f a0 b = f1 a0 b) ->\n    fold_left f l0 a = fold_left f1 l0 a)\n   ((fun (a : A) (f1 : A -> B -> A)\n       (_ : forall (a0 : A) (b : B), False -> f a0 b = f1 a0 b) => eq_refl)\n    :\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b nil -> f a0 b = f1 a0 b) ->\n    fold_left f nil a = fold_left f1 nil a)\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : A) (f1 : A -> B -> A),\n            (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n            fold_left f l0 a0 = fold_left f1 l0 a0) \n       (a0 : A) (f1 : A -> B -> A)\n       (H0 : forall (a1 : A) (b : B), a = b \\/ In b l0 -> f a1 b = f1 a1 b)\n     => ?Goal)\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : A) (f1 : A -> B -> A),\n     (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n     fold_left f l0 a0 = fold_left f1 l0 a0) ->\n    forall (a0 : A) (f1 : A -> B -> A),\n    (forall (a1 : A) (b : B), In b (a :: l0) -> f a1 b = f1 a1 b) ->\n    fold_left f (a :: l0) a0 = fold_left f1 (a :: l0) a0) l)"], "proof_term_after": ["(fun l : list B =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b l0 -> f a0 b = f1 a0 b) ->\n    fold_left f l0 a = fold_left f1 l0 a)\n   ((fun (a : A) (f1 : A -> B -> A)\n       (_ : forall (a0 : A) (b : B), False -> f a0 b = f1 a0 b) => eq_refl)\n    :\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b nil -> f a0 b = f1 a0 b) ->\n    fold_left f nil a = fold_left f1 nil a)\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : A) (f1 : A -> B -> A),\n            (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n            fold_left f l0 a0 = fold_left f1 l0 a0) \n       (a0 : A) (f1 : A -> B -> A)\n       (H0 : forall (a1 : A) (b : B), a = b \\/ In b l0 -> f a1 b = f1 a1 b)\n     =>\n     eq_ind_r (fun a1 : A => fold_left f l0 a1 = fold_left f1 l0 (f1 a0 a))\n       (H (f1 a0 a) f1\n          (fun (a1 : A) (b : B) (H1 : In b l0) => H0 a1 b (or_intror H1)))\n       (H0 a0 a (or_introl eq_refl)))\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : A) (f1 : A -> B -> A),\n     (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n     fold_left f l0 a0 = fold_left f1 l0 a0) ->\n    forall (a0 : A) (f1 : A -> B -> A),\n    (forall (a1 : A) (b : B), In b (a :: l0) -> f a1 b = f1 a1 b) ->\n    fold_left f (a :: l0) a0 = fold_left f1 (a :: l0) a0) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list B =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b l0 -> f a0 b = f1 a0 b) ->\n    fold_left f l0 a = fold_left f1 l0 a)\n   ((fun (a : A) (f1 : A -> B -> A)\n       (_ : forall (a0 : A) (b : B), False -> f a0 b = f1 a0 b) => eq_refl)\n    :\n    forall (a : A) (f1 : A -> B -> A),\n    (forall (a0 : A) (b : B), In b nil -> f a0 b = f1 a0 b) ->\n    fold_left f nil a = fold_left f1 nil a)\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : A) (f1 : A -> B -> A),\n            (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n            fold_left f l0 a0 = fold_left f1 l0 a0) \n       (a0 : A) (f1 : A -> B -> A)\n       (H0 : forall (a1 : A) (b : B), a = b \\/ In b l0 -> f a1 b = f1 a1 b)\n     =>\n     eq_ind_r (fun a1 : A => fold_left f l0 a1 = fold_left f1 l0 (f1 a0 a))\n       (H (f1 a0 a) f1\n          (fun (a1 : A) (b : B) (H1 : In b l0) => H0 a1 b (or_intror H1)))\n       (H0 a0 a (or_introl eq_refl)))\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : A) (f1 : A -> B -> A),\n     (forall (a1 : A) (b : B), In b l0 -> f a1 b = f1 a1 b) ->\n     fold_left f l0 a0 = fold_left f1 l0 a0) ->\n    forall (a0 : A) (f1 : A -> B -> A),\n    (forall (a1 : A) (b : B), In b (a :: l0) -> f a1 b = f1 a1 b) ->\n    fold_left f (a :: l0) a0 = fold_left f1 (a :: l0) a0) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "fold_left_map", "text": "Theorem fold_left_map :\n forall (C : Type) a l (k : C -> B),\n fold_left f (map k l) a = fold_left (fun a b => f a (k b)) l a.\nProof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\nQed.\n", "definition": "\n forall (C : Type) a l (k : C -> B),\n fold_left f (map k l) a = fold_left (fun a b => f a (k b)) l a.", "proof": "\nProof using.\nintros C a l k; generalize a; elim l; simpl in |- *; auto.\n", "def_ranges": [163, 0, 165, 64], "proof_ranges": [166, 0, 168, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (C : Type) (a : A) (l : list C) (k : C -> B),\nfold_left f (map k l) a = fold_left (fun (a0 : A) (b : C) => f a0 (k b)) l a"], "goal_after": ["forall (C : Type) (a : A) (l : list C) (k : C -> B),\nfold_left f (map k l) a = fold_left (fun (a0 : A) (b : C) => f a0 (k b)) l a"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros C a l k; generalize a; elim l; simpl in |- *; auto.", "goal_before": ["forall (C : Type) (a : A) (l : list C) (k : C -> B),\nfold_left f (map k l) a = fold_left (fun (a0 : A) (b : C) => f a0 (k b)) l a"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (C : Type) (a : A) (l : list C) (k : C -> B) =>\n list_ind\n   (fun l0 : list C =>\n    forall a0 : A,\n    fold_left f (map k l0) a0 =\n    fold_left (fun (a1 : A) (b : C) => f a1 (k b)) l0 a0)\n   ((fun a0 : A => eq_refl)\n    :\n    forall a0 : A,\n    fold_left f (map k nil) a0 =\n    fold_left (fun (a1 : A) (b : C) => f a1 (k b)) nil a0)\n   ((fun (a0 : C) (l0 : list C)\n       (H : forall a1 : A,\n            fold_left f (map k l0) a1 =\n            fold_left (fun (a2 : A) (b : C) => f a2 (k b)) l0 a1) \n       (a1 : A) => H (f a1 (k a0)))\n    :\n    forall (a0 : C) (l0 : list C),\n    (forall a1 : A,\n     fold_left f (map k l0) a1 =\n     fold_left (fun (a2 : A) (b : C) => f a2 (k b)) l0 a1) ->\n    forall a1 : A,\n    fold_left f (map k (a0 :: l0)) a1 =\n    fold_left (fun (a2 : A) (b : C) => f a2 (k b)) (a0 :: l0) a1) l a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (C : Type) (a : A) (l : list C) (k : C -> B) =>\n list_ind\n   (fun l0 : list C =>\n    forall a0 : A,\n    fold_left f (map k l0) a0 =\n    fold_left (fun (a1 : A) (b : C) => f a1 (k b)) l0 a0)\n   ((fun a0 : A => eq_refl)\n    :\n    forall a0 : A,\n    fold_left f (map k nil) a0 =\n    fold_left (fun (a1 : A) (b : C) => f a1 (k b)) nil a0)\n   ((fun (a0 : C) (l0 : list C)\n       (H : forall a1 : A,\n            fold_left f (map k l0) a1 =\n            fold_left (fun (a2 : A) (b : C) => f a2 (k b)) l0 a1) \n       (a1 : A) => H (f a1 (k a0)))\n    :\n    forall (a0 : C) (l0 : list C),\n    (forall a1 : A,\n     fold_left f (map k l0) a1 =\n     fold_left (fun (a2 : A) (b : C) => f a2 (k b)) l0 a1) ->\n    forall a1 : A,\n    fold_left f (map k (a0 :: l0)) a1 =\n    fold_left (fun (a2 : A) (b : C) => f a2 (k b)) (a0 :: l0) a1) l a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "fold_right_app", "text": "Theorem fold_right_app :\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\nQed.\n", "definition": "\n forall a l1 l2,\n fold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1.", "proof": "\nProof using.\nintros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.\nintros a l H a0 l2; rewrite H; auto.\n", "def_ranges": [170, 0, 172, 65], "proof_ranges": [173, 0, 176, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l1 l2 : list B),\nfold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1"], "goal_after": ["forall (a : A) (l1 l2 : list B),\nfold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l1; generalize a; elim l1; simpl in |- *; auto; clear a l1.", "goal_before": ["forall (a : A) (l1 l2 : list B),\nfold_right g a (l1 ++ l2) = fold_right g (fold_right g a l2) l1"], "goal_after": ["forall (a : B) (l : list B),\n(forall (a0 : A) (l2 : list B),\n fold_right g a0 (l ++ l2) = fold_right g (fold_right g a0 l2) l) ->\nforall (a0 : A) (l2 : list B),\ng a (fold_right g a0 (l ++ l2)) = g a (fold_right g (fold_right g a0 l2) l)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l1 : list B) =>\n list_ind\n   (fun l2 : list B =>\n    forall (a0 : A) (l3 : list B),\n    fold_right g a0 (l2 ++ l3) = fold_right g (fold_right g a0 l3) l2)\n   ((fun (a0 : A) (l2 : list B) => eq_refl)\n    :\n    forall (a0 : A) (l2 : list B),\n    fold_right g a0 (nil ++ l2) = fold_right g (fold_right g a0 l2) nil)\n   (?Goal\n    :\n    forall (a0 : B) (l : list B),\n    (forall (a1 : A) (l2 : list B),\n     fold_right g a1 (l ++ l2) = fold_right g (fold_right g a1 l2) l) ->\n    forall (a1 : A) (l2 : list B),\n    fold_right g a1 ((a0 :: l) ++ l2) =\n    fold_right g (fold_right g a1 l2) (a0 :: l)) l1 a)"]}, {"text": "intros a l H a0 l2; rewrite H; auto.", "goal_before": ["forall (a : B) (l : list B),\n(forall (a0 : A) (l2 : list B),\n fold_right g a0 (l ++ l2) = fold_right g (fold_right g a0 l2) l) ->\nforall (a0 : A) (l2 : list B),\ng a (fold_right g a0 (l ++ l2)) = g a (fold_right g (fold_right g a0 l2) l)"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 : list B) =>\n list_ind\n   (fun l2 : list B =>\n    forall (a0 : A) (l3 : list B),\n    fold_right g a0 (l2 ++ l3) = fold_right g (fold_right g a0 l3) l2)\n   ((fun (a0 : A) (l2 : list B) => eq_refl)\n    :\n    forall (a0 : A) (l2 : list B),\n    fold_right g a0 (nil ++ l2) = fold_right g (fold_right g a0 l2) nil)\n   (?Goal\n    :\n    forall (a0 : B) (l : list B),\n    (forall (a1 : A) (l2 : list B),\n     fold_right g a1 (l ++ l2) = fold_right g (fold_right g a1 l2) l) ->\n    forall (a1 : A) (l2 : list B),\n    fold_right g a1 ((a0 :: l) ++ l2) =\n    fold_right g (fold_right g a1 l2) (a0 :: l)) l1 a)"], "proof_term_after": ["(fun (a : A) (l1 : list B) =>\n list_ind\n   (fun l2 : list B =>\n    forall (a0 : A) (l3 : list B),\n    fold_right g a0 (l2 ++ l3) = fold_right g (fold_right g a0 l3) l2)\n   ((fun (a0 : A) (l2 : list B) => eq_refl)\n    :\n    forall (a0 : A) (l2 : list B),\n    fold_right g a0 (nil ++ l2) = fold_right g (fold_right g a0 l2) nil)\n   ((fun (a0 : B) (l : list B)\n       (H : forall (a1 : A) (l2 : list B),\n            fold_right g a1 (l ++ l2) = fold_right g (fold_right g a1 l2) l)\n       (a1 : A) (l2 : list B) =>\n     eq_ind_r\n       (fun a2 : A => g a0 a2 = g a0 (fold_right g (fold_right g a1 l2) l))\n       eq_refl (H a1 l2))\n    :\n    forall (a0 : B) (l : list B),\n    (forall (a1 : A) (l2 : list B),\n     fold_right g a1 (l ++ l2) = fold_right g (fold_right g a1 l2) l) ->\n    forall (a1 : A) (l2 : list B),\n    fold_right g a1 ((a0 :: l) ++ l2) =\n    fold_right g (fold_right g a1 l2) (a0 :: l)) l1 a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 : list B) =>\n list_ind\n   (fun l2 : list B =>\n    forall (a0 : A) (l3 : list B),\n    fold_right g a0 (l2 ++ l3) = fold_right g (fold_right g a0 l3) l2)\n   ((fun (a0 : A) (l2 : list B) => eq_refl)\n    :\n    forall (a0 : A) (l2 : list B),\n    fold_right g a0 (nil ++ l2) = fold_right g (fold_right g a0 l2) nil)\n   ((fun (a0 : B) (l : list B)\n       (H : forall (a1 : A) (l2 : list B),\n            fold_right g a1 (l ++ l2) = fold_right g (fold_right g a1 l2) l)\n       (a1 : A) (l2 : list B) =>\n     eq_ind_r\n       (fun a2 : A => g a0 a2 = g a0 (fold_right g (fold_right g a1 l2) l))\n       eq_refl (H a1 l2))\n    :\n    forall (a0 : B) (l : list B),\n    (forall (a1 : A) (l2 : list B),\n     fold_right g a1 (l ++ l2) = fold_right g (fold_right g a1 l2) l) ->\n    forall (a1 : A) (l2 : list B),\n    fold_right g a1 ((a0 :: l) ++ l2) =\n    fold_right g (fold_right g a1 l2) (a0 :: l)) l1 a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "fold_left_init", "text": "Theorem fold_left_init :\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\nQed.\n", "definition": "\n (forall (a : A) (b : B), h (f a b) = f (h a) b) ->\n forall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a).", "proof": "\nProof using.\nintros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.\nintros a l H0 a0.\nrewrite <- H; auto.\n", "def_ranges": [178, 0, 180, 72], "proof_ranges": [181, 0, 185, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["(forall (a : A) (b : B), h (f a b) = f (h a) b) ->\nforall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a)"], "goal_after": ["(forall (a : A) (b : B), h (f a b) = f (h a) b) ->\nforall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros H a l; generalize a; elim l; clear l a; simpl in |- *; auto.", "goal_before": ["(forall (a : A) (b : B), h (f a b) = f (h a) b) ->\nforall (a : A) (l : list B), fold_left f l (h a) = h (fold_left f l a)"], "goal_after": ["forall (a : B) (l : list B),\n(forall a0 : A, fold_left f l (h a0) = h (fold_left f l a0)) ->\nforall a0 : A, fold_left f l (f (h a0) a) = h (fold_left f l (f a0 a))"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (H : forall (a : A) (b : B), h (f a b) = f (h a) b) (a : A) (l : list B)\n =>\n list_ind\n   (fun l0 : list B =>\n    forall a0 : A, fold_left f l0 (h a0) = h (fold_left f l0 a0))\n   ((fun a0 : A => eq_refl)\n    :\n    forall a0 : A, fold_left f nil (h a0) = h (fold_left f nil a0))\n   (?Goal\n    :\n    forall (a0 : B) (l0 : list B),\n    (forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1)) ->\n    forall a1 : A,\n    fold_left f (a0 :: l0) (h a1) = h (fold_left f (a0 :: l0) a1)) l a)"]}, {"text": "intros a l H0 a0.", "goal_before": ["forall (a : B) (l : list B),\n(forall a0 : A, fold_left f l (h a0) = h (fold_left f l a0)) ->\nforall a0 : A, fold_left f l (f (h a0) a) = h (fold_left f l (f a0 a))"], "goal_after": ["fold_left f l (f (h a0) a) = h (fold_left f l (f a0 a))"], "proof_term_before": ["(fun (H : forall (a : A) (b : B), h (f a b) = f (h a) b) (a : A) (l : list B)\n =>\n list_ind\n   (fun l0 : list B =>\n    forall a0 : A, fold_left f l0 (h a0) = h (fold_left f l0 a0))\n   ((fun a0 : A => eq_refl)\n    :\n    forall a0 : A, fold_left f nil (h a0) = h (fold_left f nil a0))\n   (?Goal\n    :\n    forall (a0 : B) (l0 : list B),\n    (forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1)) ->\n    forall a1 : A,\n    fold_left f (a0 :: l0) (h a1) = h (fold_left f (a0 :: l0) a1)) l a)"], "proof_term_after": ["(fun (H : forall (a : A) (b : B), h (f a b) = f (h a) b) (a : A) (l : list B)\n =>\n list_ind\n   (fun l0 : list B =>\n    forall a0 : A, fold_left f l0 (h a0) = h (fold_left f l0 a0))\n   ((fun a0 : A => eq_refl)\n    :\n    forall a0 : A, fold_left f nil (h a0) = h (fold_left f nil a0))\n   ((fun (a0 : B) (l0 : list B)\n       (H0 : forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1))\n       (a1 : A) => ?Goal@{a:=a0; l:=l0; a0:=a1})\n    :\n    forall (a0 : B) (l0 : list B),\n    (forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1)) ->\n    forall a1 : A,\n    fold_left f (a0 :: l0) (h a1) = h (fold_left f (a0 :: l0) a1)) l a)"]}, {"text": "rewrite <- H; auto.", "goal_before": ["fold_left f l (f (h a0) a) = h (fold_left f l (f a0 a))"], "goal_after": [], "proof_term_before": ["(fun (H : forall (a : A) (b : B), h (f a b) = f (h a) b) (a : A) (l : list B)\n =>\n list_ind\n   (fun l0 : list B =>\n    forall a0 : A, fold_left f l0 (h a0) = h (fold_left f l0 a0))\n   ((fun a0 : A => eq_refl)\n    :\n    forall a0 : A, fold_left f nil (h a0) = h (fold_left f nil a0))\n   ((fun (a0 : B) (l0 : list B)\n       (H0 : forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1))\n       (a1 : A) => ?Goal@{a:=a0; l:=l0; a0:=a1})\n    :\n    forall (a0 : B) (l0 : list B),\n    (forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1)) ->\n    forall a1 : A,\n    fold_left f (a0 :: l0) (h a1) = h (fold_left f (a0 :: l0) a1)) l a)"], "proof_term_after": ["(fun (H : forall (a : A) (b : B), h (f a b) = f (h a) b) (a : A) (l : list B)\n =>\n list_ind\n   (fun l0 : list B =>\n    forall a0 : A, fold_left f l0 (h a0) = h (fold_left f l0 a0))\n   ((fun a0 : A => eq_refl)\n    :\n    forall a0 : A, fold_left f nil (h a0) = h (fold_left f nil a0))\n   ((fun (a0 : B) (l0 : list B)\n       (H0 : forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1))\n       (a1 : A) =>\n     eq_ind (h (f a1 a0))\n       (fun a2 : A => fold_left f l0 a2 = h (fold_left f l0 (f a1 a0)))\n       (H0 (f a1 a0)) (f (h a1) a0) (H a1 a0))\n    :\n    forall (a0 : B) (l0 : list B),\n    (forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1)) ->\n    forall a1 : A,\n    fold_left f (a0 :: l0) (h a1) = h (fold_left f (a0 :: l0) a1)) l a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (H : forall (a : A) (b : B), h (f a b) = f (h a) b) (a : A) (l : list B)\n =>\n list_ind\n   (fun l0 : list B =>\n    forall a0 : A, fold_left f l0 (h a0) = h (fold_left f l0 a0))\n   ((fun a0 : A => eq_refl)\n    :\n    forall a0 : A, fold_left f nil (h a0) = h (fold_left f nil a0))\n   ((fun (a0 : B) (l0 : list B)\n       (H0 : forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1))\n       (a1 : A) =>\n     eq_ind (h (f a1 a0))\n       (fun a2 : A => fold_left f l0 a2 = h (fold_left f l0 (f a1 a0)))\n       (H0 (f a1 a0)) (f (h a1) a0) (H a1 a0))\n    :\n    forall (a0 : B) (l0 : list B),\n    (forall a1 : A, fold_left f l0 (h a1) = h (fold_left f l0 a1)) ->\n    forall a1 : A,\n    fold_left f (a0 :: l0) (h a1) = h (fold_left f (a0 :: l0) a1)) l a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "list_length_ind", "text": "Theorem list_length_ind :\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\nQed.\n", "definition": "\n forall P : list A -> Prop,\n (forall l1 : list A,\n  (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\n forall l : list A, P l.", "proof": "\nProof using.\nintros P H l;\n apply well_founded_ind with (R := fun x y : list A => length x < length y);\n auto.\napply wf_inverse_image with (R := lt); auto.\napply lt_wf.\n", "def_ranges": [195, 0, 199, 24], "proof_ranges": [200, 0, 206, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "goal_after": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros P H l;", "goal_before": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "goal_after": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "apply well_founded_ind with (R := fun x y : list A => length x < length y);", "goal_before": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "goal_after": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "auto.", "goal_before": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "goal_after": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "proof_term_before": ["?Goal"], "proof_term_after": ["?Goal"]}, {"text": "apply wf_inverse_image with (R := lt); auto.", "goal_before": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "goal_after": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "proof_term_before": ["?Goal"], "proof_term_after": ["?Goal"]}, {"text": "apply lt_wf.", "goal_before": ["forall P : list A -> Prop,\n(forall l1 : list A,\n (forall l2 : list A, length l2 < length l1 -> P l2) -> P l1) ->\nforall l : list A, P l"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "in_ex_app", "text": "Theorem in_ex_app :\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n", "definition": "\n forall (a : A) (l : list A),\n In a l -> exists l1 : list A, (exists l2 : list A, l = l1 ++ a :: l2).", "proof": "\nProof using.\nintros a l; elim l; clear l; simpl in |- *; auto.\nintros H; case H.\nintros a1 l H [H1| H1]; auto.\nexists (nil (A:=A)); exists l; simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\ncase H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;\n simpl in |- *; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\n", "def_ranges": [221, 0, 223, 71], "proof_ranges": [224, 0, 233, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l : list A),\nIn a l -> exists l1 l2 : list A, l = l1 ++ a :: l2"], "goal_after": ["forall (a : A) (l : list A),\nIn a l -> exists l1 l2 : list A, l = l1 ++ a :: l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l; elim l; clear l; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l : list A),\nIn a l -> exists l1 l2 : list A, l = l1 ++ a :: l2"], "goal_after": ["False -> exists l1 l2 : list A, nil = l1 ++ a :: l2", "forall (a0 : A) (l : list A),\n(In a l -> exists l1 l2 : list A, l = l1 ++ a :: l2) ->\na0 = a \\/ In a l -> exists l1 l2 : list A, a0 :: l = l1 ++ a :: l2"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   (?Goal : In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   (?Goal0\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"]}, {"text": "intros H; case H.", "goal_before": ["False -> exists l1 l2 : list A, nil = l1 ++ a :: l2", "forall (a0 : A) (l : list A),\n(In a l -> exists l1 l2 : list A, l = l1 ++ a :: l2) ->\na0 = a \\/ In a l -> exists l1 l2 : list A, a0 :: l = l1 ++ a :: l2"], "goal_after": ["forall (a0 : A) (l : list A),\n(In a l -> exists l1 l2 : list A, l = l1 ++ a :: l2) ->\na0 = a \\/ In a l -> exists l1 l2 : list A, a0 :: l = l1 ++ a :: l2"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   (?Goal : In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   (?Goal0\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   ((fun H : False =>\n     match H return (exists l1 l2 : list A, nil = l1 ++ a :: l2) with\n     end)\n    :\n    In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   (?Goal\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"]}, {"text": "intros a1 l H [H1| H1]; auto.", "goal_before": ["forall (a0 : A) (l : list A),\n(In a l -> exists l1 l2 : list A, l = l1 ++ a :: l2) ->\na0 = a \\/ In a l -> exists l1 l2 : list A, a0 :: l = l1 ++ a :: l2"], "goal_after": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2", "exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   ((fun H : False =>\n     match H return (exists l1 l2 : list A, nil = l1 ++ a :: l2) with\n     end)\n    :\n    In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   (?Goal\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   ((fun H : False =>\n     match H return (exists l1 l2 : list A, nil = l1 ++ a :: l2) with\n     end)\n    :\n    In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   ((fun (a1 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n       (H0 : a1 = a \\/ In a l0) =>\n     match H0 with\n     | or_introl x => (fun H1 : a1 = a => ?Goal@{l:=l0}) x\n     | or_intror x => (fun H1 : In a l0 => ?Goal0@{l:=l0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"]}, {"text": "exists (nil (A:=A)); exists l; simpl in |- *; auto.", "goal_before": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2", "exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "goal_after": ["a1 :: l = a :: l", "exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   ((fun H : False =>\n     match H return (exists l1 l2 : list A, nil = l1 ++ a :: l2) with\n     end)\n    :\n    In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   ((fun (a1 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n       (H0 : a1 = a \\/ In a l0) =>\n     match H0 with\n     | or_introl x => (fun H1 : a1 = a => ?Goal@{l:=l0}) x\n     | or_intror x => (fun H1 : In a l0 => ?Goal0@{l:=l0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   ((fun H : False =>\n     match H return (exists l1 l2 : list A, nil = l1 ++ a :: l2) with\n     end)\n    :\n    In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   ((fun (a1 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n       (H0 : a1 = a \\/ In a l0) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : a1 = a =>\n          ex_intro\n            (fun l1 : list A => exists l2 : list A, a1 :: l0 = l1 ++ a :: l2)\n            nil\n            (ex_intro (fun l2 : list A => a1 :: l0 = nil ++ a :: l2) l0\n               (?Goal0@{l:=l0} : a1 :: l0 = nil ++ a :: l0))) x\n     | or_intror x => (fun H1 : In a l0 => ?Goal@{l:=l0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"]}, {"text": "apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": ["a1 :: l = a :: l", "exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "goal_after": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   ((fun H : False =>\n     match H return (exists l1 l2 : list A, nil = l1 ++ a :: l2) with\n     end)\n    :\n    In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   ((fun (a1 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n       (H0 : a1 = a \\/ In a l0) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : a1 = a =>\n          ex_intro\n            (fun l1 : list A => exists l2 : list A, a1 :: l0 = l1 ++ a :: l2)\n            nil\n            (ex_intro (fun l2 : list A => a1 :: l0 = nil ++ a :: l2) l0\n               (?Goal0@{l:=l0} : a1 :: l0 = nil ++ a :: l0))) x\n     | or_intror x => (fun H1 : In a l0 => ?Goal@{l:=l0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"], "proof_term_after": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   ((fun H : False =>\n     match H return (exists l1 l2 : list A, nil = l1 ++ a :: l2) with\n     end)\n    :\n    In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   ((fun (a1 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n       (H0 : a1 = a \\/ In a l0) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : a1 = a =>\n          ex_intro\n            (fun l1 : list A => exists l2 : list A, a1 :: l0 = l1 ++ a :: l2)\n            nil\n            (ex_intro (fun l2 : list A => a1 :: l0 = nil ++ a :: l2) l0\n               (f_equal2 cons H1 eq_refl : a1 :: l0 = nil ++ a :: l0))) x\n     | or_intror x => (fun H1 : In a l0 => ?Goal@{l:=l0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"]}, {"text": "case H; auto; intros l1 (l2, Hl2); exists (a1 :: l1); exists l2;", "goal_before": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "goal_after": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "proof_term_before": ["(fun (a : A) (l : list A) =>\n list_ind\n   (fun l0 : list A => In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n   ((fun H : False =>\n     match H return (exists l1 l2 : list A, nil = l1 ++ a :: l2) with\n     end)\n    :\n    In a nil -> exists l1 l2 : list A, nil = l1 ++ a :: l2)\n   ((fun (a1 : A) (l0 : list A)\n       (H : In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2)\n       (H0 : a1 = a \\/ In a l0) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : a1 = a =>\n          ex_intro\n            (fun l1 : list A => exists l2 : list A, a1 :: l0 = l1 ++ a :: l2)\n            nil\n            (ex_intro (fun l2 : list A => a1 :: l0 = nil ++ a :: l2) l0\n               (f_equal2 cons H1 eq_refl : a1 :: l0 = nil ++ a :: l0))) x\n     | or_intror x => (fun H1 : In a l0 => ?Goal@{l:=l0}) x\n     end)\n    :\n    forall (a0 : A) (l0 : list A),\n    (In a l0 -> exists l1 l2 : list A, l0 = l1 ++ a :: l2) ->\n    In a (a0 :: l0) -> exists l1 l2 : list A, a0 :: l0 = l1 ++ a :: l2) l)"], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "goal_after": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "goal_after": ["exists l1 l2 : list A, a1 :: l = l1 ++ a :: l2"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "length_app", "text": "Theorem length_app :\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nQed.\n", "definition": "\n forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2.", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\n", "def_ranges": [236, 0, 237, 66], "proof_ranges": [238, 0, 240, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2"], "goal_after": ["forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall l1 l2 : list A, length (l1 ++ l2) = length l1 + length l2"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall l3 : list A, length (l2 ++ l3) = length l2 + length l3)\n   ((fun l2 : list A => eq_refl)\n    :\n    forall l2 : list A, length (nil ++ l2) = length nil + length l2)\n   ((fun (_ : A) (l : list A)\n       (H : forall l2 : list A, length (l ++ l2) = length l + length l2)\n       (l2 : list A) =>\n     f_equal_nat nat S (length (l ++ l2)) (length l + length l2) (H l2))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, length (l ++ l2) = length l + length l2) ->\n    forall l2 : list A, length ((a :: l) ++ l2) = length (a :: l) + length l2)\n   l1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall l3 : list A, length (l2 ++ l3) = length l2 + length l3)\n   ((fun l2 : list A => eq_refl)\n    :\n    forall l2 : list A, length (nil ++ l2) = length nil + length l2)\n   ((fun (_ : A) (l : list A)\n       (H : forall l2 : list A, length (l ++ l2) = length l + length l2)\n       (l2 : list A) =>\n     f_equal_nat nat S (length (l ++ l2)) (length l + length l2) (H l2))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 : list A, length (l ++ l2) = length l + length l2) ->\n    forall l2 : list A, length ((a :: l) ++ l2) = length (a :: l) + length l2)\n   l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "app_inv_head", "text": "Theorem app_inv_head :\n forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\nQed.\n", "definition": "\n forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3.", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros a l H l2 l3 H0; apply H; injection H0; auto.\n", "def_ranges": [242, 0, 243, 58], "proof_ranges": [244, 0, 247, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3"], "goal_after": ["forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall l1 l2 l3 : list A, l1 ++ l2 = l1 ++ l3 -> l2 = l3"], "goal_after": ["forall (a : A) (l : list A),\n(forall l2 l3 : list A, l ++ l2 = l ++ l3 -> l2 = l3) ->\nforall l2 l3 : list A, a :: l ++ l2 = a :: l ++ l3 -> l2 = l3"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 l4 : list A, l2 ++ l3 = l2 ++ l4 -> l3 = l4)\n   ((fun (l2 l3 : list A) (H : l2 = l3) => H)\n    :\n    forall l2 l3 : list A, nil ++ l2 = nil ++ l3 -> l2 = l3)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l2 l3 : list A, l ++ l2 = l ++ l3 -> l2 = l3) ->\n    forall l2 l3 : list A, (a :: l) ++ l2 = (a :: l) ++ l3 -> l2 = l3) l1)"]}, {"text": "intros a l H l2 l3 H0; apply H; injection H0; auto.", "goal_before": ["forall (a : A) (l : list A),\n(forall l2 l3 : list A, l ++ l2 = l ++ l3 -> l2 = l3) ->\nforall l2 l3 : list A, a :: l ++ l2 = a :: l ++ l3 -> l2 = l3"], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 l4 : list A, l2 ++ l3 = l2 ++ l4 -> l3 = l4)\n   ((fun (l2 l3 : list A) (H : l2 = l3) => H)\n    :\n    forall l2 l3 : list A, nil ++ l2 = nil ++ l3 -> l2 = l3)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l2 l3 : list A, l ++ l2 = l ++ l3 -> l2 = l3) ->\n    forall l2 l3 : list A, (a :: l) ++ l2 = (a :: l) ++ l3 -> l2 = l3) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 l4 : list A, l2 ++ l3 = l2 ++ l4 -> l3 = l4)\n   ((fun (l2 l3 : list A) (H : l2 = l3) => H)\n    :\n    forall l2 l3 : list A, nil ++ l2 = nil ++ l3 -> l2 = l3)\n   ((fun (a : A) (l : list A)\n       (H : forall l2 l3 : list A, l ++ l2 = l ++ l3 -> l2 = l3)\n       (l2 l3 : list A) (H0 : a :: l ++ l2 = a :: l ++ l3) =>\n     H l2 l3\n       (let H1 : l ++ l2 = l ++ l3 :=\n          f_equal\n            (fun e : list A =>\n             match e with\n             | nil =>\n                 (fix app (l0 m : list A) {struct l0} : list A :=\n                    match l0 with\n                    | nil => m\n                    | a0 :: l4 => a0 :: app l4 m\n                    end) l l2\n             | _ :: l0 => l0\n             end) H0 in\n        (fun H2 : l ++ l2 = l ++ l3 => H2) H1))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 l3 : list A, l ++ l2 = l ++ l3 -> l2 = l3) ->\n    forall l2 l3 : list A, (a :: l) ++ l2 = (a :: l) ++ l3 -> l2 = l3) l1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A => forall l3 l4 : list A, l2 ++ l3 = l2 ++ l4 -> l3 = l4)\n   ((fun (l2 l3 : list A) (H : l2 = l3) => H)\n    :\n    forall l2 l3 : list A, nil ++ l2 = nil ++ l3 -> l2 = l3)\n   ((fun (a : A) (l : list A)\n       (H : forall l2 l3 : list A, l ++ l2 = l ++ l3 -> l2 = l3)\n       (l2 l3 : list A) (H0 : a :: l ++ l2 = a :: l ++ l3) =>\n     H l2 l3\n       (let H1 : l ++ l2 = l ++ l3 :=\n          f_equal\n            (fun e : list A =>\n             match e with\n             | nil =>\n                 (fix app (l0 m : list A) {struct l0} : list A :=\n                    match l0 with\n                    | nil => m\n                    | a0 :: l4 => a0 :: app l4 m\n                    end) l l2\n             | _ :: l0 => l0\n             end) H0 in\n        (fun H2 : l ++ l2 = l ++ l3 => H2) H1))\n    :\n    forall (a : A) (l : list A),\n    (forall l2 l3 : list A, l ++ l2 = l ++ l3 -> l2 = l3) ->\n    forall l2 l3 : list A, (a :: l) ++ l2 = (a :: l) ++ l3 -> l2 = l3) l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "app_inv_tail", "text": "Theorem app_inv_tail :\n forall l1 l2 l3 : list A, l2 ++ l1 = l3 ++ l1 -> l2 = l3.\nProof using.\nintros l1 l2; generalize l1; elim l2; clear l1 l2; simpl in |- *; auto.\nintros l1 l3; case l3; auto.\nintros b l H; absurd (length ((b :: l) ++ l1) <= length l1).\nsimpl in |- *; rewrite length_app; auto with arith.\nrewrite <- H; auto with arith.\nintros a l H l1 l3; case l3.\nsimpl in |- *; intros H1; absurd (length (a :: l ++ l1) <= length l1).\nsimpl in |- *; rewrite length_app; auto with arith.\nrewrite H1; auto with arith.\nsimpl in |- *; intros b l0 H0; injection H0.\nintros H1 H2; apply f_equal2 with (f := cons (A:=A)); auto.\napply H with (1 := H1); auto.\nQed.\n", "definition": "\n forall l1 l2 l3 : list A, l2 ++ l1 = l3 ++ l1 -> l2 = l3.", "proof": "\nProof using.\nintros l1 l2; generalize l1; elim l2; clear l1 l2; simpl in |- *; auto.\nintros l1 l3; case l3; auto.\nintros b l H; absurd (length ((b :: l) ++ l1) <= length l1).\nsimpl in |- *; rewrite length_app; auto with arith.\nrewrite <- H; auto with arith.\nintros a l H l1 l3; case l3.\nsimpl in |- *; intros H1; absurd (length (a :: l ++ l1) <= length l1).\nsimpl in |- *; rewrite length_app; auto with arith.\nrewrite H1; auto with arith.\nsimpl in |- *; intros b l0 H0; injection H0.\nintros H1 H2; apply f_equal2 with (f := cons (A:=A)); auto.\napply H with (1 := H1); auto.\n", "def_ranges": [249, 0, 250, 58], "proof_ranges": [251, 0, 264, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 l3 : list A, l2 ++ l1 = l3 ++ l1 -> l2 = l3"], "goal_after": ["forall l1 l2 l3 : list A, l2 ++ l1 = l3 ++ l1 -> l2 = l3"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1 l2; generalize l1; elim l2; clear l1 l2; simpl in |- *; auto.", "goal_before": ["forall l1 l2 l3 : list A, l2 ++ l1 = l3 ++ l1 -> l2 = l3"], "goal_after": ["forall l1 l3 : list A, l1 = l3 ++ l1 -> nil = l3", "forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   (?Goal : forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "intros l1 l3; case l3; auto.", "goal_before": ["forall l1 l3 : list A, l1 = l3 ++ l1 -> nil = l3", "forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "goal_after": ["forall (a : A) (l : list A), l1 = (a :: l) ++ l1 -> nil = a :: l", "forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   (?Goal : forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l => ?Goal0@{l1:=l3; l3:=l4} a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "intros b l H; absurd (length ((b :: l) ++ l1) <= length l1).", "goal_before": ["forall (a : A) (l : list A), l1 = (a :: l) ++ l1 -> nil = a :: l", "forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "goal_after": ["~ length ((b :: l) ++ l1) <= length l1", "length ((b :: l) ++ l1) <= length l1", "forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l => ?Goal0@{l1:=l3; l3:=l4} a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            (?Goal0@{l1:=l3; l3:=l4; l:=l0} ?Goal1@{l1:=l3; l3:=l4; l:=l0}))\n           a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "simpl in |- *; rewrite length_app; auto with arith.", "goal_before": ["~ length ((b :: l) ++ l1) <= length l1", "length ((b :: l) ++ l1) <= length l1", "forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "goal_after": ["length ((b :: l) ++ l1) <= length l1", "forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            (?Goal0@{l1:=l3; l3:=l4; l:=l0} ?Goal1@{l1:=l3; l3:=l4; l:=l0}))\n           a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               ?Goal0@{l1:=l3; l3:=l4; l:=l0})) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "rewrite <- H; auto with arith.", "goal_before": ["length ((b :: l) ++ l1) <= length l1", "forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "goal_after": ["forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               ?Goal0@{l1:=l3; l3:=l4; l:=l0})) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "intros a l H l1 l3; case l3.", "goal_before": ["forall (a : A) (l : list A),\n(forall l1 l3 : list A, l ++ l1 = l3 ++ l1 -> l = l3) ->\nforall l1 l3 : list A, a :: l ++ l1 = l3 ++ l1 -> a :: l = l3"], "goal_after": ["a :: l ++ l1 = nil ++ l1 -> a :: l = nil", "forall (a0 : A) (l0 : list A),\na :: l ++ l1 = (a0 :: l0) ++ l1 -> a :: l = a0 :: l0"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil => ?Goal@{l1:=l3; l3:=l4}\n     | a0 :: l0 => ?Goal0@{l1:=l3; l3:=l4} a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "simpl in |- *; intros H1; absurd (length (a :: l ++ l1) <= length l1).", "goal_before": ["a :: l ++ l1 = nil ++ l1 -> a :: l = nil", "forall (a0 : A) (l0 : list A),\na :: l ++ l1 = (a0 :: l0) ++ l1 -> a :: l = a0 :: l0"], "goal_after": ["~ length (a :: l ++ l1) <= length l1", "length (a :: l ++ l1) <= length l1", "forall (a0 : A) (l0 : list A),\na :: l ++ l1 = (a0 :: l0) ++ l1 -> a :: l = a0 :: l0"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil => ?Goal@{l1:=l3; l3:=l4}\n     | a0 :: l0 => ?Goal0@{l1:=l3; l3:=l4} a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            (?Goal0@{l1:=l3; l3:=l4} ?Goal1@{l1:=l3; l3:=l4}))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 => ?Goal@{l1:=l3; l3:=l4} a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "simpl in |- *; rewrite length_app; auto with arith.", "goal_before": ["~ length (a :: l ++ l1) <= length l1", "length (a :: l ++ l1) <= length l1", "forall (a0 : A) (l0 : list A),\na :: l ++ l1 = (a0 :: l0) ++ l1 -> a :: l = a0 :: l0"], "goal_after": ["length (a :: l ++ l1) <= length l1", "forall (a0 : A) (l0 : list A),\na :: l ++ l1 = (a0 :: l0) ++ l1 -> a :: l = a0 :: l0"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            (?Goal0@{l1:=l3; l3:=l4} ?Goal1@{l1:=l3; l3:=l4}))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 => ?Goal@{l1:=l3; l3:=l4} a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3) \n               ?Goal0@{l1:=l3; l3:=l4}))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 => ?Goal@{l1:=l3; l3:=l4} a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "rewrite H1; auto with arith.", "goal_before": ["length (a :: l ++ l1) <= length l1", "forall (a0 : A) (l0 : list A),\na :: l ++ l1 = (a0 :: l0) ++ l1 -> a :: l = a0 :: l0"], "goal_after": ["forall (a0 : A) (l0 : list A),\na :: l ++ l1 = (a0 :: l0) ++ l1 -> a :: l = a0 :: l0"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3) \n               ?Goal0@{l1:=l3; l3:=l4}))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 => ?Goal@{l1:=l3; l3:=l4} a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3)\n               (eq_ind_r (fun l0 : list A => length l0 <= length l3)\n                  (le_n (length l3)) H1)))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 => ?Goal@{l1:=l3; l3:=l4} a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "simpl in |- *; intros b l0 H0; injection H0.", "goal_before": ["forall (a0 : A) (l0 : list A),\na :: l ++ l1 = (a0 :: l0) ++ l1 -> a :: l = a0 :: l0"], "goal_after": ["l ++ l1 = l0 ++ l1 -> a = b -> a :: l = b :: l0"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3)\n               (eq_ind_r (fun l0 : list A => length l0 <= length l3)\n                  (le_n (length l3)) H1)))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 => ?Goal@{l1:=l3; l3:=l4} a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3)\n               (eq_ind_r (fun l0 : list A => length l0 <= length l3)\n                  (le_n (length l3)) H1)))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 =>\n         ((fun (b : A) (l5 : list A) (H0 : a :: l ++ l3 = b :: l5 ++ l3) =>\n           let H1 : a = b :=\n             f_equal\n               (fun e : list A => match e with\n                                  | nil => a\n                                  | a1 :: _ => a1\n                                  end) H0 in\n           (let H2 : l ++ l3 = l5 ++ l3 :=\n              f_equal\n                (fun e : list A =>\n                 match e with\n                 | nil =>\n                     (fix app (l6 m : list A) {struct l6} : list A :=\n                        match l6 with\n                        | nil => m\n                        | a1 :: l7 => a1 :: app l7 m\n                        end) l l3\n                 | _ :: l6 => l6\n                 end) H0 in\n            ?Goal@{l1:=l3; l3:=l4; l0:=l5} H2) H1)\n          :\n          forall (a1 : A) (l5 : list A),\n          a :: l ++ l3 = (a1 :: l5) ++ l3 -> a :: l = a1 :: l5) a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "intros H1 H2; apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": ["l ++ l1 = l0 ++ l1 -> a = b -> a :: l = b :: l0"], "goal_after": ["l = l0"], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3)\n               (eq_ind_r (fun l0 : list A => length l0 <= length l3)\n                  (le_n (length l3)) H1)))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 =>\n         ((fun (b : A) (l5 : list A) (H0 : a :: l ++ l3 = b :: l5 ++ l3) =>\n           let H1 : a = b :=\n             f_equal\n               (fun e : list A => match e with\n                                  | nil => a\n                                  | a1 :: _ => a1\n                                  end) H0 in\n           (let H2 : l ++ l3 = l5 ++ l3 :=\n              f_equal\n                (fun e : list A =>\n                 match e with\n                 | nil =>\n                     (fix app (l6 m : list A) {struct l6} : list A :=\n                        match l6 with\n                        | nil => m\n                        | a1 :: l7 => a1 :: app l7 m\n                        end) l l3\n                 | _ :: l6 => l6\n                 end) H0 in\n            ?Goal@{l1:=l3; l3:=l4; l0:=l5} H2) H1)\n          :\n          forall (a1 : A) (l5 : list A),\n          a :: l ++ l3 = (a1 :: l5) ++ l3 -> a :: l = a1 :: l5) a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3)\n               (eq_ind_r (fun l0 : list A => length l0 <= length l3)\n                  (le_n (length l3)) H1)))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 =>\n         ((fun (b : A) (l5 : list A) (H0 : a :: l ++ l3 = b :: l5 ++ l3) =>\n           let H1 : a = b :=\n             f_equal\n               (fun e : list A => match e with\n                                  | nil => a\n                                  | a1 :: _ => a1\n                                  end) H0 in\n           (let H2 : l ++ l3 = l5 ++ l3 :=\n              f_equal\n                (fun e : list A =>\n                 match e with\n                 | nil =>\n                     (fix app (l6 m : list A) {struct l6} : list A :=\n                        match l6 with\n                        | nil => m\n                        | a1 :: l7 => a1 :: app l7 m\n                        end) l l3\n                 | _ :: l6 => l6\n                 end) H0 in\n            (fun (H3 : l ++ l3 = l5 ++ l3) (H4 : a = b) =>\n             f_equal2 cons H4 ?Goal@{l1:=l3; l3:=l4; l0:=l5; H1:=H3; H2:=H4})\n              H2) H1)\n          :\n          forall (a1 : A) (l5 : list A),\n          a :: l ++ l3 = (a1 :: l5) ++ l3 -> a :: l = a1 :: l5) a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "apply H with (1 := H1); auto.", "goal_before": ["l = l0"], "goal_after": [], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3)\n               (eq_ind_r (fun l0 : list A => length l0 <= length l3)\n                  (le_n (length l3)) H1)))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 =>\n         ((fun (b : A) (l5 : list A) (H0 : a :: l ++ l3 = b :: l5 ++ l3) =>\n           let H1 : a = b :=\n             f_equal\n               (fun e : list A => match e with\n                                  | nil => a\n                                  | a1 :: _ => a1\n                                  end) H0 in\n           (let H2 : l ++ l3 = l5 ++ l3 :=\n              f_equal\n                (fun e : list A =>\n                 match e with\n                 | nil =>\n                     (fix app (l6 m : list A) {struct l6} : list A :=\n                        match l6 with\n                        | nil => m\n                        | a1 :: l7 => a1 :: app l7 m\n                        end) l l3\n                 | _ :: l6 => l6\n                 end) H0 in\n            (fun (H3 : l ++ l3 = l5 ++ l3) (H4 : a = b) =>\n             f_equal2 cons H4 ?Goal@{l1:=l3; l3:=l4; l0:=l5; H1:=H3; H2:=H4})\n              H2) H1)\n          :\n          forall (a1 : A) (l5 : list A),\n          a :: l ++ l3 = (a1 :: l5) ++ l3 -> a :: l = a1 :: l5) a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3)\n               (eq_ind_r (fun l0 : list A => length l0 <= length l3)\n                  (le_n (length l3)) H1)))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 =>\n         ((fun (b : A) (l5 : list A) (H0 : a :: l ++ l3 = b :: l5 ++ l3) =>\n           let H1 : a = b :=\n             f_equal\n               (fun e : list A => match e with\n                                  | nil => a\n                                  | a1 :: _ => a1\n                                  end) H0 in\n           (let H2 : l ++ l3 = l5 ++ l3 :=\n              f_equal\n                (fun e : list A =>\n                 match e with\n                 | nil =>\n                     (fix app (l6 m : list A) {struct l6} : list A :=\n                        match l6 with\n                        | nil => m\n                        | a1 :: l7 => a1 :: app l7 m\n                        end) l l3\n                 | _ :: l6 => l6\n                 end) H0 in\n            (fun (H3 : l ++ l3 = l5 ++ l3) (H4 : a = b) =>\n             f_equal2 cons H4 (H l3 l5 H3)) H2) H1)\n          :\n          forall (a1 : A) (l5 : list A),\n          a :: l ++ l3 = (a1 :: l5) ++ l3 -> a :: l = a1 :: l5) a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l1 l2 : list A =>\n list_ind\n   (fun l3 : list A => forall l4 l5 : list A, l3 ++ l4 = l5 ++ l4 -> l3 = l5)\n   ((fun l3 l4 : list A =>\n     match l4 as l return (l3 = l ++ l3 -> nil = l) with\n     | nil => fun _ : l3 = nil ++ l3 => eq_refl\n     | a :: l =>\n         (fun (b : A) (l0 : list A) (H : l3 = (b :: l0) ++ l3) =>\n          False_ind (nil = b :: l0)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l0 + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l0 + length l3)\n                       (le_plus_r (length l0) (length l3))\n                     :\n                     length l3 < S (length l0 + length l3))\n                    :\n                    S (length l0 + length l3) > length l3))\n                (length_app l0 l3)\n              :\n              ~ length ((b :: l0) ++ l3) <= length l3)\n               (eq_ind l3 (fun l5 : list A => length l5 <= length l3)\n                  (le_n (length l3)) ((b :: l0) ++ l3) H))) a l\n     end)\n    :\n    forall l3 l4 : list A, nil ++ l3 = l4 ++ l3 -> nil = l4)\n   ((fun (a : A) (l : list A)\n       (H : forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4)\n       (l3 l4 : list A) =>\n     match l4 as l0 return (a :: l ++ l3 = l0 ++ l3 -> a :: l = l0) with\n     | nil =>\n         (fun H1 : a :: l ++ l3 = l3 =>\n          False_ind (a :: l = nil)\n            ((eq_ind_r (fun n : nat => ~ S n <= length l3)\n                (gt_not_le (S (length l + length l3)) \n                   (length l3)\n                   ((le_n_S (length l3) (length l + length l3)\n                       (le_plus_r (length l) (length l3))\n                     :\n                     length l3 < S (length l + length l3))\n                    :\n                    S (length l + length l3) > length l3)) \n                (length_app l l3)\n              :\n              ~ length (a :: l ++ l3) <= length l3)\n               (eq_ind_r (fun l0 : list A => length l0 <= length l3)\n                  (le_n (length l3)) H1)))\n         :\n         a :: l ++ l3 = nil ++ l3 -> a :: l = nil\n     | a0 :: l0 =>\n         ((fun (b : A) (l5 : list A) (H0 : a :: l ++ l3 = b :: l5 ++ l3) =>\n           let H1 : a = b :=\n             f_equal\n               (fun e : list A => match e with\n                                  | nil => a\n                                  | a1 :: _ => a1\n                                  end) H0 in\n           (let H2 : l ++ l3 = l5 ++ l3 :=\n              f_equal\n                (fun e : list A =>\n                 match e with\n                 | nil =>\n                     (fix app (l6 m : list A) {struct l6} : list A :=\n                        match l6 with\n                        | nil => m\n                        | a1 :: l7 => a1 :: app l7 m\n                        end) l l3\n                 | _ :: l6 => l6\n                 end) H0 in\n            (fun (H3 : l ++ l3 = l5 ++ l3) (H4 : a = b) =>\n             f_equal2 cons H4 (H l3 l5 H3)) H2) H1)\n          :\n          forall (a1 : A) (l5 : list A),\n          a :: l ++ l3 = (a1 :: l5) ++ l3 -> a :: l = a1 :: l5) a0 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall l3 l4 : list A, l ++ l3 = l4 ++ l3 -> l = l4) ->\n    forall l3 l4 : list A, (a :: l) ++ l3 = l4 ++ l3 -> a :: l = l4) l2 l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "app_inv_app", "text": "Theorem app_inv_app :\n forall l1 l2 l3 l4 a,\n l1 ++ l2 = l3 ++ a :: l4 ->\n (exists l5 : list A, l1 = l3 ++ a :: l5) \\/\n (exists l5 : _, l2 = l5 ++ a :: l4).\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros l2 l3 l4 a H; right; exists l3; auto.\nintros a l H l2 l3 l4 a0; case l3; simpl in |- *.\nintros H0; left; exists l; apply f_equal2 with (f := cons (A:=A));\n injection H0; auto.\nintros b l0 H0; case (H l2 l0 l4 a0); auto.\ninjection H0; auto.\nintros (l5, H1).\nleft; exists l5; apply f_equal2 with (f := cons (A:=A)); injection H0; auto.\nQed.\n", "definition": "\n forall l1 l2 l3 l4 a,\n l1 ++ l2 = l3 ++ a :: l4 ->\n (exists l5 : list A, l1 = l3 ++ a :: l5) \\/\n (exists l5 : _, l2 = l5 ++ a :: l4).", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros l2 l3 l4 a H; right; exists l3; auto.\nintros a l H l2 l3 l4 a0; case l3; simpl in |- *.\nintros H0; left; exists l; apply f_equal2 with (f := cons (A:=A));\n injection H0; auto.\nintros b l0 H0; case (H l2 l0 l4 a0); auto.\ninjection H0; auto.\nintros (l5, H1).\nleft; exists l5; apply f_equal2 with (f := cons (A:=A)); injection H0; auto.\n", "def_ranges": [266, 0, 270, 37], "proof_ranges": [271, 0, 281, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l1 l2 l3 l4 : list A) (a : A),\nl1 ++ l2 = l3 ++ a :: l4 ->\n(exists l5 : list A, l1 = l3 ++ a :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: l4)"], "goal_after": ["forall (l1 l2 l3 l4 : list A) (a : A),\nl1 ++ l2 = l3 ++ a :: l4 ->\n(exists l5 : list A, l1 = l3 ++ a :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: l4)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall (l1 l2 l3 l4 : list A) (a : A),\nl1 ++ l2 = l3 ++ a :: l4 ->\n(exists l5 : list A, l1 = l3 ++ a :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: l4)"], "goal_after": ["forall (l2 l3 l4 : list A) (a : A),\nl2 = l3 ++ a :: l4 ->\n(exists l5 : list A, nil = l3 ++ a :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: l4)", "forall (a : A) (l : list A),\n(forall (l2 l3 l4 : list A) (a0 : A),\n l ++ l2 = l3 ++ a0 :: l4 ->\n (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\nforall (l2 l3 l4 : list A) (a0 : A),\na :: l ++ l2 = l3 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a : A),\n    l2 ++ l3 = l4 ++ a :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: l5))\n   (?Goal\n    :\n    forall (l2 l3 l4 : list A) (a : A),\n    nil ++ l2 = l3 ++ a :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: l4))\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 : A),\n     l ++ l2 = l3 ++ a0 :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\n    forall (l2 l3 l4 : list A) (a0 : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: l4)) l1)"]}, {"text": "intros l2 l3 l4 a H; right; exists l3; auto.", "goal_before": ["forall (l2 l3 l4 : list A) (a : A),\nl2 = l3 ++ a :: l4 ->\n(exists l5 : list A, nil = l3 ++ a :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: l4)", "forall (a : A) (l : list A),\n(forall (l2 l3 l4 : list A) (a0 : A),\n l ++ l2 = l3 ++ a0 :: l4 ->\n (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\nforall (l2 l3 l4 : list A) (a0 : A),\na :: l ++ l2 = l3 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "goal_after": ["forall (a : A) (l : list A),\n(forall (l2 l3 l4 : list A) (a0 : A),\n l ++ l2 = l3 ++ a0 :: l4 ->\n (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\nforall (l2 l3 l4 : list A) (a0 : A),\na :: l ++ l2 = l3 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a : A),\n    l2 ++ l3 = l4 ++ a :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: l5))\n   (?Goal\n    :\n    forall (l2 l3 l4 : list A) (a : A),\n    nil ++ l2 = l3 ++ a :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: l4))\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 : A),\n     l ++ l2 = l3 ++ a0 :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\n    forall (l2 l3 l4 : list A) (a0 : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: l4)) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a : A),\n    l2 ++ l3 = l4 ++ a :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: l5))\n   ((fun (l2 l3 l4 : list A) (a : A) (H : l2 = l3 ++ a :: l4) =>\n     or_intror (ex_intro (fun l5 : list A => l2 = l5 ++ a :: l4) l3 H))\n    :\n    forall (l2 l3 l4 : list A) (a : A),\n    nil ++ l2 = l3 ++ a :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: l4))\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 : A),\n     l ++ l2 = l3 ++ a0 :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\n    forall (l2 l3 l4 : list A) (a0 : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: l4)) l1)"]}, {"text": "intros a l H l2 l3 l4 a0; case l3; simpl in |- *.", "goal_before": ["forall (a : A) (l : list A),\n(forall (l2 l3 l4 : list A) (a0 : A),\n l ++ l2 = l3 ++ a0 :: l4 ->\n (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\nforall (l2 l3 l4 : list A) (a0 : A),\na :: l ++ l2 = l3 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "goal_after": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a : A),\n    l2 ++ l3 = l4 ++ a :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: l5))\n   ((fun (l2 l3 l4 : list A) (a : A) (H : l2 = l3 ++ a :: l4) =>\n     or_intror (ex_intro (fun l5 : list A => l2 = l5 ++ a :: l4) l3 H))\n    :\n    forall (l2 l3 l4 : list A) (a : A),\n    nil ++ l2 = l3 ++ a :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: l4))\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 : A),\n     l ++ l2 = l3 ++ a0 :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\n    forall (l2 l3 l4 : list A) (a0 : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: l4)) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a : A),\n    l2 ++ l3 = l4 ++ a :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: l5))\n   ((fun (l2 l3 l4 : list A) (a : A) (H : l2 = l3 ++ a :: l4) =>\n     or_intror (ex_intro (fun l5 : list A => l2 = l5 ++ a :: l4) l3 H))\n    :\n    forall (l2 l3 l4 : list A) (a : A),\n    nil ++ l2 = l3 ++ a :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: l4))\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 : A),\n            l ++ l2 = l3 ++ a0 :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: l4)) \n       (l2 l3 l4 : list A) (a0 : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: l4))\n     with\n     | nil =>\n         ?Goal\n         :\n         a :: l ++ l2 = nil ++ a0 :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: l4)\n     | a1 :: l0 =>\n         (?Goal0\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: l4)) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 : A),\n     l ++ l2 = l3 ++ a0 :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\n    forall (l2 l3 l4 : list A) (a0 : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: l4)) l1)"]}, {"text": "intros H0; left; exists l; apply f_equal2 with (f := cons (A:=A));", "goal_before": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "goal_after": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a : A),\n    l2 ++ l3 = l4 ++ a :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: l5))\n   ((fun (l2 l3 l4 : list A) (a : A) (H : l2 = l3 ++ a :: l4) =>\n     or_intror (ex_intro (fun l5 : list A => l2 = l5 ++ a :: l4) l3 H))\n    :\n    forall (l2 l3 l4 : list A) (a : A),\n    nil ++ l2 = l3 ++ a :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: l4))\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 : A),\n            l ++ l2 = l3 ++ a0 :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: l4)) \n       (l2 l3 l4 : list A) (a0 : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: l4))\n     with\n     | nil =>\n         ?Goal\n         :\n         a :: l ++ l2 = nil ++ a0 :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: l4)\n     | a1 :: l0 =>\n         (?Goal0\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: l4)) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 : A),\n     l ++ l2 = l3 ++ a0 :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: l4)) ->\n    forall (l2 l3 l4 : list A) (a0 : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: l4)) l1)"], "proof_term_after": []}, {"text": "injection H0; auto.", "goal_before": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "goal_after": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b l0 H0; case (H l2 l0 l4 a0); auto.", "goal_before": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "goal_after": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H0; auto.", "goal_before": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "goal_after": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (l5, H1).", "goal_before": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "goal_after": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": [], "proof_term_after": []}, {"text": "left; exists l5; apply f_equal2 with (f := cons (A:=A)); injection H0; auto.", "goal_before": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "goal_after": ["a :: l ++ l2 = a0 :: l4 ->\n(exists l5 : list A, a :: l = a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: l4)"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "app_inv_app2", "text": "Theorem app_inv_app2 :\n forall l1 l2 l3 l4 a b,\n l1 ++ l2 = l3 ++ a :: b :: l4 ->\n (exists l5 : list A, l1 = l3 ++ a :: b :: l5) \\/\n (exists l5 : _, l2 = l5 ++ a :: b :: l4) \\/\n l1 = l3 ++ a :: nil /\\ l2 = b :: l4.\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros l2 l3 l4 a b H; right; left; exists l3; auto.\nintros a l H l2 l3 l4 a0 b; case l3; simpl in |- *.\ncase l; simpl in |- *.\nintros H0; right; right; injection H0; split; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nintros b0 l0 H0; left; exists l0; injection H0; intros;\n repeat apply f_equal2 with (f := cons (A:=A)); auto.\nintros b0 l0 H0; case (H l2 l0 l4 a0 b); auto.\ninjection H0; auto.\nintros (l5, HH1); left; exists l5; apply f_equal2 with (f := cons (A:=A));\n auto; injection H0; auto.\nintros [H1| (H1, H2)]; auto.\nright; right; split; auto; apply f_equal2 with (f := cons (A:=A)); auto;\n injection H0; auto.\nQed.\n", "definition": "\n forall l1 l2 l3 l4 a b,\n l1 ++ l2 = l3 ++ a :: b :: l4 ->\n (exists l5 : list A, l1 = l3 ++ a :: b :: l5) \\/\n (exists l5 : _, l2 = l5 ++ a :: b :: l4) \\/\n l1 = l3 ++ a :: nil /\\ l2 = b :: l4.", "proof": "\nProof using.\nintros l1; elim l1; simpl in |- *; auto.\nintros l2 l3 l4 a b H; right; left; exists l3; auto.\nintros a l H l2 l3 l4 a0 b; case l3; simpl in |- *.\ncase l; simpl in |- *.\nintros H0; right; right; injection H0; split; auto.\napply f_equal2 with (f := cons (A:=A)); auto.\nintros b0 l0 H0; left; exists l0; injection H0; intros;\n repeat apply f_equal2 with (f := cons (A:=A)); auto.\nintros b0 l0 H0; case (H l2 l0 l4 a0 b); auto.\ninjection H0; auto.\nintros (l5, HH1); left; exists l5; apply f_equal2 with (f := cons (A:=A));\n auto; injection H0; auto.\nintros [H1| (H1, H2)]; auto.\nright; right; split; auto; apply f_equal2 with (f := cons (A:=A)); auto;\n injection H0; auto.\n", "def_ranges": [283, 0, 288, 37], "proof_ranges": [289, 0, 305, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l1 l2 l3 l4 : list A) (a b : A),\nl1 ++ l2 = l3 ++ a :: b :: l4 ->\n(exists l5 : list A, l1 = l3 ++ a :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\nl1 = l3 ++ a :: nil /\\ l2 = b :: l4"], "goal_after": ["forall (l1 l2 l3 l4 : list A) (a b : A),\nl1 ++ l2 = l3 ++ a :: b :: l4 ->\n(exists l5 : list A, l1 = l3 ++ a :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\nl1 = l3 ++ a :: nil /\\ l2 = b :: l4"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall (l1 l2 l3 l4 : list A) (a b : A),\nl1 ++ l2 = l3 ++ a :: b :: l4 ->\n(exists l5 : list A, l1 = l3 ++ a :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\nl1 = l3 ++ a :: nil /\\ l2 = b :: l4"], "goal_after": ["forall (l2 l3 l4 : list A) (a b : A),\nl2 = l3 ++ a :: b :: l4 ->\n(exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\nnil = l3 ++ a :: nil /\\ l2 = b :: l4", "forall (a : A) (l : list A),\n(forall (l2 l3 l4 : list A) (a0 b : A),\n l ++ l2 = l3 ++ a0 :: b :: l4 ->\n (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\nforall (l2 l3 l4 : list A) (a0 b : A),\na :: l ++ l2 = l3 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   (?Goal\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"]}, {"text": "intros l2 l3 l4 a b H; right; left; exists l3; auto.", "goal_before": ["forall (l2 l3 l4 : list A) (a b : A),\nl2 = l3 ++ a :: b :: l4 ->\n(exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\nnil = l3 ++ a :: nil /\\ l2 = b :: l4", "forall (a : A) (l : list A),\n(forall (l2 l3 l4 : list A) (a0 b : A),\n l ++ l2 = l3 ++ a0 :: b :: l4 ->\n (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\nforall (l2 l3 l4 : list A) (a0 b : A),\na :: l ++ l2 = l3 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["forall (a : A) (l : list A),\n(forall (l2 l3 l4 : list A) (a0 b : A),\n l ++ l2 = l3 ++ a0 :: b :: l4 ->\n (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\nforall (l2 l3 l4 : list A) (a0 b : A),\na :: l ++ l2 = l3 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   (?Goal\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"]}, {"text": "intros a l H l2 l3 l4 a0 b; case l3; simpl in |- *.", "goal_before": ["forall (a : A) (l : list A),\n(forall (l2 l3 l4 : list A) (a0 b : A),\n l ++ l2 = l3 ++ a0 :: b :: l4 ->\n (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\nforall (l2 l3 l4 : list A) (a0 b : A),\na :: l ++ l2 = l3 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["a :: l ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         ?Goal\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal0\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"]}, {"text": "case l; simpl in |- *.", "goal_before": ["a :: l ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["a :: l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: nil = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         ?Goal\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal0\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             ?Goal0\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             (?Goal1\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"]}, {"text": "intros H0; right; right; injection H0; split; auto.", "goal_before": ["a :: l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: nil = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["a :: nil = a0 :: nil", "forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             ?Goal0\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             (?Goal1\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             (fun H0 : a :: l2 = a0 :: b :: l4 =>\n              or_intror\n                (or_intror\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a1 :: _ => a1\n                         end) H0 in\n                    (let H2 : l2 = b :: l4 :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | nil => l2\n                          | _ :: l0 => l0\n                          end) H0 in\n                     (fun (H3 : l2 = b :: l4) (H4 : a = a0) =>\n                      conj ?Goal1@{H1:=H3; H2:=H4} H3) H2) H1)))\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             (?Goal0\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"]}, {"text": "apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": ["a :: nil = a0 :: nil", "forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             (fun H0 : a :: l2 = a0 :: b :: l4 =>\n              or_intror\n                (or_intror\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a1 :: _ => a1\n                         end) H0 in\n                    (let H2 : l2 = b :: l4 :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | nil => l2\n                          | _ :: l0 => l0\n                          end) H0 in\n                     (fun (H3 : l2 = b :: l4) (H4 : a = a0) =>\n                      conj ?Goal1@{H1:=H3; H2:=H4} H3) H2) H1)))\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             (?Goal0\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             (fun H0 : a :: l2 = a0 :: b :: l4 =>\n              or_intror\n                (or_intror\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a1 :: _ => a1\n                         end) H0 in\n                    (let H2 : l2 = b :: l4 :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | nil => l2\n                          | _ :: l0 => l0\n                          end) H0 in\n                     (fun (H3 : l2 = b :: l4) (H4 : a = a0) =>\n                      conj (f_equal2 cons H4 eq_refl) H3) H2) H1)))\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             (?Goal0\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"]}, {"text": "intros b0 l0 H0; left; exists l0; injection H0; intros;", "goal_before": ["forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             (fun H0 : a :: l2 = a0 :: b :: l4 =>\n              or_intror\n                (or_intror\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a1 :: _ => a1\n                         end) H0 in\n                    (let H2 : l2 = b :: l4 :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | nil => l2\n                          | _ :: l0 => l0\n                          end) H0 in\n                     (fun (H3 : l2 = b :: l4) (H4 : a = a0) =>\n                      conj (f_equal2 cons H4 eq_refl) H3) H2) H1)))\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             (?Goal0\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"], "proof_term_after": []}, {"text": "repeat apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": ["forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["forall (a1 : A) (l0 : list A),\na :: a1 :: l0 ++ l2 = a0 :: b :: l4 ->\n(exists l5 : list A, a :: a1 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: a1 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b0 l0 H0; case (H l2 l0 l4 a0 b); auto.", "goal_before": ["l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H0; auto.", "goal_before": ["l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros (l5, HH1); left; exists l5; apply f_equal2 with (f := cons (A:=A));", "goal_before": ["l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["l0 ++ l2 = l4 ->\nb0 = b ->\na = a0 -> l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": [], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             (fun H0 : a :: l2 = a0 :: b :: l4 =>\n              or_intror\n                (or_intror\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a1 :: _ => a1\n                         end) H0 in\n                    (let H2 : l2 = b :: l4 :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | nil => l2\n                          | _ :: l0 => l0\n                          end) H0 in\n                     (fun (H3 : l2 = b :: l4) (H4 : a = a0) =>\n                      conj (f_equal2 cons H4 eq_refl) H3) H2) H1)))\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             ((fun (b0 : A) (l5 : list A)\n                 (H0 : a :: b0 :: l5 ++ l2 = a0 :: b :: l4) =>\n               match\n                 H l2 l5 l4 a0 b\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a2 :: _ => a2\n                         end) H0 in\n                    (let H2 : b0 = b :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | _ :: a3 :: _ => a3\n                          | _ => b0\n                          end) H0 in\n                     (let H3 : l5 ++ l2 = l4 :=\n                        f_equal\n                          (fun e : list A =>\n                           match e with\n                           | nil =>\n                               (fix app (l6 m : list A) {struct l6} :\n                                    list A :=\n                                  match l6 with\n                                  | nil => m\n                                  | a2 :: l7 => a2 :: app l7 m\n                                  end) l5 l2\n                           | _ :: nil =>\n                               (fix app (l7 m : list A) {struct l7} :\n                                    list A :=\n                                  match l7 with\n                                  | nil => m\n                                  | a3 :: l8 => a3 :: app l8 m\n                                  end) l5 l2\n                           | _ :: _ :: l7 => l7\n                           end) H0 in\n                      (let H4 : a = a0 :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => a\n                            | a2 :: _ => a2\n                            end) H0 in\n                       (let H5 : b0 = b :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | _ :: a3 :: _ => a3\n                             | _ => b0\n                             end) H0 in\n                        (let H6 : l5 ++ l2 = l4 :=\n                           f_equal\n                             (fun e : list A =>\n                              match e with\n                              | nil =>\n                                  (fix app (l6 m : list A) {struct l6} :\n                                       list A :=\n                                     match l6 with\n                                     | nil => m\n                                     | a2 :: l7 => a2 :: app l7 m\n                                     end) l5 l2\n                              | _ :: nil =>\n                                  (fix app (l7 m : list A) {struct l7} :\n                                       list A :=\n                                     match l7 with\n                                     | nil => m\n                                     | a3 :: l8 => a3 :: app l8 m\n                                     end) l5 l2\n                              | _ :: _ :: l7 => l7\n                              end) H0 in\n                         ?Goal2@{l0:=l5} H6) H5) H4) H3) H2) H1)\n               with\n               | or_introl x => ?Goal0@{l0:=l5} x\n               | or_intror x => ?Goal1@{l0:=l5} x\n               end)\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"]}, {"text": "auto; injection H0; auto.", "goal_before": ["l0 ++ l2 = l4 ->\nb0 = b ->\na = a0 -> l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["l0 ++ l2 = l4 ->\nb0 = b ->\na = a0 -> l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             (fun H0 : a :: l2 = a0 :: b :: l4 =>\n              or_intror\n                (or_intror\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a1 :: _ => a1\n                         end) H0 in\n                    (let H2 : l2 = b :: l4 :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | nil => l2\n                          | _ :: l0 => l0\n                          end) H0 in\n                     (fun (H3 : l2 = b :: l4) (H4 : a = a0) =>\n                      conj (f_equal2 cons H4 eq_refl) H3) H2) H1)))\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             ((fun (b0 : A) (l5 : list A)\n                 (H0 : a :: b0 :: l5 ++ l2 = a0 :: b :: l4) =>\n               match\n                 H l2 l5 l4 a0 b\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a2 :: _ => a2\n                         end) H0 in\n                    (let H2 : b0 = b :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | _ :: a3 :: _ => a3\n                          | _ => b0\n                          end) H0 in\n                     (let H3 : l5 ++ l2 = l4 :=\n                        f_equal\n                          (fun e : list A =>\n                           match e with\n                           | nil =>\n                               (fix app (l6 m : list A) {struct l6} :\n                                    list A :=\n                                  match l6 with\n                                  | nil => m\n                                  | a2 :: l7 => a2 :: app l7 m\n                                  end) l5 l2\n                           | _ :: nil =>\n                               (fix app (l7 m : list A) {struct l7} :\n                                    list A :=\n                                  match l7 with\n                                  | nil => m\n                                  | a3 :: l8 => a3 :: app l8 m\n                                  end) l5 l2\n                           | _ :: _ :: l7 => l7\n                           end) H0 in\n                      (let H4 : a = a0 :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => a\n                            | a2 :: _ => a2\n                            end) H0 in\n                       (let H5 : b0 = b :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | _ :: a3 :: _ => a3\n                             | _ => b0\n                             end) H0 in\n                        (let H6 : l5 ++ l2 = l4 :=\n                           f_equal\n                             (fun e : list A =>\n                              match e with\n                              | nil =>\n                                  (fix app (l6 m : list A) {struct l6} :\n                                       list A :=\n                                     match l6 with\n                                     | nil => m\n                                     | a2 :: l7 => a2 :: app l7 m\n                                     end) l5 l2\n                              | _ :: nil =>\n                                  (fix app (l7 m : list A) {struct l7} :\n                                       list A :=\n                                     match l7 with\n                                     | nil => m\n                                     | a3 :: l8 => a3 :: app l8 m\n                                     end) l5 l2\n                              | _ :: _ :: l7 => l7\n                              end) H0 in\n                         ?Goal2@{l0:=l5} H6) H5) H4) H3) H2) H1)\n               with\n               | or_introl x => ?Goal0@{l0:=l5} x\n               | or_intror x => ?Goal1@{l0:=l5} x\n               end)\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             (fun H0 : a :: l2 = a0 :: b :: l4 =>\n              or_intror\n                (or_intror\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a1 :: _ => a1\n                         end) H0 in\n                    (let H2 : l2 = b :: l4 :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | nil => l2\n                          | _ :: l0 => l0\n                          end) H0 in\n                     (fun (H3 : l2 = b :: l4) (H4 : a = a0) =>\n                      conj (f_equal2 cons H4 eq_refl) H3) H2) H1)))\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             ((fun (b0 : A) (l5 : list A)\n                 (H0 : a :: b0 :: l5 ++ l2 = a0 :: b :: l4) =>\n               match\n                 H l2 l5 l4 a0 b\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a2 :: _ => a2\n                         end) H0 in\n                    (let H2 : b0 = b :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | _ :: a3 :: _ => a3\n                          | _ => b0\n                          end) H0 in\n                     (let H3 : l5 ++ l2 = l4 :=\n                        f_equal\n                          (fun e : list A =>\n                           match e with\n                           | nil =>\n                               (fix app (l6 m : list A) {struct l6} :\n                                    list A :=\n                                  match l6 with\n                                  | nil => m\n                                  | a2 :: l7 => a2 :: app l7 m\n                                  end) l5 l2\n                           | _ :: nil =>\n                               (fix app (l7 m : list A) {struct l7} :\n                                    list A :=\n                                  match l7 with\n                                  | nil => m\n                                  | a3 :: l8 => a3 :: app l8 m\n                                  end) l5 l2\n                           | _ :: _ :: l7 => l7\n                           end) H0 in\n                      (let H4 : a = a0 :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => a\n                            | a2 :: _ => a2\n                            end) H0 in\n                       (let H5 : b0 = b :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | _ :: a3 :: _ => a3\n                             | _ => b0\n                             end) H0 in\n                        (let H6 : l5 ++ l2 = l4 :=\n                           f_equal\n                             (fun e : list A =>\n                              match e with\n                              | nil =>\n                                  (fix app (l6 m : list A) {struct l6} :\n                                       list A :=\n                                     match l6 with\n                                     | nil => m\n                                     | a2 :: l7 => a2 :: app l7 m\n                                     end) l5 l2\n                              | _ :: nil =>\n                                  (fix app (l7 m : list A) {struct l7} :\n                                       list A :=\n                                     match l7 with\n                                     | nil => m\n                                     | a3 :: l8 => a3 :: app l8 m\n                                     end) l5 l2\n                              | _ :: _ :: l7 => l7\n                              end) H0 in\n                         ?Goal2@{l0:=l5} H6) H5) H4) H3) H2) H1)\n               with\n               | or_introl x => ?Goal0@{l0:=l5} x\n               | or_intror x => ?Goal1@{l0:=l5} x\n               end)\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"]}, {"text": "intros [H1| (H1, H2)]; auto.", "goal_before": ["l0 ++ l2 = l4 ->\nb0 = b ->\na = a0 -> l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["l0 ++ l2 = l4 ->\nb0 = b ->\na = a0 -> l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 l4 l5 : list A) (a b : A),\n    l2 ++ l3 = l4 ++ a :: b :: l5 ->\n    (exists l6 : list A, l2 = l4 ++ a :: b :: l6) \\/\n    (exists l6 : list A, l3 = l6 ++ a :: b :: l5) \\/\n    l2 = l4 ++ a :: nil /\\ l3 = b :: l5)\n   ((fun (l2 l3 l4 : list A) (a b : A) (H : l2 = l3 ++ a :: b :: l4) =>\n     or_intror\n       (or_introl\n          (ex_intro (fun l5 : list A => l2 = l5 ++ a :: b :: l4) l3 H)))\n    :\n    forall (l2 l3 l4 : list A) (a b : A),\n    nil ++ l2 = l3 ++ a :: b :: l4 ->\n    (exists l5 : list A, nil = l3 ++ a :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a :: b :: l4) \\/\n    nil = l3 ++ a :: nil /\\ l2 = b :: l4)\n   ((fun (a : A) (l : list A)\n       (H : forall (l2 l3 l4 : list A) (a0 b : A),\n            l ++ l2 = l3 ++ a0 :: b :: l4 ->\n            (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n            (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n            l = l3 ++ a0 :: nil /\\ l2 = b :: l4) (l2 l3 l4 : list A)\n       (a0 b : A) =>\n     match\n       l3 as l0\n       return\n         (a :: l ++ l2 = l0 ++ a0 :: b :: l4 ->\n          (exists l5 : list A, a :: l = l0 ++ a0 :: b :: l5) \\/\n          (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n          a :: l = l0 ++ a0 :: nil /\\ l2 = b :: l4)\n     with\n     | nil =>\n         match\n           l as l0\n           return\n             (a :: l0 ++ l2 = a0 :: b :: l4 ->\n              (exists l5 : list A, a :: l0 = a0 :: b :: l5) \\/\n              (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n              a :: l0 = a0 :: nil /\\ l2 = b :: l4)\n         with\n         | nil =>\n             (fun H0 : a :: l2 = a0 :: b :: l4 =>\n              or_intror\n                (or_intror\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a1 :: _ => a1\n                         end) H0 in\n                    (let H2 : l2 = b :: l4 :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | nil => l2\n                          | _ :: l0 => l0\n                          end) H0 in\n                     (fun (H3 : l2 = b :: l4) (H4 : a = a0) =>\n                      conj (f_equal2 cons H4 eq_refl) H3) H2) H1)))\n             :\n             a :: nil ++ l2 = a0 :: b :: l4 ->\n             (exists l5 : list A, a :: nil = a0 :: b :: l5) \\/\n             (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n             a :: nil = a0 :: nil /\\ l2 = b :: l4\n         | a1 :: l0 =>\n             ((fun (b0 : A) (l5 : list A)\n                 (H0 : a :: b0 :: l5 ++ l2 = a0 :: b :: l4) =>\n               match\n                 H l2 l5 l4 a0 b\n                   (let H1 : a = a0 :=\n                      f_equal\n                        (fun e : list A =>\n                         match e with\n                         | nil => a\n                         | a2 :: _ => a2\n                         end) H0 in\n                    (let H2 : b0 = b :=\n                       f_equal\n                         (fun e : list A =>\n                          match e with\n                          | _ :: a3 :: _ => a3\n                          | _ => b0\n                          end) H0 in\n                     (let H3 : l5 ++ l2 = l4 :=\n                        f_equal\n                          (fun e : list A =>\n                           match e with\n                           | nil =>\n                               (fix app (l6 m : list A) {struct l6} :\n                                    list A :=\n                                  match l6 with\n                                  | nil => m\n                                  | a2 :: l7 => a2 :: app l7 m\n                                  end) l5 l2\n                           | _ :: nil =>\n                               (fix app (l7 m : list A) {struct l7} :\n                                    list A :=\n                                  match l7 with\n                                  | nil => m\n                                  | a3 :: l8 => a3 :: app l8 m\n                                  end) l5 l2\n                           | _ :: _ :: l7 => l7\n                           end) H0 in\n                      (let H4 : a = a0 :=\n                         f_equal\n                           (fun e : list A =>\n                            match e with\n                            | nil => a\n                            | a2 :: _ => a2\n                            end) H0 in\n                       (let H5 : b0 = b :=\n                          f_equal\n                            (fun e : list A =>\n                             match e with\n                             | _ :: a3 :: _ => a3\n                             | _ => b0\n                             end) H0 in\n                        (let H6 : l5 ++ l2 = l4 :=\n                           f_equal\n                             (fun e : list A =>\n                              match e with\n                              | nil =>\n                                  (fix app (l6 m : list A) {struct l6} :\n                                       list A :=\n                                     match l6 with\n                                     | nil => m\n                                     | a2 :: l7 => a2 :: app l7 m\n                                     end) l5 l2\n                              | _ :: nil =>\n                                  (fix app (l7 m : list A) {struct l7} :\n                                       list A :=\n                                     match l7 with\n                                     | nil => m\n                                     | a3 :: l8 => a3 :: app l8 m\n                                     end) l5 l2\n                              | _ :: _ :: l7 => l7\n                              end) H0 in\n                         ?Goal2@{l0:=l5} H6) H5) H4) H3) H2) H1)\n               with\n               | or_introl x => ?Goal0@{l0:=l5} x\n               | or_intror x => ?Goal1@{l0:=l5} x\n               end)\n              :\n              forall (a2 : A) (l5 : list A),\n              a :: (a2 :: l5) ++ l2 = a0 :: b :: l4 ->\n              (exists l6 : list A, a :: a2 :: l5 = a0 :: b :: l6) \\/\n              (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n              a :: a2 :: l5 = a0 :: nil /\\ l2 = b :: l4) a1 l0\n         end\n         :\n         a :: l ++ l2 = nil ++ a0 :: b :: l4 ->\n         (exists l5 : list A, a :: l = nil ++ a0 :: b :: l5) \\/\n         (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n         a :: l = nil ++ a0 :: nil /\\ l2 = b :: l4\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (a2 : A) (l5 : list A),\n          a :: l ++ l2 = (a2 :: l5) ++ a0 :: b :: l4 ->\n          (exists l6 : list A, a :: l = (a2 :: l5) ++ a0 :: b :: l6) \\/\n          (exists l6 : list A, l2 = l6 ++ a0 :: b :: l4) \\/\n          a :: l = (a2 :: l5) ++ a0 :: nil /\\ l2 = b :: l4) a1 l0\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall (l2 l3 l4 : list A) (a0 b : A),\n     l ++ l2 = l3 ++ a0 :: b :: l4 ->\n     (exists l5 : list A, l = l3 ++ a0 :: b :: l5) \\/\n     (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n     l = l3 ++ a0 :: nil /\\ l2 = b :: l4) ->\n    forall (l2 l3 l4 : list A) (a0 b : A),\n    (a :: l) ++ l2 = l3 ++ a0 :: b :: l4 ->\n    (exists l5 : list A, a :: l = l3 ++ a0 :: b :: l5) \\/\n    (exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\n    a :: l = l3 ++ a0 :: nil /\\ l2 = b :: l4) l1)"], "proof_term_after": []}, {"text": "right; right; split; auto; apply f_equal2 with (f := cons (A:=A)); auto;", "goal_before": ["l0 ++ l2 = l4 ->\nb0 = b ->\na = a0 ->\nl0 ++ l2 = l4 ->\nb0 = b ->\na = a0 -> l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "goal_after": ["l0 ++ l2 = l4 ->\nb0 = b ->\na = a0 ->\nl0 ++ l2 = l4 ->\nb0 = b ->\na = a0 -> l0 ++ l2 = l4 -> b0 = b -> a = a0 -> l ++ l2 = l0 ++ a0 :: b :: l4", "(exists l5 : list A, l = l0 ++ a0 :: b :: l5) ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\nl = l0 ++ a0 :: nil /\\ l2 = b :: l4 ->\n(exists l5 : list A, a :: b0 :: l0 = a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: b0 :: l0 = a0 :: nil /\\ l2 = b :: l4", "forall (a1 : A) (l0 : list A),\na :: l ++ l2 = a1 :: l0 ++ a0 :: b :: l4 ->\n(exists l5 : list A, a :: l = a1 :: l0 ++ a0 :: b :: l5) \\/\n(exists l5 : list A, l2 = l5 ++ a0 :: b :: l4) \\/\na :: l = a1 :: l0 ++ a0 :: nil /\\ l2 = b :: l4"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "same_length_ex", "text": "Theorem same_length_ex :\n forall (a : A) l1 l2 l3,\n length (l1 ++ a :: l2) = length l3 ->\n exists l4 : _,\n   (exists l5 : _,\n      (exists b : B,\n         length l1 = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)).\nProof using.\nintros a l1; elim l1; simpl in |- *; auto.\nintros l2 l3; case l3; simpl in |- *; try (intros; discriminate).\nintros b l H; exists (nil (A:=B)); exists l; exists b; repeat (split; auto).\nintros a0 l H l2 l3; case l3; simpl in |- *; try (intros; discriminate).\nintros b l0 H0.\ncase (H l2 l0); auto.\nintros l4 (l5, (b1, (HH1, (HH2, HH3)))).\nexists (b :: l4); exists l5; exists b1; repeat (simpl in |- *; split; auto).\napply f_equal2 with (f := cons (A:=B)); auto.\nQed.\n", "definition": "\n forall (a : A) l1 l2 l3,\n length (l1 ++ a :: l2) = length l3 ->\n exists l4 : _,\n   (exists l5 : _,\n      (exists b : B,\n         length l1 = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)).", "proof": "\nProof using.\nintros a l1; elim l1; simpl in |- *; auto.\nintros l2 l3; case l3; simpl in |- *; try (intros; discriminate).\nintros b l H; exists (nil (A:=B)); exists l; exists b; repeat (split; auto).\nintros a0 l H l2 l3; case l3; simpl in |- *; try (intros; discriminate).\nintros b l0 H0.\ncase (H l2 l0); auto.\nintros l4 (l5, (b1, (HH1, (HH2, HH3)))).\nexists (b :: l4); exists l5; exists b1; repeat (simpl in |- *; split; auto).\napply f_equal2 with (f := cons (A:=B)); auto.\n", "def_ranges": [307, 0, 313, 80], "proof_ranges": [314, 0, 324, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : A) (l1 l2 : list A) (l3 : list B),\nlength (l1 ++ a :: l2) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  length l1 = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "goal_after": ["forall (a : A) (l1 l2 : list A) (l3 : list B),\nlength (l1 ++ a :: l2) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  length l1 = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l1; elim l1; simpl in |- *; auto.", "goal_before": ["forall (a : A) (l1 l2 : list A) (l3 : list B),\nlength (l1 ++ a :: l2) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  length l1 = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "goal_after": ["forall (l2 : list A) (l3 : list B),\nS (length l2) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  0 = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5", "A ->\nforall l : list A,\n(forall (l2 : list A) (l3 : list B),\n length (l ++ a :: l2) = length l3 ->\n exists (l4 l5 : list B) (b : B),\n   length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\nforall (l2 : list A) (l3 : list B),\nS (length (l ++ a :: l2)) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  S (length l) = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   (?Goal\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   (?Goal0\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "intros l2 l3; case l3; simpl in |- *; try (intros; discriminate).", "goal_before": ["forall (l2 : list A) (l3 : list B),\nS (length l2) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  0 = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5", "A ->\nforall l : list A,\n(forall (l2 : list A) (l3 : list B),\n length (l ++ a :: l2) = length l3 ->\n exists (l4 l5 : list B) (b : B),\n   length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\nforall (l2 : list A) (l3 : list B),\nS (length (l ++ a :: l2)) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  S (length l) = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "goal_after": ["forall (b : B) (l : list B),\nS (length l2) = S (length l) ->\nexists (l4 l5 : list B) (b0 : B),\n  0 = length l4 /\\ length l2 = length l5 /\\ b :: l = l4 ++ b0 :: l5", "A ->\nforall l : list A,\n(forall (l2 : list A) (l3 : list B),\n length (l ++ a :: l2) = length l3 ->\n exists (l4 l5 : list B) (b : B),\n   length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\nforall (l2 : list A) (l3 : list B),\nS (length (l ++ a :: l2)) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  S (length l) = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   (?Goal\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   (?Goal0\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         (?Goal0\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "intros b l H; exists (nil (A:=B)); exists l; exists b; repeat (split; auto).", "goal_before": ["forall (b : B) (l : list B),\nS (length l2) = S (length l) ->\nexists (l4 l5 : list B) (b0 : B),\n  0 = length l4 /\\ length l2 = length l5 /\\ b :: l = l4 ++ b0 :: l5", "A ->\nforall l : list A,\n(forall (l2 : list A) (l3 : list B),\n length (l ++ a :: l2) = length l3 ->\n exists (l4 l5 : list B) (b : B),\n   length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\nforall (l2 : list A) (l3 : list B),\nS (length (l ++ a :: l2)) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  S (length l) = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "goal_after": ["A ->\nforall l : list A,\n(forall (l2 : list A) (l3 : list B),\n length (l ++ a :: l2) = length l3 ->\n exists (l4 l5 : list B) (b : B),\n   length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\nforall (l2 : list A) (l3 : list B),\nS (length (l ++ a :: l2)) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  S (length l) = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         (?Goal0\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "intros a0 l H l2 l3; case l3; simpl in |- *; try (intros; discriminate).", "goal_before": ["A ->\nforall l : list A,\n(forall (l2 : list A) (l3 : list B),\n length (l ++ a :: l2) = length l3 ->\n exists (l4 l5 : list B) (b : B),\n   length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\nforall (l2 : list A) (l3 : list B),\nS (length (l ++ a :: l2)) = length l3 ->\nexists (l4 l5 : list B) (b : B),\n  S (length l) = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5"], "goal_after": ["forall (b : B) (l0 : list B),\nS (length (l ++ a :: l2)) = S (length l0) ->\nexists (l4 l5 : list B) (b0 : B),\n  S (length l) = length l4 /\\\n  length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   (?Goal\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "intros b l0 H0.", "goal_before": ["forall (b : B) (l0 : list B),\nS (length (l ++ a :: l2)) = S (length l0) ->\nexists (l4 l5 : list B) (b0 : B),\n  S (length l) = length l4 /\\\n  length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5"], "goal_after": ["exists (l4 l5 : list B) (b0 : B),\n  S (length l) = length l4 /\\\n  length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         (?Goal\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           ?Goal@{l0:=l4})\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "case (H l2 l0); auto.", "goal_before": ["exists (l4 l5 : list B) (b0 : B),\n  S (length l) = length l4 /\\\n  length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5"], "goal_after": ["forall x : list B,\n(exists (l5 : list B) (b0 : B),\n   length l = length x /\\ length l2 = length l5 /\\ l0 = x ++ b0 :: l5) ->\nexists (l4 l5 : list B) (b0 : B),\n  S (length l) = length l4 /\\\n  length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           ?Goal@{l0:=l4})\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           match\n             H l2 l4 (eq_add_S (length (l ++ a :: l2)) (length l4) H0)\n           with\n           | ex_intro _ x x0 => ?Goal@{l0:=l4} x x0\n           end)\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "intros l4 (l5, (b1, (HH1, (HH2, HH3)))).", "goal_before": ["forall x : list B,\n(exists (l5 : list B) (b0 : B),\n   length l = length x /\\ length l2 = length l5 /\\ l0 = x ++ b0 :: l5) ->\nexists (l4 l5 : list B) (b0 : B),\n  S (length l) = length l4 /\\\n  length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5"], "goal_after": ["exists (l6 l7 : list B) (b0 : B),\n  S (length l) = length l6 /\\\n  length l2 = length l7 /\\ b :: l0 = l6 ++ b0 :: l7"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           match\n             H l2 l4 (eq_add_S (length (l ++ a :: l2)) (length l4) H0)\n           with\n           | ex_intro _ x x0 => ?Goal@{l0:=l4} x x0\n           end)\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           match\n             H l2 l4 (eq_add_S (length (l ++ a :: l2)) (length l4) H0)\n           with\n           | ex_intro _ x x0 =>\n               (fun (l5 : list B)\n                  (H1 : exists (l6 : list B) (b0 : B),\n                          length l = length l5 /\\\n                          length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6) =>\n                match H1 with\n                | ex_intro _ x1 x2 =>\n                    (fun (l6 : list B)\n                       (H2 : exists b0 : B,\n                               length l = length l5 /\\\n                               length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6)\n                     =>\n                     match H2 with\n                     | ex_intro _ x3 x4 =>\n                         (fun (b1 : B)\n                            (H3 : length l = length l5 /\\\n                                  length l2 = length l6 /\\\n                                  l4 = l5 ++ b1 :: l6) =>\n                          match H3 with\n                          | conj x5 x6 =>\n                              (fun (HH1 : length l = length l5)\n                                 (H4 : length l2 = length l6 /\\\n                                       l4 = l5 ++ b1 :: l6) =>\n                               match H4 with\n                               | conj x7 x8 =>\n                                   (fun (HH2 : length l2 = length l6)\n                                      (HH3 : l4 = l5 ++ b1 :: l6) =>\n                                    ?Goal@{l0:=l4; l4:=l5; l5:=l6}) x7 x8\n                               end) x5 x6\n                          end) x3 x4\n                     end) x1 x2\n                end) x x0\n           end)\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "exists (b :: l4); exists l5; exists b1; repeat (simpl in |- *; split; auto).", "goal_before": ["exists (l6 l7 : list B) (b0 : B),\n  S (length l) = length l6 /\\\n  length l2 = length l7 /\\ b :: l0 = l6 ++ b0 :: l7"], "goal_after": ["b :: l0 = b :: l4 ++ b1 :: l5"], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           match\n             H l2 l4 (eq_add_S (length (l ++ a :: l2)) (length l4) H0)\n           with\n           | ex_intro _ x x0 =>\n               (fun (l5 : list B)\n                  (H1 : exists (l6 : list B) (b0 : B),\n                          length l = length l5 /\\\n                          length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6) =>\n                match H1 with\n                | ex_intro _ x1 x2 =>\n                    (fun (l6 : list B)\n                       (H2 : exists b0 : B,\n                               length l = length l5 /\\\n                               length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6)\n                     =>\n                     match H2 with\n                     | ex_intro _ x3 x4 =>\n                         (fun (b1 : B)\n                            (H3 : length l = length l5 /\\\n                                  length l2 = length l6 /\\\n                                  l4 = l5 ++ b1 :: l6) =>\n                          match H3 with\n                          | conj x5 x6 =>\n                              (fun (HH1 : length l = length l5)\n                                 (H4 : length l2 = length l6 /\\\n                                       l4 = l5 ++ b1 :: l6) =>\n                               match H4 with\n                               | conj x7 x8 =>\n                                   (fun (HH2 : length l2 = length l6)\n                                      (HH3 : l4 = l5 ++ b1 :: l6) =>\n                                    ?Goal@{l0:=l4; l4:=l5; l5:=l6}) x7 x8\n                               end) x5 x6\n                          end) x3 x4\n                     end) x1 x2\n                end) x x0\n           end)\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           match\n             H l2 l4 (eq_add_S (length (l ++ a :: l2)) (length l4) H0)\n           with\n           | ex_intro _ x x0 =>\n               (fun (l5 : list B)\n                  (H1 : exists (l6 : list B) (b0 : B),\n                          length l = length l5 /\\\n                          length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6) =>\n                match H1 with\n                | ex_intro _ x1 x2 =>\n                    (fun (l6 : list B)\n                       (H2 : exists b0 : B,\n                               length l = length l5 /\\\n                               length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6)\n                     =>\n                     match H2 with\n                     | ex_intro _ x3 x4 =>\n                         (fun (b1 : B)\n                            (H3 : length l = length l5 /\\\n                                  length l2 = length l6 /\\\n                                  l4 = l5 ++ b1 :: l6) =>\n                          match H3 with\n                          | conj x5 x6 =>\n                              (fun (HH1 : length l = length l5)\n                                 (H4 : length l2 = length l6 /\\\n                                       l4 = l5 ++ b1 :: l6) =>\n                               match H4 with\n                               | conj x7 x8 =>\n                                   (fun (HH2 : length l2 = length l6)\n                                      (HH3 : l4 = l5 ++ b1 :: l6) =>\n                                    ex_intro\n                                      (fun l7 : list B =>\n                                       exists (l8 : list B) \n                                       (b0 : B),\n                                         S (length l) = length l7 /\\\n                                         length l2 = length l8 /\\\n                                         b :: l4 = l7 ++ b0 :: l8) \n                                      (b :: l5)\n                                      (ex_intro\n                                         (fun l7 : list B =>\n                                          exists b0 : B,\n                                            S (length l) = length (b :: l5) /\\\n                                            length l2 = length l7 /\\\n                                            b :: l4 = (b :: l5) ++ b0 :: l7)\n                                         l6\n                                         (ex_intro\n                                            (fun b0 : B =>\n                                             S (length l) = length (b :: l5) /\\\n                                             length l2 = length l6 /\\\n                                             b :: l4 = (b :: l5) ++ b0 :: l6)\n                                            b1\n                                            (conj\n                                               (f_equal_nat nat S \n                                                 (length l) \n                                                 (length l5) HH1)\n                                               (conj HH2\n                                                 ?Goal@{\n                                                 l0:=l4; l4:=l5; l5:=l6}\n                                                :\n                                                length l2 = length l6 /\\\n                                                b :: l4 = b :: l5 ++ b1 :: l6)\n                                             :\n                                             S (length l) = length (b :: l5) /\\\n                                             length l2 = length l6 /\\\n                                             b :: l4 = (b :: l5) ++ b1 :: l6))))\n                                     x7 x8\n                               end) x5 x6\n                          end) x3 x4\n                     end) x1 x2\n                end) x x0\n           end)\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "apply f_equal2 with (f := cons (A:=B)); auto.", "goal_before": ["b :: l0 = b :: l4 ++ b1 :: l5"], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (a0 : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           match\n             H l2 l4 (eq_add_S (length (l ++ a :: l2)) (length l4) H0)\n           with\n           | ex_intro _ x x0 =>\n               (fun (l5 : list B)\n                  (H1 : exists (l6 : list B) (b0 : B),\n                          length l = length l5 /\\\n                          length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6) =>\n                match H1 with\n                | ex_intro _ x1 x2 =>\n                    (fun (l6 : list B)\n                       (H2 : exists b0 : B,\n                               length l = length l5 /\\\n                               length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6)\n                     =>\n                     match H2 with\n                     | ex_intro _ x3 x4 =>\n                         (fun (b1 : B)\n                            (H3 : length l = length l5 /\\\n                                  length l2 = length l6 /\\\n                                  l4 = l5 ++ b1 :: l6) =>\n                          match H3 with\n                          | conj x5 x6 =>\n                              (fun (HH1 : length l = length l5)\n                                 (H4 : length l2 = length l6 /\\\n                                       l4 = l5 ++ b1 :: l6) =>\n                               match H4 with\n                               | conj x7 x8 =>\n                                   (fun (HH2 : length l2 = length l6)\n                                      (HH3 : l4 = l5 ++ b1 :: l6) =>\n                                    ex_intro\n                                      (fun l7 : list B =>\n                                       exists (l8 : list B) \n                                       (b0 : B),\n                                         S (length l) = length l7 /\\\n                                         length l2 = length l8 /\\\n                                         b :: l4 = l7 ++ b0 :: l8) \n                                      (b :: l5)\n                                      (ex_intro\n                                         (fun l7 : list B =>\n                                          exists b0 : B,\n                                            S (length l) = length (b :: l5) /\\\n                                            length l2 = length l7 /\\\n                                            b :: l4 = (b :: l5) ++ b0 :: l7)\n                                         l6\n                                         (ex_intro\n                                            (fun b0 : B =>\n                                             S (length l) = length (b :: l5) /\\\n                                             length l2 = length l6 /\\\n                                             b :: l4 = (b :: l5) ++ b0 :: l6)\n                                            b1\n                                            (conj\n                                               (f_equal_nat nat S \n                                                 (length l) \n                                                 (length l5) HH1)\n                                               (conj HH2\n                                                 ?Goal@{\n                                                 l0:=l4; l4:=l5; l5:=l6}\n                                                :\n                                                length l2 = length l6 /\\\n                                                b :: l4 = b :: l5 ++ b1 :: l6)\n                                             :\n                                             S (length l) = length (b :: l5) /\\\n                                             length l2 = length l6 /\\\n                                             b :: l4 = (b :: l5) ++ b1 :: l6))))\n                                     x7 x8\n                               end) x5 x6\n                          end) x3 x4\n                     end) x1 x2\n                end) x x0\n           end)\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (_ : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           match\n             H l2 l4 (eq_add_S (length (l ++ a :: l2)) (length l4) H0)\n           with\n           | ex_intro _ x x0 =>\n               (fun (l5 : list B)\n                  (H1 : exists (l6 : list B) (b0 : B),\n                          length l = length l5 /\\\n                          length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6) =>\n                match H1 with\n                | ex_intro _ x1 x2 =>\n                    (fun (l6 : list B)\n                       (H2 : exists b0 : B,\n                               length l = length l5 /\\\n                               length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6)\n                     =>\n                     match H2 with\n                     | ex_intro _ x3 x4 =>\n                         (fun (b1 : B)\n                            (H3 : length l = length l5 /\\\n                                  length l2 = length l6 /\\\n                                  l4 = l5 ++ b1 :: l6) =>\n                          match H3 with\n                          | conj x5 x6 =>\n                              (fun (HH1 : length l = length l5)\n                                 (H4 : length l2 = length l6 /\\\n                                       l4 = l5 ++ b1 :: l6) =>\n                               match H4 with\n                               | conj x7 x8 =>\n                                   (fun (HH2 : length l2 = length l6)\n                                      (HH3 : l4 = l5 ++ b1 :: l6) =>\n                                    ex_intro\n                                      (fun l7 : list B =>\n                                       exists (l8 : list B) \n                                       (b0 : B),\n                                         S (length l) = length l7 /\\\n                                         length l2 = length l8 /\\\n                                         b :: l4 = l7 ++ b0 :: l8) \n                                      (b :: l5)\n                                      (ex_intro\n                                         (fun l7 : list B =>\n                                          exists b0 : B,\n                                            S (length l) = length (b :: l5) /\\\n                                            length l2 = length l7 /\\\n                                            b :: l4 = (b :: l5) ++ b0 :: l7)\n                                         l6\n                                         (ex_intro\n                                            (fun b0 : B =>\n                                             S (length l) = length (b :: l5) /\\\n                                             length l2 = length l6 /\\\n                                             b :: l4 = (b :: l5) ++ b0 :: l6)\n                                            b1\n                                            (conj\n                                               (f_equal_nat nat S \n                                                 (length l) \n                                                 (length l5) HH1)\n                                               (conj HH2\n                                                 (f_equal2 cons eq_refl HH3)\n                                                :\n                                                length l2 = length l6 /\\\n                                                b :: l4 = b :: l5 ++ b1 :: l6)\n                                             :\n                                             S (length l) = length (b :: l5) /\\\n                                             length l2 = length l6 /\\\n                                             b :: l4 = (b :: l5) ++ b1 :: l6))))\n                                     x7 x8\n                               end) x5 x6\n                          end) x3 x4\n                     end) x1 x2\n                end) x x0\n           end)\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : A) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list A) (l4 : list B),\n    length (l2 ++ a :: l3) = length l4 ->\n    exists (l5 l6 : list B) (b : B),\n      length l2 = length l5 /\\ length l3 = length l6 /\\ l4 = l5 ++ b :: l6)\n   ((fun (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l\n       return\n         (S (length l2) = length l ->\n          exists (l4 l5 : list B) (b : B),\n            0 = length l4 /\\ length l2 = length l5 /\\ l = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H : S (length l2) = 0 =>\n          let H0 : False :=\n            eq_ind (S (length l2))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5)\n            H0)\n         :\n         S (length l2) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           0 = length l4 /\\ length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a0 :: l =>\n         ((fun (b : B) (l0 : list B) (H : S (length l2) = S (length l0)) =>\n           ex_intro\n             (fun l4 : list B =>\n              exists (l5 : list B) (b0 : B),\n                0 = length l4 /\\\n                length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) nil\n             (ex_intro\n                (fun l5 : list B =>\n                 exists b0 : B,\n                   0 = length nil /\\\n                   length l2 = length l5 /\\ b :: l0 = nil ++ b0 :: l5) l0\n                (ex_intro\n                   (fun b0 : B =>\n                    0 = length nil /\\\n                    length l2 = length l0 /\\ b :: l0 = nil ++ b0 :: l0) b\n                   (conj eq_refl\n                      (conj (eq_add_S (length l2) (length l0) H) eq_refl)))))\n          :\n          forall (b : B) (l0 : list B),\n          S (length l2) = length (b :: l0) ->\n          exists (l4 l5 : list B) (b0 : B),\n            0 = length l4 /\\\n            length l2 = length l5 /\\ b :: l0 = l4 ++ b0 :: l5) a0 l\n     end)\n    :\n    forall (l2 : list A) (l3 : list B),\n    length (nil ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length nil = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5)\n   ((fun (_ : A) (l : list A)\n       (H : forall (l2 : list A) (l3 : list B),\n            length (l ++ a :: l2) = length l3 ->\n            exists (l4 l5 : list B) (b : B),\n              length l = length l4 /\\\n              length l2 = length l5 /\\ l3 = l4 ++ b :: l5) \n       (l2 : list A) (l3 : list B) =>\n     match\n       l3 as l0\n       return\n         (S (length (l ++ a :: l2)) = length l0 ->\n          exists (l4 l5 : list B) (b : B),\n            S (length l) = length l4 /\\\n            length l2 = length l5 /\\ l0 = l4 ++ b :: l5)\n     with\n     | nil =>\n         (fun H0 : S (length (l ++ a :: l2)) = 0 =>\n          let H1 : False :=\n            eq_ind (S (length (l ++ a :: l2)))\n              (fun e : nat => match e with\n                              | 0 => False\n                              | S _ => True\n                              end) I 0 H0 in\n          False_ind\n            (exists (l4 l5 : list B) (b : B),\n               S (length l) = length l4 /\\\n               length l2 = length l5 /\\ nil = l4 ++ b :: l5) H1)\n         :\n         S (length (l ++ a :: l2)) = length nil ->\n         exists (l4 l5 : list B) (b : B),\n           S (length l) = length l4 /\\\n           length l2 = length l5 /\\ nil = l4 ++ b :: l5\n     | a1 :: l0 =>\n         ((fun (b : B) (l4 : list B)\n             (H0 : S (length (l ++ a :: l2)) = S (length l4)) =>\n           match\n             H l2 l4 (eq_add_S (length (l ++ a :: l2)) (length l4) H0)\n           with\n           | ex_intro _ x x0 =>\n               (fun (l5 : list B)\n                  (H1 : exists (l6 : list B) (b0 : B),\n                          length l = length l5 /\\\n                          length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6) =>\n                match H1 with\n                | ex_intro _ x1 x2 =>\n                    (fun (l6 : list B)\n                       (H2 : exists b0 : B,\n                               length l = length l5 /\\\n                               length l2 = length l6 /\\ l4 = l5 ++ b0 :: l6)\n                     =>\n                     match H2 with\n                     | ex_intro _ x3 x4 =>\n                         (fun (b1 : B)\n                            (H3 : length l = length l5 /\\\n                                  length l2 = length l6 /\\\n                                  l4 = l5 ++ b1 :: l6) =>\n                          match H3 with\n                          | conj x5 x6 =>\n                              (fun (HH1 : length l = length l5)\n                                 (H4 : length l2 = length l6 /\\\n                                       l4 = l5 ++ b1 :: l6) =>\n                               match H4 with\n                               | conj x7 x8 =>\n                                   (fun (HH2 : length l2 = length l6)\n                                      (HH3 : l4 = l5 ++ b1 :: l6) =>\n                                    ex_intro\n                                      (fun l7 : list B =>\n                                       exists (l8 : list B) \n                                       (b0 : B),\n                                         S (length l) = length l7 /\\\n                                         length l2 = length l8 /\\\n                                         b :: l4 = l7 ++ b0 :: l8) \n                                      (b :: l5)\n                                      (ex_intro\n                                         (fun l7 : list B =>\n                                          exists b0 : B,\n                                            S (length l) = length (b :: l5) /\\\n                                            length l2 = length l7 /\\\n                                            b :: l4 = (b :: l5) ++ b0 :: l7)\n                                         l6\n                                         (ex_intro\n                                            (fun b0 : B =>\n                                             S (length l) = length (b :: l5) /\\\n                                             length l2 = length l6 /\\\n                                             b :: l4 = (b :: l5) ++ b0 :: l6)\n                                            b1\n                                            (conj\n                                               (f_equal_nat nat S \n                                                 (length l) \n                                                 (length l5) HH1)\n                                               (conj HH2\n                                                 (f_equal2 cons eq_refl HH3)\n                                                :\n                                                length l2 = length l6 /\\\n                                                b :: l4 = b :: l5 ++ b1 :: l6)\n                                             :\n                                             S (length l) = length (b :: l5) /\\\n                                             length l2 = length l6 /\\\n                                             b :: l4 = (b :: l5) ++ b1 :: l6))))\n                                     x7 x8\n                               end) x5 x6\n                          end) x3 x4\n                     end) x1 x2\n                end) x x0\n           end)\n          :\n          forall (b : B) (l4 : list B),\n          S (length (l ++ a :: l2)) = length (b :: l4) ->\n          exists (l5 l6 : list B) (b0 : B),\n            S (length l) = length l5 /\\\n            length l2 = length l6 /\\ b :: l4 = l5 ++ b0 :: l6) a1 l0\n     end)\n    :\n    forall (a0 : A) (l : list A),\n    (forall (l2 : list A) (l3 : list B),\n     length (l ++ a :: l2) = length l3 ->\n     exists (l4 l5 : list B) (b : B),\n       length l = length l4 /\\ length l2 = length l5 /\\ l3 = l4 ++ b :: l5) ->\n    forall (l2 : list A) (l3 : list B),\n    length ((a0 :: l) ++ a :: l2) = length l3 ->\n    exists (l4 l5 : list B) (b : B),\n      length (a0 :: l) = length l4 /\\\n      length l2 = length l5 /\\ l3 = l4 ++ b :: l5) l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "in_map_inv", "text": "Theorem in_map_inv :\n forall (b : B) (l : list A),\n In b (map f l) -> exists a : A, In a l /\\ b = f a.\nProof using.\nintros b l; elim l; simpl in |- *; auto.\nintros tmp; case tmp.\nintros a0 l0 H [H1| H1]; auto.\nexists a0; auto.\ncase (H H1); intros a1 (H2, H3); exists a1; auto.\nQed.\n", "definition": "\n forall (b : B) (l : list A),\n In b (map f l) -> exists a : A, In a l /\\ b = f a.", "proof": "\nProof using.\nintros b l; elim l; simpl in |- *; auto.\nintros tmp; case tmp.\nintros a0 l0 H [H1| H1]; auto.\nexists a0; auto.\ncase (H H1); intros a1 (H2, H3); exists a1; auto.\n", "def_ranges": [327, 0, 329, 51], "proof_ranges": [330, 0, 336, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (b : B) (l : list A),\nIn b (map f l) -> exists a : A, In a l /\\ b = f a"], "goal_after": ["forall (b : B) (l : list A),\nIn b (map f l) -> exists a : A, In a l /\\ b = f a"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros b l; elim l; simpl in |- *; auto.", "goal_before": ["forall (b : B) (l : list A),\nIn b (map f l) -> exists a : A, In a l /\\ b = f a"], "goal_after": ["False -> exists a : A, False /\\ b = f a", "forall (a : A) (l0 : list A),\n(In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\nf a = b \\/ In b (map f l0) -> exists a0 : A, (a = a0 \\/ In a0 l0) /\\ b = f a0"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   (?Goal : In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   (?Goal0\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"]}, {"text": "intros tmp; case tmp.", "goal_before": ["False -> exists a : A, False /\\ b = f a", "forall (a : A) (l0 : list A),\n(In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\nf a = b \\/ In b (map f l0) -> exists a0 : A, (a = a0 \\/ In a0 l0) /\\ b = f a0"], "goal_after": ["forall (a : A) (l0 : list A),\n(In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\nf a = b \\/ In b (map f l0) -> exists a0 : A, (a = a0 \\/ In a0 l0) /\\ b = f a0"], "proof_term_before": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   (?Goal : In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   (?Goal0\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"], "proof_term_after": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   ((fun tmp : False =>\n     match tmp return (exists a : A, False /\\ b = f a) with\n     end)\n    :\n    In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"]}, {"text": "intros a0 l0 H [H1| H1]; auto.", "goal_before": ["forall (a : A) (l0 : list A),\n(In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\nf a = b \\/ In b (map f l0) -> exists a0 : A, (a = a0 \\/ In a0 l0) /\\ b = f a0"], "goal_after": ["exists a : A, (a0 = a \\/ In a l0) /\\ b = f a", "exists a : A, (a0 = a \\/ In a l0) /\\ b = f a"], "proof_term_before": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   ((fun tmp : False =>\n     match tmp return (exists a : A, False /\\ b = f a) with\n     end)\n    :\n    In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"], "proof_term_after": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   ((fun tmp : False =>\n     match tmp return (exists a : A, False /\\ b = f a) with\n     end)\n    :\n    In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n       (H0 : f a0 = b \\/ In b (map f l0)) =>\n     match H0 with\n     | or_introl x => (fun H1 : f a0 = b => ?Goal) x\n     | or_intror x => (fun H1 : In b (map f l0) => ?Goal0) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"]}, {"text": "exists a0; auto.", "goal_before": ["exists a : A, (a0 = a \\/ In a l0) /\\ b = f a", "exists a : A, (a0 = a \\/ In a l0) /\\ b = f a"], "goal_after": ["exists a : A, (a0 = a \\/ In a l0) /\\ b = f a"], "proof_term_before": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   ((fun tmp : False =>\n     match tmp return (exists a : A, False /\\ b = f a) with\n     end)\n    :\n    In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n       (H0 : f a0 = b \\/ In b (map f l0)) =>\n     match H0 with\n     | or_introl x => (fun H1 : f a0 = b => ?Goal) x\n     | or_intror x => (fun H1 : In b (map f l0) => ?Goal0) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"], "proof_term_after": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   ((fun tmp : False =>\n     match tmp return (exists a : A, False /\\ b = f a) with\n     end)\n    :\n    In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n       (H0 : f a0 = b \\/ In b (map f l0)) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : f a0 = b =>\n          ex_intro (fun a : A => (a0 = a \\/ In a l0) /\\ b = f a) a0\n            (conj (or_introl eq_refl) (eq_sym H1))) x\n     | or_intror x => (fun H1 : In b (map f l0) => ?Goal) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"]}, {"text": "case (H H1); intros a1 (H2, H3); exists a1; auto.", "goal_before": ["exists a : A, (a0 = a \\/ In a l0) /\\ b = f a"], "goal_after": [], "proof_term_before": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   ((fun tmp : False =>\n     match tmp return (exists a : A, False /\\ b = f a) with\n     end)\n    :\n    In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n       (H0 : f a0 = b \\/ In b (map f l0)) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : f a0 = b =>\n          ex_intro (fun a : A => (a0 = a \\/ In a l0) /\\ b = f a) a0\n            (conj (or_introl eq_refl) (eq_sym H1))) x\n     | or_intror x => (fun H1 : In b (map f l0) => ?Goal) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"], "proof_term_after": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   ((fun tmp : False =>\n     match tmp return (exists a : A, False /\\ b = f a) with\n     end)\n    :\n    In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n       (H0 : f a0 = b \\/ In b (map f l0)) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : f a0 = b =>\n          ex_intro (fun a : A => (a0 = a \\/ In a l0) /\\ b = f a) a0\n            (conj (or_introl eq_refl) (eq_sym H1))) x\n     | or_intror x =>\n         (fun H1 : In b (map f l0) =>\n          match H H1 with\n          | ex_intro _ x0 x1 =>\n              (fun (a1 : A) (H2 : In a1 l0 /\\ b = f a1) =>\n               match H2 with\n               | conj x2 x3 =>\n                   (fun (H3 : In a1 l0) (H4 : b = f a1) =>\n                    ex_intro (fun a : A => (a0 = a \\/ In a l0) /\\ b = f a) a1\n                      (conj (or_intror H3) H4)) x2 x3\n               end) x0 x1\n          end) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (b : B) (l : list A) =>\n list_ind\n   (fun l0 : list A => In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n   ((fun tmp : False =>\n     match tmp return (exists a : A, False /\\ b = f a) with\n     end)\n    :\n    In b (map f nil) -> exists a : A, In a nil /\\ b = f a)\n   ((fun (a0 : A) (l0 : list A)\n       (H : In b (map f l0) -> exists a : A, In a l0 /\\ b = f a)\n       (H0 : f a0 = b \\/ In b (map f l0)) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : f a0 = b =>\n          ex_intro (fun a : A => (a0 = a \\/ In a l0) /\\ b = f a) a0\n            (conj (or_introl eq_refl) (eq_sym H1))) x\n     | or_intror x =>\n         (fun H1 : In b (map f l0) =>\n          match H H1 with\n          | ex_intro _ x0 x1 =>\n              (fun (a1 : A) (H2 : In a1 l0 /\\ b = f a1) =>\n               match H2 with\n               | conj x2 x3 =>\n                   (fun (H3 : In a1 l0) (H4 : b = f a1) =>\n                    ex_intro (fun a : A => (a0 = a \\/ In a l0) /\\ b = f a) a1\n                      (conj (or_intror H3) H4)) x2 x3\n               end) x0 x1\n          end) x\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    (In b (map f l0) -> exists a0 : A, In a0 l0 /\\ b = f a0) ->\n    In b (map f (a :: l0)) -> exists a0 : A, In a0 (a :: l0) /\\ b = f a0) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "in_map_fst_inv", "text": "Theorem in_map_fst_inv :\n forall a (l : list (B * C)),\n In a (map (fst (B:=_)) l) -> exists c : _, In (a, c) l.\nProof using.\nintros a l; elim l; simpl in |- *; auto.\nintros H; case H.\nintros a0 l0 H [H0| H0]; auto.\nexists (snd a0); left; rewrite <- H0; case a0; simpl in |- *; auto.\ncase H; auto; intros l1 Hl1; exists l1; auto.\nQed.\n", "definition": "\n forall a (l : list (B * C)),\n In a (map (fst (B:=_)) l) -> exists c : _, In (a, c) l.", "proof": "\nProof using.\nintros a l; elim l; simpl in |- *; auto.\nintros H; case H.\nintros a0 l0 H [H0| H0]; auto.\nexists (snd a0); left; rewrite <- H0; case a0; simpl in |- *; auto.\ncase H; auto; intros l1 Hl1; exists l1; auto.\n", "def_ranges": [338, 0, 340, 56], "proof_ranges": [341, 0, 347, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (a : B) (l : list (B * C)),\nIn a (map fst l) -> exists c : C, In (a, c) l"], "goal_after": ["forall (a : B) (l : list (B * C)),\nIn a (map fst l) -> exists c : C, In (a, c) l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a l; elim l; simpl in |- *; auto.", "goal_before": ["forall (a : B) (l : list (B * C)),\nIn a (map fst l) -> exists c : C, In (a, c) l"], "goal_after": ["False -> exists _ : C, False", "forall (a0 : B * C) (l0 : list (B * C)),\n(In a (map fst l0) -> exists c : C, In (a, c) l0) ->\nfst a0 = a \\/ In a (map fst l0) -> exists c : C, a0 = (a, c) \\/ In (a, c) l0"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   (?Goal : In a (map fst nil) -> exists c : C, In (a, c) nil)\n   (?Goal0\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"]}, {"text": "intros H; case H.", "goal_before": ["False -> exists _ : C, False", "forall (a0 : B * C) (l0 : list (B * C)),\n(In a (map fst l0) -> exists c : C, In (a, c) l0) ->\nfst a0 = a \\/ In a (map fst l0) -> exists c : C, a0 = (a, c) \\/ In (a, c) l0"], "goal_after": ["forall (a0 : B * C) (l0 : list (B * C)),\n(In a (map fst l0) -> exists c : C, In (a, c) l0) ->\nfst a0 = a \\/ In a (map fst l0) -> exists c : C, a0 = (a, c) \\/ In (a, c) l0"], "proof_term_before": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   (?Goal : In a (map fst nil) -> exists c : C, In (a, c) nil)\n   (?Goal0\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"], "proof_term_after": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   ((fun H : False => match H return (exists _ : C, False) with\n                      end)\n    :\n    In a (map fst nil) -> exists c : C, In (a, c) nil)\n   (?Goal\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"]}, {"text": "intros a0 l0 H [H0| H0]; auto.", "goal_before": ["forall (a0 : B * C) (l0 : list (B * C)),\n(In a (map fst l0) -> exists c : C, In (a, c) l0) ->\nfst a0 = a \\/ In a (map fst l0) -> exists c : C, a0 = (a, c) \\/ In (a, c) l0"], "goal_after": ["exists c : C, a0 = (a, c) \\/ In (a, c) l0", "exists c : C, a0 = (a, c) \\/ In (a, c) l0"], "proof_term_before": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   ((fun H : False => match H return (exists _ : C, False) with\n                      end)\n    :\n    In a (map fst nil) -> exists c : C, In (a, c) nil)\n   (?Goal\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"], "proof_term_after": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   ((fun H : False => match H return (exists _ : C, False) with\n                      end)\n    :\n    In a (map fst nil) -> exists c : C, In (a, c) nil)\n   ((fun (a0 : B * C) (l0 : list (B * C))\n       (H : In a (map fst l0) -> exists c : C, In (a, c) l0)\n       (H1 : fst a0 = a \\/ In a (map fst l0)) =>\n     match H1 with\n     | or_introl x => (fun H0 : fst a0 = a => ?Goal) x\n     | or_intror x => (fun H0 : In a (map fst l0) => ?Goal0) x\n     end)\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"]}, {"text": "exists (snd a0); left; rewrite <- H0; case a0; simpl in |- *; auto.", "goal_before": ["exists c : C, a0 = (a, c) \\/ In (a, c) l0", "exists c : C, a0 = (a, c) \\/ In (a, c) l0"], "goal_after": ["exists c : C, a0 = (a, c) \\/ In (a, c) l0"], "proof_term_before": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   ((fun H : False => match H return (exists _ : C, False) with\n                      end)\n    :\n    In a (map fst nil) -> exists c : C, In (a, c) nil)\n   ((fun (a0 : B * C) (l0 : list (B * C))\n       (H : In a (map fst l0) -> exists c : C, In (a, c) l0)\n       (H1 : fst a0 = a \\/ In a (map fst l0)) =>\n     match H1 with\n     | or_introl x => (fun H0 : fst a0 = a => ?Goal) x\n     | or_intror x => (fun H0 : In a (map fst l0) => ?Goal0) x\n     end)\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"], "proof_term_after": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   ((fun H : False => match H return (exists _ : C, False) with\n                      end)\n    :\n    In a (map fst nil) -> exists c : C, In (a, c) nil)\n   ((fun (a0 : B * C) (l0 : list (B * C))\n       (H : In a (map fst l0) -> exists c : C, In (a, c) l0)\n       (H1 : fst a0 = a \\/ In a (map fst l0)) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : fst a0 = a =>\n          ex_intro (fun c : C => a0 = (a, c) \\/ In (a, c) l0) \n            (snd a0)\n            (or_introl\n               (eq_ind (fst a0) (fun a1 : B => a0 = (a1, snd a0))\n                  (let (a1, b) as p return (p = (fst p, snd p)) := a0 in\n                   ((fun (b0 : B) (c : C) => eq_refl)\n                    :\n                    forall (b0 : B) (c : C),\n                    (b0, c) = (fst (b0, c), snd (b0, c))) a1 b) a H0))) x\n     | or_intror x => (fun H0 : In a (map fst l0) => ?Goal) x\n     end)\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"]}, {"text": "case H; auto; intros l1 Hl1; exists l1; auto.", "goal_before": ["exists c : C, a0 = (a, c) \\/ In (a, c) l0"], "goal_after": [], "proof_term_before": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   ((fun H : False => match H return (exists _ : C, False) with\n                      end)\n    :\n    In a (map fst nil) -> exists c : C, In (a, c) nil)\n   ((fun (a0 : B * C) (l0 : list (B * C))\n       (H : In a (map fst l0) -> exists c : C, In (a, c) l0)\n       (H1 : fst a0 = a \\/ In a (map fst l0)) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : fst a0 = a =>\n          ex_intro (fun c : C => a0 = (a, c) \\/ In (a, c) l0) \n            (snd a0)\n            (or_introl\n               (eq_ind (fst a0) (fun a1 : B => a0 = (a1, snd a0))\n                  (let (a1, b) as p return (p = (fst p, snd p)) := a0 in\n                   ((fun (b0 : B) (c : C) => eq_refl)\n                    :\n                    forall (b0 : B) (c : C),\n                    (b0, c) = (fst (b0, c), snd (b0, c))) a1 b) a H0))) x\n     | or_intror x => (fun H0 : In a (map fst l0) => ?Goal) x\n     end)\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"], "proof_term_after": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   ((fun H : False => match H return (exists _ : C, False) with\n                      end)\n    :\n    In a (map fst nil) -> exists c : C, In (a, c) nil)\n   ((fun (a0 : B * C) (l0 : list (B * C))\n       (H : In a (map fst l0) -> exists c : C, In (a, c) l0)\n       (H1 : fst a0 = a \\/ In a (map fst l0)) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : fst a0 = a =>\n          ex_intro (fun c : C => a0 = (a, c) \\/ In (a, c) l0) \n            (snd a0)\n            (or_introl\n               (eq_ind (fst a0) (fun a1 : B => a0 = (a1, snd a0))\n                  (let (a1, b) as p return (p = (fst p, snd p)) := a0 in\n                   ((fun (b0 : B) (c : C) => eq_refl)\n                    :\n                    forall (b0 : B) (c : C),\n                    (b0, c) = (fst (b0, c), snd (b0, c))) a1 b) a H0))) x\n     | or_intror x =>\n         (fun H0 : In a (map fst l0) =>\n          match H H0 with\n          | ex_intro _ x0 x1 =>\n              (fun (l1 : C) (Hl1 : In (a, l1) l0) =>\n               ex_intro (fun c : C => a0 = (a, c) \\/ In (a, c) l0) l1\n                 (or_intror Hl1)) x0 x1\n          end) x\n     end)\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : B) (l : list (B * C)) =>\n list_ind\n   (fun l0 : list (B * C) => In a (map fst l0) -> exists c : C, In (a, c) l0)\n   ((fun H : False => match H return (exists _ : C, False) with\n                      end)\n    :\n    In a (map fst nil) -> exists c : C, In (a, c) nil)\n   ((fun (a0 : B * C) (l0 : list (B * C))\n       (H : In a (map fst l0) -> exists c : C, In (a, c) l0)\n       (H1 : fst a0 = a \\/ In a (map fst l0)) =>\n     match H1 with\n     | or_introl x =>\n         (fun H0 : fst a0 = a =>\n          ex_intro (fun c : C => a0 = (a, c) \\/ In (a, c) l0) \n            (snd a0)\n            (or_introl\n               (eq_ind (fst a0) (fun a1 : B => a0 = (a1, snd a0))\n                  (let (a1, b) as p return (p = (fst p, snd p)) := a0 in\n                   ((fun (b0 : B) (c : C) => eq_refl)\n                    :\n                    forall (b0 : B) (c : C),\n                    (b0, c) = (fst (b0, c), snd (b0, c))) a1 b) a H0))) x\n     | or_intror x =>\n         (fun H0 : In a (map fst l0) =>\n          match H H0 with\n          | ex_intro _ x0 x1 =>\n              (fun (l1 : C) (Hl1 : In (a, l1) l0) =>\n               ex_intro (fun c : C => a0 = (a, c) \\/ In (a, c) l0) l1\n                 (or_intror Hl1)) x0 x1\n          end) x\n     end)\n    :\n    forall (a0 : B * C) (l0 : list (B * C)),\n    (In a (map fst l0) -> exists c : C, In (a, c) l0) ->\n    In a (map fst (a0 :: l0)) -> exists c : C, In (a, c) (a0 :: l0)) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "length_map", "text": "Theorem length_map : forall l, length (map f l) = length l.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nQed.\n", "definition": " forall l, length (map f l) = length l.", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\n", "def_ranges": [349, 0, 349, 59], "proof_ranges": [350, 0, 352, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l : list A, length (map f l) = length l"], "goal_after": ["forall l : list A, length (map f l) = length l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall l : list A, length (map f l) = length l"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list A =>\n list_ind (fun l0 : list A => length (map f l0) = length l0)\n   (eq_refl : length (map f nil) = length nil)\n   ((fun (_ : A) (l0 : list A) (H : length (map f l0) = length l0) =>\n     f_equal_nat nat S (length (map f l0)) (length l0) H)\n    :\n    forall (a : A) (l0 : list A),\n    length (map f l0) = length l0 ->\n    length (map f (a :: l0)) = length (a :: l0)) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind (fun l0 : list A => length (map f l0) = length l0)\n   (eq_refl : length (map f nil) = length nil)\n   ((fun (_ : A) (l0 : list A) (H : length (map f l0) = length l0) =>\n     f_equal_nat nat S (length (map f l0)) (length l0) H)\n    :\n    forall (a : A) (l0 : list A),\n    length (map f l0) = length l0 ->\n    length (map f (a :: l0)) = length (a :: l0)) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "map_app", "text": "Theorem map_app : forall l1 l2, map f (l1 ++ l2) = map f l1 ++ map f l2.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H l2; apply f_equal2 with (f := cons (A:=B)); auto.\nQed.\n", "definition": " forall l1 l2, map f (l1 ++ l2) = map f l1 ++ map f l2.", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H l2; apply f_equal2 with (f := cons (A:=B)); auto.\n", "def_ranges": [354, 0, 354, 72], "proof_ranges": [355, 0, 358, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l1 l2 : list A, map f (l1 ++ l2) = map f l1 ++ map f l2"], "goal_after": ["forall l1 l2 : list A, map f (l1 ++ l2) = map f l1 ++ map f l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall l1 l2 : list A, map f (l1 ++ l2) = map f l1 ++ map f l2"], "goal_after": ["forall (a : A) (l0 : list A),\n(forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2) ->\nforall l2 : list A, f a :: map f (l0 ++ l2) = f a :: map f l0 ++ map f l2"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2)\n   ((fun l2 : list A => eq_refl)\n    :\n    forall l2 : list A, map f (nil ++ l2) = map f nil ++ map f l2)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    (forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2) ->\n    forall l2 : list A, map f ((a :: l0) ++ l2) = map f (a :: l0) ++ map f l2)\n   l)"]}, {"text": "intros a l0 H l2; apply f_equal2 with (f := cons (A:=B)); auto.", "goal_before": ["forall (a : A) (l0 : list A),\n(forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2) ->\nforall l2 : list A, f a :: map f (l0 ++ l2) = f a :: map f l0 ++ map f l2"], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2)\n   ((fun l2 : list A => eq_refl)\n    :\n    forall l2 : list A, map f (nil ++ l2) = map f nil ++ map f l2)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    (forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2) ->\n    forall l2 : list A, map f ((a :: l0) ++ l2) = map f (a :: l0) ++ map f l2)\n   l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2)\n   ((fun l2 : list A => eq_refl)\n    :\n    forall l2 : list A, map f (nil ++ l2) = map f nil ++ map f l2)\n   ((fun (a : A) (l0 : list A)\n       (H : forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2)\n       (l2 : list A) => f_equal2 cons eq_refl (H l2))\n    :\n    forall (a : A) (l0 : list A),\n    (forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2) ->\n    forall l2 : list A, map f ((a :: l0) ++ l2) = map f (a :: l0) ++ map f l2)\n   l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2)\n   ((fun l2 : list A => eq_refl)\n    :\n    forall l2 : list A, map f (nil ++ l2) = map f nil ++ map f l2)\n   ((fun (a : A) (l0 : list A)\n       (H : forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2)\n       (l2 : list A) => f_equal2 cons eq_refl (H l2))\n    :\n    forall (a : A) (l0 : list A),\n    (forall l2 : list A, map f (l0 ++ l2) = map f l0 ++ map f l2) ->\n    forall l2 : list A, map f ((a :: l0) ++ l2) = map f (a :: l0) ++ map f l2)\n   l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "in_flat_map", "text": "Theorem in_flat_map :\n forall (l : list B) (f : B -> list C) a b,\n In a (f b) -> In b l -> In a (flat_map f l).\nProof using.\nintros l g; elim l; simpl in |- *; auto.\nintros a l0 H a0 b H0 [H1| H1]; apply in_or_app; auto.\nleft; rewrite H1; auto.\nright; apply H with (b := b); auto.\nQed.\n", "definition": "\n forall (l : list B) (f : B -> list C) a b,\n In a (f b) -> In b l -> In a (flat_map f l).", "proof": "\nProof using.\nintros l g; elim l; simpl in |- *; auto.\nintros a l0 H a0 b H0 [H1| H1]; apply in_or_app; auto.\nleft; rewrite H1; auto.\nright; apply H with (b := b); auto.\n", "def_ranges": [361, 0, 363, 45], "proof_ranges": [364, 0, 369, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l : list B) (f0 : B -> list C) (a : C) (b : B),\nIn a (f0 b) -> In b l -> In a (flat_map f0 l)"], "goal_after": ["forall (l : list B) (f0 : B -> list C) (a : C) (b : B),\nIn a (f0 b) -> In b l -> In a (flat_map f0 l)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l g; elim l; simpl in |- *; auto.", "goal_before": ["forall (l : list B) (f0 : B -> list C) (a : C) (b : B),\nIn a (f0 b) -> In b l -> In a (flat_map f0 l)"], "goal_after": ["forall (a : B) (l0 : list B),\n(forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\nforall (a0 : C) (b : B),\nIn a0 (g b) -> a = b \\/ In b l0 -> In a0 (g a ++ flat_map g l0)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : C) (b : B), In a (g b) -> In b l0 -> In a (flat_map g l0))\n   ((fun (a : C) (b : B) (_ : In a (g b)) (H0 : False) => H0)\n    :\n    forall (a : C) (b : B), In a (g b) -> In b nil -> In a (flat_map g nil))\n   (?Goal\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\n    forall (a0 : C) (b : B),\n    In a0 (g b) -> In b (a :: l0) -> In a0 (flat_map g (a :: l0))) l)"]}, {"text": "intros a l0 H a0 b H0 [H1| H1]; apply in_or_app; auto.", "goal_before": ["forall (a : B) (l0 : list B),\n(forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\nforall (a0 : C) (b : B),\nIn a0 (g b) -> a = b \\/ In b l0 -> In a0 (g a ++ flat_map g l0)"], "goal_after": ["In a0 (g a) \\/ In a0 (flat_map g l0)", "In a0 (g a) \\/ In a0 (flat_map g l0)"], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : C) (b : B), In a (g b) -> In b l0 -> In a (flat_map g l0))\n   ((fun (a : C) (b : B) (_ : In a (g b)) (H0 : False) => H0)\n    :\n    forall (a : C) (b : B), In a (g b) -> In b nil -> In a (flat_map g nil))\n   (?Goal\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\n    forall (a0 : C) (b : B),\n    In a0 (g b) -> In b (a :: l0) -> In a0 (flat_map g (a :: l0))) l)"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : C) (b : B), In a (g b) -> In b l0 -> In a (flat_map g l0))\n   ((fun (a : C) (b : B) (_ : In a (g b)) (H0 : False) => H0)\n    :\n    forall (a : C) (b : B), In a (g b) -> In b nil -> In a (flat_map g nil))\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : C) (b : B),\n            In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) \n       (a0 : C) (b : B) (H0 : In a0 (g b)) (H2 : a = b \\/ In b l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : a = b => in_or_app (g a) (flat_map g l0) a0 ?Goal) x\n     | or_intror x =>\n         (fun H1 : In b l0 => in_or_app (g a) (flat_map g l0) a0 ?Goal0) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\n    forall (a0 : C) (b : B),\n    In a0 (g b) -> In b (a :: l0) -> In a0 (flat_map g (a :: l0))) l)"]}, {"text": "left; rewrite H1; auto.", "goal_before": ["In a0 (g a) \\/ In a0 (flat_map g l0)", "In a0 (g a) \\/ In a0 (flat_map g l0)"], "goal_after": ["In a0 (g a) \\/ In a0 (flat_map g l0)"], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : C) (b : B), In a (g b) -> In b l0 -> In a (flat_map g l0))\n   ((fun (a : C) (b : B) (_ : In a (g b)) (H0 : False) => H0)\n    :\n    forall (a : C) (b : B), In a (g b) -> In b nil -> In a (flat_map g nil))\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : C) (b : B),\n            In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) \n       (a0 : C) (b : B) (H0 : In a0 (g b)) (H2 : a = b \\/ In b l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : a = b => in_or_app (g a) (flat_map g l0) a0 ?Goal) x\n     | or_intror x =>\n         (fun H1 : In b l0 => in_or_app (g a) (flat_map g l0) a0 ?Goal0) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\n    forall (a0 : C) (b : B),\n    In a0 (g b) -> In b (a :: l0) -> In a0 (flat_map g (a :: l0))) l)"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : C) (b : B), In a (g b) -> In b l0 -> In a (flat_map g l0))\n   ((fun (a : C) (b : B) (_ : In a (g b)) (H0 : False) => H0)\n    :\n    forall (a : C) (b : B), In a (g b) -> In b nil -> In a (flat_map g nil))\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : C) (b : B),\n            In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) \n       (a0 : C) (b : B) (H0 : In a0 (g b)) (H2 : a = b \\/ In b l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : a = b =>\n          in_or_app (g a) (flat_map g l0) a0\n            (or_introl (eq_ind_r (fun a1 : B => In a0 (g a1)) H0 H1))) x\n     | or_intror x =>\n         (fun H1 : In b l0 => in_or_app (g a) (flat_map g l0) a0 ?Goal) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\n    forall (a0 : C) (b : B),\n    In a0 (g b) -> In b (a :: l0) -> In a0 (flat_map g (a :: l0))) l)"]}, {"text": "right; apply H with (b := b); auto.", "goal_before": ["In a0 (g a) \\/ In a0 (flat_map g l0)"], "goal_after": [], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : C) (b : B), In a (g b) -> In b l0 -> In a (flat_map g l0))\n   ((fun (a : C) (b : B) (_ : In a (g b)) (H0 : False) => H0)\n    :\n    forall (a : C) (b : B), In a (g b) -> In b nil -> In a (flat_map g nil))\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : C) (b : B),\n            In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) \n       (a0 : C) (b : B) (H0 : In a0 (g b)) (H2 : a = b \\/ In b l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : a = b =>\n          in_or_app (g a) (flat_map g l0) a0\n            (or_introl (eq_ind_r (fun a1 : B => In a0 (g a1)) H0 H1))) x\n     | or_intror x =>\n         (fun H1 : In b l0 => in_or_app (g a) (flat_map g l0) a0 ?Goal) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\n    forall (a0 : C) (b : B),\n    In a0 (g b) -> In b (a :: l0) -> In a0 (flat_map g (a :: l0))) l)"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : C) (b : B), In a (g b) -> In b l0 -> In a (flat_map g l0))\n   ((fun (a : C) (b : B) (_ : In a (g b)) (H0 : False) => H0)\n    :\n    forall (a : C) (b : B), In a (g b) -> In b nil -> In a (flat_map g nil))\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : C) (b : B),\n            In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) \n       (a0 : C) (b : B) (H0 : In a0 (g b)) (H2 : a = b \\/ In b l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : a = b =>\n          in_or_app (g a) (flat_map g l0) a0\n            (or_introl (eq_ind_r (fun a1 : B => In a0 (g a1)) H0 H1))) x\n     | or_intror x =>\n         (fun H1 : In b l0 =>\n          in_or_app (g a) (flat_map g l0) a0 (or_intror (H a0 b H0 H1))) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\n    forall (a0 : C) (b : B),\n    In a0 (g b) -> In b (a :: l0) -> In a0 (flat_map g (a :: l0))) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall (a : C) (b : B), In a (g b) -> In b l0 -> In a (flat_map g l0))\n   ((fun (a : C) (b : B) (_ : In a (g b)) (H0 : False) => H0)\n    :\n    forall (a : C) (b : B), In a (g b) -> In b nil -> In a (flat_map g nil))\n   ((fun (a : B) (l0 : list B)\n       (H : forall (a0 : C) (b : B),\n            In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) \n       (a0 : C) (b : B) (H0 : In a0 (g b)) (H2 : a = b \\/ In b l0) =>\n     match H2 with\n     | or_introl x =>\n         (fun H1 : a = b =>\n          in_or_app (g a) (flat_map g l0) a0\n            (or_introl (eq_ind_r (fun a1 : B => In a0 (g a1)) H0 H1))) x\n     | or_intror x =>\n         (fun H1 : In b l0 =>\n          in_or_app (g a) (flat_map g l0) a0 (or_intror (H a0 b H0 H1))) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall (a0 : C) (b : B), In a0 (g b) -> In b l0 -> In a0 (flat_map g l0)) ->\n    forall (a0 : C) (b : B),\n    In a0 (g b) -> In b (a :: l0) -> In a0 (flat_map g (a :: l0))) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "in_flat_map_ex", "text": "Theorem in_flat_map_ex :\n forall (l : list B) (f : B -> list C) a,\n In a (flat_map f l) -> exists b : _, In b l /\\ In a (f b).\nProof using.\nintros l g; elim l; simpl in |- *; auto.\nintros a H; case H.\nintros a l0 H a0 H0; case in_app_or with (1 := H0); simpl in |- *; auto.\nintros H1; exists a; auto.\nintros H1; case H with (1 := H1).\nintros b (H2, H3); exists b; simpl in |- *; auto.\nQed.\n", "definition": "\n forall (l : list B) (f : B -> list C) a,\n In a (flat_map f l) -> exists b : _, In b l /\\ In a (f b).", "proof": "\nProof using.\nintros l g; elim l; simpl in |- *; auto.\nintros a H; case H.\nintros a l0 H a0 H0; case in_app_or with (1 := H0); simpl in |- *; auto.\nintros H1; exists a; auto.\nintros H1; case H with (1 := H1).\nintros b (H2, H3); exists b; simpl in |- *; auto.\n", "def_ranges": [371, 0, 373, 59], "proof_ranges": [374, 0, 381, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l : list B) (f0 : B -> list C) (a : C),\nIn a (flat_map f0 l) -> exists b : B, In b l /\\ In a (f0 b)"], "goal_after": ["forall (l : list B) (f0 : B -> list C) (a : C),\nIn a (flat_map f0 l) -> exists b : B, In b l /\\ In a (f0 b)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l g; elim l; simpl in |- *; auto.", "goal_before": ["forall (l : list B) (f0 : B -> list C) (a : C),\nIn a (flat_map f0 l) -> exists b : B, In b l /\\ In a (f0 b)"], "goal_after": ["forall a : C, False -> exists b : B, False /\\ In a (g b)", "forall (a : B) (l0 : list B),\n(forall a0 : C, In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\nforall a0 : C,\nIn a0 (g a ++ flat_map g l0) ->\nexists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   (?Goal\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   (?Goal0\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"]}, {"text": "intros a H; case H.", "goal_before": ["forall a : C, False -> exists b : B, False /\\ In a (g b)", "forall (a : B) (l0 : list B),\n(forall a0 : C, In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\nforall a0 : C,\nIn a0 (g a ++ flat_map g l0) ->\nexists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "goal_after": ["forall (a : B) (l0 : list B),\n(forall a0 : C, In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\nforall a0 : C,\nIn a0 (g a ++ flat_map g l0) ->\nexists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   (?Goal\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   (?Goal0\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   (?Goal\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"]}, {"text": "intros a l0 H a0 H0; case in_app_or with (1 := H0); simpl in |- *; auto.", "goal_before": ["forall (a : B) (l0 : list B),\n(forall a0 : C, In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\nforall a0 : C,\nIn a0 (g a ++ flat_map g l0) ->\nexists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "goal_after": ["In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)", "In a0 (flat_map g l0) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   (?Goal\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   ((fun (a : B) (l0 : list B)\n       (H : forall a0 : C,\n            In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b))\n       (a0 : C) (H0 : In a0 (g a ++ flat_map g l0)) =>\n     match in_app_or (g a) (flat_map g l0) a0 H0 with\n     | or_introl x =>\n         (?Goal\n          :\n          In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     | or_intror x =>\n         (?Goal0\n          :\n          In a0 (flat_map g l0) ->\n          exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"]}, {"text": "intros H1; exists a; auto.", "goal_before": ["In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)", "In a0 (flat_map g l0) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "goal_after": ["In a0 (flat_map g l0) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   ((fun (a : B) (l0 : list B)\n       (H : forall a0 : C,\n            In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b))\n       (a0 : C) (H0 : In a0 (g a ++ flat_map g l0)) =>\n     match in_app_or (g a) (flat_map g l0) a0 H0 with\n     | or_introl x =>\n         (?Goal\n          :\n          In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     | or_intror x =>\n         (?Goal0\n          :\n          In a0 (flat_map g l0) ->\n          exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   ((fun (a : B) (l0 : list B)\n       (H : forall a0 : C,\n            In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b))\n       (a0 : C) (H0 : In a0 (g a ++ flat_map g l0)) =>\n     match in_app_or (g a) (flat_map g l0) a0 H0 with\n     | or_introl x =>\n         ((fun H1 : In a0 (g a) =>\n           ex_intro (fun b : B => (a = b \\/ In b l0) /\\ In a0 (g b)) a\n             (conj (or_introl eq_refl) H1))\n          :\n          In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     | or_intror x =>\n         (?Goal\n          :\n          In a0 (flat_map g l0) ->\n          exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"]}, {"text": "intros H1; case H with (1 := H1).", "goal_before": ["In a0 (flat_map g l0) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "goal_after": ["forall x : B,\nIn x l0 /\\ In a0 (g x) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   ((fun (a : B) (l0 : list B)\n       (H : forall a0 : C,\n            In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b))\n       (a0 : C) (H0 : In a0 (g a ++ flat_map g l0)) =>\n     match in_app_or (g a) (flat_map g l0) a0 H0 with\n     | or_introl x =>\n         ((fun H1 : In a0 (g a) =>\n           ex_intro (fun b : B => (a = b \\/ In b l0) /\\ In a0 (g b)) a\n             (conj (or_introl eq_refl) H1))\n          :\n          In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     | or_intror x =>\n         (?Goal\n          :\n          In a0 (flat_map g l0) ->\n          exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   ((fun (a : B) (l0 : list B)\n       (H : forall a0 : C,\n            In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b))\n       (a0 : C) (H0 : In a0 (g a ++ flat_map g l0)) =>\n     match in_app_or (g a) (flat_map g l0) a0 H0 with\n     | or_introl x =>\n         ((fun H1 : In a0 (g a) =>\n           ex_intro (fun b : B => (a = b \\/ In b l0) /\\ In a0 (g b)) a\n             (conj (or_introl eq_refl) H1))\n          :\n          In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     | or_intror x =>\n         ((fun H1 : In a0 (flat_map g l0) =>\n           match H a0 H1 with\n           | ex_intro _ x0 x1 => ?Goal x0 x1\n           end)\n          :\n          In a0 (flat_map g l0) ->\n          exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"]}, {"text": "intros b (H2, H3); exists b; simpl in |- *; auto.", "goal_before": ["forall x : B,\nIn x l0 /\\ In a0 (g x) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)"], "goal_after": [], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   ((fun (a : B) (l0 : list B)\n       (H : forall a0 : C,\n            In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b))\n       (a0 : C) (H0 : In a0 (g a ++ flat_map g l0)) =>\n     match in_app_or (g a) (flat_map g l0) a0 H0 with\n     | or_introl x =>\n         ((fun H1 : In a0 (g a) =>\n           ex_intro (fun b : B => (a = b \\/ In b l0) /\\ In a0 (g b)) a\n             (conj (or_introl eq_refl) H1))\n          :\n          In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     | or_intror x =>\n         ((fun H1 : In a0 (flat_map g l0) =>\n           match H a0 H1 with\n           | ex_intro _ x0 x1 => ?Goal x0 x1\n           end)\n          :\n          In a0 (flat_map g l0) ->\n          exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"], "proof_term_after": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   ((fun (a : B) (l0 : list B)\n       (H : forall a0 : C,\n            In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b))\n       (a0 : C) (H0 : In a0 (g a ++ flat_map g l0)) =>\n     match in_app_or (g a) (flat_map g l0) a0 H0 with\n     | or_introl x =>\n         ((fun H1 : In a0 (g a) =>\n           ex_intro (fun b : B => (a = b \\/ In b l0) /\\ In a0 (g b)) a\n             (conj (or_introl eq_refl) H1))\n          :\n          In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     | or_intror x =>\n         ((fun H1 : In a0 (flat_map g l0) =>\n           match H a0 H1 with\n           | ex_intro _ x0 x1 =>\n               (fun (b : B) (H4 : In b l0 /\\ In a0 (g b)) =>\n                match H4 with\n                | conj x2 x3 =>\n                    (fun (H2 : In b l0) (H3 : In a0 (g b)) =>\n                     ex_intro\n                       (fun b0 : B => (a = b0 \\/ In b0 l0) /\\ In a0 (g b0)) b\n                       (conj (or_intror H2) H3\n                        :\n                        (a = b \\/ In b l0) /\\ In a0 (g b))) x2 x3\n                end) x0 x1\n           end)\n          :\n          In a0 (flat_map g l0) ->\n          exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : list B) (g : B -> list C) =>\n list_ind\n   (fun l0 : list B =>\n    forall a : C, In a (flat_map g l0) -> exists b : B, In b l0 /\\ In a (g b))\n   ((fun (a : C) (H : False) =>\n     match H return (exists b : B, False /\\ In a (g b)) with\n     end)\n    :\n    forall a : C,\n    In a (flat_map g nil) -> exists b : B, In b nil /\\ In a (g b))\n   ((fun (a : B) (l0 : list B)\n       (H : forall a0 : C,\n            In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b))\n       (a0 : C) (H0 : In a0 (g a ++ flat_map g l0)) =>\n     match in_app_or (g a) (flat_map g l0) a0 H0 with\n     | or_introl x =>\n         ((fun H1 : In a0 (g a) =>\n           ex_intro (fun b : B => (a = b \\/ In b l0) /\\ In a0 (g b)) a\n             (conj (or_introl eq_refl) H1))\n          :\n          In a0 (g a) -> exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     | or_intror x =>\n         ((fun H1 : In a0 (flat_map g l0) =>\n           match H a0 H1 with\n           | ex_intro _ x0 x1 =>\n               (fun (b : B) (H4 : In b l0 /\\ In a0 (g b)) =>\n                match H4 with\n                | conj x2 x3 =>\n                    (fun (H2 : In b l0) (H3 : In a0 (g b)) =>\n                     ex_intro\n                       (fun b0 : B => (a = b0 \\/ In b0 l0) /\\ In a0 (g b0)) b\n                       (conj (or_intror H2) H3\n                        :\n                        (a = b \\/ In b l0) /\\ In a0 (g b))) x2 x3\n                end) x0 x1\n           end)\n          :\n          In a0 (flat_map g l0) ->\n          exists b : B, (a = b \\/ In b l0) /\\ In a0 (g b)) x\n     end)\n    :\n    forall (a : B) (l0 : list B),\n    (forall a0 : C,\n     In a0 (flat_map g l0) -> exists b : B, In b l0 /\\ In a0 (g b)) ->\n    forall a0 : C,\n    In a0 (flat_map g (a :: l0)) ->\n    exists b : B, In b (a :: l0) /\\ In a0 (g b)) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "map2_app", "text": "Theorem map2_app :\n forall l1 l2 l3 l4,\n length l1 = length l2 ->\n map2 (l1 ++ l3) (l2 ++ l4) = map2 l1 l2 ++ map2 l3 l4.\nProof using.\nintros l1; elim l1; auto.\nintros l2; case l2; simpl in |- *; auto; intros; discriminate.\nintros a l H l2 l3 l4; case l2.\nsimpl in |- *; intros; discriminate.\nintros b l0 H0.\napply trans_equal with (f a b :: map2 (l ++ l3) (l0 ++ l4)).\nsimpl in |- *; auto.\nrewrite H; auto.\nQed.\n", "definition": "\n forall l1 l2 l3 l4,\n length l1 = length l2 ->\n map2 (l1 ++ l3) (l2 ++ l4) = map2 l1 l2 ++ map2 l3 l4.", "proof": "\nProof using.\nintros l1; elim l1; auto.\nintros l2; case l2; simpl in |- *; auto; intros; discriminate.\nintros a l H l2 l3 l4; case l2.\nsimpl in |- *; intros; discriminate.\nintros b l0 H0.\napply trans_equal with (f a b :: map2 (l ++ l3) (l0 ++ l4)).\nsimpl in |- *; auto.\nrewrite H; auto.\n", "def_ranges": [401, 0, 404, 55], "proof_ranges": [405, 0, 414, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (l1 : list A) (l2 : list B) (l3 : list A) (l4 : list B),\nlength l1 = length l2 ->\nmap2 (l1 ++ l3) (l2 ++ l4) = map2 l1 l2 ++ map2 l3 l4"], "goal_after": ["forall (l1 : list A) (l2 : list B) (l3 : list A) (l4 : list B),\nlength l1 = length l2 ->\nmap2 (l1 ++ l3) (l2 ++ l4) = map2 l1 l2 ++ map2 l3 l4"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l1; elim l1; auto.", "goal_before": ["forall (l1 : list A) (l2 : list B) (l3 : list A) (l4 : list B),\nlength l1 = length l2 ->\nmap2 (l1 ++ l3) (l2 ++ l4) = map2 l1 l2 ++ map2 l3 l4"], "goal_after": ["forall (l2 : list B) (l3 : list A) (l4 : list B),\nlength nil = length l2 ->\nmap2 (nil ++ l3) (l2 ++ l4) = map2 nil l2 ++ map2 l3 l4", "forall (a : A) (l : list A),\n(forall (l2 : list B) (l3 : list A) (l4 : list B),\n length l = length l2 -> map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) ->\nforall (l2 : list B) (l3 : list A) (l4 : list B),\nlength (a :: l) = length l2 ->\nmap2 ((a :: l) ++ l3) (l2 ++ l4) = map2 (a :: l) l2 ++ map2 l3 l4"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5) \n   ?Goal ?Goal0 l1)"]}, {"text": "intros l2; case l2; simpl in |- *; auto; intros; discriminate.", "goal_before": ["forall (l2 : list B) (l3 : list A) (l4 : list B),\nlength nil = length l2 ->\nmap2 (nil ++ l3) (l2 ++ l4) = map2 nil l2 ++ map2 l3 l4", "forall (a : A) (l : list A),\n(forall (l2 : list B) (l3 : list A) (l4 : list B),\n length l = length l2 -> map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) ->\nforall (l2 : list B) (l3 : list A) (l4 : list B),\nlength (a :: l) = length l2 ->\nmap2 ((a :: l) ++ l3) (l2 ++ l4) = map2 (a :: l) l2 ++ map2 l3 l4"], "goal_after": ["forall (a : A) (l : list A),\n(forall (l2 : list B) (l3 : list A) (l4 : list B),\n length l = length l2 -> map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) ->\nforall (l2 : list B) (l3 : list A) (l4 : list B),\nlength (a :: l) = length l2 ->\nmap2 ((a :: l) ++ l3) (l2 ++ l4) = map2 (a :: l) l2 ++ map2 l3 l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5) \n   ?Goal ?Goal0 l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end) ?Goal l1)"]}, {"text": "intros a l H l2 l3 l4; case l2.", "goal_before": ["forall (a : A) (l : list A),\n(forall (l2 : list B) (l3 : list A) (l4 : list B),\n length l = length l2 -> map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) ->\nforall (l2 : list B) (l3 : list A) (l4 : list B),\nlength (a :: l) = length l2 ->\nmap2 ((a :: l) ++ l3) (l2 ++ l4) = map2 (a :: l) l2 ++ map2 l3 l4"], "goal_after": ["length (a :: l) = length nil ->\nmap2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4", "forall (b : B) (l0 : list B),\nlength (a :: l) = length (b :: l0) ->\nmap2 ((a :: l) ++ l3) ((b :: l0) ++ l4) =\nmap2 (a :: l) (b :: l0) ++ map2 l3 l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end) ?Goal l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil => ?Goal\n    | a0 :: l0 => ?Goal0 a0 l0\n    end) l1)"]}, {"text": "simpl in |- *; intros; discriminate.", "goal_before": ["length (a :: l) = length nil ->\nmap2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4", "forall (b : B) (l0 : list B),\nlength (a :: l) = length (b :: l0) ->\nmap2 ((a :: l) ++ l3) ((b :: l0) ++ l4) =\nmap2 (a :: l) (b :: l0) ++ map2 l3 l4"], "goal_after": ["forall (b : B) (l0 : list B),\nlength (a :: l) = length (b :: l0) ->\nmap2 ((a :: l) ++ l3) ((b :: l0) ++ l4) =\nmap2 (a :: l) (b :: l0) ++ map2 l3 l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil => ?Goal\n    | a0 :: l0 => ?Goal0 a0 l0\n    end) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 => ?Goal a0 l0\n    end) l1)"]}, {"text": "intros b l0 H0.", "goal_before": ["forall (b : B) (l0 : list B),\nlength (a :: l) = length (b :: l0) ->\nmap2 ((a :: l) ++ l3) ((b :: l0) ++ l4) =\nmap2 (a :: l) (b :: l0) ++ map2 l3 l4"], "goal_after": ["map2 ((a :: l) ++ l3) ((b :: l0) ++ l4) =\nmap2 (a :: l) (b :: l0) ++ map2 l3 l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 => ?Goal a0 l0\n    end) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 =>\n        (fun (b : B) (l5 : list B) (H0 : length (a :: l) = length (b :: l5))\n         => ?Goal@{l0:=l5}) a0 l0\n    end) l1)"]}, {"text": "apply trans_equal with (f a b :: map2 (l ++ l3) (l0 ++ l4)).", "goal_before": ["map2 ((a :: l) ++ l3) ((b :: l0) ++ l4) =\nmap2 (a :: l) (b :: l0) ++ map2 l3 l4"], "goal_after": ["map2 ((a :: l) ++ l3) ((b :: l0) ++ l4) = f a b :: map2 (l ++ l3) (l0 ++ l4)", "f a b :: map2 (l ++ l3) (l0 ++ l4) = map2 (a :: l) (b :: l0) ++ map2 l3 l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 =>\n        (fun (b : B) (l5 : list B) (H0 : length (a :: l) = length (b :: l5))\n         => ?Goal@{l0:=l5}) a0 l0\n    end) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 =>\n        (fun (b : B) (l5 : list B) (H0 : length (a :: l) = length (b :: l5))\n         => eq_trans ?Goal@{l0:=l5} ?Goal0@{l0:=l5}) a0 l0\n    end) l1)"]}, {"text": "simpl in |- *; auto.", "goal_before": ["map2 ((a :: l) ++ l3) ((b :: l0) ++ l4) = f a b :: map2 (l ++ l3) (l0 ++ l4)", "f a b :: map2 (l ++ l3) (l0 ++ l4) = map2 (a :: l) (b :: l0) ++ map2 l3 l4"], "goal_after": ["f a b :: map2 (l ++ l3) (l0 ++ l4) = map2 (a :: l) (b :: l0) ++ map2 l3 l4"], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 =>\n        (fun (b : B) (l5 : list B) (H0 : length (a :: l) = length (b :: l5))\n         => eq_trans ?Goal@{l0:=l5} ?Goal0@{l0:=l5}) a0 l0\n    end) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 =>\n        (fun (b : B) (l5 : list B) (H0 : length (a :: l) = length (b :: l5))\n         =>\n         eq_trans\n           (eq_refl\n            :\n            map2 ((a :: l) ++ l3) ((b :: l5) ++ l4) =\n            f a b :: map2 (l ++ l3) (l5 ++ l4)) ?Goal@{l0:=l5}) a0 l0\n    end) l1)"]}, {"text": "rewrite H; auto.", "goal_before": ["f a b :: map2 (l ++ l3) (l0 ++ l4) = map2 (a :: l) (b :: l0) ++ map2 l3 l4"], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 =>\n        (fun (b : B) (l5 : list B) (H0 : length (a :: l) = length (b :: l5))\n         =>\n         eq_trans\n           (eq_refl\n            :\n            map2 ((a :: l) ++ l3) ((b :: l5) ++ l4) =\n            f a b :: map2 (l ++ l3) (l5 ++ l4)) ?Goal@{l0:=l5}) a0 l0\n    end) l1)"], "proof_term_after": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 =>\n        (fun (b : B) (l5 : list B) (H0 : length (a :: l) = length (b :: l5))\n         =>\n         eq_trans\n           (eq_refl\n            :\n            map2 ((a :: l) ++ l3) ((b :: l5) ++ l4) =\n            f a b :: map2 (l ++ l3) (l5 ++ l4))\n           (eq_ind_r\n              (fun l6 : list C =>\n               f a b :: l6 = map2 (a :: l) (b :: l5) ++ map2 l3 l4) eq_refl\n              (H l5 l3 l4 (eq_add_S (length l) (length l5) H0)))) a0 l0\n    end) l1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l1 : list A =>\n list_ind\n   (fun l2 : list A =>\n    forall (l3 : list B) (l4 : list A) (l5 : list B),\n    length l2 = length l3 ->\n    map2 (l2 ++ l4) (l3 ++ l5) = map2 l2 l3 ++ map2 l4 l5)\n   (fun l2 : list B =>\n    match\n      l2 as l\n      return\n        (forall (l3 : list A) (l4 : list B),\n         length nil = length l ->\n         map2 (nil ++ l3) (l ++ l4) = map2 nil l ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun (l3 : list A) (l4 : list B) (_ : 0 = 0) => eq_refl)\n        :\n        forall (l3 : list A) (l4 : list B),\n        length nil = length nil ->\n        map2 (nil ++ l3) (nil ++ l4) = map2 nil nil ++ map2 l3 l4\n    | a :: l =>\n        ((fun (b : B) (l0 : list B) (l3 : list A) \n            (l4 : list B) (H : 0 = S (length l0)) =>\n          let H0 : False :=\n            eq_ind 0\n              (fun e : nat => match e with\n                              | 0 => True\n                              | S _ => False\n                              end) I (S (length l0)) H in\n          False_ind (map2 l3 (b :: l0 ++ l4) = map2 l3 l4) H0)\n         :\n         forall (b : B) (l0 : list B) (l3 : list A) (l4 : list B),\n         length nil = length (b :: l0) ->\n         map2 (nil ++ l3) ((b :: l0) ++ l4) =\n         map2 nil (b :: l0) ++ map2 l3 l4) a l\n    end)\n   (fun (a : A) (l : list A)\n      (H : forall (l2 : list B) (l3 : list A) (l4 : list B),\n           length l = length l2 ->\n           map2 (l ++ l3) (l2 ++ l4) = map2 l l2 ++ map2 l3 l4) \n      (l2 : list B) (l3 : list A) (l4 : list B) =>\n    match\n      l2 as l0\n      return\n        (length (a :: l) = length l0 ->\n         map2 ((a :: l) ++ l3) (l0 ++ l4) = map2 (a :: l) l0 ++ map2 l3 l4)\n    with\n    | nil =>\n        (fun H0 : S (length l) = 0 =>\n         let H1 : False :=\n           eq_ind (S (length l))\n             (fun e : nat => match e with\n                             | 0 => False\n                             | S _ => True\n                             end) I 0 H0 in\n         False_ind\n           (match l4 with\n            | nil => nil\n            | b :: l5 => f a b :: map2 (l ++ l3) l5\n            end = map2 l3 l4) H1)\n        :\n        length (a :: l) = length nil ->\n        map2 ((a :: l) ++ l3) (nil ++ l4) = map2 (a :: l) nil ++ map2 l3 l4\n    | a0 :: l0 =>\n        (fun (b : B) (l5 : list B) (H0 : length (a :: l) = length (b :: l5))\n         =>\n         eq_trans\n           (eq_refl\n            :\n            map2 ((a :: l) ++ l3) ((b :: l5) ++ l4) =\n            f a b :: map2 (l ++ l3) (l5 ++ l4))\n           (eq_ind_r\n              (fun l6 : list C =>\n               f a b :: l6 = map2 (a :: l) (b :: l5) ++ map2 l3 l4) eq_refl\n              (H l5 l3 l4 (eq_add_S (length l) (length l5) H0)))) a0 l0\n    end) l1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "first_n_app1", "text": "Theorem first_n_app1 :\n forall (n : nat) (l1 l2 : list A),\n length l1 <= n -> first_n (l1 ++ l2) n = l1 ++ first_n l2 (n - length l1).\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros l1; case l1; simpl in |- *; auto.\nintros b l l2 H; Contradict H; auto with arith.\nintros n0 H l1; case l1; simpl in |- *; auto with arith.\nintros b l l2 H0; rewrite H; auto with arith.\nQed.\n", "definition": "\n forall (n : nat) (l1 l2 : list A),\n length l1 <= n -> first_n (l1 ++ l2) n = l1 ++ first_n l2 (n - length l1).", "proof": "\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros l1; case l1; simpl in |- *; auto.\nintros b l l2 H; Contradict H; auto with arith.\nintros n0 H l1; case l1; simpl in |- *; auto with arith.\nintros b l l2 H0; rewrite H; auto with arith.\n", "def_ranges": [435, 0, 437, 75], "proof_ranges": [438, 0, 444, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (n : nat) (l1 l2 : list A),\nlength l1 <= n -> first_n (l1 ++ l2) n = l1 ++ first_n l2 (n - length l1)"], "goal_after": ["forall (n : nat) (l1 l2 : list A),\nlength l1 <= n -> first_n (l1 ++ l2) n = l1 ++ first_n l2 (n - length l1)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros n; elim n; simpl in |- *; auto.", "goal_before": ["forall (n : nat) (l1 l2 : list A),\nlength l1 <= n -> first_n (l1 ++ l2) n = l1 ++ first_n l2 (n - length l1)"], "goal_after": ["forall l1 : list A, list A -> length l1 <= 0 -> nil = l1 ++ nil", "forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = l1 ++ first_n l2 match length l1 with\n                       | 0 => S n0\n                       | S l => n0 - l\n                       end"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   (?Goal\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   (?Goal0\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"]}, {"text": "intros l1; case l1; simpl in |- *; auto.", "goal_before": ["forall l1 : list A, list A -> length l1 <= 0 -> nil = l1 ++ nil", "forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = l1 ++ first_n l2 match length l1 with\n                       | 0 => S n0\n                       | S l => n0 - l\n                       end"], "goal_after": ["forall (a : A) (l : list A),\nlist A -> S (length l) <= 0 -> nil = a :: l ++ nil", "forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = l1 ++ first_n l2 match length l1 with\n                       | 0 => S n0\n                       | S l => n0 - l\n                       end"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   (?Goal\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   (?Goal0\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match l1 as l return (list A -> length l <= 0 -> nil = l ++ nil) with\n     | nil =>\n         (fun (_ : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         list A -> length nil <= 0 -> nil = nil ++ nil\n     | a :: l =>\n         (?Goal0\n          :\n          forall (a0 : A) (l0 : list A),\n          list A -> length (a0 :: l0) <= 0 -> nil = (a0 :: l0) ++ nil) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"]}, {"text": "intros b l l2 H; Contradict H; auto with arith.", "goal_before": ["forall (a : A) (l : list A),\nlist A -> S (length l) <= 0 -> nil = a :: l ++ nil", "forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = l1 ++ first_n l2 match length l1 with\n                       | 0 => S n0\n                       | S l => n0 - l\n                       end"], "goal_after": ["forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = l1 ++ first_n l2 match length l1 with\n                       | 0 => S n0\n                       | S l => n0 - l\n                       end"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match l1 as l return (list A -> length l <= 0 -> nil = l ++ nil) with\n     | nil =>\n         (fun (_ : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         list A -> length nil <= 0 -> nil = nil ++ nil\n     | a :: l =>\n         (?Goal0\n          :\n          forall (a0 : A) (l0 : list A),\n          list A -> length (a0 :: l0) <= 0 -> nil = (a0 :: l0) ++ nil) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match l1 as l return (list A -> length l <= 0 -> nil = l ++ nil) with\n     | nil =>\n         (fun (_ : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         list A -> length nil <= 0 -> nil = nil ++ nil\n     | a :: l =>\n         ((fun (b : A) (l0 _ : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (nil = b :: l0 ++ nil) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 : list A),\n          list A -> length (a0 :: l0) <= 0 -> nil = (a0 :: l0) ++ nil) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"]}, {"text": "intros n0 H l1; case l1; simpl in |- *; auto with arith.", "goal_before": ["forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = l1 ++ first_n l2 match length l1 with\n                       | 0 => S n0\n                       | S l => n0 - l\n                       end"], "goal_after": ["forall (a : A) (l l2 : list A),\nS (length l) <= S n0 ->\na :: first_n (l ++ l2) n0 = a :: l ++ first_n l2 (n0 - length l)"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match l1 as l return (list A -> length l <= 0 -> nil = l ++ nil) with\n     | nil =>\n         (fun (_ : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         list A -> length nil <= 0 -> nil = nil ++ nil\n     | a :: l =>\n         ((fun (b : A) (l0 _ : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (nil = b :: l0 ++ nil) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 : list A),\n          list A -> length (a0 :: l0) <= 0 -> nil = (a0 :: l0) ++ nil) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match l1 as l return (list A -> length l <= 0 -> nil = l ++ nil) with\n     | nil =>\n         (fun (_ : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         list A -> length nil <= 0 -> nil = nil ++ nil\n     | a :: l =>\n         ((fun (b : A) (l0 _ : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (nil = b :: l0 ++ nil) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 : list A),\n          list A -> length (a0 :: l0) <= 0 -> nil = (a0 :: l0) ++ nil) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            length l1 <= n0 ->\n            first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          length l <= S n0 ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end =\n          l ++\n          first_n l2 match length l with\n                     | 0 => S n0\n                     | S l0 => n0 - l0\n                     end)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= S n0) => eq_refl)\n         :\n         forall l2 : list A,\n         length nil <= S n0 ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end =\n         nil ++\n         first_n l2 match length nil with\n                    | 0 => S n0\n                    | S l => n0 - l\n                    end\n     | a :: l =>\n         (?Goal\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= S n0 ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end =\n          (a0 :: l0) ++\n          first_n l2\n            match length (a0 :: l0) with\n            | 0 => S n0\n            | S l3 => n0 - l3\n            end) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"]}, {"text": "intros b l l2 H0; rewrite H; auto with arith.", "goal_before": ["forall (a : A) (l l2 : list A),\nS (length l) <= S n0 ->\na :: first_n (l ++ l2) n0 = a :: l ++ first_n l2 (n0 - length l)"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match l1 as l return (list A -> length l <= 0 -> nil = l ++ nil) with\n     | nil =>\n         (fun (_ : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         list A -> length nil <= 0 -> nil = nil ++ nil\n     | a :: l =>\n         ((fun (b : A) (l0 _ : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (nil = b :: l0 ++ nil) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 : list A),\n          list A -> length (a0 :: l0) <= 0 -> nil = (a0 :: l0) ++ nil) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            length l1 <= n0 ->\n            first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          length l <= S n0 ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end =\n          l ++\n          first_n l2 match length l with\n                     | 0 => S n0\n                     | S l0 => n0 - l0\n                     end)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= S n0) => eq_refl)\n         :\n         forall l2 : list A,\n         length nil <= S n0 ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end =\n         nil ++\n         first_n l2 match length nil with\n                    | 0 => S n0\n                    | S l => n0 - l\n                    end\n     | a :: l =>\n         (?Goal\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= S n0 ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end =\n          (a0 :: l0) ++\n          first_n l2\n            match length (a0 :: l0) with\n            | 0 => S n0\n            | S l3 => n0 - l3\n            end) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match l1 as l return (list A -> length l <= 0 -> nil = l ++ nil) with\n     | nil =>\n         (fun (_ : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         list A -> length nil <= 0 -> nil = nil ++ nil\n     | a :: l =>\n         ((fun (b : A) (l0 _ : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (nil = b :: l0 ++ nil) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 : list A),\n          list A -> length (a0 :: l0) <= 0 -> nil = (a0 :: l0) ++ nil) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            length l1 <= n0 ->\n            first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          length l <= S n0 ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end =\n          l ++\n          first_n l2 match length l with\n                     | 0 => S n0\n                     | S l0 => n0 - l0\n                     end)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= S n0) => eq_refl)\n         :\n         forall l2 : list A,\n         length nil <= S n0 ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end =\n         nil ++\n         first_n l2 match length nil with\n                    | 0 => S n0\n                    | S l => n0 - l\n                    end\n     | a :: l =>\n         ((fun (b : A) (l0 l2 : list A) (H0 : S (length l0) <= S n0) =>\n           eq_ind_r\n             (fun l3 : list A =>\n              b :: l3 = b :: l0 ++ first_n l2 (n0 - length l0)) eq_refl\n             (H l0 l2 (gt_S_le (length l0) n0 H0)))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= S n0 ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end =\n          (a0 :: l0) ++\n          first_n l2\n            match length (a0 :: l0) with\n            | 0 => S n0\n            | S l3 => n0 - l3\n            end) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 ->\n    first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match l1 as l return (list A -> length l <= 0 -> nil = l ++ nil) with\n     | nil =>\n         (fun (_ : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         list A -> length nil <= 0 -> nil = nil ++ nil\n     | a :: l =>\n         ((fun (b : A) (l0 _ : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (nil = b :: l0 ++ nil) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 : list A),\n          list A -> length (a0 :: l0) <= 0 -> nil = (a0 :: l0) ++ nil) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> first_n (l1 ++ l2) 0 = l1 ++ first_n l2 (0 - length l1))\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            length l1 <= n0 ->\n            first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1))\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          length l <= S n0 ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end =\n          l ++\n          first_n l2 match length l with\n                     | 0 => S n0\n                     | S l0 => n0 - l0\n                     end)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= S n0) => eq_refl)\n         :\n         forall l2 : list A,\n         length nil <= S n0 ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end =\n         nil ++\n         first_n l2 match length nil with\n                    | 0 => S n0\n                    | S l => n0 - l\n                    end\n     | a :: l =>\n         ((fun (b : A) (l0 l2 : list A) (H0 : S (length l0) <= S n0) =>\n           eq_ind_r\n             (fun l3 : list A =>\n              b :: l3 = b :: l0 ++ first_n l2 (n0 - length l0)) eq_refl\n             (H l0 l2 (gt_S_le (length l0) n0 H0)))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= S n0 ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end =\n          (a0 :: l0) ++\n          first_n l2\n            match length (a0 :: l0) with\n            | 0 => S n0\n            | S l3 => n0 - l3\n            end) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 ->\n     first_n (l1 ++ l2) n0 = l1 ++ first_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    first_n (l1 ++ l2) (S n0) = l1 ++ first_n l2 (S n0 - length l1)) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "first_n_app2", "text": "Theorem first_n_app2 :\n forall (n : nat) (l1 l2 : list A),\n n <= length l1 -> first_n (l1 ++ l2) n = first_n l1 n.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros n0 H l1 l2; case l1; simpl in |- *.\nintros H1; Contradict H1; auto with arith.\nintros a l H0; (apply f_equal2 with (f := cons (A:=A)); auto).\napply H; apply le_S_n; auto.\nQed.\n", "definition": "\n forall (n : nat) (l1 l2 : list A),\n n <= length l1 -> first_n (l1 ++ l2) n = first_n l1 n.", "proof": "\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros n0 H l1 l2; case l1; simpl in |- *.\nintros H1; Contradict H1; auto with arith.\nintros a l H0; (apply f_equal2 with (f := cons (A:=A)); auto).\napply H; apply le_S_n; auto.\n", "def_ranges": [446, 0, 448, 55], "proof_ranges": [449, 0, 455, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (n : nat) (l1 l2 : list A),\nn <= length l1 -> first_n (l1 ++ l2) n = first_n l1 n"], "goal_after": ["forall (n : nat) (l1 l2 : list A),\nn <= length l1 -> first_n (l1 ++ l2) n = first_n l1 n"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros n; elim n; simpl in |- *; auto.", "goal_before": ["forall (n : nat) (l1 l2 : list A),\nn <= length l1 -> first_n (l1 ++ l2) n = first_n l1 n"], "goal_after": ["forall n0 : nat,\n(forall l1 l2 : list A,\n n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\nforall l1 l2 : list A,\nS n0 <= length l1 ->\nmatch l1 ++ l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = match l1 with\n      | nil => nil\n      | a :: l0 => a :: first_n l0 n0\n      end"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"]}, {"text": "intros n0 H l1 l2; case l1; simpl in |- *.", "goal_before": ["forall n0 : nat,\n(forall l1 l2 : list A,\n n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\nforall l1 l2 : list A,\nS n0 <= length l1 ->\nmatch l1 ++ l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = match l1 with\n      | nil => nil\n      | a :: l0 => a :: first_n l0 n0\n      end"], "goal_after": ["S n0 <= 0 ->\nmatch l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = nil", "forall (a : A) (l : list A),\nS n0 <= S (length l) -> a :: first_n (l ++ l2) n0 = a :: first_n l n0"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n       (l1 l2 : list A) =>\n     match\n       l1 as l\n       return\n         (S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end = match l with\n                | nil => nil\n                | a :: l3 => a :: first_n l3 n0\n                end)\n     with\n     | nil =>\n         ?Goal\n         :\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end = nil\n     | a :: l =>\n         (?Goal0\n          :\n          forall (a0 : A) (l0 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end = a0 :: first_n l0 n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"]}, {"text": "intros H1; Contradict H1; auto with arith.", "goal_before": ["S n0 <= 0 ->\nmatch l2 with\n| nil => nil\n| a :: l0 => a :: first_n l0 n0\nend = nil", "forall (a : A) (l : list A),\nS n0 <= S (length l) -> a :: first_n (l ++ l2) n0 = a :: first_n l n0"], "goal_after": ["forall (a : A) (l : list A),\nS n0 <= S (length l) -> a :: first_n (l ++ l2) n0 = a :: first_n l n0"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n       (l1 l2 : list A) =>\n     match\n       l1 as l\n       return\n         (S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end = match l with\n                | nil => nil\n                | a :: l3 => a :: first_n l3 n0\n                end)\n     with\n     | nil =>\n         ?Goal\n         :\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end = nil\n     | a :: l =>\n         (?Goal0\n          :\n          forall (a0 : A) (l0 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end = a0 :: first_n l0 n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n       (l1 l2 : list A) =>\n     match\n       l1 as l\n       return\n         (S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end = match l with\n                | nil => nil\n                | a :: l3 => a :: first_n l3 n0\n                end)\n     with\n     | nil =>\n         (fun H1 : S n0 <= 0 =>\n          Contradict2\n            (match l2 with\n             | nil => nil\n             | a :: l3 => a :: first_n l3 n0\n             end = nil) (S n0 <= 0) H1 (Nat.nle_succ_0 n0))\n         :\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end = nil\n     | a :: l =>\n         (?Goal\n          :\n          forall (a0 : A) (l0 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end = a0 :: first_n l0 n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"]}, {"text": "intros a l H0; (apply f_equal2 with (f := cons (A:=A)); auto).", "goal_before": ["forall (a : A) (l : list A),\nS n0 <= S (length l) -> a :: first_n (l ++ l2) n0 = a :: first_n l n0"], "goal_after": ["first_n (l ++ l2) n0 = first_n l n0"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n       (l1 l2 : list A) =>\n     match\n       l1 as l\n       return\n         (S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end = match l with\n                | nil => nil\n                | a :: l3 => a :: first_n l3 n0\n                end)\n     with\n     | nil =>\n         (fun H1 : S n0 <= 0 =>\n          Contradict2\n            (match l2 with\n             | nil => nil\n             | a :: l3 => a :: first_n l3 n0\n             end = nil) (S n0 <= 0) H1 (Nat.nle_succ_0 n0))\n         :\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end = nil\n     | a :: l =>\n         (?Goal\n          :\n          forall (a0 : A) (l0 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end = a0 :: first_n l0 n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n       (l1 l2 : list A) =>\n     match\n       l1 as l\n       return\n         (S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end = match l with\n                | nil => nil\n                | a :: l3 => a :: first_n l3 n0\n                end)\n     with\n     | nil =>\n         (fun H1 : S n0 <= 0 =>\n          Contradict2\n            (match l2 with\n             | nil => nil\n             | a :: l3 => a :: first_n l3 n0\n             end = nil) (S n0 <= 0) H1 (Nat.nle_succ_0 n0))\n         :\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end = nil\n     | a :: l =>\n         ((fun (a0 : A) (l0 : list A) (H0 : S n0 <= S (length l0)) =>\n           f_equal2 cons eq_refl ?Goal@{a:=a0; l:=l0})\n          :\n          forall (a0 : A) (l0 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end = a0 :: first_n l0 n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"]}, {"text": "apply H; apply le_S_n; auto.", "goal_before": ["first_n (l ++ l2) n0 = first_n l n0"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n       (l1 l2 : list A) =>\n     match\n       l1 as l\n       return\n         (S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end = match l with\n                | nil => nil\n                | a :: l3 => a :: first_n l3 n0\n                end)\n     with\n     | nil =>\n         (fun H1 : S n0 <= 0 =>\n          Contradict2\n            (match l2 with\n             | nil => nil\n             | a :: l3 => a :: first_n l3 n0\n             end = nil) (S n0 <= 0) H1 (Nat.nle_succ_0 n0))\n         :\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end = nil\n     | a :: l =>\n         ((fun (a0 : A) (l0 : list A) (H0 : S n0 <= S (length l0)) =>\n           f_equal2 cons eq_refl ?Goal@{a:=a0; l:=l0})\n          :\n          forall (a0 : A) (l0 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end = a0 :: first_n l0 n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n       (l1 l2 : list A) =>\n     match\n       l1 as l\n       return\n         (S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end = match l with\n                | nil => nil\n                | a :: l3 => a :: first_n l3 n0\n                end)\n     with\n     | nil =>\n         (fun H1 : S n0 <= 0 =>\n          Contradict2\n            (match l2 with\n             | nil => nil\n             | a :: l3 => a :: first_n l3 n0\n             end = nil) (S n0 <= 0) H1 (Nat.nle_succ_0 n0))\n         :\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end = nil\n     | a :: l =>\n         ((fun (a0 : A) (l0 : list A) (H0 : S n0 <= S (length l0)) =>\n           f_equal2 cons eq_refl (H l0 l2 (le_S_n n0 (length l0) H0)))\n          :\n          forall (a0 : A) (l0 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end = a0 :: first_n l0 n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n   ((fun (l1 _ : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> first_n (l1 ++ l2) 0 = first_n l1 0)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0)\n       (l1 l2 : list A) =>\n     match\n       l1 as l\n       return\n         (S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | a :: l3 => a :: first_n l3 n0\n          end = match l with\n                | nil => nil\n                | a :: l3 => a :: first_n l3 n0\n                end)\n     with\n     | nil =>\n         (fun H1 : S n0 <= 0 =>\n          Contradict2\n            (match l2 with\n             | nil => nil\n             | a :: l3 => a :: first_n l3 n0\n             end = nil) (S n0 <= 0) H1 (Nat.nle_succ_0 n0))\n         :\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | a :: l3 => a :: first_n l3 n0\n         end = nil\n     | a :: l =>\n         ((fun (a0 : A) (l0 : list A) (H0 : S n0 <= S (length l0)) =>\n           f_equal2 cons eq_refl (H l0 l2 (le_S_n n0 (length l0) H0)))\n          :\n          forall (a0 : A) (l0 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | a1 :: l3 => a1 :: first_n l3 n0\n          end = a0 :: first_n l0 n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> first_n (l1 ++ l2) n0 = first_n l1 n0) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> first_n (l1 ++ l2) (S n0) = first_n l1 (S n0)) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "first_n_length", "text": "Theorem first_n_length :\n forall (n : nat) (l1 : list A), n <= length l1 -> length (first_n l1 n) = n.\nProof using.\nintros n l1; generalize n; elim l1; clear n l1; simpl in |- *; auto.\nintros n; case n; simpl in |- *; auto.\nintros n1 H1; Contradict H1; auto with arith.\nintros a l H n; case n; simpl in |- *; auto with arith.\nQed.\n", "definition": "\n forall (n : nat) (l1 : list A), n <= length l1 -> length (first_n l1 n) = n.", "proof": "\nProof using.\nintros n l1; generalize n; elim l1; clear n l1; simpl in |- *; auto.\nintros n; case n; simpl in |- *; auto.\nintros n1 H1; Contradict H1; auto with arith.\nintros a l H n; case n; simpl in |- *; auto with arith.\n", "def_ranges": [457, 0, 458, 77], "proof_ranges": [459, 0, 464, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (n : nat) (l1 : list A), n <= length l1 -> length (first_n l1 n) = n"], "goal_after": ["forall (n : nat) (l1 : list A), n <= length l1 -> length (first_n l1 n) = n"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros n l1; generalize n; elim l1; clear n l1; simpl in |- *; auto.", "goal_before": ["forall (n : nat) (l1 : list A), n <= length l1 -> length (first_n l1 n) = n"], "goal_after": ["forall n : nat, n <= 0 -> length (first_n nil n) = n", "forall (a : A) (l : list A),\n(forall n : nat, n <= length l -> length (first_n l n) = n) ->\nforall n : nat, n <= S (length l) -> length (first_n (a :: l) n) = n"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (n : nat) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall n0 : nat, n0 <= length l2 -> length (first_n l2 n0) = n0)\n   (?Goal : forall n0 : nat, n0 <= length nil -> length (first_n nil n0) = n0)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0) ->\n    forall n0 : nat,\n    n0 <= length (a :: l) -> length (first_n (a :: l) n0) = n0) l1 n)"]}, {"text": "intros n; case n; simpl in |- *; auto.", "goal_before": ["forall n : nat, n <= 0 -> length (first_n nil n) = n", "forall (a : A) (l : list A),\n(forall n : nat, n <= length l -> length (first_n l n) = n) ->\nforall n : nat, n <= S (length l) -> length (first_n (a :: l) n) = n"], "goal_after": ["forall n0 : nat, S n0 <= 0 -> 0 = S n0", "forall (a : A) (l : list A),\n(forall n : nat, n <= length l -> length (first_n l n) = n) ->\nforall n : nat, n <= S (length l) -> length (first_n (a :: l) n) = n"], "proof_term_before": ["(fun (n : nat) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall n0 : nat, n0 <= length l2 -> length (first_n l2 n0) = n0)\n   (?Goal : forall n0 : nat, n0 <= length nil -> length (first_n nil n0) = n0)\n   (?Goal0\n    :\n    forall (a : A) (l : list A),\n    (forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0) ->\n    forall n0 : nat,\n    n0 <= length (a :: l) -> length (first_n (a :: l) n0) = n0) l1 n)"], "proof_term_after": ["(fun (n : nat) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall n0 : nat, n0 <= length l2 -> length (first_n l2 n0) = n0)\n   ((fun n0 : nat =>\n     match n0 as n1 return (n1 <= 0 -> length (first_n nil n1) = n1) with\n     | 0 =>\n         (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> length (first_n nil 0) = 0\n     | S n1 =>\n         (?Goal0@{n:=n0}\n          :\n          forall n2 : nat, S n2 <= 0 -> length (first_n nil (S n2)) = S n2)\n           n1\n     end)\n    :\n    forall n0 : nat, n0 <= length nil -> length (first_n nil n0) = n0)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0) ->\n    forall n0 : nat,\n    n0 <= length (a :: l) -> length (first_n (a :: l) n0) = n0) l1 n)"]}, {"text": "intros n1 H1; Contradict H1; auto with arith.", "goal_before": ["forall n0 : nat, S n0 <= 0 -> 0 = S n0", "forall (a : A) (l : list A),\n(forall n : nat, n <= length l -> length (first_n l n) = n) ->\nforall n : nat, n <= S (length l) -> length (first_n (a :: l) n) = n"], "goal_after": ["forall (a : A) (l : list A),\n(forall n : nat, n <= length l -> length (first_n l n) = n) ->\nforall n : nat, n <= S (length l) -> length (first_n (a :: l) n) = n"], "proof_term_before": ["(fun (n : nat) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall n0 : nat, n0 <= length l2 -> length (first_n l2 n0) = n0)\n   ((fun n0 : nat =>\n     match n0 as n1 return (n1 <= 0 -> length (first_n nil n1) = n1) with\n     | 0 =>\n         (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> length (first_n nil 0) = 0\n     | S n1 =>\n         (?Goal0@{n:=n0}\n          :\n          forall n2 : nat, S n2 <= 0 -> length (first_n nil (S n2)) = S n2)\n           n1\n     end)\n    :\n    forall n0 : nat, n0 <= length nil -> length (first_n nil n0) = n0)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0) ->\n    forall n0 : nat,\n    n0 <= length (a :: l) -> length (first_n (a :: l) n0) = n0) l1 n)"], "proof_term_after": ["(fun (n : nat) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall n0 : nat, n0 <= length l2 -> length (first_n l2 n0) = n0)\n   ((fun n0 : nat =>\n     match n0 as n1 return (n1 <= 0 -> length (first_n nil n1) = n1) with\n     | 0 =>\n         (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> length (first_n nil 0) = 0\n     | S n1 =>\n         ((fun (n2 : nat) (H1 : S n2 <= 0) =>\n           Contradict2 (0 = S n2) (S n2 <= 0) H1 (Nat.nle_succ_0 n2))\n          :\n          forall n2 : nat, S n2 <= 0 -> length (first_n nil (S n2)) = S n2)\n           n1\n     end)\n    :\n    forall n0 : nat, n0 <= length nil -> length (first_n nil n0) = n0)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0) ->\n    forall n0 : nat,\n    n0 <= length (a :: l) -> length (first_n (a :: l) n0) = n0) l1 n)"]}, {"text": "intros a l H n; case n; simpl in |- *; auto with arith.", "goal_before": ["forall (a : A) (l : list A),\n(forall n : nat, n <= length l -> length (first_n l n) = n) ->\nforall n : nat, n <= S (length l) -> length (first_n (a :: l) n) = n"], "goal_after": [], "proof_term_before": ["(fun (n : nat) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall n0 : nat, n0 <= length l2 -> length (first_n l2 n0) = n0)\n   ((fun n0 : nat =>\n     match n0 as n1 return (n1 <= 0 -> length (first_n nil n1) = n1) with\n     | 0 =>\n         (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> length (first_n nil 0) = 0\n     | S n1 =>\n         ((fun (n2 : nat) (H1 : S n2 <= 0) =>\n           Contradict2 (0 = S n2) (S n2 <= 0) H1 (Nat.nle_succ_0 n2))\n          :\n          forall n2 : nat, S n2 <= 0 -> length (first_n nil (S n2)) = S n2)\n           n1\n     end)\n    :\n    forall n0 : nat, n0 <= length nil -> length (first_n nil n0) = n0)\n   (?Goal\n    :\n    forall (a : A) (l : list A),\n    (forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0) ->\n    forall n0 : nat,\n    n0 <= length (a :: l) -> length (first_n (a :: l) n0) = n0) l1 n)"], "proof_term_after": ["(fun (n : nat) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall n0 : nat, n0 <= length l2 -> length (first_n l2 n0) = n0)\n   ((fun n0 : nat =>\n     match n0 as n1 return (n1 <= 0 -> length (first_n nil n1) = n1) with\n     | 0 =>\n         (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> length (first_n nil 0) = 0\n     | S n1 =>\n         ((fun (n2 : nat) (H1 : S n2 <= 0) =>\n           Contradict2 (0 = S n2) (S n2 <= 0) H1 (Nat.nle_succ_0 n2))\n          :\n          forall n2 : nat, S n2 <= 0 -> length (first_n nil (S n2)) = S n2)\n           n1\n     end)\n    :\n    forall n0 : nat, n0 <= length nil -> length (first_n nil n0) = n0)\n   ((fun (a : A) (l : list A)\n       (H : forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0)\n       (n0 : nat) =>\n     match\n       n0 as n1\n       return (n1 <= S (length l) -> length (first_n (a :: l) n1) = n1)\n     with\n     | 0 =>\n         (fun _ : 0 <= S (length l) => eq_refl)\n         :\n         0 <= S (length l) -> length (first_n (a :: l) 0) = 0\n     | S n1 =>\n         ((fun (n2 : nat) (H0 : S n2 <= S (length l)) =>\n           f_equal_nat nat S (length (first_n l n2)) n2\n             (H n2 (gt_S_le n2 (length l) H0)))\n          :\n          forall n2 : nat,\n          S n2 <= S (length l) -> length (first_n (a :: l) (S n2)) = S n2) n1\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0) ->\n    forall n0 : nat,\n    n0 <= length (a :: l) -> length (first_n (a :: l) n0) = n0) l1 n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n : nat) (l1 : list A) =>\n list_ind\n   (fun l2 : list A =>\n    forall n0 : nat, n0 <= length l2 -> length (first_n l2 n0) = n0)\n   ((fun n0 : nat =>\n     match n0 as n1 return (n1 <= 0 -> length (first_n nil n1) = n1) with\n     | 0 =>\n         (fun _ : 0 <= 0 => eq_refl) : 0 <= 0 -> length (first_n nil 0) = 0\n     | S n1 =>\n         ((fun (n2 : nat) (H1 : S n2 <= 0) =>\n           Contradict2 (0 = S n2) (S n2 <= 0) H1 (Nat.nle_succ_0 n2))\n          :\n          forall n2 : nat, S n2 <= 0 -> length (first_n nil (S n2)) = S n2)\n           n1\n     end)\n    :\n    forall n0 : nat, n0 <= length nil -> length (first_n nil n0) = n0)\n   ((fun (a : A) (l : list A)\n       (H : forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0)\n       (n0 : nat) =>\n     match\n       n0 as n1\n       return (n1 <= S (length l) -> length (first_n (a :: l) n1) = n1)\n     with\n     | 0 =>\n         (fun _ : 0 <= S (length l) => eq_refl)\n         :\n         0 <= S (length l) -> length (first_n (a :: l) 0) = 0\n     | S n1 =>\n         ((fun (n2 : nat) (H0 : S n2 <= S (length l)) =>\n           f_equal_nat nat S (length (first_n l n2)) n2\n             (H n2 (gt_S_le n2 (length l) H0)))\n          :\n          forall n2 : nat,\n          S n2 <= S (length l) -> length (first_n (a :: l) (S n2)) = S n2) n1\n     end)\n    :\n    forall (a : A) (l : list A),\n    (forall n0 : nat, n0 <= length l -> length (first_n l n0) = n0) ->\n    forall n0 : nat,\n    n0 <= length (a :: l) -> length (first_n (a :: l) n0) = n0) l1 n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "first_n_id", "text": "Theorem first_n_id : forall l : list A, first_n l (length l) = l.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H; apply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n", "definition": " forall l : list A, first_n l (length l) = l.", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0 H; apply f_equal2 with (f := cons (A:=A)); auto.\n", "def_ranges": [466, 0, 466, 65], "proof_ranges": [467, 0, 470, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l : list A, first_n l (length l) = l"], "goal_after": ["forall l : list A, first_n l (length l) = l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall l : list A, first_n l (length l) = l"], "goal_after": ["forall (a : A) (l0 : list A),\nfirst_n l0 (length l0) = l0 -> a :: first_n l0 (length l0) = a :: l0"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list A =>\n list_ind (fun l0 : list A => first_n l0 (length l0) = l0)\n   (eq_refl : first_n nil (length nil) = nil)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    first_n l0 (length l0) = l0 ->\n    first_n (a :: l0) (length (a :: l0)) = a :: l0) l)"]}, {"text": "intros a l0 H; apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": ["forall (a : A) (l0 : list A),\nfirst_n l0 (length l0) = l0 -> a :: first_n l0 (length l0) = a :: l0"], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind (fun l0 : list A => first_n l0 (length l0) = l0)\n   (eq_refl : first_n nil (length nil) = nil)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    first_n l0 (length l0) = l0 ->\n    first_n (a :: l0) (length (a :: l0)) = a :: l0) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind (fun l0 : list A => first_n l0 (length l0) = l0)\n   (eq_refl : first_n nil (length nil) = nil)\n   ((fun (a : A) (l0 : list A) (H : first_n l0 (length l0) = l0) =>\n     f_equal2 cons eq_refl H)\n    :\n    forall (a : A) (l0 : list A),\n    first_n l0 (length l0) = l0 ->\n    first_n (a :: l0) (length (a :: l0)) = a :: l0) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind (fun l0 : list A => first_n l0 (length l0) = l0)\n   (eq_refl : first_n nil (length nil) = nil)\n   ((fun (a : A) (l0 : list A) (H : first_n l0 (length l0) = l0) =>\n     f_equal2 cons eq_refl H)\n    :\n    forall (a : A) (l0 : list A),\n    first_n l0 (length l0) = l0 ->\n    first_n (a :: l0) (length (a :: l0)) = a :: l0) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "skip_n_app1", "text": "Theorem skip_n_app1 :\n forall (n : nat) (l1 l2 : list A),\n length l1 <= n -> skip_n (l1 ++ l2) n = skip_n l2 (n - length l1).\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros l1; case l1; simpl in |- *; auto.\nintros b l l2 H; Contradict H; auto with arith.\nintros n0 H l1; case l1; simpl in |- *; auto with arith.\nQed.\n", "definition": "\n forall (n : nat) (l1 l2 : list A),\n length l1 <= n -> skip_n (l1 ++ l2) n = skip_n l2 (n - length l1).", "proof": "\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros l1; case l1; simpl in |- *; auto.\nintros b l l2 H; Contradict H; auto with arith.\nintros n0 H l1; case l1; simpl in |- *; auto with arith.\n", "def_ranges": [483, 0, 485, 67], "proof_ranges": [486, 0, 491, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (n : nat) (l1 l2 : list A),\nlength l1 <= n -> skip_n (l1 ++ l2) n = skip_n l2 (n - length l1)"], "goal_after": ["forall (n : nat) (l1 l2 : list A),\nlength l1 <= n -> skip_n (l1 ++ l2) n = skip_n l2 (n - length l1)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros n; elim n; simpl in |- *; auto.", "goal_before": ["forall (n : nat) (l1 l2 : list A),\nlength l1 <= n -> skip_n (l1 ++ l2) n = skip_n l2 (n - length l1)"], "goal_after": ["forall l1 l2 : list A, length l1 <= 0 -> l1 ++ l2 = l2", "forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| _ :: l0 => skip_n l0 n0\nend = skip_n l2 match length l1 with\n                | 0 => S n0\n                | S l => n0 - l\n                end"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1))\n   (?Goal\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> skip_n (l1 ++ l2) 0 = skip_n l2 (0 - length l1))\n   (?Goal0\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    skip_n (l1 ++ l2) (S n0) = skip_n l2 (S n0 - length l1)) n)"]}, {"text": "intros l1; case l1; simpl in |- *; auto.", "goal_before": ["forall l1 l2 : list A, length l1 <= 0 -> l1 ++ l2 = l2", "forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| _ :: l0 => skip_n l0 n0\nend = skip_n l2 match length l1 with\n                | 0 => S n0\n                | S l => n0 - l\n                end"], "goal_after": ["forall (a : A) (l l2 : list A), S (length l) <= 0 -> a :: l ++ l2 = l2", "forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| _ :: l0 => skip_n l0 n0\nend = skip_n l2 match length l1 with\n                | 0 => S n0\n                | S l => n0 - l\n                end"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1))\n   (?Goal\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> skip_n (l1 ++ l2) 0 = skip_n l2 (0 - length l1))\n   (?Goal0\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    skip_n (l1 ++ l2) (S n0) = skip_n l2 (S n0 - length l1)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match\n       l1 as l return (forall l2 : list A, length l <= 0 -> l ++ l2 = l2)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         forall l2 : list A, length nil <= 0 -> nil ++ l2 = l2\n     | a :: l =>\n         (?Goal0\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= 0 -> (a0 :: l0) ++ l2 = l2) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> skip_n (l1 ++ l2) 0 = skip_n l2 (0 - length l1))\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    skip_n (l1 ++ l2) (S n0) = skip_n l2 (S n0 - length l1)) n)"]}, {"text": "intros b l l2 H; Contradict H; auto with arith.", "goal_before": ["forall (a : A) (l l2 : list A), S (length l) <= 0 -> a :: l ++ l2 = l2", "forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| _ :: l0 => skip_n l0 n0\nend = skip_n l2 match length l1 with\n                | 0 => S n0\n                | S l => n0 - l\n                end"], "goal_after": ["forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| _ :: l0 => skip_n l0 n0\nend = skip_n l2 match length l1 with\n                | 0 => S n0\n                | S l => n0 - l\n                end"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match\n       l1 as l return (forall l2 : list A, length l <= 0 -> l ++ l2 = l2)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         forall l2 : list A, length nil <= 0 -> nil ++ l2 = l2\n     | a :: l =>\n         (?Goal0\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= 0 -> (a0 :: l0) ++ l2 = l2) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> skip_n (l1 ++ l2) 0 = skip_n l2 (0 - length l1))\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    skip_n (l1 ++ l2) (S n0) = skip_n l2 (S n0 - length l1)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match\n       l1 as l return (forall l2 : list A, length l <= 0 -> l ++ l2 = l2)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         forall l2 : list A, length nil <= 0 -> nil ++ l2 = l2\n     | a :: l =>\n         ((fun (b : A) (l0 l2 : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (b :: l0 ++ l2 = l2) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= 0 -> (a0 :: l0) ++ l2 = l2) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> skip_n (l1 ++ l2) 0 = skip_n l2 (0 - length l1))\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    skip_n (l1 ++ l2) (S n0) = skip_n l2 (S n0 - length l1)) n)"]}, {"text": "intros n0 H l1; case l1; simpl in |- *; auto with arith.", "goal_before": ["forall n0 : nat,\n(forall l1 l2 : list A,\n length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\nforall l1 l2 : list A,\nlength l1 <= S n0 ->\nmatch l1 ++ l2 with\n| nil => nil\n| _ :: l0 => skip_n l0 n0\nend = skip_n l2 match length l1 with\n                | 0 => S n0\n                | S l => n0 - l\n                end"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match\n       l1 as l return (forall l2 : list A, length l <= 0 -> l ++ l2 = l2)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         forall l2 : list A, length nil <= 0 -> nil ++ l2 = l2\n     | a :: l =>\n         ((fun (b : A) (l0 l2 : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (b :: l0 ++ l2 = l2) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= 0 -> (a0 :: l0) ++ l2 = l2) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> skip_n (l1 ++ l2) 0 = skip_n l2 (0 - length l1))\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    skip_n (l1 ++ l2) (S n0) = skip_n l2 (S n0 - length l1)) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match\n       l1 as l return (forall l2 : list A, length l <= 0 -> l ++ l2 = l2)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         forall l2 : list A, length nil <= 0 -> nil ++ l2 = l2\n     | a :: l =>\n         ((fun (b : A) (l0 l2 : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (b :: l0 ++ l2 = l2) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= 0 -> (a0 :: l0) ++ l2 = l2) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> skip_n (l1 ++ l2) 0 = skip_n l2 (0 - length l1))\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            length l1 <= n0 ->\n            skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) \n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          length l <= S n0 ->\n          match l ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end =\n          skip_n l2 match length l with\n                    | 0 => S n0\n                    | S l0 => n0 - l0\n                    end)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= S n0) => eq_refl)\n         :\n         forall l2 : list A,\n         length nil <= S n0 ->\n         match nil ++ l2 with\n         | nil => nil\n         | _ :: l3 => skip_n l3 n0\n         end =\n         skip_n l2 match length nil with\n                   | 0 => S n0\n                   | S l => n0 - l\n                   end\n     | a :: l =>\n         ((fun (_ : A) (l0 l2 : list A) (H0 : S (length l0) <= S n0) =>\n           H l0 l2 (gt_S_le (length l0) n0 H0))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= S n0 ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end =\n          skip_n l2\n            match length (a0 :: l0) with\n            | 0 => S n0\n            | S l3 => n0 - l3\n            end) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    skip_n (l1 ++ l2) (S n0) = skip_n l2 (S n0 - length l1)) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1))\n   ((fun l1 : list A =>\n     match\n       l1 as l return (forall l2 : list A, length l <= 0 -> l ++ l2 = l2)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= 0) => eq_refl)\n         :\n         forall l2 : list A, length nil <= 0 -> nil ++ l2 = l2\n     | a :: l =>\n         ((fun (b : A) (l0 l2 : list A) (H : S (length l0) <= 0) =>\n           Contradict2 (b :: l0 ++ l2 = l2) (S (length l0) <= 0) H\n             (Nat.nle_succ_0 (length l0)))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= 0 -> (a0 :: l0) ++ l2 = l2) a l\n     end)\n    :\n    forall l1 l2 : list A,\n    length l1 <= 0 -> skip_n (l1 ++ l2) 0 = skip_n l2 (0 - length l1))\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            length l1 <= n0 ->\n            skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) \n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          length l <= S n0 ->\n          match l ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end =\n          skip_n l2 match length l with\n                    | 0 => S n0\n                    | S l0 => n0 - l0\n                    end)\n     with\n     | nil =>\n         (fun (l2 : list A) (_ : 0 <= S n0) => eq_refl)\n         :\n         forall l2 : list A,\n         length nil <= S n0 ->\n         match nil ++ l2 with\n         | nil => nil\n         | _ :: l3 => skip_n l3 n0\n         end =\n         skip_n l2 match length nil with\n                   | 0 => S n0\n                   | S l => n0 - l\n                   end\n     | a :: l =>\n         ((fun (_ : A) (l0 l2 : list A) (H0 : S (length l0) <= S n0) =>\n           H l0 l2 (gt_S_le (length l0) n0 H0))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          length (a0 :: l0) <= S n0 ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end =\n          skip_n l2\n            match length (a0 :: l0) with\n            | 0 => S n0\n            | S l3 => n0 - l3\n            end) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     length l1 <= n0 -> skip_n (l1 ++ l2) n0 = skip_n l2 (n0 - length l1)) ->\n    forall l1 l2 : list A,\n    length l1 <= S n0 ->\n    skip_n (l1 ++ l2) (S n0) = skip_n l2 (S n0 - length l1)) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "skip_n_app2", "text": "Theorem skip_n_app2 :\n forall (n : nat) (l1 l2 : list A),\n n <= length l1 -> skip_n (l1 ++ l2) n = skip_n l1 n ++ l2.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros n0 H l1; case l1; simpl in |- *; auto with arith.\nintros l2 H1; Contradict H1; auto with arith.\nQed.\n", "definition": "\n forall (n : nat) (l1 l2 : list A),\n n <= length l1 -> skip_n (l1 ++ l2) n = skip_n l1 n ++ l2.", "proof": "\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros n0 H l1; case l1; simpl in |- *; auto with arith.\nintros l2 H1; Contradict H1; auto with arith.\n", "def_ranges": [493, 0, 495, 59], "proof_ranges": [496, 0, 500, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (n : nat) (l1 l2 : list A),\nn <= length l1 -> skip_n (l1 ++ l2) n = skip_n l1 n ++ l2"], "goal_after": ["forall (n : nat) (l1 l2 : list A),\nn <= length l1 -> skip_n (l1 ++ l2) n = skip_n l1 n ++ l2"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros n; elim n; simpl in |- *; auto.", "goal_before": ["forall (n : nat) (l1 l2 : list A),\nn <= length l1 -> skip_n (l1 ++ l2) n = skip_n l1 n ++ l2"], "goal_after": ["forall n0 : nat,\n(forall l1 l2 : list A,\n n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2) ->\nforall l1 l2 : list A,\nS n0 <= length l1 ->\nmatch l1 ++ l2 with\n| nil => nil\n| _ :: l0 => skip_n l0 n0\nend = match l1 with\n      | nil => nil\n      | _ :: l0 => skip_n l0 n0\n      end ++ l2"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n   ((fun (l1 l2 : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> skip_n (l1 ++ l2) 0 = skip_n l1 0 ++ l2)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> skip_n (l1 ++ l2) (S n0) = skip_n l1 (S n0) ++ l2) n)"]}, {"text": "intros n0 H l1; case l1; simpl in |- *; auto with arith.", "goal_before": ["forall n0 : nat,\n(forall l1 l2 : list A,\n n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2) ->\nforall l1 l2 : list A,\nS n0 <= length l1 ->\nmatch l1 ++ l2 with\n| nil => nil\n| _ :: l0 => skip_n l0 n0\nend = match l1 with\n      | nil => nil\n      | _ :: l0 => skip_n l0 n0\n      end ++ l2"], "goal_after": ["forall l2 : list A,\nS n0 <= 0 -> match l2 with\n             | nil => nil\n             | _ :: l0 => skip_n l0 n0\n             end = l2"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n   ((fun (l1 l2 : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> skip_n (l1 ++ l2) 0 = skip_n l1 0 ++ l2)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> skip_n (l1 ++ l2) (S n0) = skip_n l1 (S n0) ++ l2) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n   ((fun (l1 l2 : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> skip_n (l1 ++ l2) 0 = skip_n l1 0 ++ l2)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end = match l with\n                | nil => nil\n                | _ :: l3 => skip_n l3 n0\n                end ++ l2)\n     with\n     | nil =>\n         ?Goal\n         :\n         forall l2 : list A,\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | _ :: l3 => skip_n l3 n0\n         end = nil ++ l2\n     | a :: l =>\n         ((fun (_ : A) (l0 l2 : list A) (H0 : S n0 <= S (length l0)) =>\n           H l0 l2 (gt_S_le n0 (length l0) H0))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end = skip_n l0 n0 ++ l2) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> skip_n (l1 ++ l2) (S n0) = skip_n l1 (S n0) ++ l2) n)"]}, {"text": "intros l2 H1; Contradict H1; auto with arith.", "goal_before": ["forall l2 : list A,\nS n0 <= 0 -> match l2 with\n             | nil => nil\n             | _ :: l0 => skip_n l0 n0\n             end = l2"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n   ((fun (l1 l2 : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> skip_n (l1 ++ l2) 0 = skip_n l1 0 ++ l2)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end = match l with\n                | nil => nil\n                | _ :: l3 => skip_n l3 n0\n                end ++ l2)\n     with\n     | nil =>\n         ?Goal\n         :\n         forall l2 : list A,\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | _ :: l3 => skip_n l3 n0\n         end = nil ++ l2\n     | a :: l =>\n         ((fun (_ : A) (l0 l2 : list A) (H0 : S n0 <= S (length l0)) =>\n           H l0 l2 (gt_S_le n0 (length l0) H0))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end = skip_n l0 n0 ++ l2) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> skip_n (l1 ++ l2) (S n0) = skip_n l1 (S n0) ++ l2) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n   ((fun (l1 l2 : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> skip_n (l1 ++ l2) 0 = skip_n l1 0 ++ l2)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end = match l with\n                | nil => nil\n                | _ :: l3 => skip_n l3 n0\n                end ++ l2)\n     with\n     | nil =>\n         (fun (l2 : list A) (H1 : S n0 <= 0) =>\n          Contradict2\n            (match l2 with\n             | nil => nil\n             | _ :: l3 => skip_n l3 n0\n             end = l2) (S n0 <= 0) H1 (Nat.nle_succ_0 n0))\n         :\n         forall l2 : list A,\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | _ :: l3 => skip_n l3 n0\n         end = nil ++ l2\n     | a :: l =>\n         ((fun (_ : A) (l0 l2 : list A) (H0 : S n0 <= S (length l0)) =>\n           H l0 l2 (gt_S_le n0 (length l0) H0))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end = skip_n l0 n0 ++ l2) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> skip_n (l1 ++ l2) (S n0) = skip_n l1 (S n0) ++ l2) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 l2 : list A,\n    n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n   ((fun (l1 l2 : list A) (_ : 0 <= length l1) => eq_refl)\n    :\n    forall l1 l2 : list A,\n    0 <= length l1 -> skip_n (l1 ++ l2) 0 = skip_n l1 0 ++ l2)\n   ((fun (n0 : nat)\n       (H : forall l1 l2 : list A,\n            n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2)\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (forall l2 : list A,\n          S n0 <= length l ->\n          match l ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end = match l with\n                | nil => nil\n                | _ :: l3 => skip_n l3 n0\n                end ++ l2)\n     with\n     | nil =>\n         (fun (l2 : list A) (H1 : S n0 <= 0) =>\n          Contradict2\n            (match l2 with\n             | nil => nil\n             | _ :: l3 => skip_n l3 n0\n             end = l2) (S n0 <= 0) H1 (Nat.nle_succ_0 n0))\n         :\n         forall l2 : list A,\n         S n0 <= length nil ->\n         match nil ++ l2 with\n         | nil => nil\n         | _ :: l3 => skip_n l3 n0\n         end = nil ++ l2\n     | a :: l =>\n         ((fun (_ : A) (l0 l2 : list A) (H0 : S n0 <= S (length l0)) =>\n           H l0 l2 (gt_S_le n0 (length l0) H0))\n          :\n          forall (a0 : A) (l0 l2 : list A),\n          S n0 <= length (a0 :: l0) ->\n          match (a0 :: l0) ++ l2 with\n          | nil => nil\n          | _ :: l3 => skip_n l3 n0\n          end = skip_n l0 n0 ++ l2) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 l2 : list A,\n     n0 <= length l1 -> skip_n (l1 ++ l2) n0 = skip_n l1 n0 ++ l2) ->\n    forall l1 l2 : list A,\n    S n0 <= length l1 -> skip_n (l1 ++ l2) (S n0) = skip_n l1 (S n0) ++ l2) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "skip_n_length", "text": "Theorem skip_n_length :\n forall (n : nat) (l1 : list A), length (skip_n l1 n) = length l1 - n.\nProof using.\nintros n; elim n; simpl in |- *; auto with arith.\nintros n0 H l1; case l1; simpl in |- *; auto.\nQed.\n", "definition": "\n forall (n : nat) (l1 : list A), length (skip_n l1 n) = length l1 - n.", "proof": "\nProof using.\nintros n; elim n; simpl in |- *; auto with arith.\nintros n0 H l1; case l1; simpl in |- *; auto.\n", "def_ranges": [502, 0, 503, 70], "proof_ranges": [504, 0, 507, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (n : nat) (l1 : list A), length (skip_n l1 n) = length l1 - n"], "goal_after": ["forall (n : nat) (l1 : list A), length (skip_n l1 n) = length l1 - n"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros n; elim n; simpl in |- *; auto with arith.", "goal_before": ["forall (n : nat) (l1 : list A), length (skip_n l1 n) = length l1 - n"], "goal_after": ["forall n0 : nat,\n(forall l1 : list A, length (skip_n l1 n0) = length l1 - n0) ->\nforall l1 : list A,\nlength match l1 with\n       | nil => nil\n       | _ :: l0 => skip_n l0 n0\n       end = length l1 - S n0"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 : list A, length (skip_n l1 n0) = length l1 - n0)\n   ((fun l1 : list A => minus_n_O (length l1))\n    :\n    forall l1 : list A, length (skip_n l1 0) = length l1 - 0)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 : list A, length (skip_n l1 n0) = length l1 - n0) ->\n    forall l1 : list A, length (skip_n l1 (S n0)) = length l1 - S n0) n)"]}, {"text": "intros n0 H l1; case l1; simpl in |- *; auto.", "goal_before": ["forall n0 : nat,\n(forall l1 : list A, length (skip_n l1 n0) = length l1 - n0) ->\nforall l1 : list A,\nlength match l1 with\n       | nil => nil\n       | _ :: l0 => skip_n l0 n0\n       end = length l1 - S n0"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 : list A, length (skip_n l1 n0) = length l1 - n0)\n   ((fun l1 : list A => minus_n_O (length l1))\n    :\n    forall l1 : list A, length (skip_n l1 0) = length l1 - 0)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l1 : list A, length (skip_n l1 n0) = length l1 - n0) ->\n    forall l1 : list A, length (skip_n l1 (S n0)) = length l1 - S n0) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 : list A, length (skip_n l1 n0) = length l1 - n0)\n   ((fun l1 : list A => minus_n_O (length l1))\n    :\n    forall l1 : list A, length (skip_n l1 0) = length l1 - 0)\n   ((fun (n0 : nat)\n       (H : forall l1 : list A, length (skip_n l1 n0) = length l1 - n0)\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (length match l with\n                 | nil => nil\n                 | _ :: l2 => skip_n l2 n0\n                 end = length l - S n0)\n     with\n     | nil => eq_refl : length nil = length nil - S n0\n     | a :: l =>\n         ((fun _ : A => H)\n          :\n          forall (a0 : A) (l0 : list A),\n          length (skip_n l0 n0) = length (a0 :: l0) - S n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 : list A, length (skip_n l1 n0) = length l1 - n0) ->\n    forall l1 : list A, length (skip_n l1 (S n0)) = length l1 - S n0) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall l1 : list A, length (skip_n l1 n0) = length l1 - n0)\n   ((fun l1 : list A => minus_n_O (length l1))\n    :\n    forall l1 : list A, length (skip_n l1 0) = length l1 - 0)\n   ((fun (n0 : nat)\n       (H : forall l1 : list A, length (skip_n l1 n0) = length l1 - n0)\n       (l1 : list A) =>\n     match\n       l1 as l\n       return\n         (length match l with\n                 | nil => nil\n                 | _ :: l2 => skip_n l2 n0\n                 end = length l - S n0)\n     with\n     | nil => eq_refl : length nil = length nil - S n0\n     | a :: l =>\n         ((fun _ : A => H)\n          :\n          forall (a0 : A) (l0 : list A),\n          length (skip_n l0 n0) = length (a0 :: l0) - S n0) a l\n     end)\n    :\n    forall n0 : nat,\n    (forall l1 : list A, length (skip_n l1 n0) = length l1 - n0) ->\n    forall l1 : list A, length (skip_n l1 (S n0)) = length l1 - S n0) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "skip_n_id", "text": "Theorem skip_n_id : forall l : list A, skip_n l (length l) = nil.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nQed.\n", "definition": " forall l : list A, skip_n l (length l) = nil.", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\n", "def_ranges": [509, 0, 509, 65], "proof_ranges": [510, 0, 512, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l : list A, skip_n l (length l) = nil"], "goal_after": ["forall l : list A, skip_n l (length l) = nil"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall l : list A, skip_n l (length l) = nil"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list A =>\n list_ind (fun l0 : list A => skip_n l0 (length l0) = nil)\n   (eq_refl : skip_n nil (length nil) = nil)\n   ((fun (_ : A) (l0 : list A) (H : skip_n l0 (length l0) = nil) => H)\n    :\n    forall (a : A) (l0 : list A),\n    skip_n l0 (length l0) = nil -> skip_n (a :: l0) (length (a :: l0)) = nil)\n   l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind (fun l0 : list A => skip_n l0 (length l0) = nil)\n   (eq_refl : skip_n nil (length nil) = nil)\n   ((fun (_ : A) (l0 : list A) (H : skip_n l0 (length l0) = nil) => H)\n    :\n    forall (a : A) (l0 : list A),\n    skip_n l0 (length l0) = nil -> skip_n (a :: l0) (length (a :: l0)) = nil)\n   l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "first_n_skip_n_app", "text": "Theorem first_n_skip_n_app :\n forall (n : nat) (l : list A), first_n l n ++ skip_n l n = l.\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros n0 H l; case l; simpl in |- *; auto.\nintros a l0; apply f_equal2 with (f := cons (A:=A)); auto.\nQed.\n", "definition": "\n forall (n : nat) (l : list A), first_n l n ++ skip_n l n = l.", "proof": "\nProof using.\nintros n; elim n; simpl in |- *; auto.\nintros n0 H l; case l; simpl in |- *; auto.\nintros a l0; apply f_equal2 with (f := cons (A:=A)); auto.\n", "def_ranges": [514, 0, 515, 62], "proof_ranges": [516, 0, 520, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall (n : nat) (l : list A), first_n l n ++ skip_n l n = l"], "goal_after": ["forall (n : nat) (l : list A), first_n l n ++ skip_n l n = l"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros n; elim n; simpl in |- *; auto.", "goal_before": ["forall (n : nat) (l : list A), first_n l n ++ skip_n l n = l"], "goal_after": ["forall n0 : nat,\n(forall l : list A, first_n l n0 ++ skip_n l n0 = l) ->\nforall l : list A,\nmatch l with\n| nil => nil\n| a :: l1 => a :: first_n l1 n0\nend ++ match l with\n       | nil => nil\n       | _ :: l1 => skip_n l1 n0\n       end = l"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n   ((fun l : list A => eq_refl)\n    :\n    forall l : list A, first_n l 0 ++ skip_n l 0 = l)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l : list A, first_n l n0 ++ skip_n l n0 = l) ->\n    forall l : list A, first_n l (S n0) ++ skip_n l (S n0) = l) n)"]}, {"text": "intros n0 H l; case l; simpl in |- *; auto.", "goal_before": ["forall n0 : nat,\n(forall l : list A, first_n l n0 ++ skip_n l n0 = l) ->\nforall l : list A,\nmatch l with\n| nil => nil\n| a :: l1 => a :: first_n l1 n0\nend ++ match l with\n       | nil => nil\n       | _ :: l1 => skip_n l1 n0\n       end = l"], "goal_after": ["forall (a : A) (l0 : list A), a :: first_n l0 n0 ++ skip_n l0 n0 = a :: l0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n   ((fun l : list A => eq_refl)\n    :\n    forall l : list A, first_n l 0 ++ skip_n l 0 = l)\n   (?Goal\n    :\n    forall n0 : nat,\n    (forall l : list A, first_n l n0 ++ skip_n l n0 = l) ->\n    forall l : list A, first_n l (S n0) ++ skip_n l (S n0) = l) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n   ((fun l : list A => eq_refl)\n    :\n    forall l : list A, first_n l 0 ++ skip_n l 0 = l)\n   ((fun (n0 : nat) (H : forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n       (l : list A) =>\n     match\n       l as l0\n       return\n         (match l0 with\n          | nil => nil\n          | a :: l1 => a :: first_n l1 n0\n          end ++ match l0 with\n                 | nil => nil\n                 | _ :: l1 => skip_n l1 n0\n                 end = l0)\n     with\n     | nil => eq_refl : nil ++ nil = nil\n     | a :: l0 =>\n         (?Goal\n          :\n          forall (a0 : A) (l1 : list A),\n          (a0 :: first_n l1 n0) ++ skip_n l1 n0 = a0 :: l1) a l0\n     end)\n    :\n    forall n0 : nat,\n    (forall l : list A, first_n l n0 ++ skip_n l n0 = l) ->\n    forall l : list A, first_n l (S n0) ++ skip_n l (S n0) = l) n)"]}, {"text": "intros a l0; apply f_equal2 with (f := cons (A:=A)); auto.", "goal_before": ["forall (a : A) (l0 : list A), a :: first_n l0 n0 ++ skip_n l0 n0 = a :: l0"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n   ((fun l : list A => eq_refl)\n    :\n    forall l : list A, first_n l 0 ++ skip_n l 0 = l)\n   ((fun (n0 : nat) (H : forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n       (l : list A) =>\n     match\n       l as l0\n       return\n         (match l0 with\n          | nil => nil\n          | a :: l1 => a :: first_n l1 n0\n          end ++ match l0 with\n                 | nil => nil\n                 | _ :: l1 => skip_n l1 n0\n                 end = l0)\n     with\n     | nil => eq_refl : nil ++ nil = nil\n     | a :: l0 =>\n         (?Goal\n          :\n          forall (a0 : A) (l1 : list A),\n          (a0 :: first_n l1 n0) ++ skip_n l1 n0 = a0 :: l1) a l0\n     end)\n    :\n    forall n0 : nat,\n    (forall l : list A, first_n l n0 ++ skip_n l n0 = l) ->\n    forall l : list A, first_n l (S n0) ++ skip_n l (S n0) = l) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n   ((fun l : list A => eq_refl)\n    :\n    forall l : list A, first_n l 0 ++ skip_n l 0 = l)\n   ((fun (n0 : nat) (H : forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n       (l : list A) =>\n     match\n       l as l0\n       return\n         (match l0 with\n          | nil => nil\n          | a :: l1 => a :: first_n l1 n0\n          end ++ match l0 with\n                 | nil => nil\n                 | _ :: l1 => skip_n l1 n0\n                 end = l0)\n     with\n     | nil => eq_refl : nil ++ nil = nil\n     | a :: l0 =>\n         ((fun (a0 : A) (l1 : list A) => f_equal2 cons eq_refl (H l1))\n          :\n          forall (a0 : A) (l1 : list A),\n          (a0 :: first_n l1 n0) ++ skip_n l1 n0 = a0 :: l1) a l0\n     end)\n    :\n    forall n0 : nat,\n    (forall l : list A, first_n l n0 ++ skip_n l n0 = l) ->\n    forall l : list A, first_n l (S n0) ++ skip_n l (S n0) = l) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n   ((fun l : list A => eq_refl)\n    :\n    forall l : list A, first_n l 0 ++ skip_n l 0 = l)\n   ((fun (n0 : nat) (H : forall l : list A, first_n l n0 ++ skip_n l n0 = l)\n       (l : list A) =>\n     match\n       l as l0\n       return\n         (match l0 with\n          | nil => nil\n          | a :: l1 => a :: first_n l1 n0\n          end ++ match l0 with\n                 | nil => nil\n                 | _ :: l1 => skip_n l1 n0\n                 end = l0)\n     with\n     | nil => eq_refl : nil ++ nil = nil\n     | a :: l0 =>\n         ((fun (a0 : A) (l1 : list A) => f_equal2 cons eq_refl (H l1))\n          :\n          forall (a0 : A) (l1 : list A),\n          (a0 :: first_n l1 n0) ++ skip_n l1 n0 = a0 :: l1) a l0\n     end)\n    :\n    forall n0 : nat,\n    (forall l : list A, first_n l n0 ++ skip_n l n0 = l) ->\n    forall l : list A, first_n l (S n0) ++ skip_n l (S n0) = l) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "exist_first_max", "text": "Theorem exist_first_max :\n forall l : list nat,\n l <> nil ->\n exists a : nat,\n   (exists l1 : list nat,\n      (exists l2 : list nat,\n         l = l1 ++ a :: l2 /\\\n         (forall n1, In n1 l1 -> n1 < a) /\\ (forall n1, In n1 l2 -> n1 <= a))).\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros H; case H; auto.\nintros a l0; case l0.\nintros H H0; exists a; exists (nil (A:=nat)); exists (nil (A:=nat));\n repeat (split; simpl in |- *; auto with datatypes).\nintros n1 H1; case H1.\nintros n1 H1; case H1.\nintros n l1 H H0; case H; clear H; auto.\nred in |- *; intros H1; discriminate; auto.\nintros a1 (l2, (l3, (HH1, (HH2, HH3)))).\ncase (le_or_lt a1 a); intros HH4; auto.\nexists a; exists (nil (A:=nat)); exists (n :: l1);\n repeat (split; auto with datatypes).\nintros n1 H1; case H1.\nrewrite HH1.\nintros n1 H1; apply le_trans with (2 := HH4); case in_app_or with (1 := H1);\n auto with arith.\nintros H2; apply lt_le_weak; auto.\nsimpl in |- *; intros [H2| H2]; [ rewrite H2 | idtac ]; auto.\nexists a1; exists (a :: l2); exists l3;\n repeat (split; simpl in |- *; auto with datatypes).\napply f_equal2 with (f := cons (A:=nat)); auto.\nintros n1 [H2| H2]; [ rewrite <- H2 | idtac ]; auto.\nQed.\n", "definition": "\n forall l : list nat,\n l <> nil ->\n exists a : nat,\n   (exists l1 : list nat,\n      (exists l2 : list nat,\n         l = l1 ++ a :: l2 /\\\n         (forall n1, In n1 l1 -> n1 < a) /\\ (forall n1, In n1 l2 -> n1 <= a))).", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros H; case H; auto.\nintros a l0; case l0.\nintros H H0; exists a; exists (nil (A:=nat)); exists (nil (A:=nat));\n repeat (split; simpl in |- *; auto with datatypes).\nintros n1 H1; case H1.\nintros n1 H1; case H1.\nintros n l1 H H0; case H; clear H; auto.\nred in |- *; intros H1; discriminate; auto.\nintros a1 (l2, (l3, (HH1, (HH2, HH3)))).\ncase (le_or_lt a1 a); intros HH4; auto.\nexists a; exists (nil (A:=nat)); exists (n :: l1);\n repeat (split; auto with datatypes).\nintros n1 H1; case H1.\nrewrite HH1.\nintros n1 H1; apply le_trans with (2 := HH4); case in_app_or with (1 := H1);\n auto with arith.\nintros H2; apply lt_le_weak; auto.\nsimpl in |- *; intros [H2| H2]; [ rewrite H2 | idtac ]; auto.\nexists a1; exists (a :: l2); exists l3;\n repeat (split; simpl in |- *; auto with datatypes).\napply f_equal2 with (f := cons (A:=nat)); auto.\nintros n1 [H2| H2]; [ rewrite <- H2 | idtac ]; auto.\n", "def_ranges": [529, 0, 536, 79], "proof_ranges": [537, 0, 561, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l : list nat,\nl <> nil ->\nexists (a : nat) (l1 l2 : list nat),\n  l = l1 ++ a :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a)"], "goal_after": ["forall l : list nat,\nl <> nil ->\nexists (a : nat) (l1 l2 : list nat),\n  l = l1 ++ a :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall l : list nat,\nl <> nil ->\nexists (a : nat) (l1 l2 : list nat),\n  l = l1 ++ a :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a)"], "goal_after": ["nil <> nil ->\nexists (a : nat) (l1 l2 : list nat),\n  nil = l1 ++ a :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a)", "forall (a : nat) (l0 : list nat),\n(l0 <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   l0 = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: l0 <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: l0 = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   (?Goal\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   (?Goal0\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "intros H; case H; auto.", "goal_before": ["nil <> nil ->\nexists (a : nat) (l1 l2 : list nat),\n  nil = l1 ++ a :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a)", "forall (a : nat) (l0 : list nat),\n(l0 <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   l0 = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: l0 <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: l0 = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)"], "goal_after": ["forall (a : nat) (l0 : list nat),\n(l0 <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   l0 = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: l0 <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: l0 = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)"], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   (?Goal\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   (?Goal0\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   (?Goal\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "intros a l0; case l0.", "goal_before": ["forall (a : nat) (l0 : list nat),\n(l0 <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   l0 = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: l0 <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: l0 = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)"], "goal_after": ["(nil <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   nil = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: nil <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: nil = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   (?Goal\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil => ?Goal\n     | a0 :: l1 => ?Goal0 a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "intros H H0; exists a; exists (nil (A:=nat)); exists (nil (A:=nat));", "goal_before": ["(nil <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   nil = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: nil <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: nil = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["(nil <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   nil = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: nil <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: nil = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil => ?Goal\n     | a0 :: l1 => ?Goal0 a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": []}, {"text": "repeat (split; simpl in |- *; auto with datatypes).", "goal_before": ["(nil <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   nil = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: nil <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: nil = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["(nil <> nil ->\n exists (a0 : nat) (l1 l2 : list nat),\n   nil = l1 ++ a0 :: l2 /\\\n   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\na :: nil <> nil ->\nexists (a0 : nat) (l1 l2 : list nat),\n  a :: nil = l1 ++ a0 :: l2 /\\\n  (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l2 -> n1 <= a0)", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n1 H1; case H1.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n1 H1; case H1.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n l1 H H0; case H; clear H; auto.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; intros H1; discriminate; auto.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a1 (l2, (l3, (HH1, (HH2, HH3)))).", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": ["Notation le_or_lt is deprecated since 8.16.\nThe Arith.Lt file is obsolete. Use Nat.le_gt_cases instead.\n[deprecated-syntactic-definition,deprecated]", "Notation le_or_lt is deprecated since 8.16.\nThe Arith.Lt file is obsolete. Use Nat.le_gt_cases instead.\n[deprecated-syntactic-definition,deprecated]"]}, {"text": "case (le_or_lt a1 a); intros HH4; auto.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["Notation le_or_lt is deprecated since 8.16.\nThe Arith.Lt file is obsolete. Use Nat.le_gt_cases instead.\n[deprecated-syntactic-definition,deprecated]", "Notation le_or_lt is deprecated since 8.16.\nThe Arith.Lt file is obsolete. Use Nat.le_gt_cases instead.\n[deprecated-syntactic-definition,deprecated]"], "proof_term_after": []}, {"text": "exists a; exists (nil (A:=nat)); exists (n :: l1);", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "repeat (split; auto with datatypes).", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "intros n1 H1; case H1.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "rewrite HH1.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": []}, {"text": "intros n1 H1; apply le_trans with (2 := HH4); case in_app_or with (1 := H1);", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": ["Notation lt_le_weak is deprecated since 8.16.\nThe Arith.Lt file is obsolete. Use Nat.lt_le_incl instead.\n[deprecated-syntactic-definition,deprecated]"]}, {"text": "auto with arith.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["Notation lt_le_weak is deprecated since 8.16.\nThe Arith.Lt file is obsolete. Use Nat.lt_le_incl instead.\n[deprecated-syntactic-definition,deprecated]"], "proof_term_after": []}, {"text": "intros H2; apply lt_le_weak; auto.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros [H2| H2]; [ rewrite H2 | idtac ]; auto.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": [], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "exists a1; exists (a :: l2); exists l3;", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "repeat (split; simpl in |- *; auto with datatypes).", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"]}, {"text": "apply f_equal2 with (f := cons (A:=nat)); auto.", "goal_before": ["a :: nil = nil", "forall (n : nat) (l1 : list nat),\n(n :: l1 <> nil ->\n exists (a0 : nat) (l2 l3 : list nat),\n   n :: l1 = l2 ++ a0 :: l3 /\\\n   (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n   (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\na :: n :: l1 <> nil ->\nexists (a0 : nat) (l2 l3 : list nat),\n  a :: n :: l1 = l2 ++ a0 :: l3 /\\\n  (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n  (forall n1 : nat, In n1 l3 -> n1 <= a0)"], "goal_after": [], "proof_term_before": ["(fun l : list nat =>\n list_ind\n   (fun l0 : list nat =>\n    l0 <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      l0 = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun H : nil <> nil =>\n     match\n       H eq_refl\n       return\n         (exists (a : nat) (l1 l2 : list nat),\n            nil = l1 ++ a :: l2 /\\\n            (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n            (forall n1 : nat, In n1 l2 -> n1 <= a))\n     with\n     end)\n    :\n    nil <> nil ->\n    exists (a : nat) (l1 l2 : list nat),\n      nil = l1 ++ a :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a))\n   ((fun (a : nat) (l0 : list nat) =>\n     match\n       l0 as l1\n       return\n         ((l1 <> nil ->\n           exists (a0 : nat) (l2 l3 : list nat),\n             l1 = l2 ++ a0 :: l3 /\\\n             (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n             (forall n1 : nat, In n1 l3 -> n1 <= a0)) ->\n          a :: l1 <> nil ->\n          exists (a0 : nat) (l2 l3 : list nat),\n            a :: l1 = l2 ++ a0 :: l3 /\\\n            (forall n1 : nat, In n1 l2 -> n1 < a0) /\\\n            (forall n1 : nat, In n1 l3 -> n1 <= a0))\n     with\n     | nil =>\n         fun\n           (n1 : nil <> nil ->\n                 exists (a0 : nat) (l1 l2 : list nat),\n                   nil = l1 ++ a0 :: l2 /\\\n                   (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n                   (forall n1 : nat, In n1 l2 -> n1 <= a0))\n           (H1 : a :: nil <> nil) =>\n         match\n           H1 ?Goal0\n           return\n             (exists (a0 : nat) (l1 l2 : list nat),\n                a :: nil = l1 ++ a0 :: l2 /\\\n                (forall n2 : nat, In n2 l1 -> n2 < a0) /\\\n                (forall n2 : nat, In n2 l2 -> n2 <= a0))\n         with\n         end\n     | a0 :: l1 => ?Goal a0 l1\n     end)\n    :\n    forall (a : nat) (l0 : list nat),\n    (l0 <> nil ->\n     exists (a0 : nat) (l1 l2 : list nat),\n       l0 = l1 ++ a0 :: l2 /\\\n       (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n       (forall n1 : nat, In n1 l2 -> n1 <= a0)) ->\n    a :: l0 <> nil ->\n    exists (a0 : nat) (l1 l2 : list nat),\n      a :: l0 = l1 ++ a0 :: l2 /\\\n      (forall n1 : nat, In n1 l1 -> n1 < a0) /\\\n      (forall n1 : nat, In n1 l2 -> n1 <= a0)) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "find_min_correct", "text": "Theorem find_min_correct :\n forall l : list A,\n match find_min l with\n | None => l = nil\n | Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f b <= f c)\n end.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0; case (find_min l0); simpl in |- *.\nintros p; case p; simpl in |- *.\nintros n b ((H1, H2), H3); case (le_lt_dec n (f a)); simpl in |- *.\nintros H4; split; auto.\nintros c [H5| H5]; auto.\nrewrite <- H2; rewrite <- H5; auto.\nintros H4; split; auto.\nintros c [H5| H5]; auto.\nrewrite <- H5; auto.\napply le_trans with (f b); auto.\nrewrite <- H2; auto with arith.\nintros H; rewrite H; split; simpl in |- *; auto.\nintros c [H1| H1]; rewrite H1 || case H1; auto.\nQed.\n", "definition": "\n forall l : list A,\n match find_min l with\n | None => l = nil\n | Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f b <= f c)\n end.", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0; case (find_min l0); simpl in |- *.\nintros p; case p; simpl in |- *.\nintros n b ((H1, H2), H3); case (le_lt_dec n (f a)); simpl in |- *.\nintros H4; split; auto.\nintros c [H5| H5]; auto.\nrewrite <- H2; rewrite <- H5; auto.\nintros H4; split; auto.\nintros c [H5| H5]; auto.\nrewrite <- H5; auto.\napply le_trans with (f b); auto.\nrewrite <- H2; auto with arith.\nintros H; rewrite H; split; simpl in |- *; auto.\nintros c [H1| H1]; rewrite H1 || case H1; auto.\n", "def_ranges": [586, 0, 591, 5], "proof_ranges": [592, 0, 607, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l : list A,\nmatch find_min l with\n| Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f b <= f c)\n| None => l = nil\nend"], "goal_after": ["forall l : list A,\nmatch find_min l with\n| Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f b <= f c)\n| None => l = nil\nend"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall l : list A,\nmatch find_min l with\n| Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f b <= f c)\n| None => l = nil\nend"], "goal_after": ["forall (a : A) (l0 : list A),\nmatch find_min l0 with\n| Some (a0, b) =>\n    (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n| None => l0 = nil\nend ->\nmatch\n  match find_min l0 with\n  | Some (n1, b) =>\n      if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n  | None => Some (f a, a)\n  end\nwith\n| Some (a0, b) =>\n    ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n| None => a :: l0 = nil\nend"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros a l0; case (find_min l0); simpl in |- *.", "goal_before": ["forall (a : A) (l0 : list A),\nmatch find_min l0 with\n| Some (a0, b) =>\n    (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n| None => l0 = nil\nend ->\nmatch\n  match find_min l0 with\n  | Some (n1, b) =>\n      if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n  | None => Some (f a, a)\n  end\nwith\n| Some (a0, b) =>\n    ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n| None => a :: l0 = nil\nend"], "goal_after": ["forall p : nat * A,\n(let (a0, b) := p in\n (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\nmatch\n  (let (n1, b) := p in\n   if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\nwith\n| Some (a0, b) =>\n    ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n| None => a :: l0 = nil\nend", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         (?Goal\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal0\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros p; case p; simpl in |- *.", "goal_before": ["forall p : nat * A,\n(let (a0, b) := p in\n (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\nmatch\n  (let (n1, b) := p in\n   if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\nwith\n| Some (a0, b) =>\n    ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n| None => a :: l0 = nil\nend", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["forall (n : nat) (a0 : A),\n(In a0 l0 /\\ n = f a0) /\\ (forall c : A, In c l0 -> f a0 <= f c) ->\nmatch (if le_lt_dec n (f a) then Some (n, a0) else Some (f a, a)) with\n| Some (a1, b) =>\n    ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n| None => a :: l0 = nil\nend", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         (?Goal\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal0\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           (?Goal0\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros n b ((H1, H2), H3); case (le_lt_dec n (f a)); simpl in |- *.", "goal_before": ["forall (n : nat) (a0 : A),\n(In a0 l0 /\\ n = f a0) /\\ (forall c : A, In c l0 -> f a0 <= f c) ->\nmatch (if le_lt_dec n (f a) then Some (n, a0) else Some (f a, a)) with\n| Some (a1, b) =>\n    ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n| None => a :: l0 = nil\nend", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["n <= f a ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f b <= f c)", "f a < n ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           (?Goal0\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           (?Goal1@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros H4; split; auto.", "goal_before": ["n <= f a ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f b <= f c)", "f a < n ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["forall c : A, a = c \\/ In c l0 -> f b <= f c", "f a < n ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           (?Goal1@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2) ?Goal1@{b:=b0})\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros c [H5| H5]; auto.", "goal_before": ["forall c : A, a = c \\/ In c l0 -> f b <= f c", "f a < n ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["f b <= f c", "f a < n ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2) ?Goal1@{b:=b0})\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c => ?Goal1@{b:=b0; H5:=H6})\n                                      x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "rewrite <- H2; rewrite <- H5; auto.", "goal_before": ["f b <= f c", "f a < n ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["f a < n ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c => ?Goal1@{b:=b0; H5:=H6})\n                                      x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros H4; split; auto.", "goal_before": ["f a < n ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["forall c : A, a = c \\/ In c l0 -> f a <= f c", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               ?Goal0@{b:=b0})\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros c [H5| H5]; auto.", "goal_before": ["forall c : A, a = c \\/ In c l0 -> f a <= f c", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["f a <= f c", "f a <= f c", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               ?Goal0@{b:=b0})\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c => ?Goal0@{b:=b0; H5:=H6})\n                                      x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     ?Goal1@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "rewrite <- H5; auto.", "goal_before": ["f a <= f c", "f a <= f c", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["f a <= f c", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c => ?Goal0@{b:=b0; H5:=H6})\n                                      x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     ?Goal1@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     ?Goal0@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "apply le_trans with (f b); auto.", "goal_before": ["f a <= f c", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["f a <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     ?Goal0@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f a) (f b0) \n                                       (f c) ?Goal0@{b:=b0; H5:=H6} \n                                       (H3 c H6)) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "rewrite <- H2; auto with arith.", "goal_before": ["f a <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f a) (f b0) \n                                       (f c) ?Goal0@{b:=b0; H5:=H6} \n                                       (H3 c H6)) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f a) (f b0) \n                                       (f c)\n                                       (eq_ind n (fun n0 : nat => f a <= n0)\n                                          (Nat.lt_le_incl (f a) n H4) \n                                          (f b0) H2) \n                                       (H3 c H6)) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros H; rewrite H; split; simpl in |- *; auto.", "goal_before": ["l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f a <= f c)"], "goal_after": ["forall c : A, a = c \\/ False -> f a <= f c"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f a) (f b0) \n                                       (f c)\n                                       (eq_ind n (fun n0 : nat => f a <= n0)\n                                          (Nat.lt_le_incl (f a) n H4) \n                                          (f b0) H2) \n                                       (H3 c H6)) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f a) (f b0) \n                                       (f c)\n                                       (eq_ind n (fun n0 : nat => f a <= n0)\n                                          (Nat.lt_le_incl (f a) n H4) \n                                          (f b0) H2) \n                                       (H3 c H6)) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         (fun H : l0 = nil =>\n          eq_ind_r\n            (fun l1 : list A =>\n             ((a = a \\/ In a l1) /\\ f a = f a) /\\\n             (forall c : A, a = c \\/ In c l1 -> f a <= f c))\n            (conj\n               (conj (or_introl eq_refl) eq_refl\n                :\n                (a = a \\/ In a nil) /\\ f a = f a)\n               (?Goal : forall c : A, a = c \\/ In c nil -> f a <= f c)) H)\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros c [H1| H1]; rewrite H1 || case H1; auto.", "goal_before": ["forall c : A, a = c \\/ False -> f a <= f c"], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f a) (f b0) \n                                       (f c)\n                                       (eq_ind n (fun n0 : nat => f a <= n0)\n                                          (Nat.lt_le_incl (f a) n H4) \n                                          (f b0) H2) \n                                       (H3 c H6)) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         (fun H : l0 = nil =>\n          eq_ind_r\n            (fun l1 : list A =>\n             ((a = a \\/ In a l1) /\\ f a = f a) /\\\n             (forall c : A, a = c \\/ In c l1 -> f a <= f c))\n            (conj\n               (conj (or_introl eq_refl) eq_refl\n                :\n                (a = a \\/ In a nil) /\\ f a = f a)\n               (?Goal : forall c : A, a = c \\/ In c nil -> f a <= f c)) H)\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f a) (f b0) \n                                       (f c)\n                                       (eq_ind n (fun n0 : nat => f a <= n0)\n                                          (Nat.lt_le_incl (f a) n H4) \n                                          (f b0) H2) \n                                       (H3 c H6)) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         (fun H : l0 = nil =>\n          eq_ind_r\n            (fun l1 : list A =>\n             ((a = a \\/ In a l1) /\\ f a = f a) /\\\n             (forall c : A, a = c \\/ In c l1 -> f a <= f c))\n            (conj\n               (conj (or_introl eq_refl) eq_refl\n                :\n                (a = a \\/ In a nil) /\\ f a = f a)\n               ((fun (c : A) (H0 : a = c \\/ False) =>\n                 match H0 with\n                 | or_introl x =>\n                     (fun H1 : a = c =>\n                      eq_ind_r (fun a0 : A => f a0 <= f c) (le_n (f c)) H1) x\n                 | or_intror x =>\n                     (fun H1 : False => match H1 return (f a <= f c) with\n                                        end) x\n                 end)\n                :\n                forall c : A, a = c \\/ In c nil -> f a <= f c)) H)\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_min l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_min nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f b <= f c)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_min l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f b <= f c)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (n1, b)\n                    else Some (f a, a))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f b0 <= f c)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f b0 <= f c) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (n, b0) else Some (f a, a))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f b1 <= f c)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind n (fun n0 : nat => n0 <= f c)\n                                       (eq_ind a (fun c0 : A => n <= f c0) H4\n                                          c H6) (f b0) H2) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f b0 <= f c))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f a <= f c0)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f a) (f b0) \n                                       (f c)\n                                       (eq_ind n (fun n0 : nat => f a <= n0)\n                                          (Nat.lt_le_incl (f a) n H4) \n                                          (f b0) H2) \n                                       (H3 c H6)) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f a <= f c))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f a2 <= f c) ->\n            match\n              (if le_lt_dec n (f a) then Some (n, a2) else Some (f a, a))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f b0 <= f c)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (n1, b) else Some (f a, a))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f b <= f c)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         (fun H : l0 = nil =>\n          eq_ind_r\n            (fun l1 : list A =>\n             ((a = a \\/ In a l1) /\\ f a = f a) /\\\n             (forall c : A, a = c \\/ In c l1 -> f a <= f c))\n            (conj\n               (conj (or_introl eq_refl) eq_refl\n                :\n                (a = a \\/ In a nil) /\\ f a = f a)\n               ((fun (c : A) (H0 : a = c \\/ False) =>\n                 match H0 with\n                 | or_introl x =>\n                     (fun H1 : a = c =>\n                      eq_ind_r (fun a0 : A => f a0 <= f c) (le_n (f c)) H1) x\n                 | or_intror x =>\n                     (fun H1 : False => match H1 return (f a <= f c) with\n                                        end) x\n                 end)\n                :\n                forall c : A, a = c \\/ In c nil -> f a <= f c)) H)\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f a <= f c)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_min l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f b <= f c)\n    | None => l0 = nil\n    end ->\n    match find_min (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f b <= f c)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/Aux.v", "name": "find_max_correct", "text": "Theorem find_max_correct :\n forall l : list A,\n match find_max l with\n | None => l = nil\n | Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f c <= f b)\n end.\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0; case (find_max l0); simpl in |- *.\nintros p; case p; simpl in |- *.\nintros n b ((H1, H2), H3); case (le_lt_dec n (f a)); simpl in |- *.\nintros H4; split; auto.\nintros c [H5| H5]; auto.\nrewrite <- H5; auto.\napply le_trans with (f b); auto.\nrewrite <- H2; auto with arith.\nintros H4; split; auto.\nintros c [H5| H5]; auto.\nrewrite <- H5; auto.\napply le_trans with (f b); auto.\nrewrite <- H2; auto with arith.\nintros H; rewrite H; split; simpl in |- *; auto.\nintros c [H1| H1]; rewrite H1 || case H1; auto.\nQed.\n", "definition": "\n forall l : list A,\n match find_max l with\n | None => l = nil\n | Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f c <= f b)\n end.", "proof": "\nProof using.\nintros l; elim l; simpl in |- *; auto.\nintros a l0; case (find_max l0); simpl in |- *.\nintros p; case p; simpl in |- *.\nintros n b ((H1, H2), H3); case (le_lt_dec n (f a)); simpl in |- *.\nintros H4; split; auto.\nintros c [H5| H5]; auto.\nrewrite <- H5; auto.\napply le_trans with (f b); auto.\nrewrite <- H2; auto with arith.\nintros H4; split; auto.\nintros c [H5| H5]; auto.\nrewrite <- H5; auto.\napply le_trans with (f b); auto.\nrewrite <- H2; auto with arith.\nintros H; rewrite H; split; simpl in |- *; auto.\nintros c [H1| H1]; rewrite H1 || case H1; auto.\n", "def_ranges": [625, 0, 630, 5], "proof_ranges": [631, 0, 648, 4], "proof_steps": [{"text": "Proof using.", "goal_before": ["forall l : list A,\nmatch find_max l with\n| Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f c <= f b)\n| None => l = nil\nend"], "goal_after": ["forall l : list A,\nmatch find_max l with\n| Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f c <= f b)\n| None => l = nil\nend"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros l; elim l; simpl in |- *; auto.", "goal_before": ["forall l : list A,\nmatch find_max l with\n| Some (a, b) => (In b l /\\ a = f b) /\\ (forall c : A, In c l -> f c <= f b)\n| None => l = nil\nend"], "goal_after": ["forall (a : A) (l0 : list A),\nmatch find_max l0 with\n| Some (a0, b) =>\n    (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n| None => l0 = nil\nend ->\nmatch\n  match find_max l0 with\n  | Some (n1, b) =>\n      if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n  | None => Some (f a, a)\n  end\nwith\n| Some (a0, b) =>\n    ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n| None => a :: l0 = nil\nend"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros a l0; case (find_max l0); simpl in |- *.", "goal_before": ["forall (a : A) (l0 : list A),\nmatch find_max l0 with\n| Some (a0, b) =>\n    (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n| None => l0 = nil\nend ->\nmatch\n  match find_max l0 with\n  | Some (n1, b) =>\n      if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n  | None => Some (f a, a)\n  end\nwith\n| Some (a0, b) =>\n    ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n| None => a :: l0 = nil\nend"], "goal_after": ["forall p : nat * A,\n(let (a0, b) := p in\n (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\nmatch\n  (let (n1, b) := p in\n   if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\nwith\n| Some (a0, b) =>\n    ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n| None => a :: l0 = nil\nend", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   (?Goal\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         (?Goal\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal0\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros p; case p; simpl in |- *.", "goal_before": ["forall p : nat * A,\n(let (a0, b) := p in\n (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\nmatch\n  (let (n1, b) := p in\n   if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\nwith\n| Some (a0, b) =>\n    ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n| None => a :: l0 = nil\nend", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["forall (n : nat) (a0 : A),\n(In a0 l0 /\\ n = f a0) /\\ (forall c : A, In c l0 -> f c <= f a0) ->\nmatch (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a0)) with\n| Some (a1, b) =>\n    ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n| None => a :: l0 = nil\nend", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         (?Goal\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal0\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           (?Goal0\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros n b ((H1, H2), H3); case (le_lt_dec n (f a)); simpl in |- *.", "goal_before": ["forall (n : nat) (a0 : A),\n(In a0 l0 /\\ n = f a0) /\\ (forall c : A, In c l0 -> f c <= f a0) ->\nmatch (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a0)) with\n| Some (a1, b) =>\n    ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n    (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n| None => a :: l0 = nil\nend", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["n <= f a ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           (?Goal0\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal1@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros H4; split; auto.", "goal_before": ["n <= f a ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["forall c : A, a = c \\/ In c l0 -> f c <= f a", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal1@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               ?Goal1@{b:=b0})\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros c [H5| H5]; auto.", "goal_before": ["forall c : A, a = c \\/ In c l0 -> f c <= f a", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["f c <= f a", "f c <= f a", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               ?Goal1@{b:=b0})\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c => ?Goal1@{b:=b0; H5:=H6})\n                                      x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     ?Goal2@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "rewrite <- H5; auto.", "goal_before": ["f c <= f a", "f c <= f a", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["f c <= f a", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c => ?Goal1@{b:=b0; H5:=H6})\n                                      x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     ?Goal2@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     ?Goal1@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "apply le_trans with (f b); auto.", "goal_before": ["f c <= f a", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["f b <= f a", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     ?Goal1@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6) \n                                       ?Goal1@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "rewrite <- H2; auto with arith.", "goal_before": ["f b <= f a", "f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6) \n                                       ?Goal1@{b:=b0; H5:=H6}) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros H4; split; auto.", "goal_before": ["f a < n ->\n((a = b \\/ In b l0) /\\ n = f b) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f b)", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["forall c : A, a = c \\/ In c l0 -> f c <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           (?Goal0@{b:=b0}\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2) ?Goal0@{b:=b0})\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros c [H5| H5]; auto.", "goal_before": ["forall c : A, a = c \\/ In c l0 -> f c <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["f c <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2) ?Goal0@{b:=b0})\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c => ?Goal0@{b:=b0; H5:=H6})\n                                      x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "rewrite <- H5; auto.", "goal_before": ["f c <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["f a <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c => ?Goal0@{b:=b0; H5:=H6})\n                                      x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       ?Goal0@{b:=b0; H5:=H6} c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "apply le_trans with (f b); auto.", "goal_before": ["f a <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["f a <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       ?Goal0@{b:=b0; H5:=H6} c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       (Nat.le_trans \n                                          (f a) (f b0) \n                                          (f b0) ?Goal0@{b:=b0; H5:=H6}\n                                          (H3 b0 H1)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "rewrite <- H2; auto with arith.", "goal_before": ["f a <= f b", "l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       (Nat.le_trans \n                                          (f a) (f b0) \n                                          (f b0) ?Goal0@{b:=b0; H5:=H6}\n                                          (H3 b0 H1)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       (Nat.le_trans \n                                          (f a) (f b0) \n                                          (f b0)\n                                          (eq_ind n\n                                             (fun n0 : nat => f a <= n0)\n                                             (Nat.lt_le_incl (f a) n H4)\n                                             (f b0) H2) \n                                          (H3 b0 H1)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros H; rewrite H; split; simpl in |- *; auto.", "goal_before": ["l0 = nil ->\n((a = a \\/ In a l0) /\\ f a = f a) /\\\n(forall c : A, a = c \\/ In c l0 -> f c <= f a)"], "goal_after": ["forall c : A, a = c \\/ False -> f c <= f a"], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       (Nat.le_trans \n                                          (f a) (f b0) \n                                          (f b0)\n                                          (eq_ind n\n                                             (fun n0 : nat => f a <= n0)\n                                             (Nat.lt_le_incl (f a) n H4)\n                                             (f b0) H2) \n                                          (H3 b0 H1)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         ?Goal\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       (Nat.le_trans \n                                          (f a) (f b0) \n                                          (f b0)\n                                          (eq_ind n\n                                             (fun n0 : nat => f a <= n0)\n                                             (Nat.lt_le_incl (f a) n H4)\n                                             (f b0) H2) \n                                          (H3 b0 H1)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         (fun H : l0 = nil =>\n          eq_ind_r\n            (fun l1 : list A =>\n             ((a = a \\/ In a l1) /\\ f a = f a) /\\\n             (forall c : A, a = c \\/ In c l1 -> f c <= f a))\n            (conj\n               (conj (or_introl eq_refl) eq_refl\n                :\n                (a = a \\/ In a nil) /\\ f a = f a)\n               (?Goal : forall c : A, a = c \\/ In c nil -> f c <= f a)) H)\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "intros c [H1| H1]; rewrite H1 || case H1; auto.", "goal_before": ["forall c : A, a = c \\/ False -> f c <= f a"], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       (Nat.le_trans \n                                          (f a) (f b0) \n                                          (f b0)\n                                          (eq_ind n\n                                             (fun n0 : nat => f a <= n0)\n                                             (Nat.lt_le_incl (f a) n H4)\n                                             (f b0) H2) \n                                          (H3 b0 H1)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         (fun H : l0 = nil =>\n          eq_ind_r\n            (fun l1 : list A =>\n             ((a = a \\/ In a l1) /\\ f a = f a) /\\\n             (forall c : A, a = c \\/ In c l1 -> f c <= f a))\n            (conj\n               (conj (or_introl eq_refl) eq_refl\n                :\n                (a = a \\/ In a nil) /\\ f a = f a)\n               (?Goal : forall c : A, a = c \\/ In c nil -> f c <= f a)) H)\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       (Nat.le_trans \n                                          (f a) (f b0) \n                                          (f b0)\n                                          (eq_ind n\n                                             (fun n0 : nat => f a <= n0)\n                                             (Nat.lt_le_incl (f a) n H4)\n                                             (f b0) H2) \n                                          (H3 b0 H1)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         (fun H : l0 = nil =>\n          eq_ind_r\n            (fun l1 : list A =>\n             ((a = a \\/ In a l1) /\\ f a = f a) /\\\n             (forall c : A, a = c \\/ In c l1 -> f c <= f a))\n            (conj\n               (conj (or_introl eq_refl) eq_refl\n                :\n                (a = a \\/ In a nil) /\\ f a = f a)\n               ((fun (c : A) (H0 : a = c \\/ False) =>\n                 match H0 with\n                 | or_introl x =>\n                     (fun H1 : a = c =>\n                      eq_ind_r (fun a0 : A => f c <= f a0) (le_n (f c)) H1) x\n                 | or_intror x =>\n                     (fun H1 : False => match H1 return (f c <= f a) with\n                                        end) x\n                 end)\n                :\n                forall c : A, a = c \\/ In c nil -> f c <= f a)) H)\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun l : list A =>\n list_ind\n   (fun l0 : list A =>\n    match find_max l0 with\n    | Some (a, b) =>\n        (In b l0 /\\ a = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end)\n   (eq_refl\n    :\n    match find_max nil with\n    | Some (a, b) =>\n        (In b nil /\\ a = f b) /\\ (forall c : A, In c nil -> f c <= f b)\n    | None => nil = nil\n    end)\n   ((fun (a : A) (l0 : list A) =>\n     match\n       find_max l0 as o\n       return\n         (match o with\n          | Some (a0, b) =>\n              (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n          | None => l0 = nil\n          end ->\n          match\n            match o with\n            | Some (n1, b) =>\n                if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b)\n            | None => Some (f a, a)\n            end\n          with\n          | Some (a0, b) =>\n              ((a = b \\/ In b l0) /\\ a0 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end)\n     with\n     | Some a0 =>\n         ((fun p : nat * A =>\n           let\n             (a1, b) as p0\n              return\n                ((let (a1, b) := p0 in\n                  (In b l0 /\\ a1 = f b) /\\\n                  (forall c : A, In c l0 -> f c <= f b)) ->\n                 match\n                   (let (n1, b) := p0 in\n                    if le_lt_dec n1 (f a)\n                    then Some (f a, a)\n                    else Some (n1, b))\n                 with\n                 | Some (a1, b) =>\n                     ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n                     (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n                 | None => a :: l0 = nil\n                 end) := p in\n           ((fun (n : nat) (b0 : A)\n               (H : (In b0 l0 /\\ n = f b0) /\\\n                    (forall c : A, In c l0 -> f c <= f b0)) =>\n             match H with\n             | conj x x0 =>\n                 (fun H0 : In b0 l0 /\\ n = f b0 =>\n                  match H0 with\n                  | conj x1 x2 =>\n                      (fun (H1 : In b0 l0) (H2 : n = f b0)\n                         (H3 : forall c : A, In c l0 -> f c <= f b0) =>\n                       match\n                         le_lt_dec n (f a) as s\n                         return\n                           match\n                             (if s then Some (f a, a) else Some (n, b0))\n                           with\n                           | Some (a2, b1) =>\n                               ((a = b1 \\/ In b1 l0) /\\ a2 = f b1) /\\\n                               (forall c : A, a = c \\/ In c l0 -> f c <= f b1)\n                           | None => a :: l0 = nil\n                           end\n                       with\n                       | left a2 =>\n                           ((fun H4 : n <= f a =>\n                             conj (conj (or_introl eq_refl) eq_refl)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f a)\n                                       (le_n (f a)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 =>\n                                     Nat.le_trans \n                                       (f c) (f b0) \n                                       (f a) (H3 c H6)\n                                       (eq_ind n (fun n0 : nat => n0 <= f a)\n                                          H4 (f b0) H2)) x3\n                                end))\n                            :\n                            n <= f a ->\n                            ((a = a \\/ In a l0) /\\ f a = f a) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f a))\n                             a2\n                       | right b1 =>\n                           ((fun H4 : f a < n =>\n                             conj (conj (or_intror H1) H2)\n                               (fun (c : A) (H5 : a = c \\/ In c l0) =>\n                                match H5 with\n                                | or_introl x3 =>\n                                    (fun H6 : a = c =>\n                                     eq_ind a (fun c0 : A => f c0 <= f b0)\n                                       (Nat.le_trans \n                                          (f a) (f b0) \n                                          (f b0)\n                                          (eq_ind n\n                                             (fun n0 : nat => f a <= n0)\n                                             (Nat.lt_le_incl (f a) n H4)\n                                             (f b0) H2) \n                                          (H3 b0 H1)) c H6) x3\n                                | or_intror x3 =>\n                                    (fun H6 : In c l0 => H3 c H6) x3\n                                end))\n                            :\n                            f a < n ->\n                            ((a = b0 \\/ In b0 l0) /\\ n = f b0) /\\\n                            (forall c : A, a = c \\/ In c l0 -> f c <= f b0))\n                             b1\n                       end) x1 x2\n                  end) x x0\n             end)\n            :\n            forall (n : nat) (a2 : A),\n            (In a2 l0 /\\ n = f a2) /\\ (forall c : A, In c l0 -> f c <= f a2) ->\n            match\n              (if le_lt_dec n (f a) then Some (f a, a) else Some (n, a2))\n            with\n            | Some (a3, b0) =>\n                ((a = b0 \\/ In b0 l0) /\\ a3 = f b0) /\\\n                (forall c : A, a = c \\/ In c l0 -> f c <= f b0)\n            | None => a :: l0 = nil\n            end) a1 b)\n          :\n          forall p : nat * A,\n          (let (a1, b) := p in\n           (In b l0 /\\ a1 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)) ->\n          match\n            (let (n1, b) := p in\n             if le_lt_dec n1 (f a) then Some (f a, a) else Some (n1, b))\n          with\n          | Some (a1, b) =>\n              ((a = b \\/ In b l0) /\\ a1 = f b) /\\\n              (forall c : A, a = c \\/ In c l0 -> f c <= f b)\n          | None => a :: l0 = nil\n          end) a0\n     | None =>\n         (fun H : l0 = nil =>\n          eq_ind_r\n            (fun l1 : list A =>\n             ((a = a \\/ In a l1) /\\ f a = f a) /\\\n             (forall c : A, a = c \\/ In c l1 -> f c <= f a))\n            (conj\n               (conj (or_introl eq_refl) eq_refl\n                :\n                (a = a \\/ In a nil) /\\ f a = f a)\n               ((fun (c : A) (H0 : a = c \\/ False) =>\n                 match H0 with\n                 | or_introl x =>\n                     (fun H1 : a = c =>\n                      eq_ind_r (fun a0 : A => f c <= f a0) (le_n (f c)) H1) x\n                 | or_intror x =>\n                     (fun H1 : False => match H1 return (f c <= f a) with\n                                        end) x\n                 end)\n                :\n                forall c : A, a = c \\/ In c nil -> f c <= f a)) H)\n         :\n         l0 = nil ->\n         ((a = a \\/ In a l0) /\\ f a = f a) /\\\n         (forall c : A, a = c \\/ In c l0 -> f c <= f a)\n     end)\n    :\n    forall (a : A) (l0 : list A),\n    match find_max l0 with\n    | Some (a0, b) =>\n        (In b l0 /\\ a0 = f b) /\\ (forall c : A, In c l0 -> f c <= f b)\n    | None => l0 = nil\n    end ->\n    match find_max (a :: l0) with\n    | Some (a0, b) =>\n        (In b (a :: l0) /\\ a0 = f b) /\\\n        (forall c : A, In c (a :: l0) -> f c <= f b)\n    | None => a :: l0 = nil\n    end) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/sTactic.v", "name": "Contradict1", "text": "Theorem Contradict1 : forall a b : Prop, b -> (a -> ~ b) -> ~ a.\nProof.\nintuition.\nQed.\n", "definition": " forall a b : Prop, b -> (a -> ~ b) -> ~ a.\n", "proof": "\nintuition.\n", "def_ranges": [24, 0, 24, 64], "proof_ranges": [25, 0, 27, 4], "proof_steps": [{"text": "intuition.", "goal_before": ["forall a b : Prop, b -> (a -> ~ b) -> ~ a"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (a b : Prop) (H : b) (H0 : a -> ~ b) =>\n (fun H1 : a =>\n  let H2 : ~ b := H0 H1 in let H3 : False := H2 H in False_ind False H3)\n :\n ~ a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : Prop) (H : b) (H0 : a -> ~ b) =>\n (fun H1 : a =>\n  let H2 : ~ b := H0 H1 in let H3 : False := H2 H in False_ind False H3)\n :\n ~ a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/sTactic.v", "name": "Contradict2", "text": "Theorem Contradict2 : forall a b : Prop, b -> ~ b -> a.\nProof.\nintuition.\nQed.\n", "definition": " forall a b : Prop, b -> ~ b -> a.\n", "proof": "\nintuition.\n", "def_ranges": [29, 0, 29, 55], "proof_ranges": [30, 0, 32, 4], "proof_steps": [{"text": "intuition.", "goal_before": ["forall a b : Prop, b -> ~ b -> a"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (a b : Prop) (H : b) (H0 : ~ b) =>\n let H1 : False := H0 H in False_ind a H1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : Prop) (H : b) (H0 : ~ b) =>\n let H1 : False := H0 H in False_ind a H1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/huffman/theories/sTactic.v", "name": "Contradict3", "text": "Theorem Contradict3 : forall a : Prop, a -> ~ ~ a.\nProof.\nauto.\nQed.\n", "definition": " forall a : Prop, a -> ~ ~ a.\n", "proof": "\nauto.\n", "def_ranges": [34, 0, 34, 50], "proof_ranges": [35, 0, 37, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall a : Prop, a -> ~ ~ a"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (a : Prop) (H : a) => (fun H0 : a -> False => H0 H) : ~ ~ a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : Prop) (H : a) => (fun H0 : a -> False => H0 H) : ~ ~ a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/podefs.v", "name": "Carrier_of", "text": "Theorem Carrier_of : PO -> Carrier.\n   intro H'; elim H'.\n   intros C R H'0 H'1; exact C.\n   Defined.\n", "definition": " PO -> Carrier.", "proof": "\n   intro H'; elim H'.\n   intros C R H'0 H'1; exact C.\n   ", "def_ranges": [23, 0, 23, 38], "proof_ranges": [24, 0, 26, 11], "proof_steps": [{"text": "intro H'; elim H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros C R H'0 H'1; exact C.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/podefs.v", "name": "Rel_of", "text": "Theorem Rel_of : PO -> Rel.\n   intro H'; elim H'.\n   intros C R H'0 H'1; exact R.\n   Defined.\n", "definition": " PO -> Rel.", "proof": "\n   intro H'; elim H'.\n   intros C R H'0 H'1; exact R.\n   ", "def_ranges": [28, 0, 28, 30], "proof_ranges": [29, 0, 31, 11], "proof_steps": [{"text": "intro H'; elim H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros C R H'0 H'1; exact R.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_3_facts.v", "name": "Rstar_imp_coherent", "text": "Theorem Rstar_imp_coherent :\n forall (U : Type) (R : Relation U) (x y : U),\n Rstar U R x y -> coherent U R x y.\nintros U R x y H'; red in |- *.\nexists y; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U) (x y : U),\n Rstar U R x y -> coherent U R x y.", "proof": "\nintros U R x y H'; red in |- *.\nexists y; auto.\n", "def_ranges": [14, 0, 16, 35], "proof_ranges": [17, 0, 19, 4], "proof_steps": [{"text": "intros U R x y H'; red in |- *.", "goal_before": ["forall (U : Type) (R : Relation U) (x y : U),\nRstar U R x y -> coherent U R x y"], "goal_after": ["exists z : U, Rstar U R x z /\\ Rstar U R y z"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (x y : U) (H' : Rstar U R x y) =>\n ?Goal : coherent U R x y)"]}, {"text": "exists y; auto.", "goal_before": ["exists z : U, Rstar U R x z /\\ Rstar U R y z"], "goal_after": ["Rstar U R x y /\\ Rstar U R y y"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (x y : U) (H' : Rstar U R x y) =>\n ?Goal : coherent U R x y)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (x y : U) (H' : Rstar U R x y) =>\n ex_intro (fun z : U => Rstar U R x z /\\ Rstar U R y z) y ?Goal\n :\n coherent U R x y)"]}, {"text": "Qed.", "goal_before": ["Rstar U R x y /\\ Rstar U R y y"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) (x y : U) (H' : Rstar U R x y) =>\n ex_intro (fun z : U => Rstar U R x z /\\ Rstar U R y z) y ?Goal\n :\n coherent U R x y)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_3_facts.v", "name": "coherent_symmetric", "text": "Theorem coherent_symmetric :\n forall (U : Type) (R : Relation U), Symmetric U (coherent U R).\nunfold coherent at 1 in |- *.\nintros U R; red in |- *.\nintros x y h; elim h; intros z h0; elim h0; intros H' H'0; clear h h0.\nexists z; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Symmetric U (coherent U R).", "proof": "\nunfold coherent at 1 in |- *.\nintros U R; red in |- *.\nintros x y h; elim h; intros z h0; elim h0; intros H' H'0; clear h h0.\nexists z; auto.\n", "def_ranges": [22, 0, 23, 64], "proof_ranges": [24, 0, 28, 4], "proof_steps": [{"text": "unfold coherent at 1 in |- *.", "goal_before": ["forall (U : Type) (R : Relation U), Symmetric U (coherent U R)"], "goal_after": ["forall (U : Type) (R : Relation U),\nSymmetric U (fun x y : U => exists z : U, Rstar U R x z /\\ Rstar U R y z)"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall (U : Type) (R : Relation U), Symmetric U (coherent U R))"]}, {"text": "intros U R; red in |- *.", "goal_before": ["forall (U : Type) (R : Relation U),\nSymmetric U (fun x y : U => exists z : U, Rstar U R x z /\\ Rstar U R y z)"], "goal_after": ["forall x y : U,\n(exists z : U, Rstar U R x z /\\ Rstar U R y z) ->\nexists z : U, Rstar U R y z /\\ Rstar U R x z"], "proof_term_before": ["(?Goal : forall (U : Type) (R : Relation U), Symmetric U (coherent U R))"], "proof_term_after": ["((fun (U : Type) (R : Relation U) =>\n  ?Goal\n  :\n  Symmetric U (fun x y : U => exists z : U, Rstar U R x z /\\ Rstar U R y z))\n :\n forall (U : Type) (R : Relation U), Symmetric U (coherent U R))"]}, {"text": "intros x y h; elim h; intros z h0; elim h0; intros H' H'0; clear h h0.", "goal_before": ["forall x y : U,\n(exists z : U, Rstar U R x z /\\ Rstar U R y z) ->\nexists z : U, Rstar U R y z /\\ Rstar U R x z"], "goal_after": ["exists z0 : U, Rstar U R y z0 /\\ Rstar U R x z0"], "proof_term_before": ["((fun (U : Type) (R : Relation U) =>\n  ?Goal\n  :\n  Symmetric U (fun x y : U => exists z : U, Rstar U R x z /\\ Rstar U R y z))\n :\n forall (U : Type) (R : Relation U), Symmetric U (coherent U R))"], "proof_term_after": ["((fun (U : Type) (R : Relation U) =>\n  (fun (x y : U) (h : exists z : U, Rstar U R x z /\\ Rstar U R y z) =>\n   ex_ind\n     (fun (z : U) (h0 : Rstar U R x z /\\ Rstar U R y z) =>\n      and_ind (fun (H' : Rstar U R x z) (H'0 : Rstar U R y z) => ?Goal) h0) h)\n  :\n  Symmetric U (fun x y : U => exists z : U, Rstar U R x z /\\ Rstar U R y z))\n :\n forall (U : Type) (R : Relation U), Symmetric U (coherent U R))"]}, {"text": "exists z; auto.", "goal_before": ["exists z0 : U, Rstar U R y z0 /\\ Rstar U R x z0"], "goal_after": [], "proof_term_before": ["((fun (U : Type) (R : Relation U) =>\n  (fun (x y : U) (h : exists z : U, Rstar U R x z /\\ Rstar U R y z) =>\n   ex_ind\n     (fun (z : U) (h0 : Rstar U R x z /\\ Rstar U R y z) =>\n      and_ind (fun (H' : Rstar U R x z) (H'0 : Rstar U R y z) => ?Goal) h0) h)\n  :\n  Symmetric U (fun x y : U => exists z : U, Rstar U R x z /\\ Rstar U R y z))\n :\n forall (U : Type) (R : Relation U), Symmetric U (coherent U R))"], "proof_term_after": ["((fun (U : Type) (R : Relation U) =>\n  (fun (x y : U) (h : exists z : U, Rstar U R x z /\\ Rstar U R y z) =>\n   ex_ind\n     (fun (z : U) (h0 : Rstar U R x z /\\ Rstar U R y z) =>\n      and_ind\n        (fun (H' : Rstar U R x z) (H'0 : Rstar U R y z) =>\n         ex_intro (fun z0 : U => Rstar U R y z0 /\\ Rstar U R x z0) z\n           (conj H'0 H')) h0) h)\n  :\n  Symmetric U (fun x y : U => exists z : U, Rstar U R x z /\\ Rstar U R y z))\n :\n forall (U : Type) (R : Relation U), Symmetric U (coherent U R))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (U : Type) (R : Relation U) =>\n  (fun (x y : U) (h : exists z : U, Rstar U R x z /\\ Rstar U R y z) =>\n   ex_ind\n     (fun (z : U) (h0 : Rstar U R x z /\\ Rstar U R y z) =>\n      and_ind\n        (fun (H' : Rstar U R x z) (H'0 : Rstar U R y z) =>\n         ex_intro (fun z0 : U => Rstar U R y z0 /\\ Rstar U R x z0) z\n           (conj H'0 H')) h0) h)\n  :\n  Symmetric U (fun x y : U => exists z : U, Rstar U R x z /\\ Rstar U R y z))\n :\n forall (U : Type) (R : Relation U), Symmetric U (coherent U R))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_3_facts.v", "name": "Strong_confluence", "text": "Theorem Strong_confluence :\n forall (U : Type) (R : Relation U), Strongly_confluent U R -> Confluent U R.\nintros U R H'; red in |- *.\nintro x; red in |- *; intros a b H'0.\nunfold coherent at 1 in |- *.\ngeneralize b; clear b.\nelim H'0; clear H'0.\nintros x0 b H'1; exists b; auto.\nintros x0 y z H'1 H'2 H'3 b H'4.\ngeneralize (Lemma1 U R); intro h; lapply h;\n [ intro H'0; generalize (H'0 x0 b); intro h0; lapply h0;\n    [ intro H'5; generalize (H'5 y); intro h1; lapply h1;\n       [ intro h2; elim h2; intros z0 h3; elim h3; intros H'6 H'7;\n          clear h h0 h1 h2 h3\n       | clear h h0 h1 ]\n    | clear h h0 ]\n | clear h ]; auto.\ngeneralize (H'3 z0); intro h; lapply h;\n [ intro h0; elim h0; intros z1 h1; elim h1; intros H'8 H'9; clear h h0 h1\n | clear h ]; auto.\nexists z1; split; auto.\napply Rstar_n with z0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Strongly_confluent U R -> Confluent U R.", "proof": "\nintros U R H'; red in |- *.\nintro x; red in |- *; intros a b H'0.\nunfold coherent at 1 in |- *.\ngeneralize b; clear b.\nelim H'0; clear H'0.\nintros x0 b H'1; exists b; auto.\nintros x0 y z H'1 H'2 H'3 b H'4.\ngeneralize (Lemma1 U R); intro h; lapply h;\n [ intro H'0; generalize (H'0 x0 b); intro h0; lapply h0;\n    [ intro H'5; generalize (H'5 y); intro h1; lapply h1;\n       [ intro h2; elim h2; intros z0 h3; elim h3; intros H'6 H'7;\n          clear h h0 h1 h2 h3\n       | clear h h0 h1 ]\n    | clear h h0 ]\n | clear h ]; auto.\ngeneralize (H'3 z0); intro h; lapply h;\n [ intro h0; elim h0; intros z1 h1; elim h1; intros H'8 H'9; clear h h0 h1\n | clear h ]; auto.\nexists z1; split; auto.\napply Rstar_n with z0; auto.\n", "def_ranges": [30, 0, 31, 77], "proof_ranges": [32, 0, 52, 4], "proof_steps": [{"text": "intros U R H'; red in |- *.", "goal_before": ["forall (U : Type) (R : Relation U), Strongly_confluent U R -> Confluent U R"], "goal_after": ["forall x : U, confluent U R x"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n ?Goal : Confluent U R)"]}, {"text": "intro x; red in |- *; intros a b H'0.", "goal_before": ["forall x : U, confluent U R x"], "goal_after": ["Rstar U R x b -> coherent U R a b"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n ?Goal : Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) => ?Goal) : confluent U R x)\n :\n Confluent U R)"]}, {"text": "unfold coherent at 1 in |- *.", "goal_before": ["Rstar U R x b -> coherent U R a b"], "goal_after": ["Rstar U R x b -> exists z : U, Rstar U R a z /\\ Rstar U R b z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) => ?Goal) : confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   ?Goal : Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "generalize b; clear b.", "goal_before": ["Rstar U R x b -> exists z : U, Rstar U R a z /\\ Rstar U R b z"], "goal_after": ["forall b : U, Rstar U R x b -> exists z : U, Rstar U R a z /\\ Rstar U R b z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   ?Goal : Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   ?Goal b : Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "elim H'0; clear H'0.", "goal_before": ["forall b : U, Rstar U R x b -> exists z : U, Rstar U R a z /\\ Rstar U R b z"], "goal_after": ["forall x0 b : U,\nRstar U R x0 b -> exists z : U, Rstar U R x0 z /\\ Rstar U R b z", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   ?Goal b : Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     ?Goal ?Goal0 x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "intros x0 b H'1; exists b; auto.", "goal_before": ["forall x0 b : U,\nRstar U R x0 b -> exists z : U, Rstar U R x0 z /\\ Rstar U R b z", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     ?Goal ?Goal0 x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "intros x0 y z H'1 H'2 H'3 b H'4.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "generalize (Lemma1 U R); intro h; lapply h;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": []}, {"text": "[ intro H'0; generalize (H'0 x0 b); intro h0; lapply h0;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'5; generalize (H'5 y); intro h1; lapply h1;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h2; elim h2; intros z0 h3; elim h3; intros H'6 H'7;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h h0 h1 h2 h3", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h h0 h1 ]", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h h0 ]", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'3 z0); intro h; lapply h;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_3_facts.v", "name": "Strong_confluence_direct", "text": "Theorem Strong_confluence_direct :\n forall (U : Type) (R : Relation U), Strongly_confluent U R -> Confluent U R.\nintros U R H'; red in |- *.\nintro x; red in |- *; intros a b H'0.\nunfold coherent at 1 in |- *.\ngeneralize b; clear b.\nelim H'0; clear H'0.\nintros x0 b H'1; exists b; auto.\nintros x0 y z H'1 H'2 H'3 b H'4.\ncut (exists t : U, Rstar U R y t /\\ R b t).\nintro h; elim h; intros t h0; elim h0; intros H'0 H'5; clear h h0.\ngeneralize (H'3 t); intro h; lapply h;\n [ intro h0; elim h0; intros z0 h1; elim h1; intros H'6 H'7; clear h h0 h1\n | clear h ]; auto.\nexists z0; split; [ assumption | idtac ].\napply Rstar_n with t; auto.\ngeneralize H'1; generalize y; clear H'1.\nelim H'4.\nintros x1 y0 H'0; exists y0; auto.\nintros x1 y0 z0 H'0 H'1 H'5 y1 H'6.\nred in H'.\ngeneralize (H' x1 y0 y1); intro h; lapply h;\n [ intro H'7; lapply H'7;\n    [ intro h0; elim h0; intros z1 h1; elim h1; intros H'8 H'9;\n       clear h H'7 h0 h1\n    | clear h ]\n | clear h ]; auto.\ngeneralize (H'5 z1); intro h; lapply h;\n [ intro h0; elim h0; intros t h1; elim h1; intros H'7 H'10; clear h h0 h1\n | clear h ]; auto.\nexists t; split; auto.\napply Rstar_n with z1; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Strongly_confluent U R -> Confluent U R.", "proof": "\nintros U R H'; red in |- *.\nintro x; red in |- *; intros a b H'0.\nunfold coherent at 1 in |- *.\ngeneralize b; clear b.\nelim H'0; clear H'0.\nintros x0 b H'1; exists b; auto.\nintros x0 y z H'1 H'2 H'3 b H'4.\ncut (exists t : U, Rstar U R y t /\\ R b t).\nintro h; elim h; intros t h0; elim h0; intros H'0 H'5; clear h h0.\ngeneralize (H'3 t); intro h; lapply h;\n [ intro h0; elim h0; intros z0 h1; elim h1; intros H'6 H'7; clear h h0 h1\n | clear h ]; auto.\nexists z0; split; [ assumption | idtac ].\napply Rstar_n with t; auto.\ngeneralize H'1; generalize y; clear H'1.\nelim H'4.\nintros x1 y0 H'0; exists y0; auto.\nintros x1 y0 z0 H'0 H'1 H'5 y1 H'6.\nred in H'.\ngeneralize (H' x1 y0 y1); intro h; lapply h;\n [ intro H'7; lapply H'7;\n    [ intro h0; elim h0; intros z1 h1; elim h1; intros H'8 H'9;\n       clear h H'7 h0 h1\n    | clear h ]\n | clear h ]; auto.\ngeneralize (H'5 z1); intro h; lapply h;\n [ intro h0; elim h0; intros t h1; elim h1; intros H'7 H'10; clear h h0 h1\n | clear h ]; auto.\nexists t; split; auto.\napply Rstar_n with z1; auto.\n", "def_ranges": [54, 0, 55, 77], "proof_ranges": [56, 0, 86, 4], "proof_steps": [{"text": "intros U R H'; red in |- *.", "goal_before": ["forall (U : Type) (R : Relation U), Strongly_confluent U R -> Confluent U R"], "goal_after": ["forall x : U, confluent U R x"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n ?Goal : Confluent U R)"]}, {"text": "intro x; red in |- *; intros a b H'0.", "goal_before": ["forall x : U, confluent U R x"], "goal_after": ["Rstar U R x b -> coherent U R a b"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n ?Goal : Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) => ?Goal) : confluent U R x)\n :\n Confluent U R)"]}, {"text": "unfold coherent at 1 in |- *.", "goal_before": ["Rstar U R x b -> coherent U R a b"], "goal_after": ["Rstar U R x b -> exists z : U, Rstar U R a z /\\ Rstar U R b z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) => ?Goal) : confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   ?Goal : Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "generalize b; clear b.", "goal_before": ["Rstar U R x b -> exists z : U, Rstar U R a z /\\ Rstar U R b z"], "goal_after": ["forall b : U, Rstar U R x b -> exists z : U, Rstar U R a z /\\ Rstar U R b z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   ?Goal : Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   ?Goal b : Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "elim H'0; clear H'0.", "goal_before": ["forall b : U, Rstar U R x b -> exists z : U, Rstar U R a z /\\ Rstar U R b z"], "goal_after": ["forall x0 b : U,\nRstar U R x0 b -> exists z : U, Rstar U R x0 z /\\ Rstar U R b z", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   ?Goal b : Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     ?Goal ?Goal0 x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "intros x0 b H'1; exists b; auto.", "goal_before": ["forall x0 b : U,\nRstar U R x0 b -> exists z : U, Rstar U R x0 z /\\ Rstar U R b z", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     ?Goal ?Goal0 x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "intros x0 y z H'1 H'2 H'3 b H'4.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "cut (exists t : U, Rstar U R y t /\\ R b t).", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "intro h; elim h; intros t h0; elim h0; intros H'0 H'5; clear h h0.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "generalize (H'3 t); intro h; lapply h;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros z0 h1; elim h1; intros H'6 H'7; clear h h0 h1", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "| clear h ]; auto.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "exists z0; split; [ assumption | idtac ].", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "apply Rstar_n with t; auto.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "generalize H'1; generalize y; clear H'1.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "elim H'4.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "intros x1 y0 H'0; exists y0; auto.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "intros x1 y0 z0 H'0 H'1 H'5 y1 H'6.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"]}, {"text": "red in H'.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) =>\n (fun x : U =>\n  (fun (a b : U) (H'0 : Rstar U R x a) =>\n   Rstar_ind U R\n     (fun x0 a0 : U =>\n      forall b0 : U,\n      Rstar U R x0 b0 -> exists z : U, Rstar U R a0 z /\\ Rstar U R b0 z)\n     (fun (x0 b0 : U) (H'1 : Rstar U R x0 b0) =>\n      ex_intro (fun z : U => Rstar U R x0 z /\\ Rstar U R b0 z) b0\n        ?Goal0@{b:=b0}) ?Goal x a H'0 b\n   :\n   Rstar U R x b -> coherent U R a b)\n  :\n  confluent U R x)\n :\n Confluent U R)"], "proof_term_after": []}, {"text": "generalize (H' x1 y0 y1); intro h; lapply h;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'7; lapply H'7;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros z1 h1; elim h1; intros H'8 H'9;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h H'7 h0 h1", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'5 z1); intro h; lapply h;", "goal_before": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "goal_after": ["Rstar U R x0 b /\\ Rstar U R b b", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall b : U,\n Rstar U R y b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0) ->\nforall b : U,\nRstar U R x0 b -> exists z0 : U, Rstar U R z z0 /\\ Rstar U R b z0"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_3_facts.v", "name": "Noetherian_contains_Noetherian", "text": "Theorem Noetherian_contains_Noetherian :\n forall (U : Type) (R R' : Relation U),\n Noetherian U R -> contains U R R' -> Noetherian U R'.\nunfold Noetherian in |- *.\nintros U R R' H' H'0 x.\nelim (H' x); auto.\nQed.\n", "definition": "\n forall (U : Type) (R R' : Relation U),\n Noetherian U R -> contains U R R' -> Noetherian U R'.", "proof": "\nunfold Noetherian in |- *.\nintros U R R' H' H'0 x.\nelim (H' x); auto.\n", "def_ranges": [89, 0, 91, 54], "proof_ranges": [92, 0, 95, 4], "proof_steps": [{"text": "unfold Noetherian in |- *.", "goal_before": ["forall (U : Type) (R R' : Relation U),\nNoetherian U R -> contains U R R' -> Noetherian U R'"], "goal_after": ["forall (U : Type) (R R' : Relation U),\n(forall x : U, noetherian U R x) ->\ncontains U R R' -> forall x : U, noetherian U R' x"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall (U : Type) (R R' : Relation U),\n Noetherian U R -> contains U R R' -> Noetherian U R')"]}, {"text": "intros U R R' H' H'0 x.", "goal_before": ["forall (U : Type) (R R' : Relation U),\n(forall x : U, noetherian U R x) ->\ncontains U R R' -> forall x : U, noetherian U R' x"], "goal_after": ["noetherian U R' x"], "proof_term_before": ["(?Goal\n :\n forall (U : Type) (R R' : Relation U),\n Noetherian U R -> contains U R R' -> Noetherian U R')"], "proof_term_after": ["((fun (U : Type) (R R' : Relation U) (H' : forall x : U, noetherian U R x)\n    (H'0 : contains U R R') (x : U) => ?Goal)\n :\n forall (U : Type) (R R' : Relation U),\n Noetherian U R -> contains U R R' -> Noetherian U R')"]}, {"text": "elim (H' x); auto.", "goal_before": ["noetherian U R' x"], "goal_after": ["forall x0 : U,\n(forall y : U, R x0 y -> noetherian U R y) ->\n(forall y : U, R x0 y -> noetherian U R' y) -> noetherian U R' x0"], "proof_term_before": ["((fun (U : Type) (R R' : Relation U) (H' : forall x : U, noetherian U R x)\n    (H'0 : contains U R R') (x : U) => ?Goal)\n :\n forall (U : Type) (R R' : Relation U),\n Noetherian U R -> contains U R R' -> Noetherian U R')"], "proof_term_after": ["((fun (U : Type) (R R' : Relation U) (H' : forall x : U, noetherian U R x)\n    (H'0 : contains U R R') (x : U) =>\n  noetherian_ind U R (fun x0 : U => noetherian U R' x0) ?Goal x (H' x))\n :\n forall (U : Type) (R R' : Relation U),\n Noetherian U R -> contains U R R' -> Noetherian U R')"]}, {"text": "Qed.", "goal_before": ["forall x0 : U,\n(forall y : U, R x0 y -> noetherian U R y) ->\n(forall y : U, R x0 y -> noetherian U R' y) -> noetherian U R' x0"], "goal_after": [], "proof_term_before": ["((fun (U : Type) (R R' : Relation U) (H' : forall x : U, noetherian U R x)\n    (H'0 : contains U R R') (x : U) =>\n  noetherian_ind U R (fun x0 : U => noetherian U R' x0) ?Goal x (H' x))\n :\n forall (U : Type) (R R' : Relation U),\n Noetherian U R -> contains U R R' -> Noetherian U R')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_3_facts.v", "name": "Newman", "text": "Theorem Newman :\n forall (U : Type) (R : Relation U),\n Noetherian U R -> Locally_confluent U R -> Confluent U R.\nintros U R H' H'0; red in |- *; intro x.\nelim (H' x); unfold confluent in |- *.\nintros x0 H'1 H'2 y z H'3 H'4.\ngeneralize (Rstar_cases U R x0 y); intro h; lapply h;\n [ intro h0; elim h0;\n    [ clear h h0; intro h1\n    | intro h1; elim h1; intros u h2; elim h2; intros H'5 H'6;\n       clear h h0 h1 h2 ]\n | clear h ]; auto.\nelim h1; auto.\ngeneralize (Rstar_cases U R x0 z); intro h; lapply h;\n [ intro h0; elim h0;\n    [ clear h h0; intro h1\n    | intro h1; elim h1; intros v h2; elim h2; intros H'7 H'8;\n       clear h h0 h1 h2 ]\n | clear h ]; auto.\nelim h1; generalize coherent_symmetric; intro t; red in t; auto.\nunfold Locally_confluent, locally_confluent, coherent in H'0.\ngeneralize (H'0 x0 u v); intro h; lapply h;\n [ intro H'9; lapply H'9;\n    [ intro h0; elim h0; intros t h1; elim h1; intros H'10 H'11;\n       clear h H'9 h0 h1\n    | clear h ]\n | clear h ]; auto.\nclear H'0.\nunfold coherent at 1 in H'2.\ngeneralize (H'2 u); intro h; lapply h;\n [ intro H'0; generalize (H'0 y t); intro h0; lapply h0;\n    [ intro H'9; lapply H'9;\n       [ intro h1; elim h1; intros y1 h2; elim h2; intros H'12 H'13;\n          clear h h0 H'9 h1 h2\n       | clear h h0 ]\n    | clear h h0 ]\n | clear h ]; auto.\ngeneralize Rstar_transitive; intro T; red in T.\ngeneralize (H'2 v); intro h; lapply h;\n [ intro H'9; generalize (H'9 y1 z); intro h0; lapply h0;\n    [ intro H'14; lapply H'14;\n       [ intro h1; elim h1; intros z1 h2; elim h2; intros H'15 H'16;\n          clear h h0 H'14 h1 h2\n       | clear h h0 ]\n    | clear h h0 ]\n | clear h ]; auto.\nred in |- *; (exists z1; split); auto.\napply T with y1; auto.\napply T with t; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U),\n Noetherian U R -> Locally_confluent U R -> Confluent U R.", "proof": "\nintros U R H' H'0; red in |- *; intro x.\nelim (H' x); unfold confluent in |- *.\nintros x0 H'1 H'2 y z H'3 H'4.\ngeneralize (Rstar_cases U R x0 y); intro h; lapply h;\n [ intro h0; elim h0;\n    [ clear h h0; intro h1\n    | intro h1; elim h1; intros u h2; elim h2; intros H'5 H'6;\n       clear h h0 h1 h2 ]\n | clear h ]; auto.\nelim h1; auto.\ngeneralize (Rstar_cases U R x0 z); intro h; lapply h;\n [ intro h0; elim h0;\n    [ clear h h0; intro h1\n    | intro h1; elim h1; intros v h2; elim h2; intros H'7 H'8;\n       clear h h0 h1 h2 ]\n | clear h ]; auto.\nelim h1; generalize coherent_symmetric; intro t; red in t; auto.\nunfold Locally_confluent, locally_confluent, coherent in H'0.\ngeneralize (H'0 x0 u v); intro h; lapply h;\n [ intro H'9; lapply H'9;\n    [ intro h0; elim h0; intros t h1; elim h1; intros H'10 H'11;\n       clear h H'9 h0 h1\n    | clear h ]\n | clear h ]; auto.\nclear H'0.\nunfold coherent at 1 in H'2.\ngeneralize (H'2 u); intro h; lapply h;\n [ intro H'0; generalize (H'0 y t); intro h0; lapply h0;\n    [ intro H'9; lapply H'9;\n       [ intro h1; elim h1; intros y1 h2; elim h2; intros H'12 H'13;\n          clear h h0 H'9 h1 h2\n       | clear h h0 ]\n    | clear h h0 ]\n | clear h ]; auto.\ngeneralize Rstar_transitive; intro T; red in T.\ngeneralize (H'2 v); intro h; lapply h;\n [ intro H'9; generalize (H'9 y1 z); intro h0; lapply h0;\n    [ intro H'14; lapply H'14;\n       [ intro h1; elim h1; intros z1 h2; elim h2; intros H'15 H'16;\n          clear h h0 H'14 h1 h2\n       | clear h h0 ]\n    | clear h h0 ]\n | clear h ]; auto.\nred in |- *; (exists z1; split); auto.\napply T with y1; auto.\napply T with t; auto.\n", "def_ranges": [97, 0, 99, 58], "proof_ranges": [100, 0, 146, 4], "proof_steps": [{"text": "intros U R H' H'0; red in |- *; intro x.", "goal_before": ["forall (U : Type) (R : Relation U),\nNoetherian U R -> Locally_confluent U R -> Confluent U R"], "goal_after": ["confluent U R x"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) => (fun x : U => ?Goal) : Confluent U R)"]}, {"text": "elim (H' x); unfold confluent in |- *.", "goal_before": ["confluent U R x"], "goal_after": ["forall x0 : U,\n(forall y : U, R x0 y -> noetherian U R y) ->\n(forall y : U,\n R x0 y ->\n forall y0 z : U, Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z) ->\nforall y z : U, Rstar U R x0 y -> Rstar U R x0 z -> coherent U R y z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) => (fun x : U => ?Goal) : Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    (?Goal\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"]}, {"text": "intros x0 H'1 H'2 y z H'3 H'4.", "goal_before": ["forall x0 : U,\n(forall y : U, R x0 y -> noetherian U R y) ->\n(forall y : U,\n R x0 y ->\n forall y0 z : U, Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z) ->\nforall y z : U, Rstar U R x0 y -> Rstar U R x0 z -> coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    (?Goal\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"]}, {"text": "generalize (Rstar_cases U R x0 y); intro h; lapply h;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"], "proof_term_after": []}, {"text": "[ intro h0; elim h0;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ clear h h0; intro h1", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "| intro h1; elim h1; intros u h2; elim h2; intros H'5 H'6;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h h0 h1 h2 ]", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim h1; auto.", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Rstar_cases U R x0 z); intro h; lapply h;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"]}, {"text": "[ intro h0; elim h0;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"]}, {"text": "[ clear h h0; intro h1", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"]}, {"text": "| intro h1; elim h1; intros v h2; elim h2; intros H'7 H'8;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (H'0 : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"], "proof_term_after": []}, {"text": "clear h h0 h1 h2 ]", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim h1; generalize coherent_symmetric; intro t; red in t; auto.", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Locally_confluent, locally_confluent, coherent in H'0.", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'0 x0 u v); intro h; lapply h;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'9; lapply H'9;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros t h1; elim h1; intros H'10 H'11;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h H'9 h0 h1", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (_ : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"]}, {"text": "| clear h ]; auto.", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (_ : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) => \n      ?Goal)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (_ : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) =>\n      (fun\n         T : forall (U0 : Type) (R0 : Relation U0),\n             Transitive U0 (Rstar U0 R0) => ?Goal) Rstar_transitive)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"]}, {"text": "clear H'0.", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Noetherian U R)\n   (_ : Locally_confluent U R) =>\n (fun x : U =>\n  noetherian_ind U R (fun x0 : U => confluent U R x0)\n    ((fun (x0 : U) (H'1 : forall y : U, R x0 y -> noetherian U R y)\n        (H'2 : forall y : U,\n               R x0 y ->\n               forall y0 z : U,\n               Rstar U R y y0 -> Rstar U R y z -> coherent U R y0 z)\n        (y z : U) (H'3 : Rstar U R x0 y) (H'4 : Rstar U R x0 z) =>\n      (fun\n         T : forall (U0 : Type) (R0 : Relation U0),\n             Transitive U0 (Rstar U0 R0) => ?Goal) Rstar_transitive)\n     :\n     forall x0 : U,\n     (forall y : U, R x0 y -> noetherian U R y) ->\n     (forall y : U, R x0 y -> confluent U R y) -> confluent U R x0) x \n    (H' x))\n :\n Confluent U R)"], "proof_term_after": []}, {"text": "unfold coherent at 1 in H'2.", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'2 u); intro h; lapply h;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'0; generalize (H'0 y t); intro h0; lapply h0;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'9; lapply H'9;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h1; elim h1; intros y1 h2; elim h2; intros H'12 H'13;", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h h0 H'9 h1 h2", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h h0 ]", "goal_before": ["coherent U R y z"], "goal_after": ["coherent U R y z"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_1_facts.v", "name": "Rsym_imp_notRsym", "text": "Theorem Rsym_imp_notRsym :\n forall (U : Type) (R : Relation U),\n Symmetric U R -> Symmetric U (Complement U R).\nunfold Symmetric, Complement in |- *.\nintros U R H' x y H'0; red in |- *; intro H'1; apply H'0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U),\n Symmetric U R -> Symmetric U (Complement U R).", "proof": "\nunfold Symmetric, Complement in |- *.\nintros U R H' x y H'0; red in |- *; intro H'1; apply H'0; auto.\n", "def_ranges": [14, 0, 16, 47], "proof_ranges": [17, 0, 19, 4], "proof_steps": [{"text": "unfold Symmetric, Complement in |- *.", "goal_before": ["forall (U : Type) (R : Relation U),\nSymmetric U R -> Symmetric U (Complement U R)"], "goal_after": ["forall (U : Type) (R : Relation U),\n(forall x y : U, R x y -> R y x) -> forall x y : U, ~ R x y -> ~ R y x"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall (U : Type) (R : Relation U),\n Symmetric U R -> Symmetric U (Complement U R))"]}, {"text": "intros U R H' x y H'0; red in |- *; intro H'1; apply H'0; auto.", "goal_before": ["forall (U : Type) (R : Relation U),\n(forall x y : U, R x y -> R y x) -> forall x y : U, ~ R x y -> ~ R y x"], "goal_after": [], "proof_term_before": ["(?Goal\n :\n forall (U : Type) (R : Relation U),\n Symmetric U R -> Symmetric U (Complement U R))"], "proof_term_after": ["((fun (U : Type) (R : Relation U) (H' : forall x y : U, R x y -> R y x)\n    (x y : U) (H'0 : ~ R x y) =>\n  (fun H'1 : R y x => H'0 (H' y x H'1)) : ~ R y x)\n :\n forall (U : Type) (R : Relation U),\n Symmetric U R -> Symmetric U (Complement U R))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (U : Type) (R : Relation U) (H' : forall x y : U, R x y -> R y x)\n    (x y : U) (H'0 : ~ R x y) =>\n  (fun H'1 : R y x => H'0 (H' y x H'1)) : ~ R y x)\n :\n forall (U : Type) (R : Relation U),\n Symmetric U R -> Symmetric U (Complement U R))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_1_facts.v", "name": "Equiv_from_preorder", "text": "Theorem Equiv_from_preorder :\n forall (U : Type) (R : Relation U),\n Preorder U R -> Equivalence U (fun x y : U => R x y /\\ R y x).\nintros U R H'; elim H'; intros H'0 H'1.\napply Definition_of_equivalence.\nred in H'0; auto 10.\n2: red in |- *; intros x y h; elim h; intros H'3 H'4; auto 10.\nred in H'1; red in |- *; auto 10.\nintros x y z h; elim h; intros H'3 H'4; clear h.\nintro h; elim h; intros H'5 H'6; clear h.\nsplit; apply H'1 with y; auto 10.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U),\n Preorder U R -> Equivalence U (fun x y : U => R x y /\\ R y x).", "proof": "\nintros U R H'; elim H'; intros H'0 H'1.\napply Definition_of_equivalence.\nred in H'0; auto 10.\n2: red in |- *; intros x y h; elim h; intros H'3 H'4; auto 10.\nred in H'1; red in |- *; auto 10.\nintros x y z h; elim h; intros H'3 H'4; clear h.\nintro h; elim h; intros H'5 H'6; clear h.\nsplit; apply H'1 with y; auto 10.\n", "def_ranges": [21, 0, 23, 63], "proof_ranges": [24, 0, 32, 4], "proof_steps": [{"text": "intros U R H'; elim H'; intros H'0 H'1.", "goal_before": ["forall (U : Type) (R : Relation U),\nPreorder U R -> Equivalence U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["Equivalence U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) => ?Goal) H')"]}, {"text": "apply Definition_of_equivalence.", "goal_before": ["Equivalence U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["Reflexive U (fun x y : U => R x y /\\ R y x)", "Transitive U (fun x y : U => R x y /\\ R y x)", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) => ?Goal) H')"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x) \n      ?Goal ?Goal0 ?Goal1) H')"]}, {"text": "red in H'0; auto 10.", "goal_before": ["Reflexive U (fun x y : U => R x y /\\ R y x)", "Transitive U (fun x y : U => R x y /\\ R y x)", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["Reflexive U (fun x y : U => R x y /\\ R y x)", "Transitive U (fun x y : U => R x y /\\ R y x)", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x) \n      ?Goal ?Goal0 ?Goal1) H')"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x) \n      ?Goal1 ?Goal ?Goal0) H')"]}, {"text": "2: red in |- *; intros x y h; elim h; intros H'3 H'4; auto 10.", "goal_before": ["Reflexive U (fun x y : U => R x y /\\ R y x)", "Transitive U (fun x y : U => R x y /\\ R y x)", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["Reflexive U (fun x y : U => R x y /\\ R y x)", "Transitive U (fun x y : U => R x y /\\ R y x)", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x) \n      ?Goal1 ?Goal ?Goal0) H')"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x) \n      ?Goal1 ?Goal ?Goal0) H')"]}, {"text": "red in H'1; red in |- *; auto 10.", "goal_before": ["Reflexive U (fun x y : U => R x y /\\ R y x)", "Transitive U (fun x y : U => R x y /\\ R y x)", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["Transitive U (fun x y : U => R x y /\\ R y x)", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x) \n      ?Goal1 ?Goal ?Goal0) H')"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x)\n      ((fun x : U => conj (H'0 x) (H'0 x))\n       :\n       Reflexive U (fun x y : U => R x y /\\ R y x)) \n      ?Goal ?Goal0) H')"]}, {"text": "intros x y z h; elim h; intros H'3 H'4; clear h.", "goal_before": ["Transitive U (fun x y : U => R x y /\\ R y x)", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["R y z /\\ R z y -> R x z /\\ R z x", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x)\n      ((fun x : U => conj (H'0 x) (H'0 x))\n       :\n       Reflexive U (fun x y : U => R x y /\\ R y x)) \n      ?Goal ?Goal0) H')"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x)\n      ((fun x : U => conj (H'0 x) (H'0 x))\n       :\n       Reflexive U (fun x y : U => R x y /\\ R y x))\n      ((fun (x y z : U) (h : R x y /\\ R y x) =>\n        and_ind (fun (H'3 : R x y) (H'4 : R y x) => ?Goal0) h)\n       :\n       Transitive U (fun x y : U => R x y /\\ R y x)) \n      ?Goal) H')"]}, {"text": "intro h; elim h; intros H'5 H'6; clear h.", "goal_before": ["R y z /\\ R z y -> R x z /\\ R z x", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["R x z /\\ R z x", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x)\n      ((fun x : U => conj (H'0 x) (H'0 x))\n       :\n       Reflexive U (fun x y : U => R x y /\\ R y x))\n      ((fun (x y z : U) (h : R x y /\\ R y x) =>\n        and_ind (fun (H'3 : R x y) (H'4 : R y x) => ?Goal0) h)\n       :\n       Transitive U (fun x y : U => R x y /\\ R y x)) \n      ?Goal) H')"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x)\n      ((fun x : U => conj (H'0 x) (H'0 x))\n       :\n       Reflexive U (fun x y : U => R x y /\\ R y x))\n      ((fun (x y z : U) (h : R x y /\\ R y x) =>\n        and_ind\n          (fun (H'3 : R x y) (H'4 : R y x) (h0 : R y z /\\ R z y) =>\n           and_ind (fun (H'5 : R y z) (H'6 : R z y) => ?Goal0) h0) h)\n       :\n       Transitive U (fun x y : U => R x y /\\ R y x)) \n      ?Goal) H')"]}, {"text": "split; apply H'1 with y; auto 10.", "goal_before": ["R x z /\\ R z x", "Symmetric U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["Symmetric U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x)\n      ((fun x : U => conj (H'0 x) (H'0 x))\n       :\n       Reflexive U (fun x y : U => R x y /\\ R y x))\n      ((fun (x y z : U) (h : R x y /\\ R y x) =>\n        and_ind\n          (fun (H'3 : R x y) (H'4 : R y x) (h0 : R y z /\\ R z y) =>\n           and_ind (fun (H'5 : R y z) (H'6 : R z y) => ?Goal0) h0) h)\n       :\n       Transitive U (fun x y : U => R x y /\\ R y x)) \n      ?Goal) H')"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x)\n      ((fun x : U => conj (H'0 x) (H'0 x))\n       :\n       Reflexive U (fun x y : U => R x y /\\ R y x))\n      ((fun (x y z : U) (h : R x y /\\ R y x) =>\n        and_ind\n          (fun (H'3 : R x y) (H'4 : R y x) (h0 : R y z /\\ R z y) =>\n           and_ind\n             (fun (H'5 : R y z) (H'6 : R z y) =>\n              conj (H'1 x y z H'3 H'5) (H'1 z y x H'6 H'4)) h0) h)\n       :\n       Transitive U (fun x y : U => R x y /\\ R y x)) \n      ?Goal) H')"]}, {"text": "Qed.", "goal_before": ["Symmetric U (fun x y : U => R x y /\\ R y x)"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Preorder U R) =>\n Preorder_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x))\n   (fun (H'0 : Reflexive U R) (H'1 : Transitive U R) =>\n    Definition_of_equivalence U (fun x y : U => R x y /\\ R y x)\n      ((fun x : U => conj (H'0 x) (H'0 x))\n       :\n       Reflexive U (fun x y : U => R x y /\\ R y x))\n      ((fun (x y z : U) (h : R x y /\\ R y x) =>\n        and_ind\n          (fun (H'3 : R x y) (H'4 : R y x) (h0 : R y z /\\ R z y) =>\n           and_ind\n             (fun (H'5 : R y z) (H'6 : R z y) =>\n              conj (H'1 x y z H'3 H'5) (H'1 z y x H'6 H'4)) h0) h)\n       :\n       Transitive U (fun x y : U => R x y /\\ R y x)) \n      ?Goal) H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_1_facts.v", "name": "Equiv_from_order", "text": "Theorem Equiv_from_order :\n forall (U : Type) (R : Relation U),\n Order U R -> Equivalence U (fun x y : U => R x y /\\ R y x).\nintros U R H'; elim H'; auto 10.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U),\n Order U R -> Equivalence U (fun x y : U => R x y /\\ R y x).", "proof": "\nintros U R H'; elim H'; auto 10.\n", "def_ranges": [35, 0, 37, 60], "proof_ranges": [38, 0, 39, 4], "proof_steps": [{"text": "intros U R H'; elim H'; auto 10.", "goal_before": ["forall (U : Type) (R : Relation U),\nOrder U R -> Equivalence U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["Reflexive U R ->\nTransitive U R ->\nAntisymmetric U R -> Equivalence U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n Order_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x)) ?Goal H')"]}, {"text": "Qed.", "goal_before": ["Reflexive U R ->\nTransitive U R ->\nAntisymmetric U R -> Equivalence U (fun x y : U => R x y /\\ R y x)"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n Order_ind U R (Equivalence U (fun x y : U => R x y /\\ R y x)) ?Goal H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_1_facts.v", "name": "contains_is_preorder", "text": "Theorem contains_is_preorder :\n forall U : Type, Preorder (Relation U) (contains U).\nauto 10.\nQed.\n", "definition": "\n forall U : Type, Preorder (Relation U) (contains U).", "proof": "\nauto 10.\n", "def_ranges": [42, 0, 43, 53], "proof_ranges": [44, 0, 45, 4], "proof_steps": [{"text": "auto 10.", "goal_before": ["forall U : Type, Preorder (Relation U) (contains U)"], "goal_after": ["forall U : Type, Preorder (Relation U) (contains U)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall U : Type, Preorder (Relation U) (contains U)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_1_facts.v", "name": "same_relation_is_equivalence", "text": "Theorem same_relation_is_equivalence :\n forall U : Type, Equivalence (Relation U) (same_relation U).\nunfold same_relation at 1 in |- *; auto 10.\nQed.\n", "definition": "\n forall U : Type, Equivalence (Relation U) (same_relation U).", "proof": "\nunfold same_relation at 1 in |- *; auto 10.\n", "def_ranges": [48, 0, 49, 61], "proof_ranges": [50, 0, 51, 4], "proof_steps": [{"text": "unfold same_relation at 1 in |- *; auto 10.", "goal_before": ["forall U : Type, Equivalence (Relation U) (same_relation U)"], "goal_after": ["forall U : Type,\nEquivalence (Relation U)\n  (fun R R' : Relation U => contains U R R' /\\ contains U R' R)"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall U : Type, Equivalence (Relation U) (same_relation U))"]}, {"text": "Qed.", "goal_before": ["forall U : Type,\nEquivalence (Relation U)\n  (fun R R' : Relation U => contains U R R' /\\ contains U R' R)"], "goal_after": [], "proof_term_before": ["(?Goal : forall U : Type, Equivalence (Relation U) (same_relation U))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Rel_of_reflexive", "text": "Theorem Rel_of_reflexive : forall x : U, Rel_of U D x x.\n   elim D; simpl in |- *; auto.\n   intros C R H' H'0; elim H'0; auto 10.\n   Qed.\n", "definition": " forall x : U, Rel_of U D x x.", "proof": "\n   elim D; simpl in |- *; auto.\n   intros C R H' H'0; elim H'0; auto 10.\n   ", "def_ranges": [28, 0, 28, 59], "proof_ranges": [29, 0, 31, 7], "proof_steps": [{"text": "elim D; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros C R H' H'0; elim H'0; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Rel_of_antisymmetric", "text": "Theorem Rel_of_antisymmetric : Antisymmetric U (Rel_of U D).\n   elim D; simpl in |- *; auto.\n   intros C R H' H'0; elim H'0; auto 10.\n   Qed.\n", "definition": " Antisymmetric U (Rel_of U D).", "proof": "\n   elim D; simpl in |- *; auto.\n   intros C R H' H'0; elim H'0; auto 10.\n   ", "def_ranges": [34, 0, 34, 63], "proof_ranges": [35, 0, 37, 7], "proof_steps": [{"text": "elim D; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros C R H' H'0; elim H'0; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Rel_of_transitive", "text": "Theorem Rel_of_transitive : Transitive U (Rel_of U D).\n   elim D; simpl in |- *; auto.\n   intros C R H' H'0; elim H'0; auto 10.\n   Qed.\n", "definition": " Transitive U (Rel_of U D).", "proof": "\n   elim D; simpl in |- *; auto.\n   intros C R H' H'0; elim H'0; auto 10.\n   ", "def_ranges": [40, 0, 40, 57], "proof_ranges": [41, 0, 43, 7], "proof_steps": [{"text": "elim D; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros C R H' H'0; elim H'0; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Couple_included_in_carrier", "text": "Theorem Couple_included_in_carrier :\n    forall x y : U,\n    In U (Carrier_of U D) x ->\n    In U (Carrier_of U D) y -> Included U (Couple U x y) (Carrier_of U D).\n   intros x y H' H'0; red in |- *; auto 20.\n   intros x0 H'1; elim H'1; auto 20.\n   Qed.\n", "definition": "\n    forall x y : U,\n    In U (Carrier_of U D) x ->\n    In U (Carrier_of U D) y -> Included U (Couple U x y) (Carrier_of U D).", "proof": "\n   intros x y H' H'0; red in |- *; auto 20.\n   intros x0 H'1; elim H'1; auto 20.\n   ", "def_ranges": [46, 0, 49, 74], "proof_ranges": [50, 0, 52, 7], "proof_steps": [{"text": "intros x y H' H'0; red in |- *; auto 20.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'1; elim H'1; auto 20.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Lub_is_in_Carrier", "text": "Theorem Lub_is_in_Carrier :\n    forall (bsup : U) (X : Ensemble U),\n    Included U X (Carrier_of U D) ->\n    Lub U D X bsup -> In U (Carrier_of U D) bsup.\n   intros bsup X H' H'0; elim H'0; auto 20.\n   intro H'1; elim H'1; auto 20.\n   Qed.\n", "definition": "\n    forall (bsup : U) (X : Ensemble U),\n    Included U X (Carrier_of U D) ->\n    Lub U D X bsup -> In U (Carrier_of U D) bsup.", "proof": "\n   intros bsup X H' H'0; elim H'0; auto 20.\n   intro H'1; elim H'1; auto 20.\n   ", "def_ranges": [55, 0, 58, 49], "proof_ranges": [59, 0, 61, 7], "proof_steps": [{"text": "intros bsup X H' H'0; elim H'0; auto 20.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'1; elim H'1; auto 20.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Singleton_has_lub", "text": "Theorem Singleton_has_lub :\n    forall x : U, In U (Carrier_of U D) x -> Lub U D (Singleton U x) x.\n   intros x H'; auto 20.\n   apply Lub_definition; auto 10.\n   apply Upper_Bound_definition; auto 10.\n   intros y H'0; elim H'0; auto 10.\n   intros y H'0; elim H'0; auto 10.\n   Qed.\n", "definition": "\n    forall x : U, In U (Carrier_of U D) x -> Lub U D (Singleton U x) x.", "proof": "\n   intros x H'; auto 20.\n   apply Lub_definition; auto 10.\n   apply Upper_Bound_definition; auto 10.\n   intros y H'0; elim H'0; auto 10.\n   intros y H'0; elim H'0; auto 10.\n   ", "def_ranges": [63, 0, 64, 71], "proof_ranges": [65, 0, 70, 7], "proof_steps": [{"text": "intros x H'; auto 20.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lub_definition; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'0; elim H'0; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'0; elim H'0; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Empty_set_has_Upper_Bound", "text": "Theorem Empty_set_has_Upper_Bound :\n    exists maj : U, Upper_Bound U D (Empty_set U) maj.\n   elim D.\n   intros C R n o.\n   elim n.\n   intros x H'; exists x.\n   apply Upper_Bound_definition; auto.\n   intros y H'0; elim H'0; auto.\n   Qed.\n", "definition": "\n    exists maj : U, Upper_Bound U D (Empty_set U) maj.", "proof": "\n   elim D.\n   intros C R n o.\n   elim n.\n   intros x H'; exists x.\n   apply Upper_Bound_definition; auto.\n   intros y H'0; elim H'0; auto.\n   ", "def_ranges": [73, 0, 74, 54], "proof_ranges": [75, 0, 81, 7], "proof_steps": [{"text": "elim D.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros C R n o.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H'; exists x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'0; elim H'0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Empty_set_has_lub", "text": "Theorem Empty_set_has_lub :\n    Cpo U D -> exists bsup : U, Lub U D (Empty_set U) bsup.\n   intro H'; elim H'.\n   intro h; elim h; intros bot E; clear h.\n   intro H'0; exists bot.\n   apply Lub_definition.\n   apply Upper_Bound_definition.\n   elim E; auto.\n   intros y H'1; elim H'1; auto.\n   intros y H'1; elim H'1; auto.\n   elim E; auto.\n   Qed.\n", "definition": "\n    Cpo U D -> exists bsup : U, Lub U D (Empty_set U) bsup.", "proof": "\n   intro H'; elim H'.\n   intro h; elim h; intros bot E; clear h.\n   intro H'0; exists bot.\n   apply Lub_definition.\n   apply Upper_Bound_definition.\n   elim E; auto.\n   intros y H'1; elim H'1; auto.\n   intros y H'1; elim H'1; auto.\n   elim E; auto.\n   ", "def_ranges": [84, 0, 85, 59], "proof_ranges": [86, 0, 95, 7], "proof_steps": [{"text": "intro H'; elim H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro h; elim h; intros bot E; clear h.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'0; exists bot.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lub_definition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'1; elim H'1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'1; elim H'1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Upper_downward_stable", "text": "Theorem Upper_downward_stable :\n    forall (A B : Ensemble U) (maj : U),\n    Included U A (Carrier_of U D) ->\n    Included U B (Carrier_of U D) ->\n    Included U A B -> Upper_Bound U D B maj -> Upper_Bound U D A maj.\n   clear B.\n   intros A BB maj H' H'0 H'1 H'2; elim H'2; auto.\n   Qed.\n", "definition": "\n    forall (A B : Ensemble U) (maj : U),\n    Included U A (Carrier_of U D) ->\n    Included U B (Carrier_of U D) ->\n    Included U A B -> Upper_Bound U D B maj -> Upper_Bound U D A maj.", "proof": "\n   clear B.\n   intros A BB maj H' H'0 H'1 H'2; elim H'2; auto.\n   ", "def_ranges": [98, 0, 102, 69], "proof_ranges": [103, 0, 105, 7], "proof_steps": [{"text": "clear B.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A BB maj H' H'0 H'1 H'2; elim H'2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Conditionally_complete_has_a_bottom", "text": "Theorem Conditionally_complete_has_a_bottom :\n    Conditionally_complete U D -> exists bot : U, Bottom U D bot.\n   intro H'; elim H'; auto 10.\n   intro H'0; generalize (H'0 (Empty_set U)); intro h; lapply h;\n    [ intro H'1; lapply H'1;\n       [ intro h0; elim h0; intros bsup E; clear h H'1 h0; elim E | clear h ]\n    | clear h ]; auto 10.\n   intros H'1 H'2; exists bsup; apply Bottom_definition; auto 10.\n   elim H'1; auto 10.\n   intros y H'3; try assumption; auto 10.\n   apply H'2; auto 10.\n   apply Upper_Bound_definition; auto 10.\n   intros y0 H'4; elim H'4; auto 10.\n   Qed.\n", "definition": "\n    Conditionally_complete U D -> exists bot : U, Bottom U D bot.", "proof": "\n   intro H'; elim H'; auto 10.\n   intro H'0; generalize (H'0 (Empty_set U)); intro h; lapply h;\n    [ intro H'1; lapply H'1;\n       [ intro h0; elim h0; intros bsup E; clear h H'1 h0; elim E | clear h ]\n    | clear h ]; auto 10.\n   intros H'1 H'2; exists bsup; apply Bottom_definition; auto 10.\n   elim H'1; auto 10.\n   intros y H'3; try assumption; auto 10.\n   apply H'2; auto 10.\n   apply Upper_Bound_definition; auto 10.\n   intros y0 H'4; elim H'4; auto 10.\n   ", "def_ranges": [107, 0, 108, 65], "proof_ranges": [109, 0, 120, 7], "proof_steps": [{"text": "intro H'; elim H'; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'0; generalize (H'0 (Empty_set U)); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'1; lapply H'1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros bsup E; clear h H'1 h0; elim E | clear h ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'1 H'2; exists bsup; apply Bottom_definition; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'1; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'3; try assumption; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H'2; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Compatible_is_reflexive", "text": "Theorem Compatible_is_reflexive : Reflexive U (Compatible U D).\n   red in |- *; intro x; red in |- *.\n   exists x; intros H' H'0; split; [ idtac | apply Upper_Bound_definition ];\n    auto.\n   intros y H'1; elim H'1; auto.\n   Qed.\n", "definition": " Reflexive U (Compatible U D).", "proof": "\n   red in |- *; intro x; red in |- *.\n   exists x; intros H' H'0; split; [ idtac | apply Upper_Bound_definition ];\n    auto.\n   intros y H'1; elim H'1; auto.\n   ", "def_ranges": [123, 0, 123, 66], "proof_ranges": [124, 0, 128, 7], "proof_steps": [{"text": "red in |- *; intro x; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; intros H' H'0; split; [ idtac | apply Upper_Bound_definition ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'1; elim H'1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Couple_is_symmetric", "text": "Theorem Couple_is_symmetric :\n    forall x y : U, Couple U x y = Couple U y x :>Ensemble U.\n   intros x y; apply Extensionality_Ensembles; apply Same_set_intro;\n    red in |- *; (intros x0 H'; elim H'); auto 10.\n   Qed.\n", "definition": "\n    forall x y : U, Couple U x y = Couple U y x :>Ensemble U.", "proof": "\n   intros x y; apply Extensionality_Ensembles; apply Same_set_intro;\n    red in |- *; (intros x0 H'; elim H'); auto 10.\n   ", "def_ranges": [130, 0, 131, 61], "proof_ranges": [132, 0, 134, 7], "proof_steps": [{"text": "intros x y; apply Extensionality_Ensembles; apply Same_set_intro;", "goal_before": ["forall x y : U, Couple U x y = Couple U y x"], "goal_after": ["forall x y : U, Couple U x y = Couple U y x"], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; (intros x0 H'; elim H'); auto 10.", "goal_before": ["forall x y : U, Couple U x y = Couple U y x"], "goal_after": ["forall x y : U, Couple U x y = Couple U y x"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Partial_order_facts.v", "name": "Compatible_is_symmetric", "text": "Theorem Compatible_is_symmetric : Symmetric U (Compatible U D).\n   red in |- *; unfold Compatible in |- *.\n   intros x y h; elim h; intros z E; clear h.\n   elim Couple_is_symmetric; exists z; auto.\n   Qed.\n", "definition": " Symmetric U (Compatible U D).", "proof": "\n   red in |- *; unfold Compatible in |- *.\n   intros x y h; elim h; intros z E; clear h.\n   elim Couple_is_symmetric; exists z; auto.\n   ", "def_ranges": [136, 0, 136, 66], "proof_ranges": [137, 0, 140, 7], "proof_steps": [{"text": "red in |- *; unfold Compatible in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x y h; elim h; intros z E; clear h.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim Couple_is_symmetric; exists z; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "trivial", "text": "Theorem trivial : forall A : Prop, A -> A.\nauto.\nQed.\n", "definition": " forall A : Prop, A -> A.", "proof": "\nauto.\n", "def_ranges": [9, 0, 9, 42], "proof_ranges": [10, 0, 11, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall A : Prop, A -> A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (A : Prop) (H : A) => H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A : Prop) (H : A) => H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "and_commutative", "text": "Theorem and_commutative : forall A B : Prop, A /\\ B -> B /\\ A.\nintros A B H'; elim H'; auto.\nQed.\n", "definition": " forall A B : Prop, A /\\ B -> B /\\ A.", "proof": "\nintros A B H'; elim H'; auto.\n", "def_ranges": [13, 0, 13, 62], "proof_ranges": [14, 0, 15, 4], "proof_steps": [{"text": "intros A B H'; elim H'; auto.", "goal_before": ["forall A B : Prop, A /\\ B -> B /\\ A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (A B : Prop) (H' : A /\\ B) =>\n and_ind (fun (H : A) (H0 : B) => conj H0 H) H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (H' : A /\\ B) =>\n and_ind (fun (H : A) (H0 : B) => conj H0 H) H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "or_commutative", "text": "Theorem or_commutative : forall A B : Prop, A \\/ B -> B \\/ A.\nintros A B H'; elim H'; auto.\nQed.\n", "definition": " forall A B : Prop, A \\/ B -> B \\/ A.", "proof": "\nintros A B H'; elim H'; auto.\n", "def_ranges": [17, 0, 17, 61], "proof_ranges": [18, 0, 19, 4], "proof_steps": [{"text": "intros A B H'; elim H'; auto.", "goal_before": ["forall A B : Prop, A \\/ B -> B \\/ A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (A B : Prop) (H' : A \\/ B) =>\n or_ind (fun H : A => or_intror H) (fun H : B => or_introl H) H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (H' : A \\/ B) =>\n or_ind (fun H : A => or_intror H) (fun H : B => or_introl H) H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "mp", "text": "Theorem mp : forall A B : Prop, A -> (A -> B) -> B.\nauto.\nQed.\n", "definition": " forall A B : Prop, A -> (A -> B) -> B.", "proof": "\nauto.\n", "def_ranges": [21, 0, 21, 51], "proof_ranges": [22, 0, 23, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall A B : Prop, A -> (A -> B) -> B"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (A B : Prop) (H : A) (H0 : A -> B) => H0 H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (H : A) (H0 : A -> B) => H0 H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "S", "text": "Theorem S : forall A B C : Prop, (A -> B -> C) -> (A -> B) -> A -> C.\nauto.\nQed.\n", "definition": " forall A B C : Prop, (A -> B -> C) -> (A -> B) -> A -> C.", "proof": "\nauto.\n", "def_ranges": [25, 0, 25, 69], "proof_ranges": [26, 0, 27, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall A B C : Prop, (A -> B -> C) -> (A -> B) -> A -> C"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (A B C : Prop) (H : A -> B -> C) (H0 : A -> B) (H1 : A) => H H1 (H0 H1))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B C : Prop) (H : A -> B -> C) (H0 : A -> B) (H1 : A) => H H1 (H0 H1))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "Praeclarum", "text": "Theorem Praeclarum :\n forall x y z t : Prop, (x -> z) /\\ (y -> t) -> x /\\ y -> z /\\ t.\nintros x y z t H'; elim H'.\nintros H'0 H'1 H'2; elim H'2.\nauto.\nQed.\n", "definition": "\n forall x y z t : Prop, (x -> z) /\\ (y -> t) -> x /\\ y -> z /\\ t.", "proof": "\nintros x y z t H'; elim H'.\nintros H'0 H'1 H'2; elim H'2.\nauto.\n", "def_ranges": [29, 0, 30, 65], "proof_ranges": [31, 0, 34, 4], "proof_steps": [{"text": "intros x y z t H'; elim H'.", "goal_before": ["forall x y z t : Prop, (x -> z) /\\ (y -> t) -> x /\\ y -> z /\\ t"], "goal_after": ["(x -> z) -> (y -> t) -> x /\\ y -> z /\\ t"], "proof_term_before": [], "proof_term_after": ["(fun (x y z t : Prop) (H' : (x -> z) /\\ (y -> t)) => and_ind ?Goal H')"]}, {"text": "intros H'0 H'1 H'2; elim H'2.", "goal_before": ["(x -> z) -> (y -> t) -> x /\\ y -> z /\\ t"], "goal_after": ["x -> y -> z /\\ t"], "proof_term_before": ["(fun (x y z t : Prop) (H' : (x -> z) /\\ (y -> t)) => and_ind ?Goal H')"], "proof_term_after": ["(fun (x y z t : Prop) (H' : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H'0 : x -> z) (H'1 : y -> t) (H'2 : x /\\ y) => and_ind ?Goal H'2) H')"]}, {"text": "auto.", "goal_before": ["x -> y -> z /\\ t"], "goal_after": [], "proof_term_before": ["(fun (x y z t : Prop) (H' : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H'0 : x -> z) (H'1 : y -> t) (H'2 : x /\\ y) => and_ind ?Goal H'2) H')"], "proof_term_after": ["(fun (x y z t : Prop) (H' : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H'0 : x -> z) (H'1 : y -> t) (H'2 : x /\\ y) =>\n    and_ind (fun (H : x) (H0 : y) => conj (H'0 H) (H'1 H0)) H'2) H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y z t : Prop) (H' : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H'0 : x -> z) (H'1 : y -> t) (H'2 : x /\\ y) =>\n    and_ind (fun (H : x) (H0 : y) => conj (H'0 H) (H'1 H0)) H'2) H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "resolution", "text": "Theorem resolution :\n forall (p q : Type -> Prop) (a : Type),\n p a -> (forall x : Type, p x -> q x) -> q a.\nauto.\nQed.\n", "definition": "\n forall (p q : Type -> Prop) (a : Type),\n p a -> (forall x : Type, p x -> q x) -> q a.", "proof": "\nauto.\n", "def_ranges": [36, 0, 38, 45], "proof_ranges": [39, 0, 40, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall (p q : Type -> Prop) (a : Type),\np a -> (forall x : Type, p x -> q x) -> q a"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (p q : Type -> Prop) (a : Type) (H : p a)\n   (H0 : forall x : Type, p x -> q x) => H0 a H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (p q : Type -> Prop) (a : Type) (H : p a)\n   (H0 : forall x : Type, p x -> q x) => H0 a H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "Witnesses", "text": "Theorem Witnesses :\n forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x.\nintros a b p h; elim h;\n [ intro H'; clear h; try exact H' | clear h; intro H' ].\nexists a; try assumption.\nexists b; try assumption.\nQed.\n", "definition": "\n forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x.", "proof": "\nintros a b p h; elim h;\n [ intro H'; clear h; try exact H' | clear h; intro H' ].\nexists a; try assumption.\nexists b; try assumption.\n", "def_ranges": [42, 0, 43, 76], "proof_ranges": [44, 0, 48, 4], "proof_steps": [{"text": "intros a b p h; elim h;", "goal_before": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "goal_after": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'; clear h; try exact H' | clear h; intro H' ].", "goal_before": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "goal_after": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists a; try assumption.", "goal_before": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "goal_after": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists b; try assumption.", "goal_before": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "goal_after": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "Simple", "text": "Theorem Simple :\n forall (A : Set) (R : A -> A -> Prop),\n (forall x y z : A, R x y /\\ R y z -> R x z) ->\n (forall x y : A, R x y -> R y x) ->\n forall x : A, (exists y : A, R x y) -> R x x.\nintros A R H' H'0 x H'1; try assumption.\nelim H'1; intros y E; clear H'1; try exact E.\napply H' with y; auto.\nQed.\n", "definition": "\n forall (A : Set) (R : A -> A -> Prop),\n (forall x y z : A, R x y /\\ R y z -> R x z) ->\n (forall x y : A, R x y -> R y x) ->\n forall x : A, (exists y : A, R x y) -> R x x.", "proof": "\nintros A R H' H'0 x H'1; try assumption.\nelim H'1; intros y E; clear H'1; try exact E.\napply H' with y; auto.\n", "def_ranges": [50, 0, 54, 46], "proof_ranges": [55, 0, 58, 4], "proof_steps": [{"text": "intros A R H' H'0 x H'1; try assumption.", "goal_before": ["forall (A : Set) (R : A -> A -> Prop),\n(forall x y z : A, R x y /\\ R y z -> R x z) ->\n(forall x y : A, R x y -> R y x) ->\nforall x : A, (exists y : A, R x y) -> R x x"], "goal_after": ["R x x"], "proof_term_before": [], "proof_term_after": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (H'1 : exists y : A, R x y) => ?Goal)"]}, {"text": "elim H'1; intros y E; clear H'1; try exact E.", "goal_before": ["R x x"], "goal_after": ["R x x"], "proof_term_before": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (H'1 : exists y : A, R x y) => ?Goal)"], "proof_term_after": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (H'1 : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => ?Goal) H'1)"]}, {"text": "apply H' with y; auto.", "goal_before": ["R x x"], "goal_after": [], "proof_term_before": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (H'1 : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => ?Goal) H'1)"], "proof_term_after": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (H'1 : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => H' x y x (conj E (H'0 x y E))) H'1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (H'1 : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => H' x y x (conj E (H'0 x y E))) H'1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "not_not", "text": "Theorem not_not : forall a : Prop, a -> ~ ~ a.\nunfold not in |- *; auto.\nQed.\n", "definition": " forall a : Prop, a -> ~ ~ a.", "proof": "\nunfold not in |- *; auto.\n", "def_ranges": [60, 0, 60, 46], "proof_ranges": [61, 0, 62, 4], "proof_steps": [{"text": "unfold not in |- *; auto.", "goal_before": ["forall a : Prop, a -> ~ ~ a"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun (a : Prop) (H : a) (H0 : a -> False) => H0 H)\n :\n forall a : Prop, a -> ~ ~ a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (a : Prop) (H : a) (H0 : a -> False) => H0 H)\n :\n forall a : Prop, a -> ~ ~ a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "mini_cases", "text": "Theorem mini_cases : forall x y : Prop, (x \\/ ~ y) /\\ y -> x.\nintros x y h; elim h; intros h0 H'; elim h0;\n [ clear h h0; intro H'0 | intro H'0; elim H'0; clear h h0; try assumption ];\n auto.\nQed.\n", "definition": " forall x y : Prop, (x \\/ ~ y) /\\ y -> x.", "proof": "\nintros x y h; elim h; intros h0 H'; elim h0;\n [ clear h h0; intro H'0 | intro H'0; elim H'0; clear h h0; try assumption ];\n auto.\n", "def_ranges": [64, 0, 64, 61], "proof_ranges": [65, 0, 68, 4], "proof_steps": [{"text": "intros x y h; elim h; intros h0 H'; elim h0;", "goal_before": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "goal_after": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ clear h h0; intro H'0 | intro H'0; elim H'0; clear h h0; try assumption ];", "goal_before": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "goal_after": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "auto.", "goal_before": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "not_not_converse", "text": "Theorem not_not_converse : forall a : Prop, ~ ~ a -> a.\nintros a H'; try assumption; auto 10.\ngeneralize (classic a); intro h; elim h;\n [ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ].\nelim H'; assumption.\nQed.\n", "definition": " forall a : Prop, ~ ~ a -> a.", "proof": "\nintros a H'; try assumption; auto 10.\ngeneralize (classic a); intro h; elim h;\n [ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ].\nelim H'; assumption.\n", "def_ranges": [73, 0, 73, 55], "proof_ranges": [74, 0, 78, 4], "proof_steps": [{"text": "intros a H'; try assumption; auto 10.", "goal_before": ["forall a : Prop, ~ ~ a -> a"], "goal_after": ["a"], "proof_term_before": [], "proof_term_after": ["(fun (a : Prop) (H' : ~ ~ a) => ?Goal)"]}, {"text": "generalize (classic a); intro h; elim h;", "goal_before": ["a"], "goal_after": ["a"], "proof_term_before": ["(fun (a : Prop) (H' : ~ ~ a) => ?Goal)"], "proof_term_after": []}, {"text": "[ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ].", "goal_before": ["a"], "goal_after": ["a"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'; assumption.", "goal_before": ["a"], "goal_after": ["a"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "not_quite_classic", "text": "Theorem not_quite_classic : forall a : Prop, ~ ~ (a \\/ ~ a).\nunfold not in |- *; auto.\nQed.\n", "definition": " forall a : Prop, ~ ~ (a \\/ ~ a).", "proof": "\nunfold not in |- *; auto.\n", "def_ranges": [80, 0, 80, 60], "proof_ranges": [81, 0, 82, 4], "proof_steps": [{"text": "unfold not in |- *; auto.", "goal_before": ["forall a : Prop, ~ ~ (a \\/ ~ a)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun (a : Prop) (H : a \\/ (a -> False) -> False) =>\n  H (or_intror (fun H0 : a => H (or_introl H0))))\n :\n forall a : Prop, ~ ~ (a \\/ ~ a))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (a : Prop) (H : a \\/ (a -> False) -> False) =>\n  H (or_intror (fun H0 : a => H (or_introl H0))))\n :\n forall a : Prop, ~ ~ (a \\/ ~ a))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1_auto.v", "name": "Peirce", "text": "Theorem Peirce : forall A B : Prop, ((((A -> B) -> A) -> A) -> B) -> B.\nauto.\nQed.\n", "definition": " forall A B : Prop, ((((A -> B) -> A) -> A) -> B) -> B.", "proof": "\nauto.\n", "def_ranges": [84, 0, 84, 71], "proof_ranges": [85, 0, 86, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall A B : Prop, ((((A -> B) -> A) -> A) -> B) -> B"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (A B : Prop) (H : (((A -> B) -> A) -> A) -> B) =>\n H\n   (fun H0 : (A -> B) -> A =>\n    H0 (fun H1 : A => H (fun _ : (A -> B) -> A => H1))))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (H : (((A -> B) -> A) -> A) -> B) =>\n H\n   (fun H0 : (A -> B) -> A =>\n    H0 (fun H1 : A => H (fun _ : (A -> B) -> A => H1))))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/drinker.v", "name": "drinker's_theorem", "text": "Theorem drinker's_theorem :\n (forall P : Prop, P \\/ ~ P) ->\n forall (U : Set) (x : U) (Q : U -> Prop),\n exists x : U, Q x -> forall x : U, Q x.\nintros Excluded_middle U x Q.\ngeneralize (Excluded_middle (exists x : U, ~ Q x)); intro h; elim h; intro H';\n clear h.\nelim H'; intros z E; clear H'.\nexists z; intro H'0.\nelim E; assumption.\n\nexists x; intros H'0 x0.\ngeneralize (Excluded_middle (Q x0)); intro h; elim h; intro H'1; clear h;\n auto.\nelim H'; exists x0; assumption.\nQed.", "definition": "\n (forall P : Prop, P \\/ ~ P) ->\n forall (U : Set) (x : U) (Q : U -> Prop),\n exists x : U, Q x -> forall x : U, Q x.", "proof": "\nintros Excluded_middle U x Q.\ngeneralize (Excluded_middle (exists x : U, ~ Q x)); intro h; elim h; intro H';\n clear h.\nelim H'; intros z E; clear H'.\nexists z; intro H'0.\nelim E; assumption.\n\nexists x; intros H'0 x0.\ngeneralize (Excluded_middle (Q x0)); intro h; elim h; intro H'1; clear h;\n auto.\nelim H'; exists x0; assumption.\n", "def_ranges": [10, 0, 13, 40], "proof_ranges": [14, 0, 25, 4], "proof_steps": [{"text": "intros Excluded_middle U x Q.", "goal_before": ["(forall P : Prop, P \\/ ~ P) ->\nforall U : Set,\nU -> forall Q : U -> Prop, exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "goal_after": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "proof_term_before": [], "proof_term_after": ["(fun (Excluded_middle : forall P : Prop, P \\/ ~ P) \n   (U : Set) (x : U) (Q : U -> Prop) => ?Goal)"]}, {"text": "generalize (Excluded_middle (exists x : U, ~ Q x)); intro h; elim h; intro H';", "goal_before": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "goal_after": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "proof_term_before": ["(fun (Excluded_middle : forall P : Prop, P \\/ ~ P) \n   (U : Set) (x : U) (Q : U -> Prop) => ?Goal)"], "proof_term_after": []}, {"text": "clear h.", "goal_before": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "goal_after": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'; intros z E; clear H'.", "goal_before": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "goal_after": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists z; intro H'0.", "goal_before": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "goal_after": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; assumption.", "goal_before": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "goal_after": ["exists x0 : U, Q x0 -> forall x1 : U, Q x1"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; intros H'0 x0.", "goal_before": ["Q x0"], "goal_after": ["Q x0"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Excluded_middle (Q x0)); intro h; elim h; intro H'1; clear h;", "goal_before": ["Q x0"], "goal_after": ["Q x0"], "proof_term_before": [], "proof_term_after": ["(fun (Excluded_middle : forall P : Prop, P \\/ ~ P) \n   (U : Set) (x : U) (Q : U -> Prop) =>\n ex_intro (fun x0 : U => Q x0 -> forall x1 : U, Q x1) x\n   (fun (H'0 : Q x) (x0 : U) => ?Goal))"]}, {"text": "auto.", "goal_before": ["Q x0"], "goal_after": ["Q x0"], "proof_term_before": ["(fun (Excluded_middle : forall P : Prop, P \\/ ~ P) \n   (U : Set) (x : U) (Q : U -> Prop) =>\n ex_intro (fun x0 : U => Q x0 -> forall x1 : U, Q x1) x\n   (fun (H'0 : Q x) (x0 : U) => ?Goal))"], "proof_term_after": ["(fun (Excluded_middle : forall P : Prop, P \\/ ~ P) \n   (U : Set) (x : U) (Q : U -> Prop) =>\n ex_intro (fun x0 : U => Q x0 -> forall x1 : U, Q x1) x\n   (fun (H'0 : Q x) (x0 : U) => ?Goal))"]}, {"text": "elim H'; exists x0; assumption.", "goal_before": ["Q x0"], "goal_after": [], "proof_term_before": ["(fun (Excluded_middle : forall P : Prop, P \\/ ~ P) \n   (U : Set) (x : U) (Q : U -> Prop) =>\n ex_intro (fun x0 : U => Q x0 -> forall x1 : U, Q x1) x\n   (fun (H'0 : Q x) (x0 : U) => ?Goal))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Fil.v", "name": "Pairs_are_enough_finite_case", "text": "Theorem Pairs_are_enough_finite_case :\n    Cpo U D ->\n    (forall x y : U,\n     Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup) ->\n    forall X : Ensemble U,\n    Finite U X ->\n    Included U X (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X maj) ->\n    exists bsup : U, Lub U D X bsup.\n   intros H' H'0 X H'1; elim H'1; auto.\n   intros A H'2 H'3 x H'4 H'5 h; elim h; intros maj E; clear h.\n   generalize (Upper_downward_stable U D A (Union U (Singleton U x) A) maj);\n    intro h; lapply h;\n    [ intro H'6; lapply H'6;\n       [ intro H'7; lapply H'7;\n          [ intro H'8; lapply H'8;\n             [ intro H'9; clear h H'6 H'7 H'8\n             | clear h H'6 H'7; try assumption ]\n          | clear h H'6 ]\n       | clear h ]\n    | clear h ]; auto 10.\n   lapply H'3;\n    [ intro H'6; lapply H'6;\n       [ intro H'7; clear H'3 H'6 | exists maj; clear H'3; try assumption ]\n    | idtac ]; auto 10.\n   elim H'7; intros bsup E0; clear H'7; try exact E0; auto 10.\n   generalize (H'0 x bsup); intro h; lapply h;\n    [ intro h0; elim h0; intros bsup0 E1; clear h h0; try exact E1\n    | clear h ]; clear H'0.\n   exists bsup0; apply Lub_definition; auto 10.\n   elim E1; intros H'3 H'6.\n   elim H'3; intros H'7 H'8.\n   apply Upper_Bound_definition; auto 10.\n   intros y H'10; elim H'10.\n   intros x0 H'11; elim H'11; auto 10.\n   intros x0 H'11; auto 10.\n   generalize Rel_of_transitive; intro RoT; red in RoT.\n   apply RoT with bsup; auto.\n   elim E0.\n   intro H'12; elim H'12; auto.\n   elim E1.\n   intros H'3 H'6 y H'7.\n   apply H'6.\n   elim H'7; intros H'8 H'10.\n   apply Upper_Bound_definition; auto.\n   intros y0 H'11; elim H'11; auto 10.\n   elim H'7.\n   elim E0; auto 10.\n   red in |- *.\n   elim H'9.\n   intros H'0 H'3; exists maj; intros H'6 H'7; split;\n    [ idtac | apply Upper_Bound_definition ]; auto 10.\n   intros y H'10; elim H'10; auto 10.\n   elim E; auto 10.\n   elim E0; auto 10.\n   Qed.\n", "definition": "\n    Cpo U D ->\n    (forall x y : U,\n     Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup) ->\n    forall X : Ensemble U,\n    Finite U X ->\n    Included U X (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X maj) ->\n    exists bsup : U, Lub U D X bsup.", "proof": "\n   intros H' H'0 X H'1; elim H'1; auto.\n   intros A H'2 H'3 x H'4 H'5 h; elim h; intros maj E; clear h.\n   generalize (Upper_downward_stable U D A (Union U (Singleton U x) A) maj);\n    intro h; lapply h;\n    [ intro H'6; lapply H'6;\n       [ intro H'7; lapply H'7;\n          [ intro H'8; lapply H'8;\n             [ intro H'9; clear h H'6 H'7 H'8\n             | clear h H'6 H'7; try assumption ]\n          | clear h H'6 ]\n       | clear h ]\n    | clear h ]; auto 10.\n   lapply H'3;\n    [ intro H'6; lapply H'6;\n       [ intro H'7; clear H'3 H'6 | exists maj; clear H'3; try assumption ]\n    | idtac ]; auto 10.\n   elim H'7; intros bsup E0; clear H'7; try exact E0; auto 10.\n   generalize (H'0 x bsup); intro h; lapply h;\n    [ intro h0; elim h0; intros bsup0 E1; clear h h0; try exact E1\n    | clear h ]; clear H'0.\n   exists bsup0; apply Lub_definition; auto 10.\n   elim E1; intros H'3 H'6.\n   elim H'3; intros H'7 H'8.\n   apply Upper_Bound_definition; auto 10.\n   intros y H'10; elim H'10.\n   intros x0 H'11; elim H'11; auto 10.\n   intros x0 H'11; auto 10.\n   generalize Rel_of_transitive; intro RoT; red in RoT.\n   apply RoT with bsup; auto.\n   elim E0.\n   intro H'12; elim H'12; auto.\n   elim E1.\n   intros H'3 H'6 y H'7.\n   apply H'6.\n   elim H'7; intros H'8 H'10.\n   apply Upper_Bound_definition; auto.\n   intros y0 H'11; elim H'11; auto 10.\n   elim H'7.\n   elim E0; auto 10.\n   red in |- *.\n   elim H'9.\n   intros H'0 H'3; exists maj; intros H'6 H'7; split;\n    [ idtac | apply Upper_Bound_definition ]; auto 10.\n   intros y H'10; elim H'10; auto 10.\n   elim E; auto 10.\n   elim E0; auto 10.\n   ", "def_ranges": [21, 0, 29, 36], "proof_ranges": [30, 0, 76, 7], "proof_steps": [{"text": "intros H' H'0 X H'1; elim H'1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A H'2 H'3 x H'4 H'5 h; elim h; intros maj E; clear h.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Upper_downward_stable U D A (Union U (Singleton U x) A) maj);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'6; lapply H'6;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'7; lapply H'7;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'8; lapply H'8;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'9; clear h H'6 H'7 H'8", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h H'6 H'7; try assumption ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h H'6 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply H'3;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'6; lapply H'6;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'7; clear H'3 H'6 | exists maj; clear H'3; try assumption ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| idtac ]; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'7; intros bsup E0; clear H'7; try exact E0; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'0 x bsup); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros bsup0 E1; clear h h0; try exact E1", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists bsup0; apply Lub_definition; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E1; intros H'3 H'6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'3; intros H'7 H'8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'10; elim H'10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'11; elim H'11; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'11; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize Rel_of_transitive; intro RoT; red in RoT.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply RoT with bsup; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'12; elim H'12; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'3 H'6 y H'7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H'6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'7; intros H'8 H'10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y0 H'11; elim H'11; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E0; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Fil.v", "name": "Pairs_are_enough", "text": "Theorem Pairs_are_enough :\n    Cpo U D ->\n    (forall x y : U,\n     Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup) ->\n    Conditionally_complete U D.\n   intros H' H'0; apply Definition_of_Conditionally_complete.\n   intros X H'1 H'2.\n   generalize (Empty_set_has_lub U D); intro h; lapply h;\n    [ intro H'3; clear h | clear h; try assumption ].\n   elim H'3; intros bsup E; clear H'3.\n   generalize (Inclusion_is_transitive U); intro T; red in T.\n   lapply Pairs_are_enough_finite_case;\n    [ intro H'3; lapply H'3; [ intro H'4; clear H'3 | try assumption ]\n    | idtac ]; auto.\n   elim H'; intros H'6 H'7; clear H'.\n   generalize\n    (H'7\n       (fun bsup : U =>\n        exists Y : Ensemble U, Included U Y X /\\ Finite U Y /\\ Lub U D Y bsup));\n    intro h; lapply h; [ intro H'; clear h | clear h; try assumption ].\n   2: apply Definition_of_Directed; auto 10.\n   2: red in |- *; auto 10.\n   2: intros x H'; elim H'; auto 10.\n   2: intros x0 h; elim h; intros H'3 h0; elim h0; intros H'5 H'8; clear h h0;\n       elim H'8; auto 10.\n   2: intro H'9; elim H'9; auto 10.\n   2: apply Non_empty_intro with bsup.\n   2: red in |- *; auto 10.\n   2: exists (Empty_set U); split;\n       [ idtac | split; [ try assumption | idtac ] ]; \n       auto 10.\n   2: intros x1 x2 H'; red in H'; auto 10.\n   2: unfold In at 1 in |- *.\n   2: unfold In at 2 in H'.\n   2: generalize (H' x1); intro h; lapply h;\n       [ intro H'3; clear h | clear h; try assumption ]; \n       auto 10.\n   2: elim H'3; intros Y h; elim h; intros H'5 h0; elim h0; intros H'8 H'9;\n       clear H'3 h h0; try exact H'8.\n   2: generalize (H' x2); intro h; lapply h;\n       [ intro H'3; clear h | clear h; try assumption ]; \n       auto 10.\n   2: elim H'3; intros Y0 h; elim h; intros H'10 h0; elim h0;\n       intros H'11 H'12; clear H'3 h h0; try exact H'11.\n   2: generalize (Union_of_finite_is_finite U Y Y0); intro h; lapply h;\n       [ intro H'3; lapply H'3;\n          [ intro H'13; clear h H'3 | clear h; try assumption ]\n       | clear h ]; auto 10.\n   2: elim H'2; intros maj E0; clear H'2; try exact E0.\n   2: generalize (H'4 (Union U Y Y0)); intro h; lapply h;\n       [ intro H'2; lapply H'2;\n          [ intro H'3; lapply H'3;\n             [ intro H'14; clear h H'2 H'3\n             | exists maj; clear h H'2; try assumption ]\n          | clear h ]\n       | clear h ]; auto.\n   3: apply Upper_downward_stable with X; auto.\n   2: elim H'14; intros bsup0 E1; clear H'14; try exact E1.\n   2: exists bsup0; split;\n       [ exists (Union U Y Y0); split;\n          [ idtac | split; [ try assumption | idtac ] ]\n       | idtac ]; auto 10.\n   2: elim E1; intros H'2 H'3; clear E1.\n   2: generalize (Upper_downward_stable U D Y (Union U Y Y0) bsup0); intro h;\n       lapply h;\n       [ intro H'14; lapply H'14;\n          [ intro H'15; lapply H'15;\n             [ intro H'16; lapply H'16;\n                [ intro H'17; clear h H'14 H'15 H'16\n                | clear h H'14 H'15; try assumption ]\n             | clear h H'14 ]\n          | clear h ]\n       | clear h ]; auto.\n   2: generalize (Upper_downward_stable U D Y0 (Union U Y Y0) bsup0); intro h;\n       lapply h;\n       [ intro H'14; lapply H'14;\n          [ intro H'15; lapply H'15;\n             [ intro H'16; lapply H'16;\n                [ intro H'18; clear h H'14 H'15 H'16\n                | clear h H'14 H'15; try assumption ]\n             | clear h H'14 ]\n          | clear h ]\n       | clear h ]; auto.\n   2: elim H'12; intros H'14 H'15; clear H'12.\n   2: generalize (H'15 bsup0); intro h; lapply h;\n       [ intro H'16; clear h | clear h; try assumption ]; \n       auto 10.\n   2: elim H'9; intros H'12 H'19; clear H'9.\n   2: generalize (H'19 bsup0); intro h; lapply h;\n       [ intro H'9; clear h | clear h; try assumption ]; \n       auto 10.\n   2: apply Upper_Bound_definition; auto 10.\n   2: elim H'2; auto 10.\n   2: intros y H'20; elim H'20; auto 10.\n   elim H'; intros bsup0 E0; clear H'; try exact E0; auto 10.\n   exists bsup0; apply Lub_definition.\n   apply Upper_Bound_definition; auto 10.\n   generalize\n    (Lub_is_in_Carrier U D bsup0\n       (fun bsup : U =>\n        exists Y : Ensemble U, Included U Y X /\\ Finite U Y /\\ Lub U D Y bsup));\n    intro h; lapply h;\n    [ intro H'; lapply H';\n       [ intro H'3; clear h H' | clear h; try assumption ]\n    | clear h ]; auto 10.\n   red in |- *.\n   intros x H'; red in H'; auto 10.\n   elim H'; intros Y h; elim h; intros H'3 h0; elim h0; intros H'5 H'8;\n    clear H' h h0; try exact H'8; auto 10.\n   apply Lub_is_in_Carrier with Y; auto.\n   elim E0; intros H'3 H'5; clear E0.\n   elim H'3; intros H'8 H'9; clear H'3.\n   intros y H'; apply H'9; auto 10.\n   red in |- *;\n    (exists (Singleton U y); split;\n      [ idtac | split; [ try assumption | idtac ] ]); \n    auto 10.\n   red in |- *; (intros x H'3; elim H'3); auto 10.\n   intros y H'; try assumption.\n   elim E0; intros H'3 H'5; clear E0; apply H'5.\n   apply Upper_Bound_definition; auto 10.\n   elim H'; auto 10.\n   intros y0 H'8; red in H'8; auto 10.\n   elim H'8; intros Y h; elim h; intros H'9 h0; elim h0; intros H'10 H'11;\n    clear H'8 h h0; try exact H'11; auto 10.\n   elim H'11; intros H'8 H'12; clear H'11.\n   apply H'12; auto 10.\n   apply Upper_downward_stable with X; auto.\n   Qed.\n", "definition": "\n    Cpo U D ->\n    (forall x y : U,\n     Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup) ->\n    Conditionally_complete U D.", "proof": "\n   intros H' H'0; apply Definition_of_Conditionally_complete.\n   intros X H'1 H'2.\n   generalize (Empty_set_has_lub U D); intro h; lapply h;\n    [ intro H'3; clear h | clear h; try assumption ].\n   elim H'3; intros bsup E; clear H'3.\n   generalize (Inclusion_is_transitive U); intro T; red in T.\n   lapply Pairs_are_enough_finite_case;\n    [ intro H'3; lapply H'3; [ intro H'4; clear H'3 | try assumption ]\n    | idtac ]; auto.\n   elim H'; intros H'6 H'7; clear H'.\n   generalize\n    (H'7\n       (fun bsup : U =>\n        exists Y : Ensemble U, Included U Y X /\\ Finite U Y /\\ Lub U D Y bsup));\n    intro h; lapply h; [ intro H'; clear h | clear h; try assumption ].\n   2: apply Definition_of_Directed; auto 10.\n   2: red in |- *; auto 10.\n   2: intros x H'; elim H'; auto 10.\n   2: intros x0 h; elim h; intros H'3 h0; elim h0; intros H'5 H'8; clear h h0;\n       elim H'8; auto 10.\n   2: intro H'9; elim H'9; auto 10.\n   2: apply Non_empty_intro with bsup.\n   2: red in |- *; auto 10.\n   2: exists (Empty_set U); split;\n       [ idtac | split; [ try assumption | idtac ] ]; \n       auto 10.\n   2: intros x1 x2 H'; red in H'; auto 10.\n   2: unfold In at 1 in |- *.\n   2: unfold In at 2 in H'.\n   2: generalize (H' x1); intro h; lapply h;\n       [ intro H'3; clear h | clear h; try assumption ]; \n       auto 10.\n   2: elim H'3; intros Y h; elim h; intros H'5 h0; elim h0; intros H'8 H'9;\n       clear H'3 h h0; try exact H'8.\n   2: generalize (H' x2); intro h; lapply h;\n       [ intro H'3; clear h | clear h; try assumption ]; \n       auto 10.\n   2: elim H'3; intros Y0 h; elim h; intros H'10 h0; elim h0;\n       intros H'11 H'12; clear H'3 h h0; try exact H'11.\n   2: generalize (Union_of_finite_is_finite U Y Y0); intro h; lapply h;\n       [ intro H'3; lapply H'3;\n          [ intro H'13; clear h H'3 | clear h; try assumption ]\n       | clear h ]; auto 10.\n   2: elim H'2; intros maj E0; clear H'2; try exact E0.\n   2: generalize (H'4 (Union U Y Y0)); intro h; lapply h;\n       [ intro H'2; lapply H'2;\n          [ intro H'3; lapply H'3;\n             [ intro H'14; clear h H'2 H'3\n             | exists maj; clear h H'2; try assumption ]\n          | clear h ]\n       | clear h ]; auto.\n   3: apply Upper_downward_stable with X; auto.\n   2: elim H'14; intros bsup0 E1; clear H'14; try exact E1.\n   2: exists bsup0; split;\n       [ exists (Union U Y Y0); split;\n          [ idtac | split; [ try assumption | idtac ] ]\n       | idtac ]; auto 10.\n   2: elim E1; intros H'2 H'3; clear E1.\n   2: generalize (Upper_downward_stable U D Y (Union U Y Y0) bsup0); intro h;\n       lapply h;\n       [ intro H'14; lapply H'14;\n          [ intro H'15; lapply H'15;\n             [ intro H'16; lapply H'16;\n                [ intro H'17; clear h H'14 H'15 H'16\n                | clear h H'14 H'15; try assumption ]\n             | clear h H'14 ]\n          | clear h ]\n       | clear h ]; auto.\n   2: generalize (Upper_downward_stable U D Y0 (Union U Y Y0) bsup0); intro h;\n       lapply h;\n       [ intro H'14; lapply H'14;\n          [ intro H'15; lapply H'15;\n             [ intro H'16; lapply H'16;\n                [ intro H'18; clear h H'14 H'15 H'16\n                | clear h H'14 H'15; try assumption ]\n             | clear h H'14 ]\n          | clear h ]\n       | clear h ]; auto.\n   2: elim H'12; intros H'14 H'15; clear H'12.\n   2: generalize (H'15 bsup0); intro h; lapply h;\n       [ intro H'16; clear h | clear h; try assumption ]; \n       auto 10.\n   2: elim H'9; intros H'12 H'19; clear H'9.\n   2: generalize (H'19 bsup0); intro h; lapply h;\n       [ intro H'9; clear h | clear h; try assumption ]; \n       auto 10.\n   2: apply Upper_Bound_definition; auto 10.\n   2: elim H'2; auto 10.\n   2: intros y H'20; elim H'20; auto 10.\n   elim H'; intros bsup0 E0; clear H'; try exact E0; auto 10.\n   exists bsup0; apply Lub_definition.\n   apply Upper_Bound_definition; auto 10.\n   generalize\n    (Lub_is_in_Carrier U D bsup0\n       (fun bsup : U =>\n        exists Y : Ensemble U, Included U Y X /\\ Finite U Y /\\ Lub U D Y bsup));\n    intro h; lapply h;\n    [ intro H'; lapply H';\n       [ intro H'3; clear h H' | clear h; try assumption ]\n    | clear h ]; auto 10.\n   red in |- *.\n   intros x H'; red in H'; auto 10.\n   elim H'; intros Y h; elim h; intros H'3 h0; elim h0; intros H'5 H'8;\n    clear H' h h0; try exact H'8; auto 10.\n   apply Lub_is_in_Carrier with Y; auto.\n   elim E0; intros H'3 H'5; clear E0.\n   elim H'3; intros H'8 H'9; clear H'3.\n   intros y H'; apply H'9; auto 10.\n   red in |- *;\n    (exists (Singleton U y); split;\n      [ idtac | split; [ try assumption | idtac ] ]); \n    auto 10.\n   red in |- *; (intros x H'3; elim H'3); auto 10.\n   intros y H'; try assumption.\n   elim E0; intros H'3 H'5; clear E0; apply H'5.\n   apply Upper_Bound_definition; auto 10.\n   elim H'; auto 10.\n   intros y0 H'8; red in H'8; auto 10.\n   elim H'8; intros Y h; elim h; intros H'9 h0; elim h0; intros H'10 H'11;\n    clear H'8 h h0; try exact H'11; auto 10.\n   elim H'11; intros H'8 H'12; clear H'11.\n   apply H'12; auto 10.\n   apply Upper_downward_stable with X; auto.\n   ", "def_ranges": [78, 0, 82, 31], "proof_ranges": [83, 0, 206, 7], "proof_steps": [{"text": "intros H' H'0; apply Definition_of_Conditionally_complete.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros X H'1 H'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Empty_set_has_lub U D); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'3; clear h | clear h; try assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'3; intros bsup E; clear H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Inclusion_is_transitive U); intro T; red in T.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply Pairs_are_enough_finite_case;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'3; lapply H'3; [ intro H'4; clear H'3 | try assumption ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| idtac ]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'; intros H'6 H'7; clear H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(H'7", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun bsup : U =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists Y : Ensemble U, Included U Y X /\\ Finite U Y /\\ Lub U D Y bsup));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro h; lapply h; [ intro H'; clear h | clear h; try assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply Definition_of_Directed; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros x H'; elim H'; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros x0 h; elim h; intros H'3 h0; elim h0; intros H'5 H'8; clear h h0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'8; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intro H'9; elim H'9; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply Non_empty_intro with bsup.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: exists (Empty_set U); split;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ idtac | split; [ try assumption | idtac ] ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros x1 x2 H'; red in H'; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: unfold In at 1 in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: unfold In at 2 in H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: generalize (H' x1); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'3; clear h | clear h; try assumption ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: elim H'3; intros Y h; elim h; intros H'5 h0; elim h0; intros H'8 H'9;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'3 h h0; try exact H'8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: generalize (H' x2); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'3; clear h | clear h; try assumption ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: elim H'3; intros Y0 h; elim h; intros H'10 h0; elim h0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'11 H'12; clear H'3 h h0; try exact H'11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: generalize (Union_of_finite_is_finite U Y Y0); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'3; lapply H'3;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'13; clear h H'3 | clear h; try assumption ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: elim H'2; intros maj E0; clear H'2; try exact E0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: generalize (H'4 (Union U Y Y0)); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'2; lapply H'2;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'3; lapply H'3;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'14; clear h H'2 H'3", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| exists maj; clear h H'2; try assumption ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "3: apply Upper_downward_stable with X; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: elim H'14; intros bsup0 E1; clear H'14; try exact E1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: exists bsup0; split;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ exists (Union U Y Y0); split;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ idtac | split; [ try assumption | idtac ] ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| idtac ]; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: elim E1; intros H'2 H'3; clear E1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: generalize (Upper_downward_stable U D Y (Union U Y Y0) bsup0); intro h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'14; lapply H'14;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'15; lapply H'15;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'16; lapply H'16;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'17; clear h H'14 H'15 H'16", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h H'14 H'15; try assumption ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h H'14 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: generalize (Upper_downward_stable U D Y0 (Union U Y Y0) bsup0); intro h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'14; lapply H'14;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'15; lapply H'15;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'16; lapply H'16;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'18; clear h H'14 H'15 H'16", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h H'14 H'15; try assumption ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h H'14 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: elim H'12; intros H'14 H'15; clear H'12.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: generalize (H'15 bsup0); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'16; clear h | clear h; try assumption ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: elim H'9; intros H'12 H'19; clear H'9.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: generalize (H'19 bsup0); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'9; clear h | clear h; try assumption ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply Upper_Bound_definition; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: elim H'2; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros y H'20; elim H'20; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'; intros bsup0 E0; clear H'; try exact E0; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists bsup0; apply Lub_definition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Empty_set_minimal", "text": "Theorem Empty_set_minimal :\n    forall X : Ensemble U, Included U (Empty_set U) X.\n   Proof.\n   red in |- *; intros X x H'; elim H'.\n   Qed.\n", "definition": "\n    forall X : Ensemble U, Included U (Empty_set U) X.\n   ", "proof": "\n   red in |- *; intros X x H'; elim H'.\n   ", "def_ranges": [29, 0, 30, 54], "proof_ranges": [31, 0, 33, 7], "proof_steps": [{"text": "red in |- *; intros X x H'; elim H'.", "goal_before": ["forall X : Ensemble U, Included U (Empty_set U) X"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun (X : Ensemble U) (x : U) (H' : In U (Empty_set U) x) =>\n  Empty_set_ind U (fun x0 : U => In U X x0) x H')\n :\n forall X : Ensemble U, Included U (Empty_set U) X)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (X : Ensemble U) (x : U) (H' : In U (Empty_set U) x) =>\n  Empty_set_ind U (fun x0 : U => In U X x0) x H')\n :\n forall X : Ensemble U, Included U (Empty_set U) X)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Power_set_non_empty", "text": "Theorem Power_set_non_empty :\n    forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A).\n   Proof.\n   intro A'; apply Non_empty_intro with (Empty_set U); auto.\n   Qed.\n", "definition": "\n    forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A).\n   ", "proof": "\n   intro A'; apply Non_empty_intro with (Empty_set U); auto.\n   ", "def_ranges": [36, 0, 37, 64], "proof_ranges": [38, 0, 40, 7], "proof_steps": [{"text": "intro A'; apply Non_empty_intro with (Empty_set U); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Inclusion_is_an_order", "text": "Theorem Inclusion_is_an_order : Order (Ensemble U) (Included U).\n   Proof.\n   auto 8.\n   Qed.\n", "definition": " Order (Ensemble U) (Included U).\n   ", "proof": "\n   auto 8.\n   ", "def_ranges": [43, 0, 43, 67], "proof_ranges": [44, 0, 46, 7], "proof_steps": [{"text": "auto 8.", "goal_before": ["Order (Ensemble U) (Included U)"], "goal_after": ["Order (Ensemble U) (Included U)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["Order (Ensemble U) (Included U)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Inclusion_is_transitive", "text": "Theorem Inclusion_is_transitive : Transitive (Ensemble U) (Included U).\n   elim Inclusion_is_an_order; auto.\n   Qed.\n", "definition": " Transitive (Ensemble U) (Included U).", "proof": "\n   elim Inclusion_is_an_order; auto.\n   ", "def_ranges": [49, 0, 49, 74], "proof_ranges": [50, 0, 51, 7], "proof_steps": [{"text": "elim Inclusion_is_an_order; auto.", "goal_before": ["Transitive (Ensemble U) (Included U)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(Order_ind (Ensemble U) (Included U) (Transitive (Ensemble U) (Included U))\n   (fun (_ : Reflexive (Ensemble U) (Included U))\n      (H0 : Transitive (Ensemble U) (Included U))\n      (_ : Antisymmetric (Ensemble U) (Included U)) => H0)\n   Inclusion_is_an_order)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(Order_ind (Ensemble U) (Included U) (Transitive (Ensemble U) (Included U))\n   (fun (_ : Reflexive (Ensemble U) (Included U))\n      (H0 : Transitive (Ensemble U) (Included U))\n      (_ : Antisymmetric (Ensemble U) (Included U)) => H0)\n   Inclusion_is_an_order)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Same_set_equivalence", "text": "Theorem Same_set_equivalence : Equivalence (Ensemble U) (Same_set U).\n   Proof.\n   generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H';\n    auto.\n   Qed.\n", "definition": " Equivalence (Ensemble U) (Same_set U).\n   ", "proof": "\n   generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H';\n    auto.\n   ", "def_ranges": [54, 0, 54, 72], "proof_ranges": [55, 0, 58, 7], "proof_steps": [{"text": "generalize (Equiv_from_order (Ensemble U) (Included U)); intro H'; elim H';", "goal_before": ["Equivalence (Ensemble U) (Same_set U)"], "goal_after": ["Equivalence (Ensemble U) (Same_set U)"], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": ["Equivalence (Ensemble U) (Same_set U)"], "goal_after": ["Equivalence (Ensemble U) (Same_set U)"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Same_set_reflexive", "text": "Theorem Same_set_reflexive : Reflexive (Ensemble U) (Same_set U).\n   Proof.\n   elim Same_set_equivalence; auto.\n   Qed.\n", "definition": " Reflexive (Ensemble U) (Same_set U).\n   ", "proof": "\n   elim Same_set_equivalence; auto.\n   ", "def_ranges": [60, 0, 60, 68], "proof_ranges": [61, 0, 63, 7], "proof_steps": [{"text": "elim Same_set_equivalence; auto.", "goal_before": ["Reflexive (Ensemble U) (Same_set U)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(Equivalence_ind (Ensemble U) (Same_set U)\n   (Reflexive (Ensemble U) (Same_set U))\n   (fun (H : Reflexive (Ensemble U) (Same_set U))\n      (_ : Transitive (Ensemble U) (Same_set U))\n      (_ : Symmetric (Ensemble U) (Same_set U)) => H) Same_set_equivalence)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(Equivalence_ind (Ensemble U) (Same_set U)\n   (Reflexive (Ensemble U) (Same_set U))\n   (fun (H : Reflexive (Ensemble U) (Same_set U))\n      (_ : Transitive (Ensemble U) (Same_set U))\n      (_ : Symmetric (Ensemble U) (Same_set U)) => H) Same_set_equivalence)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Power_set_PO", "text": "Theorem Power_set_PO : PO (Ensemble U).\n   Proof.\n   apply Definition_of_PO with (Power_set A) (Included U); auto.\n   Defined.\n", "definition": " PO (Ensemble U).\n   ", "proof": "\n   apply Definition_of_PO with (Power_set A) (Included U); auto.\n   ", "def_ranges": [66, 0, 66, 42], "proof_ranges": [67, 0, 69, 11], "proof_steps": [{"text": "apply Definition_of_PO with (Power_set A) (Included U); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Union_minimal", "text": "Theorem Union_minimal :\n    forall a b X : Ensemble U,\n    Included U a X -> Included U b X -> Included U (Union U a b) X.\n   Proof.\n   intros a b X H' H'0; red in |- *; (intros x H'1; elim H'1); auto.\n   Qed.\n", "definition": "\n    forall a b X : Ensemble U,\n    Included U a X -> Included U b X -> Included U (Union U a b) X.\n   ", "proof": "\n   intros a b X H' H'0; red in |- *; (intros x H'1; elim H'1); auto.\n   ", "def_ranges": [71, 0, 73, 67], "proof_ranges": [74, 0, 76, 7], "proof_steps": [{"text": "intros a b X H' H'0; red in |- *; (intros x H'1; elim H'1); auto.", "goal_before": ["forall a b X : Ensemble U,\nIncluded U a X -> Included U b X -> Included U (Union U a b) X"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (a b X : Ensemble U) (H' : Included U a X) (H'0 : Included U b X) =>\n (fun (x : U) (H'1 : In U (Union U a b) x) =>\n  Union_ind U a b (fun x0 : U => In U X x0) H' H'0 x H'1)\n :\n Included U (Union U a b) X)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b X : Ensemble U) (H' : Included U a X) (H'0 : Included U b X) =>\n (fun (x : U) (H'1 : In U (Union U a b) x) =>\n  Union_ind U a b (fun x0 : U => In U X x0) H' H'0 x H'1)\n :\n Included U (Union U a b) X)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Intersection_maximal", "text": "Theorem Intersection_maximal :\n    forall a b X : Ensemble U,\n    Included U X a -> Included U X b -> Included U X (Intersection U a b).\n   Proof.\n   auto.\n   Qed.\n", "definition": "\n    forall a b X : Ensemble U,\n    Included U X a -> Included U X b -> Included U X (Intersection U a b).\n   ", "proof": "\n   auto.\n   ", "def_ranges": [79, 0, 81, 74], "proof_ranges": [82, 0, 84, 7], "proof_steps": [{"text": "auto.", "goal_before": ["forall a b X : Ensemble U,\nIncluded U X a -> Included U X b -> Included U X (Intersection U a b)"], "goal_after": ["forall a b X : Ensemble U,\nIncluded U X a -> Included U X b -> Included U X (Intersection U a b)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall a b X : Ensemble U,\nIncluded U X a -> Included U X b -> Included U X (Intersection U a b)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Union_increases_l", "text": "Theorem Union_increases_l :\n    forall a b : Ensemble U, Included U a (Union U a b).\n   Proof.\n   auto.\n   Qed.\n", "definition": "\n    forall a b : Ensemble U, Included U a (Union U a b).\n   ", "proof": "\n   auto.\n   ", "def_ranges": [86, 0, 87, 56], "proof_ranges": [88, 0, 90, 7], "proof_steps": [{"text": "auto.", "goal_before": ["forall a b : Ensemble U, Included U a (Union U a b)"], "goal_after": ["forall a b : Ensemble U, Included U a (Union U a b)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall a b : Ensemble U, Included U a (Union U a b)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Union_increases_r", "text": "Theorem Union_increases_r :\n    forall a b : Ensemble U, Included U b (Union U a b).\n   Proof.\n   auto.\n   Qed.\n", "definition": "\n    forall a b : Ensemble U, Included U b (Union U a b).\n   ", "proof": "\n   auto.\n   ", "def_ranges": [92, 0, 93, 56], "proof_ranges": [94, 0, 96, 7], "proof_steps": [{"text": "auto.", "goal_before": ["forall a b : Ensemble U, Included U b (Union U a b)"], "goal_after": ["forall a b : Ensemble U, Included U b (Union U a b)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall a b : Ensemble U, Included U b (Union U a b)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Intersection_decreases_l", "text": "Theorem Intersection_decreases_l :\n    forall a b : Ensemble U, Included U (Intersection U a b) a.\n   Proof.\n   intros a b; red in |- *; auto.\n   intros x H'; elim H'; auto.\n   Qed.\n", "definition": "\n    forall a b : Ensemble U, Included U (Intersection U a b) a.\n   ", "proof": "\n   intros a b; red in |- *; auto.\n   intros x H'; elim H'; auto.\n   ", "def_ranges": [98, 0, 99, 63], "proof_ranges": [100, 0, 103, 7], "proof_steps": [{"text": "intros a b; red in |- *; auto.", "goal_before": ["forall a b : Ensemble U, Included U (Intersection U a b) a"], "goal_after": ["forall x : U, In U (Intersection U a b) x -> In U a x"], "proof_term_before": [], "proof_term_after": ["(fun a b : Ensemble U => ?Goal : Included U (Intersection U a b) a)"]}, {"text": "intros x H'; elim H'; auto.", "goal_before": ["forall x : U, In U (Intersection U a b) x -> In U a x"], "goal_after": [], "proof_term_before": ["(fun a b : Ensemble U => ?Goal : Included U (Intersection U a b) a)"], "proof_term_after": ["(fun a b : Ensemble U =>\n (fun (x : U) (H' : In U (Intersection U a b) x) =>\n  Intersection_ind U a b (fun x0 : U => In U a x0)\n    (fun (x0 : U) (H : In U a x0) (_ : In U b x0) => H) x H')\n :\n Included U (Intersection U a b) a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun a b : Ensemble U =>\n (fun (x : U) (H' : In U (Intersection U a b) x) =>\n  Intersection_ind U a b (fun x0 : U => In U a x0)\n    (fun (x0 : U) (H : In U a x0) (_ : In U b x0) => H) x H')\n :\n Included U (Intersection U a b) a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Intersection_decreases_r", "text": "Theorem Intersection_decreases_r :\n    forall a b : Ensemble U, Included U (Intersection U a b) b.\n   Proof.\n   intros a b; red in |- *; auto.\n   intros x H'; elim H'; auto.\n   Qed.\n", "definition": "\n    forall a b : Ensemble U, Included U (Intersection U a b) b.\n   ", "proof": "\n   intros a b; red in |- *; auto.\n   intros x H'; elim H'; auto.\n   ", "def_ranges": [105, 0, 106, 63], "proof_ranges": [107, 0, 110, 7], "proof_steps": [{"text": "intros a b; red in |- *; auto.", "goal_before": ["forall a b : Ensemble U, Included U (Intersection U a b) b"], "goal_after": ["forall x : U, In U (Intersection U a b) x -> In U b x"], "proof_term_before": [], "proof_term_after": ["(fun a b : Ensemble U => ?Goal : Included U (Intersection U a b) b)"]}, {"text": "intros x H'; elim H'; auto.", "goal_before": ["forall x : U, In U (Intersection U a b) x -> In U b x"], "goal_after": [], "proof_term_before": ["(fun a b : Ensemble U => ?Goal : Included U (Intersection U a b) b)"], "proof_term_after": ["(fun a b : Ensemble U =>\n (fun (x : U) (H' : In U (Intersection U a b) x) =>\n  Intersection_ind U a b (fun x0 : U => In U b x0)\n    (fun (x0 : U) (_ : In U a x0) (H0 : In U b x0) => H0) x H')\n :\n Included U (Intersection U a b) b)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun a b : Ensemble U =>\n (fun (x : U) (H' : In U (Intersection U a b) x) =>\n  Intersection_ind U a b (fun x0 : U => In U b x0)\n    (fun (x0 : U) (_ : In U a x0) (H0 : In U b x0) => H0) x H')\n :\n Included U (Intersection U a b) b)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Empty_set_is_Bottom", "text": "Theorem Empty_set_is_Bottom :\n    Bottom (Ensemble U) Power_set_PO (Empty_set U).\n   Proof.\n   apply Bottom_definition; simpl in |- *; auto.\n   Qed.\n", "definition": "\n    Bottom (Ensemble U) Power_set_PO (Empty_set U).\n   ", "proof": "\n   apply Bottom_definition; simpl in |- *; auto.\n   ", "def_ranges": [114, 0, 115, 51], "proof_ranges": [116, 0, 118, 7], "proof_steps": [{"text": "apply Bottom_definition; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Union_is_Lub", "text": "Theorem Union_is_Lub :\n    forall a b : Ensemble U,\n    Included U a A ->\n    Included U b A ->\n    Lub (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Union U a b).\n   Proof.\n   intros a b H' H'0.\n   apply Lub_definition; simpl in |- *.\n   apply Upper_Bound_definition; simpl in |- *.\n   auto.\n   intros y H'1; elim H'1; auto.\n   intros y H'1; elim H'1; simpl in |- *; auto.\n   Qed.\n", "definition": "\n    forall a b : Ensemble U,\n    Included U a A ->\n    Included U b A ->\n    Lub (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Union U a b).\n   ", "proof": "\n   intros a b H' H'0.\n   apply Lub_definition; simpl in |- *.\n   apply Upper_Bound_definition; simpl in |- *.\n   auto.\n   intros y H'1; elim H'1; auto.\n   intros y H'1; elim H'1; simpl in |- *; auto.\n   ", "def_ranges": [121, 0, 125, 74], "proof_ranges": [126, 0, 133, 7], "proof_steps": [{"text": "intros a b H' H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lub_definition; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'1; elim H'1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'1; elim H'1; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Intersection_is_Glb", "text": "Theorem Intersection_is_Glb :\n    forall a b : Ensemble U,\n    Included U a A ->\n    Included U b A ->\n    Glb (Ensemble U) Power_set_PO (Couple (Ensemble U) a b)\n      (Intersection U a b).\n   Proof.\n   intros a b H' H'0.\n   apply Glb_definition.\n   apply Lower_Bound_definition; simpl in |- *.\n   apply Definition_of_Power_set; auto.\n   generalize Inclusion_is_transitive; intro IT; red in IT; apply IT with a;\n    auto.\n   intros y H'1; elim H'1; auto.\n   intros y H'1; elim H'1; simpl in |- *; auto.\n   Qed.\n", "definition": "\n    forall a b : Ensemble U,\n    Included U a A ->\n    Included U b A ->\n    Glb (Ensemble U) Power_set_PO (Couple (Ensemble U) a b)\n      (Intersection U a b).\n   ", "proof": "\n   intros a b H' H'0.\n   apply Glb_definition.\n   apply Lower_Bound_definition; simpl in |- *.\n   apply Definition_of_Power_set; auto.\n   generalize Inclusion_is_transitive; intro IT; red in IT; apply IT with a;\n    auto.\n   intros y H'1; elim H'1; auto.\n   intros y H'1; elim H'1; simpl in |- *; auto.\n   ", "def_ranges": [136, 0, 141, 27], "proof_ranges": [142, 0, 151, 7], "proof_steps": [{"text": "intros a b H' H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Glb_definition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lower_Bound_definition; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Power_set; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize Inclusion_is_transitive; intro IT; red in IT; apply IT with a;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'1; elim H'1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'1; elim H'1; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Empty_set_zero", "text": "Theorem Empty_set_zero :\n    forall X : Ensemble U, Union U (Empty_set U) X = X.\n   Proof.\n   auto 10.\n   Qed.\n", "definition": "\n    forall X : Ensemble U, Union U (Empty_set U) X = X.\n   ", "proof": "\n   auto 10.\n   ", "def_ranges": [153, 0, 154, 55], "proof_ranges": [155, 0, 157, 7], "proof_steps": [{"text": "auto 10.", "goal_before": ["forall X : Ensemble U, Union U (Empty_set U) X = X"], "goal_after": ["forall X : Ensemble U, Union U (Empty_set U) X = X"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall X : Ensemble U, Union U (Empty_set U) X = X"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Union_commutative", "text": "Theorem Union_commutative :\n    forall A B : Ensemble U, Union U A B = Union U B A.\n   Proof.\n   auto.\n   Qed.\n", "definition": "\n    forall A B : Ensemble U, Union U A B = Union U B A.\n   ", "proof": "\n   auto.\n   ", "def_ranges": [159, 0, 160, 55], "proof_ranges": [161, 0, 163, 7], "proof_steps": [{"text": "auto.", "goal_before": ["forall A0 B : Ensemble U, Union U A0 B = Union U B A0"], "goal_after": ["forall A0 B : Ensemble U, Union U A0 B = Union U B A0"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall A0 B : Ensemble U, Union U A0 B = Union U B A0"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Union_associative", "text": "Theorem Union_associative :\n    forall A B C : Ensemble U,\n    Union U (Union U A B) C = Union U A (Union U B C).\n   Proof.\n   auto 20.\n   Qed.\n", "definition": "\n    forall A B C : Ensemble U,\n    Union U (Union U A B) C = Union U A (Union U B C).\n   ", "proof": "\n   auto 20.\n   ", "def_ranges": [165, 0, 167, 54], "proof_ranges": [168, 0, 170, 7], "proof_steps": [{"text": "auto 20.", "goal_before": ["forall A0 B C : Ensemble U,\nUnion U (Union U A0 B) C = Union U A0 (Union U B C)"], "goal_after": ["forall A0 B C : Ensemble U,\nUnion U (Union U A0 B) C = Union U A0 (Union U B C)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall A0 B C : Ensemble U,\nUnion U (Union U A0 B) C = Union U A0 (Union U B C)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Non_disjoint_union", "text": "Theorem Non_disjoint_union :\n    forall (X : Ensemble U) (x : U),\n    In U X x -> Union U (Singleton U x) X = X.\n   Proof.\n   intros X x H'; try assumption; auto 10.\n   apply Extensionality_Ensembles; unfold Same_set in |- *; split;\n    auto.\n   red in |- *; auto 10.\n   intros x0 H'0; elim H'0; auto 10.\n   intros x1 H'1; elim H'1; auto 10.\n   Qed.\n", "definition": "\n    forall (X : Ensemble U) (x : U),\n    In U X x -> Union U (Singleton U x) X = X.\n   ", "proof": "\n   intros X x H'; try assumption; auto 10.\n   apply Extensionality_Ensembles; unfold Same_set in |- *; split;\n    auto.\n   red in |- *; auto 10.\n   intros x0 H'0; elim H'0; auto 10.\n   intros x1 H'1; elim H'1; auto 10.\n   ", "def_ranges": [172, 0, 174, 46], "proof_ranges": [175, 0, 182, 7], "proof_steps": [{"text": "intros X x H'; try assumption; auto 10.", "goal_before": ["forall (X : Ensemble U) (x : U), In U X x -> Union U (Singleton U x) X = X"], "goal_after": ["Union U (Singleton U x) X = X"], "proof_term_before": [], "proof_term_after": ["(fun (X : Ensemble U) (x : U) (H' : In U X x) => ?Goal)"]}, {"text": "apply Extensionality_Ensembles; unfold Same_set in |- *; split;", "goal_before": ["Union U (Singleton U x) X = X"], "goal_after": ["Union U (Singleton U x) X = X"], "proof_term_before": ["(fun (X : Ensemble U) (x : U) (H' : In U X x) => ?Goal)"], "proof_term_after": []}, {"text": "auto.", "goal_before": ["Union U (Singleton U x) X = X"], "goal_after": ["Union U (Singleton U x) X = X"], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; auto 10.", "goal_before": ["Union U (Singleton U x) X = X"], "goal_after": ["Union U (Singleton U x) X = X"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'0; elim H'0; auto 10.", "goal_before": ["Union U (Singleton U x) X = X"], "goal_after": ["Union U (Singleton U x) X = X"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 H'1; elim H'1; auto 10.", "goal_before": ["Union U (Singleton U x) X = X"], "goal_after": ["Union U (Singleton U x) X = X"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Finite_plus_one_is_finite", "text": "Theorem Finite_plus_one_is_finite :\n    forall (X : Ensemble U) (x : U),\n    Finite U X -> Finite U (Union U (Singleton U x) X).\n   Proof.\n   intros X x H'.\n   generalize (classic (In U X x)); intro h; elim h;\n    [ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ];\n    auto 10.\n   generalize (Non_disjoint_union X x); intro h; lapply h;\n    [ intro H'1; rewrite H'1; clear h | clear h ]; \n    auto.\n   Qed.\n", "definition": "\n    forall (X : Ensemble U) (x : U),\n    Finite U X -> Finite U (Union U (Singleton U x) X).\n   ", "proof": "\n   intros X x H'.\n   generalize (classic (In U X x)); intro h; elim h;\n    [ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ];\n    auto 10.\n   generalize (Non_disjoint_union X x); intro h; lapply h;\n    [ intro H'1; rewrite H'1; clear h | clear h ]; \n    auto.\n   ", "def_ranges": [184, 0, 186, 55], "proof_ranges": [187, 0, 195, 7], "proof_steps": [{"text": "intros X x H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (classic (In U X x)); intro h; elim h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Non_disjoint_union X x); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'1; rewrite H'1; clear h | clear h ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Singleton_is_finite", "text": "Theorem Singleton_is_finite : forall x : U, Finite U (Singleton U x).\n   Proof.\n   intro x; generalize (Empty_set_zero (Singleton U x)); intro h;\n    rewrite <- h; clear h.\n   generalize (Union_commutative (Empty_set U) (Singleton U x)); intro h;\n    rewrite h; clear h; auto.\n   Qed.\n", "definition": " forall x : U, Finite U (Singleton U x).\n   ", "proof": "\n   intro x; generalize (Empty_set_zero (Singleton U x)); intro h;\n    rewrite <- h; clear h.\n   generalize (Union_commutative (Empty_set U) (Singleton U x)); intro h;\n    rewrite h; clear h; auto.\n   ", "def_ranges": [198, 0, 198, 72], "proof_ranges": [199, 0, 204, 7], "proof_steps": [{"text": "intro x; generalize (Empty_set_zero (Singleton U x)); intro h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- h; clear h.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Union_commutative (Empty_set U) (Singleton U x)); intro h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite h; clear h; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ps.v", "name": "Union_of_finite_is_finite", "text": "Theorem Union_of_finite_is_finite :\n    forall X Y : Ensemble U,\n    Finite U X -> Finite U Y -> Finite U (Union U X Y).\n   Proof.\n   intros X Y H'; elim H'.\n   generalize (Empty_set_zero Y); intro h; rewrite h; clear h; auto.\n   clear A.\n   intros AA H'0 H'1 x H'2 H'3.\n   generalize (Union_associative (Singleton U x) AA Y); intro h; rewrite h;\n    clear h; auto.\n   Qed.\n", "definition": "\n    forall X Y : Ensemble U,\n    Finite U X -> Finite U Y -> Finite U (Union U X Y).\n   ", "proof": "\n   intros X Y H'; elim H'.\n   generalize (Empty_set_zero Y); intro h; rewrite h; clear h; auto.\n   clear A.\n   intros AA H'0 H'1 x H'2 H'3.\n   generalize (Union_associative (Singleton U x) AA Y); intro h; rewrite h;\n    clear h; auto.\n   ", "def_ranges": [207, 0, 209, 55], "proof_ranges": [210, 0, 217, 7], "proof_steps": [{"text": "intros X Y H'; elim H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Empty_set_zero Y); intro h; rewrite h; clear h; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear A.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros AA H'0 H'1 x H'2 H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Union_associative (Singleton U x) AA Y); intro h; rewrite h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Rstar_reflexive", "text": "Theorem Rstar_reflexive :\n forall (U : Type) (R : Relation U), Reflexive U (Rstar U R).\nauto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Reflexive U (Rstar U R).", "proof": "\nauto.\n", "def_ranges": [12, 0, 13, 61], "proof_ranges": [14, 0, 15, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall (U : Type) (R : Relation U), Reflexive U (Rstar U R)"], "goal_after": ["forall (U : Type) (R : Relation U), Reflexive U (Rstar U R)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall (U : Type) (R : Relation U), Reflexive U (Rstar U R)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Rplus_contains_R", "text": "Theorem Rplus_contains_R :\n forall (U : Type) (R : Relation U), contains U (Rplus U R) R.\nauto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), contains U (Rplus U R) R.", "proof": "\nauto.\n", "def_ranges": [17, 0, 18, 62], "proof_ranges": [19, 0, 20, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall (U : Type) (R : Relation U), contains U (Rplus U R) R"], "goal_after": ["forall (U : Type) (R : Relation U), contains U (Rplus U R) R"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall (U : Type) (R : Relation U), contains U (Rplus U R) R"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Rstar_contains_R", "text": "Theorem Rstar_contains_R :\n forall (U : Type) (R : Relation U), contains U (Rstar U R) R.\nintros U R; red in |- *; intros x y H'; apply Rstar_n with y; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), contains U (Rstar U R) R.", "proof": "\nintros U R; red in |- *; intros x y H'; apply Rstar_n with y; auto.\n", "def_ranges": [22, 0, 23, 62], "proof_ranges": [24, 0, 25, 4], "proof_steps": [{"text": "intros U R; red in |- *; intros x y H'; apply Rstar_n with y; auto.", "goal_before": ["forall (U : Type) (R : Relation U), contains U (Rstar U R) R"], "goal_after": ["Rstar U R y y"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y : U) (H' : R x y) => Rstar_n U R x y y H' ?Goal)\n :\n contains U (Rstar U R) R)"]}, {"text": "Qed.", "goal_before": ["Rstar U R y y"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y : U) (H' : R x y) => Rstar_n U R x y y H' ?Goal)\n :\n contains U (Rstar U R) R)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Rstar_contains_Rplus", "text": "Theorem Rstar_contains_Rplus :\n forall (U : Type) (R : Relation U), contains U (Rstar U R) (Rplus U R).\nintros U R; red in |- *.\nintros x y H'; elim H'.\ngeneralize Rstar_contains_R; intro T; red in T; auto.\nintros x0 y0 z H'0 H'1 H'2; apply Rstar_n with y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), contains U (Rstar U R) (Rplus U R).", "proof": "\nintros U R; red in |- *.\nintros x y H'; elim H'.\ngeneralize Rstar_contains_R; intro T; red in T; auto.\nintros x0 y0 z H'0 H'1 H'2; apply Rstar_n with y0; auto.\n", "def_ranges": [27, 0, 28, 72], "proof_ranges": [29, 0, 33, 4], "proof_steps": [{"text": "intros U R; red in |- *.", "goal_before": ["forall (U : Type) (R : Relation U), contains U (Rstar U R) (Rplus U R)"], "goal_after": ["forall x y : U, Rplus U R x y -> Rstar U R x y"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) =>\n ?Goal : contains U (Rstar U R) (Rplus U R))"]}, {"text": "intros x y H'; elim H'.", "goal_before": ["forall x y : U, Rplus U R x y -> Rstar U R x y"], "goal_after": ["forall x0 y0 : U, R x0 y0 -> Rstar U R x0 y0", "forall x0 y0 z : U,\nR x0 y0 -> Rplus U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) =>\n ?Goal : contains U (Rstar U R) (Rplus U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y : U) (H' : Rplus U R x y) =>\n  Rplus_ind U R (fun x0 y0 : U => Rstar U R x0 y0) ?Goal ?Goal0 x y H')\n :\n contains U (Rstar U R) (Rplus U R))"]}, {"text": "generalize Rstar_contains_R; intro T; red in T; auto.", "goal_before": ["forall x0 y0 : U, R x0 y0 -> Rstar U R x0 y0", "forall x0 y0 z : U,\nR x0 y0 -> Rplus U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z"], "goal_after": ["forall x0 y0 z : U,\nR x0 y0 -> Rplus U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y : U) (H' : Rplus U R x y) =>\n  Rplus_ind U R (fun x0 y0 : U => Rstar U R x0 y0) ?Goal ?Goal0 x y H')\n :\n contains U (Rstar U R) (Rplus U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y : U) (H' : Rplus U R x y) =>\n  Rplus_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n    ((fun\n        (T : forall (U0 : Type) (R0 : Relation U0),\n             contains U0 (Rstar U0 R0) R0) (x0 y0 : U) \n        (H : R x0 y0) => T U R x0 y0 H) Rstar_contains_R) \n    ?Goal x y H')\n :\n contains U (Rstar U R) (Rplus U R))"]}, {"text": "intros x0 y0 z H'0 H'1 H'2; apply Rstar_n with y0; auto.", "goal_before": ["forall x0 y0 z : U,\nR x0 y0 -> Rplus U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y : U) (H' : Rplus U R x y) =>\n  Rplus_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n    ((fun\n        (T : forall (U0 : Type) (R0 : Relation U0),\n             contains U0 (Rstar U0 R0) R0) (x0 y0 : U) \n        (H : R x0 y0) => T U R x0 y0 H) Rstar_contains_R) \n    ?Goal x y H')\n :\n contains U (Rstar U R) (Rplus U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y : U) (H' : Rplus U R x y) =>\n  Rplus_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n    ((fun\n        (T : forall (U0 : Type) (R0 : Relation U0),\n             contains U0 (Rstar U0 R0) R0) (x0 y0 : U) \n        (H : R x0 y0) => T U R x0 y0 H) Rstar_contains_R)\n    (fun (x0 y0 z : U) (H'0 : R x0 y0) (_ : Rplus U R y0 z)\n       (H'2 : Rstar U R y0 z) => Rstar_n U R x0 y0 z H'0 H'2) x y H')\n :\n contains U (Rstar U R) (Rplus U R))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y : U) (H' : Rplus U R x y) =>\n  Rplus_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n    ((fun\n        (T : forall (U0 : Type) (R0 : Relation U0),\n             contains U0 (Rstar U0 R0) R0) (x0 y0 : U) \n        (H : R x0 y0) => T U R x0 y0 H) Rstar_contains_R)\n    (fun (x0 y0 z : U) (H'0 : R x0 y0) (_ : Rplus U R y0 z)\n       (H'2 : Rstar U R y0 z) => Rstar_n U R x0 y0 z H'0 H'2) x y H')\n :\n contains U (Rstar U R) (Rplus U R))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Rstar_transitive", "text": "Theorem Rstar_transitive :\n forall (U : Type) (R : Relation U), Transitive U (Rstar U R).\nintros U R; red in |- *.\nintros x y z H'; elim H'; auto.\nintros x0 y0 z0 H'0 H'1 H'2 H'3; apply Rstar_n with y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Transitive U (Rstar U R).", "proof": "\nintros U R; red in |- *.\nintros x y z H'; elim H'; auto.\nintros x0 y0 z0 H'0 H'1 H'2 H'3; apply Rstar_n with y0; auto.\n", "def_ranges": [35, 0, 36, 62], "proof_ranges": [37, 0, 40, 4], "proof_steps": [{"text": "intros U R; red in |- *.", "goal_before": ["forall (U : Type) (R : Relation U), Transitive U (Rstar U R)"], "goal_after": ["forall x y z : U, Rstar U R x y -> Rstar U R y z -> Rstar U R x z"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) => ?Goal : Transitive U (Rstar U R))"]}, {"text": "intros x y z H'; elim H'; auto.", "goal_before": ["forall x y z : U, Rstar U R x y -> Rstar U R y z -> Rstar U R x z"], "goal_after": ["forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rstar U R z0 z -> Rstar U R y0 z) -> Rstar U R z0 z -> Rstar U R x0 z"], "proof_term_before": ["(fun (U : Type) (R : Relation U) => ?Goal : Transitive U (Rstar U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y z : U) (H' : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 z -> Rstar U R x0 z)\n    (fun (x0 : U) (H : Rstar U R x0 z) => H) ?Goal x y H')\n :\n Transitive U (Rstar U R))"]}, {"text": "intros x0 y0 z0 H'0 H'1 H'2 H'3; apply Rstar_n with y0; auto.", "goal_before": ["forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rstar U R z0 z -> Rstar U R y0 z) -> Rstar U R z0 z -> Rstar U R x0 z"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y z : U) (H' : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 z -> Rstar U R x0 z)\n    (fun (x0 : U) (H : Rstar U R x0 z) => H) ?Goal x y H')\n :\n Transitive U (Rstar U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y z : U) (H' : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 z -> Rstar U R x0 z)\n    (fun (x0 : U) (H : Rstar U R x0 z) => H)\n    (fun (x0 y0 z0 : U) (H'0 : R x0 y0) (_ : Rstar U R y0 z0)\n       (H'2 : Rstar U R z0 z -> Rstar U R y0 z) (H'3 : Rstar U R z0 z) =>\n     Rstar_n U R x0 y0 z H'0 (H'2 H'3)) x y H')\n :\n Transitive U (Rstar U R))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) =>\n (fun (x y z : U) (H' : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 z -> Rstar U R x0 z)\n    (fun (x0 : U) (H : Rstar U R x0 z) => H)\n    (fun (x0 y0 z0 : U) (H'0 : R x0 y0) (_ : Rstar U R y0 z0)\n       (H'2 : Rstar U R z0 z -> Rstar U R y0 z) (H'3 : Rstar U R z0 z) =>\n     Rstar_n U R x0 y0 z H'0 (H'2 H'3)) x y H')\n :\n Transitive U (Rstar U R))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Rstar_cases", "text": "Theorem Rstar_cases :\n forall (U : Type) (R : Relation U) (x y : U),\n Rstar U R x y -> x = y :>U \\/ (exists u : U, R x u /\\ Rstar U R u y).\nintros U R x y H'; elim H'; auto.\nintros x0 y0 z H'0 H'1 H'2; right; exists y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U) (x y : U),\n Rstar U R x y -> x = y :>U \\/ (exists u : U, R x u /\\ Rstar U R u y).", "proof": "\nintros U R x y H'; elim H'; auto.\nintros x0 y0 z H'0 H'1 H'2; right; exists y0; auto.\n", "def_ranges": [42, 0, 44, 70], "proof_ranges": [45, 0, 47, 4], "proof_steps": [{"text": "intros U R x y H'; elim H'; auto.", "goal_before": ["forall (U : Type) (R : Relation U) (x y : U),\nRstar U R x y -> x = y \\/ (exists u : U, R x u /\\ Rstar U R u y)"], "goal_after": ["forall x0 y0 z : U,\nR x0 y0 ->\nRstar U R y0 z ->\ny0 = z \\/ (exists u : U, R y0 u /\\ Rstar U R u z) ->\nx0 = z \\/ (exists u : U, R x0 u /\\ Rstar U R u z)"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (x y : U) (H' : Rstar U R x y) =>\n Rstar_ind U R\n   (fun x0 y0 : U => x0 = y0 \\/ (exists u : U, R x0 u /\\ Rstar U R u y0))\n   (fun x0 : U => or_introl eq_refl) ?Goal x y H')"]}, {"text": "intros x0 y0 z H'0 H'1 H'2; right; exists y0; auto.", "goal_before": ["forall x0 y0 z : U,\nR x0 y0 ->\nRstar U R y0 z ->\ny0 = z \\/ (exists u : U, R y0 u /\\ Rstar U R u z) ->\nx0 = z \\/ (exists u : U, R x0 u /\\ Rstar U R u z)"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) (x y : U) (H' : Rstar U R x y) =>\n Rstar_ind U R\n   (fun x0 y0 : U => x0 = y0 \\/ (exists u : U, R x0 u /\\ Rstar U R u y0))\n   (fun x0 : U => or_introl eq_refl) ?Goal x y H')"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (x y : U) (H' : Rstar U R x y) =>\n Rstar_ind U R\n   (fun x0 y0 : U => x0 = y0 \\/ (exists u : U, R x0 u /\\ Rstar U R u y0))\n   (fun x0 : U => or_introl eq_refl)\n   (fun (x0 y0 z : U) (H'0 : R x0 y0) (H'1 : Rstar U R y0 z)\n      (_ : y0 = z \\/ (exists u : U, R y0 u /\\ Rstar U R u z)) =>\n    or_intror\n      (ex_intro (fun u : U => R x0 u /\\ Rstar U R u z) y0 (conj H'0 H'1))) x\n   y H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) (x y : U) (H' : Rstar U R x y) =>\n Rstar_ind U R\n   (fun x0 y0 : U => x0 = y0 \\/ (exists u : U, R x0 u /\\ Rstar U R u y0))\n   (fun x0 : U => or_introl eq_refl)\n   (fun (x0 y0 z : U) (H'0 : R x0 y0) (H'1 : Rstar U R y0 z)\n      (_ : y0 = z \\/ (exists u : U, R y0 u /\\ Rstar U R u z)) =>\n    or_intror\n      (ex_intro (fun u : U => R x0 u /\\ Rstar U R u z) y0 (conj H'0 H'1))) x\n   y H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Rstar_equiv_Rstar1", "text": "Theorem Rstar_equiv_Rstar1 :\n forall (U : Type) (R : Relation U), same_relation U (Rstar U R) (Rstar1 U R).\ngeneralize Rstar_contains_R; intro T; red in T.\nintros U R; unfold same_relation, contains in |- *.\nsplit; intros x y H'; elim H'; auto.\ngeneralize Rstar_transitive; intro T1; red in T1.\nintros x0 y0 z H'0 H'1 H'2 H'3; apply T1 with y0; auto.\nintros x0 y0 z H'0 H'1 H'2; apply Rstar1_n with y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), same_relation U (Rstar U R) (Rstar1 U R).", "proof": "\ngeneralize Rstar_contains_R; intro T; red in T.\nintros U R; unfold same_relation, contains in |- *.\nsplit; intros x y H'; elim H'; auto.\ngeneralize Rstar_transitive; intro T1; red in T1.\nintros x0 y0 z H'0 H'1 H'2 H'3; apply T1 with y0; auto.\nintros x0 y0 z H'0 H'1 H'2; apply Rstar1_n with y0; auto.\n", "def_ranges": [49, 0, 50, 78], "proof_ranges": [51, 0, 57, 4], "proof_steps": [{"text": "generalize Rstar_contains_R; intro T; red in T.", "goal_before": ["forall (U : Type) (R : Relation U), same_relation U (Rstar U R) (Rstar1 U R)"], "goal_after": ["forall (U : Type) (R : Relation U), same_relation U (Rstar U R) (Rstar1 U R)"], "proof_term_before": [], "proof_term_after": ["((fun T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R =>\n  ?Goal) Rstar_contains_R)"]}, {"text": "intros U R; unfold same_relation, contains in |- *.", "goal_before": ["forall (U : Type) (R : Relation U), same_relation U (Rstar U R) (Rstar1 U R)"], "goal_after": ["(forall x y : U, Rstar1 U R x y -> Rstar U R x y) /\\\n(forall x y : U, Rstar U R x y -> Rstar1 U R x y)"], "proof_term_before": ["((fun T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R =>\n  ?Goal) Rstar_contains_R)"], "proof_term_after": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  ?Goal : same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"]}, {"text": "split; intros x y H'; elim H'; auto.", "goal_before": ["(forall x y : U, Rstar1 U R x y -> Rstar U R x y) /\\\n(forall x y : U, Rstar U R x y -> Rstar1 U R x y)"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nRstar1 U R x0 y0 ->\nRstar U R x0 y0 -> Rstar1 U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z", "forall x0 : U, Rstar1 U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar1 U R y0 z -> Rstar1 U R x0 z"], "proof_term_before": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  ?Goal : same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"], "proof_term_after": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  conj\n    (fun (x y : U) (H' : Rstar1 U R x y) =>\n     Rstar1_ind U R (fun x0 y0 : U => Rstar U R x0 y0) \n       ?Goal (fun (x0 y0 : U) (H : R x0 y0) => T U R x0 y0 H) \n       ?Goal0 x y H')\n    (fun (x y : U) (H' : Rstar U R x y) =>\n     Rstar_ind U R (fun x0 y0 : U => Rstar1 U R x0 y0) ?Goal1 ?Goal2 x y H')\n  :\n  same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"]}, {"text": "generalize Rstar_transitive; intro T1; red in T1.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nRstar1 U R x0 y0 ->\nRstar U R x0 y0 -> Rstar1 U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z", "forall x0 : U, Rstar1 U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar1 U R y0 z -> Rstar1 U R x0 z"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nRstar1 U R x0 y0 ->\nRstar U R x0 y0 -> Rstar1 U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z", "forall x0 : U, Rstar1 U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar1 U R y0 z -> Rstar1 U R x0 z"], "proof_term_before": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  conj\n    (fun (x y : U) (H' : Rstar1 U R x y) =>\n     Rstar1_ind U R (fun x0 y0 : U => Rstar U R x0 y0) \n       ?Goal (fun (x0 y0 : U) (H : R x0 y0) => T U R x0 y0 H) \n       ?Goal0 x y H')\n    (fun (x y : U) (H' : Rstar U R x y) =>\n     Rstar_ind U R (fun x0 y0 : U => Rstar1 U R x0 y0) ?Goal1 ?Goal2 x y H')\n  :\n  same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"], "proof_term_after": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  conj\n    (fun (x y : U) (H' : Rstar1 U R x y) =>\n     Rstar1_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n       ((fun\n           T1 : forall (U0 : Type) (R0 : Relation U0),\n                Transitive U0 (Rstar U0 R0) => ?Goal2) Rstar_transitive)\n       (fun (x0 y0 : U) (H : R x0 y0) => T U R x0 y0 H) \n       ?Goal x y H')\n    (fun (x y : U) (H' : Rstar U R x y) =>\n     Rstar_ind U R (fun x0 y0 : U => Rstar1 U R x0 y0) ?Goal0 ?Goal1 x y H')\n  :\n  same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"]}, {"text": "intros x0 y0 z H'0 H'1 H'2 H'3; apply T1 with y0; auto.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nRstar1 U R x0 y0 ->\nRstar U R x0 y0 -> Rstar1 U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z", "forall x0 : U, Rstar1 U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar1 U R y0 z -> Rstar1 U R x0 z"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nRstar1 U R x0 y0 ->\nRstar U R x0 y0 -> Rstar1 U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z", "forall x0 : U, Rstar1 U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar1 U R y0 z -> Rstar1 U R x0 z"], "proof_term_before": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  conj\n    (fun (x y : U) (H' : Rstar1 U R x y) =>\n     Rstar1_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n       ((fun\n           T1 : forall (U0 : Type) (R0 : Relation U0),\n                Transitive U0 (Rstar U0 R0) => ?Goal2) Rstar_transitive)\n       (fun (x0 y0 : U) (H : R x0 y0) => T U R x0 y0 H) \n       ?Goal x y H')\n    (fun (x y : U) (H' : Rstar U R x y) =>\n     Rstar_ind U R (fun x0 y0 : U => Rstar1 U R x0 y0) ?Goal0 ?Goal1 x y H')\n  :\n  same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"], "proof_term_after": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  conj\n    (fun (x y : U) (H' : Rstar1 U R x y) =>\n     Rstar1_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n       ((fun\n           T1 : forall (U0 : Type) (R0 : Relation U0),\n                Transitive U0 (Rstar U0 R0) => ?Goal2) Rstar_transitive)\n       (fun (x0 y0 : U) (H : R x0 y0) => T U R x0 y0 H) \n       ?Goal x y H')\n    (fun (x y : U) (H' : Rstar U R x y) =>\n     Rstar_ind U R (fun x0 y0 : U => Rstar1 U R x0 y0) ?Goal0 ?Goal1 x y H')\n  :\n  same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"]}, {"text": "intros x0 y0 z H'0 H'1 H'2; apply Rstar1_n with y0; auto.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nRstar1 U R x0 y0 ->\nRstar U R x0 y0 -> Rstar1 U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z", "forall x0 : U, Rstar1 U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar1 U R y0 z -> Rstar1 U R x0 z"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nRstar1 U R x0 y0 ->\nRstar U R x0 y0 -> Rstar1 U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z", "forall x0 : U, Rstar1 U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar1 U R y0 z -> Rstar1 U R x0 z"], "proof_term_before": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  conj\n    (fun (x y : U) (H' : Rstar1 U R x y) =>\n     Rstar1_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n       ((fun\n           T1 : forall (U0 : Type) (R0 : Relation U0),\n                Transitive U0 (Rstar U0 R0) => ?Goal2) Rstar_transitive)\n       (fun (x0 y0 : U) (H : R x0 y0) => T U R x0 y0 H) \n       ?Goal x y H')\n    (fun (x y : U) (H' : Rstar U R x y) =>\n     Rstar_ind U R (fun x0 y0 : U => Rstar1 U R x0 y0) ?Goal0 ?Goal1 x y H')\n  :\n  same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"], "proof_term_after": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  conj\n    (fun (x y : U) (H' : Rstar1 U R x y) =>\n     Rstar1_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n       ((fun\n           T1 : forall (U0 : Type) (R0 : Relation U0),\n                Transitive U0 (Rstar U0 R0) => ?Goal2) Rstar_transitive)\n       (fun (x0 y0 : U) (H : R x0 y0) => T U R x0 y0 H) \n       ?Goal x y H')\n    (fun (x y : U) (H' : Rstar U R x y) =>\n     Rstar_ind U R (fun x0 y0 : U => Rstar1 U R x0 y0) ?Goal0 ?Goal1 x y H')\n  :\n  same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"]}, {"text": "Qed.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nRstar1 U R x0 y0 ->\nRstar U R x0 y0 -> Rstar1 U R y0 z -> Rstar U R y0 z -> Rstar U R x0 z", "forall x0 : U, Rstar1 U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar1 U R y0 z -> Rstar1 U R x0 z"], "goal_after": [], "proof_term_before": ["((fun (T : forall (U : Type) (R : Relation U), contains U (Rstar U R) R)\n    (U : Type) (R : Relation U) =>\n  conj\n    (fun (x y : U) (H' : Rstar1 U R x y) =>\n     Rstar1_ind U R (fun x0 y0 : U => Rstar U R x0 y0)\n       ((fun\n           T1 : forall (U0 : Type) (R0 : Relation U0),\n                Transitive U0 (Rstar U0 R0) => ?Goal2) Rstar_transitive)\n       (fun (x0 y0 : U) (H : R x0 y0) => T U R x0 y0 H) \n       ?Goal x y H')\n    (fun (x y : U) (H' : Rstar U R x y) =>\n     Rstar_ind U R (fun x0 y0 : U => Rstar1 U R x0 y0) ?Goal0 ?Goal1 x y H')\n  :\n  same_relation U (Rstar U R) (Rstar1 U R)) Rstar_contains_R)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Rsym_imp_Rstarsym", "text": "Theorem Rsym_imp_Rstarsym :\n forall (U : Type) (R : Relation U), Symmetric U R -> Symmetric U (Rstar U R).\nintros U R H'; red in |- *.\nintros x y H'0; elim H'0; auto.\nintros x0 y0 z H'1 H'2 H'3.\ngeneralize Rstar_transitive; intro T; red in T.\napply T with y0; auto.\napply Rstar_n with x0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Symmetric U R -> Symmetric U (Rstar U R).", "proof": "\nintros U R H'; red in |- *.\nintros x y H'0; elim H'0; auto.\nintros x0 y0 z H'1 H'2 H'3.\ngeneralize Rstar_transitive; intro T; red in T.\napply T with y0; auto.\napply Rstar_n with x0; auto.\n", "def_ranges": [59, 0, 60, 78], "proof_ranges": [61, 0, 67, 4], "proof_steps": [{"text": "intros U R H'; red in |- *.", "goal_before": ["forall (U : Type) (R : Relation U), Symmetric U R -> Symmetric U (Rstar U R)"], "goal_after": ["forall x y : U, Rstar U R x y -> Rstar U R y x"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n ?Goal : Symmetric U (Rstar U R))"]}, {"text": "intros x y H'0; elim H'0; auto.", "goal_before": ["forall x y : U, Rstar U R x y -> Rstar U R y x"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n ?Goal : Symmetric U (Rstar U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0) ?Goal ?Goal0 x y H'0)\n :\n Symmetric U (Rstar U R))"]}, {"text": "intros x0 y0 z H'1 H'2 H'3.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0) ?Goal ?Goal0 x y H'0)\n :\n Symmetric U (Rstar U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0) ?Goal ?Goal0 x y H'0)\n :\n Symmetric U (Rstar U R))"]}, {"text": "generalize Rstar_transitive; intro T; red in T.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0) ?Goal ?Goal0 x y H'0)\n :\n Symmetric U (Rstar U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n Symmetric U (Rstar U R))"]}, {"text": "apply T with y0; auto.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n Symmetric U (Rstar U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n Symmetric U (Rstar U R))"]}, {"text": "apply Rstar_n with x0; auto.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "goal_after": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n Symmetric U (Rstar U R))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n Symmetric U (Rstar U R))"]}, {"text": "Qed.", "goal_before": ["forall x0 : U, Rstar U R x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U R z y0 -> Rstar U R z x0"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Symmetric U R) =>\n (fun (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U R y0 x0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n Symmetric U (Rstar U R))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Sstar_contains_Rstar", "text": "Theorem Sstar_contains_Rstar :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R).\nunfold contains in |- *.\nintros U R S H' x y H'0; elim H'0; auto.\ngeneralize Rstar_transitive; intro T; red in T.\nintros x0 y0 z H'1 H'2 H'3; apply T with y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R).", "proof": "\nunfold contains in |- *.\nintros U R S H' x y H'0; elim H'0; auto.\ngeneralize Rstar_transitive; intro T; red in T.\nintros x0 y0 z H'1 H'2 H'3; apply T with y0; auto.\n", "def_ranges": [69, 0, 71, 64], "proof_ranges": [72, 0, 76, 4], "proof_steps": [{"text": "unfold contains in |- *.", "goal_before": ["forall (U : Type) (R S : Relation U),\ncontains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R)"], "goal_after": ["forall (U : Type) (R S : Relation U),\n(forall x y : U, R x y -> Rstar U S x y) ->\nforall x y : U, Rstar U R x y -> Rstar U S x y"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R))"]}, {"text": "intros U R S H' x y H'0; elim H'0; auto.", "goal_before": ["forall (U : Type) (R S : Relation U),\n(forall x y : U, R x y -> Rstar U S x y) ->\nforall x y : U, Rstar U R x y -> Rstar U S x y"], "goal_after": ["forall x0 : U, Rstar U S x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U S y0 z -> Rstar U S x0 z"], "proof_term_before": ["(?Goal\n :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R))"], "proof_term_after": ["((fun (U : Type) (R S : Relation U)\n    (H' : forall x y : U, R x y -> Rstar U S x y) \n    (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U S x0 y0) ?Goal ?Goal0 x y H'0)\n :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R))"]}, {"text": "generalize Rstar_transitive; intro T; red in T.", "goal_before": ["forall x0 : U, Rstar U S x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U S y0 z -> Rstar U S x0 z"], "goal_after": ["forall x0 : U, Rstar U S x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U S y0 z -> Rstar U S x0 z"], "proof_term_before": ["((fun (U : Type) (R S : Relation U)\n    (H' : forall x y : U, R x y -> Rstar U S x y) \n    (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U S x0 y0) ?Goal ?Goal0 x y H'0)\n :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R))"], "proof_term_after": ["((fun (U : Type) (R S : Relation U)\n    (H' : forall x y : U, R x y -> Rstar U S x y) \n    (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U S x0 y0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R))"]}, {"text": "intros x0 y0 z H'1 H'2 H'3; apply T with y0; auto.", "goal_before": ["forall x0 : U, Rstar U S x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U S y0 z -> Rstar U S x0 z"], "goal_after": ["forall x0 : U, Rstar U S x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U S y0 z -> Rstar U S x0 z"], "proof_term_before": ["((fun (U : Type) (R S : Relation U)\n    (H' : forall x y : U, R x y -> Rstar U S x y) \n    (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U S x0 y0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R))"], "proof_term_after": ["((fun (U : Type) (R S : Relation U)\n    (H' : forall x y : U, R x y -> Rstar U S x y) \n    (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U S x0 y0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R))"]}, {"text": "Qed.", "goal_before": ["forall x0 : U, Rstar U S x0 x0", "forall x0 y0 z : U,\nR x0 y0 -> Rstar U R y0 z -> Rstar U S y0 z -> Rstar U S x0 z"], "goal_after": [], "proof_term_before": ["((fun (U : Type) (R S : Relation U)\n    (H' : forall x y : U, R x y -> Rstar U S x y) \n    (x y : U) (H'0 : Rstar U R x y) =>\n  Rstar_ind U R (fun x0 y0 : U => Rstar U S x0 y0)\n    ((fun\n        T : forall (U0 : Type) (R0 : Relation U0),\n            Transitive U0 (Rstar U0 R0) => ?Goal0) Rstar_transitive) \n    ?Goal x y H'0)\n :\n forall (U : Type) (R S : Relation U),\n contains U (Rstar U S) R -> contains U (Rstar U S) (Rstar U R))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "star_monotone", "text": "Theorem star_monotone :\n forall (U : Type) (R S : Relation U),\n contains U S R -> contains U (Rstar U S) (Rstar U R).\nintros U R S H'.\napply Sstar_contains_Rstar.\ngeneralize (Rstar_contains_R U S); auto.\nQed.\n", "definition": "\n forall (U : Type) (R S : Relation U),\n contains U S R -> contains U (Rstar U S) (Rstar U R).", "proof": "\nintros U R S H'.\napply Sstar_contains_Rstar.\ngeneralize (Rstar_contains_R U S); auto.\n", "def_ranges": [78, 0, 80, 54], "proof_ranges": [81, 0, 84, 4], "proof_steps": [{"text": "intros U R S H'.", "goal_before": ["forall (U : Type) (R S : Relation U),\ncontains U S R -> contains U (Rstar U S) (Rstar U R)"], "goal_after": ["contains U (Rstar U S) (Rstar U R)"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R S : Relation U) (H' : contains U S R) => ?Goal)"]}, {"text": "apply Sstar_contains_Rstar.", "goal_before": ["contains U (Rstar U S) (Rstar U R)"], "goal_after": ["contains U (Rstar U S) R"], "proof_term_before": ["(fun (U : Type) (R S : Relation U) (H' : contains U S R) => ?Goal)"], "proof_term_after": ["(fun (U : Type) (R S : Relation U) (H' : contains U S R) =>\n Sstar_contains_Rstar U R S ?Goal)"]}, {"text": "generalize (Rstar_contains_R U S); auto.", "goal_before": ["contains U (Rstar U S) R"], "goal_after": ["contains U (Rstar U S) S -> contains U (Rstar U S) R"], "proof_term_before": ["(fun (U : Type) (R S : Relation U) (H' : contains U S R) =>\n Sstar_contains_Rstar U R S ?Goal)"], "proof_term_after": ["(fun (U : Type) (R S : Relation U) (H' : contains U S R) =>\n Sstar_contains_Rstar U R S (?Goal (Rstar_contains_R U S)))"]}, {"text": "Qed.", "goal_before": ["contains U (Rstar U S) S -> contains U (Rstar U S) R"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R S : Relation U) (H' : contains U S R) =>\n Sstar_contains_Rstar U R S (?Goal (Rstar_contains_R U S)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "RstarRplus_RRstar", "text": "Theorem RstarRplus_RRstar :\n forall (U : Type) (R : Relation U) (x y z : U),\n Rstar U R x y -> Rplus U R y z -> exists u : U, R x u /\\ Rstar U R u z.\ngeneralize Rstar_contains_Rplus; intro T; red in T.\ngeneralize Rstar_transitive; intro T1; red in T1.\nintros U R x y z H'; elim H'.\nintros x0 H'0; elim H'0.\nintros; exists y0; auto.\nintros; exists y0; auto.\nintros; exists y0; auto.\nsplit; [ try assumption | idtac ].\napply T1 with z0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U) (x y z : U),\n Rstar U R x y -> Rplus U R y z -> exists u : U, R x u /\\ Rstar U R u z.", "proof": "\ngeneralize Rstar_contains_Rplus; intro T; red in T.\ngeneralize Rstar_transitive; intro T1; red in T1.\nintros U R x y z H'; elim H'.\nintros x0 H'0; elim H'0.\nintros; exists y0; auto.\nintros; exists y0; auto.\nintros; exists y0; auto.\nsplit; [ try assumption | idtac ].\napply T1 with z0; auto.\n", "def_ranges": [86, 0, 88, 72], "proof_ranges": [89, 0, 98, 4], "proof_steps": [{"text": "generalize Rstar_contains_Rplus; intro T; red in T.", "goal_before": ["forall (U : Type) (R : Relation U) (x y z : U),\nRstar U R x y -> Rplus U R y z -> exists u : U, R x u /\\ Rstar U R u z"], "goal_after": ["forall (U : Type) (R : Relation U) (x y z : U),\nRstar U R x y -> Rplus U R y z -> exists u : U, R x u /\\ Rstar U R u z"], "proof_term_before": [], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) => ?Goal) Rstar_contains_Rplus)"]}, {"text": "generalize Rstar_transitive; intro T1; red in T1.", "goal_before": ["forall (U : Type) (R : Relation U) (x y z : U),\nRstar U R x y -> Rplus U R y z -> exists u : U, R x u /\\ Rstar U R u z"], "goal_after": ["forall (U : Type) (R : Relation U) (x y z : U),\nRstar U R x y -> Rplus U R y z -> exists u : U, R x u /\\ Rstar U R u z"], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) => ?Goal) Rstar_contains_Rplus)"], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R) =>\n   ?Goal) Rstar_transitive) Rstar_contains_Rplus)"]}, {"text": "intros U R x y z H'; elim H'.", "goal_before": ["forall (U : Type) (R : Relation U) (x y z : U),\nRstar U R x y -> Rplus U R y z -> exists u : U, R x u /\\ Rstar U R u z"], "goal_after": ["forall x0 : U, Rplus U R x0 z -> exists u : U, R x0 u /\\ Rstar U R u z", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R) =>\n   ?Goal) Rstar_transitive) Rstar_contains_Rplus)"], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z) \n     ?Goal ?Goal0 x y H') Rstar_transitive) Rstar_contains_Rplus)"]}, {"text": "intros x0 H'0; elim H'0.", "goal_before": ["forall x0 : U, Rplus U R x0 z -> exists u : U, R x0 u /\\ Rstar U R u z", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "goal_after": ["forall x1 y0 : U, R x1 y0 -> exists u : U, R x1 u /\\ Rstar U R u y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z) \n     ?Goal ?Goal0 x y H') Rstar_transitive) Rstar_contains_Rplus)"], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        ?Goal0 ?Goal1 x0 z H'0) ?Goal x y H') Rstar_transitive)\n   Rstar_contains_Rplus)"]}, {"text": "intros; exists y0; auto.", "goal_before": ["forall x1 y0 : U, R x1 y0 -> exists u : U, R x1 u /\\ Rstar U R u y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "goal_after": ["R x1 y0 /\\ Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        ?Goal0 ?Goal1 x0 z H'0) ?Goal x y H') Rstar_transitive)\n   Rstar_contains_Rplus)"], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 ?Goal1) \n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"]}, {"text": "intros; exists y0; auto.", "goal_before": ["R x1 y0 /\\ Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "goal_after": ["R x1 y0 /\\ Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 ?Goal1) \n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 ?Goal1) \n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"]}, {"text": "intros; exists y0; auto.", "goal_before": ["R x1 y0 /\\ Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "goal_after": ["R x1 y0 /\\ Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 ?Goal1) \n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 ?Goal1) \n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"]}, {"text": "split; [ try assumption | idtac ].", "goal_before": ["R x1 y0 /\\ Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "goal_after": ["Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 ?Goal1) \n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 (conj H ?Goal1))\n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"]}, {"text": "apply T1 with z0; auto.", "goal_before": ["Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "goal_after": ["Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 (conj H ?Goal1))\n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"], "proof_term_after": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 (conj H ?Goal1))\n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"]}, {"text": "Qed.", "goal_before": ["Rstar U R y0 y0", "forall x1 y0 z0 : U,\nR x1 y0 ->\nRplus U R y0 z0 ->\n(exists u : U, R y0 u /\\ Rstar U R u z0) ->\nexists u : U, R x1 u /\\ Rstar U R u z0", "forall x0 y0 z0 : U,\nR x0 y0 ->\nRstar U R y0 z0 ->\n(Rplus U R z0 z -> exists u : U, R y0 u /\\ Rstar U R u z) ->\nRplus U R z0 z -> exists u : U, R x0 u /\\ Rstar U R u z"], "goal_after": [], "proof_term_before": ["((fun\n    T : forall (U : Type) (R : Relation U),\n        contains U (Rstar U R) (Rplus U R) =>\n  (fun (T1 : forall (U : Type) (R : Relation U), Transitive U (Rstar U R))\n     (U : Type) (R : Relation U) (x y z : U) (H' : Rstar U R x y) =>\n   Rstar_ind U R\n     (fun x0 y0 : U =>\n      Rplus U R y0 z -> exists u : U, R x0 u /\\ Rstar U R u z)\n     (fun (x0 : U) (H'0 : Rplus U R x0 z) =>\n      Rplus_ind U R (fun x1 z0 : U => exists u : U, R x1 u /\\ Rstar U R u z0)\n        (fun (x1 y0 : U) (H : R x1 y0) =>\n         ex_intro (fun u : U => R x1 u /\\ Rstar U R u y0) y0 (conj H ?Goal1))\n        ?Goal0 x0 z H'0) ?Goal x y H') Rstar_transitive) Rstar_contains_Rplus)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/Relations_2_facts.v", "name": "Lemma1", "text": "Theorem Lemma1 :\n forall (U : Type) (R : Relation U),\n Strongly_confluent U R ->\n forall x b : U,\n Rstar U R x b -> forall a : U, R x a -> exists z : U, Rstar U R a z /\\ R b z.\nintros U R H' x b H'0; elim H'0.\nintros x0 a H'1; exists a; auto.\nintros x0 y z H'1 H'2 H'3 a H'4.\nred in H'.\ngeneralize (H' x0 a y); intro h; lapply h;\n [ intro H'5; lapply H'5;\n    [ intro h0; elim h0; intros t h1; elim h1; intros H'6 H'7;\n       clear h H'5 h0 h1; try exact H'6\n    | clear h ]\n | clear h ]; auto 10.\ngeneralize (H'3 t); intro h; lapply h;\n [ intro h0; elim h0; intros z1 h1; elim h1; intros H'5 H'8; clear h h0 h1;\n    try exact H'5\n | clear h ]; auto 10.\nintros; exists z1; split; [ idtac | assumption ].\napply Rstar_n with t; auto.\nQed.", "definition": "\n forall (U : Type) (R : Relation U),\n Strongly_confluent U R ->\n forall x b : U,\n Rstar U R x b -> forall a : U, R x a -> exists z : U, Rstar U R a z /\\ R b z.", "proof": "\nintros U R H' x b H'0; elim H'0.\nintros x0 a H'1; exists a; auto.\nintros x0 y z H'1 H'2 H'3 a H'4.\nred in H'.\ngeneralize (H' x0 a y); intro h; lapply h;\n [ intro H'5; lapply H'5;\n    [ intro h0; elim h0; intros t h1; elim h1; intros H'6 H'7;\n       clear h H'5 h0 h1; try exact H'6\n    | clear h ]\n | clear h ]; auto 10.\ngeneralize (H'3 t); intro h; lapply h;\n [ intro h0; elim h0; intros z1 h1; elim h1; intros H'5 H'8; clear h h0 h1;\n    try exact H'5\n | clear h ]; auto 10.\nintros; exists z1; split; [ idtac | assumption ].\napply Rstar_n with t; auto.\n", "def_ranges": [100, 0, 104, 78], "proof_ranges": [105, 0, 121, 4], "proof_steps": [{"text": "intros U R H' x b H'0; elim H'0.", "goal_before": ["forall (U : Type) (R : Relation U),\nStrongly_confluent U R ->\nforall x b : U,\nRstar U R x b -> forall a : U, R x a -> exists z : U, Rstar U R a z /\\ R b z"], "goal_after": ["forall x0 a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R x0 z", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z) \n   ?Goal ?Goal0 x b H'0)"]}, {"text": "intros x0 a H'1; exists a; auto.", "goal_before": ["forall x0 a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R x0 z", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z) \n   ?Goal ?Goal0 x b H'0)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"]}, {"text": "intros x0 y z H'1 H'2 H'3 a H'4.", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"]}, {"text": "red in H'.", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"]}, {"text": "generalize (H' x0 a y); intro h; lapply h;", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"], "proof_term_after": []}, {"text": "[ intro H'5; lapply H'5;", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros t h1; elim h1; intros H'6 H'7;", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h H'5 h0 h1; try exact H'6", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto 10.", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"]}, {"text": "generalize (H'3 t); intro h; lapply h;", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"]}, {"text": "[ intro h0; elim h0; intros z1 h1; elim h1; intros H'5 H'8; clear h h0 h1;", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"]}, {"text": "try exact H'5", "goal_before": ["Rstar U R a a /\\ R x0 a", "forall x0 y z : U,\nR x0 y ->\nRstar U R y z ->\n(forall a : U, R y a -> exists z0 : U, Rstar U R a z0 /\\ R z z0) ->\nforall a : U, R x0 a -> exists z0 : U, Rstar U R a z0 /\\ R z z0"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Strongly_confluent U R) \n   (x b : U) (H'0 : Rstar U R x b) =>\n Rstar_ind U R\n   (fun x0 b0 : U =>\n    forall a : U, R x0 a -> exists z : U, Rstar U R a z /\\ R b0 z)\n   (fun (x0 a : U) (H'1 : R x0 a) =>\n    ex_intro (fun z : U => Rstar U R a z /\\ R x0 z) a ?Goal0) \n   ?Goal x b H'0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "trivial", "text": "Theorem trivial : forall A : Prop, A -> A.\nintros A H'; exact H'.\nQed.\n", "definition": " forall A : Prop, A -> A.", "proof": "\nintros A H'; exact H'.\n", "def_ranges": [10, 0, 10, 42], "proof_ranges": [11, 0, 12, 4], "proof_steps": [{"text": "intros A H'; exact H'.", "goal_before": ["forall A : Prop, A -> A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (A : Prop) (H' : A) => H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A : Prop) (H' : A) => H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "and_commutative", "text": "Theorem and_commutative : forall A B : Prop, A /\\ B -> B /\\ A.\nintros A B H'; split.\nelim H'; intros H'0 H'1; clear H'; exact H'1.\nelim H'; intros H'0 H'1; clear H'; exact H'0.\nQed.\n", "definition": " forall A B : Prop, A /\\ B -> B /\\ A.", "proof": "\nintros A B H'; split.\nelim H'; intros H'0 H'1; clear H'; exact H'1.\nelim H'; intros H'0 H'1; clear H'; exact H'0.\n", "def_ranges": [14, 0, 14, 62], "proof_ranges": [15, 0, 18, 4], "proof_steps": [{"text": "intros A B H'; split.", "goal_before": ["forall A B : Prop, A /\\ B -> B /\\ A"], "goal_after": ["B", "A"], "proof_term_before": [], "proof_term_after": ["(fun (A B : Prop) (H' : A /\\ B) => conj ?Goal ?Goal0)"]}, {"text": "elim H'; intros H'0 H'1; clear H'; exact H'1.", "goal_before": ["B", "A"], "goal_after": ["A"], "proof_term_before": ["(fun (A B : Prop) (H' : A /\\ B) => conj ?Goal ?Goal0)"], "proof_term_after": ["(fun (A B : Prop) (H' : A /\\ B) =>\n conj (and_ind (fun (_ : A) (H'1 : B) => H'1) H') ?Goal)"]}, {"text": "elim H'; intros H'0 H'1; clear H'; exact H'0.", "goal_before": ["A"], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (H' : A /\\ B) =>\n conj (and_ind (fun (_ : A) (H'1 : B) => H'1) H') ?Goal)"], "proof_term_after": ["(fun (A B : Prop) (H' : A /\\ B) =>\n conj (and_ind (fun (_ : A) (H'1 : B) => H'1) H')\n   (and_ind (fun (H'0 : A) (_ : B) => H'0) H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (H' : A /\\ B) =>\n conj (and_ind (fun (_ : A) (H'1 : B) => H'1) H')\n   (and_ind (fun (H'0 : A) (_ : B) => H'0) H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "or_commutative", "text": "Theorem or_commutative : forall A B : Prop, A \\/ B -> B \\/ A.\nintros A B h; elim h; [ intro H'; clear h; try exact H' | clear h; intro H' ].\nright; assumption.\nleft; assumption.\nQed.\n", "definition": " forall A B : Prop, A \\/ B -> B \\/ A.", "proof": "\nintros A B h; elim h; [ intro H'; clear h; try exact H' | clear h; intro H' ].\nright; assumption.\nleft; assumption.\n", "def_ranges": [20, 0, 20, 61], "proof_ranges": [21, 0, 24, 4], "proof_steps": [{"text": "intros A B h; elim h; [ intro H'; clear h; try exact H' | clear h; intro H' ].", "goal_before": ["forall A B : Prop, A \\/ B -> B \\/ A"], "goal_after": ["B \\/ A", "B \\/ A"], "proof_term_before": [], "proof_term_after": ["(fun (A B : Prop) (h : A \\/ B) =>\n or_ind (fun H' : A => ?Goal) (fun H' : B => ?Goal0) h)"]}, {"text": "right; assumption.", "goal_before": ["B \\/ A", "B \\/ A"], "goal_after": ["B \\/ A"], "proof_term_before": ["(fun (A B : Prop) (h : A \\/ B) =>\n or_ind (fun H' : A => ?Goal) (fun H' : B => ?Goal0) h)"], "proof_term_after": ["(fun (A B : Prop) (h : A \\/ B) =>\n or_ind (fun H' : A => or_intror H') (fun H' : B => ?Goal) h)"]}, {"text": "left; assumption.", "goal_before": ["B \\/ A"], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (h : A \\/ B) =>\n or_ind (fun H' : A => or_intror H') (fun H' : B => ?Goal) h)"], "proof_term_after": ["(fun (A B : Prop) (h : A \\/ B) =>\n or_ind (fun H' : A => or_intror H') (fun H' : B => or_introl H') h)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (h : A \\/ B) =>\n or_ind (fun H' : A => or_intror H') (fun H' : B => or_introl H') h)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "mp", "text": "Theorem mp : forall A B : Prop, A -> (A -> B) -> B.\nintros A B H' H'0.\napply H'0.\nexact H'.\nQed.\n", "definition": " forall A B : Prop, A -> (A -> B) -> B.", "proof": "\nintros A B H' H'0.\napply H'0.\nexact H'.\n", "def_ranges": [26, 0, 26, 51], "proof_ranges": [27, 0, 30, 4], "proof_steps": [{"text": "intros A B H' H'0.", "goal_before": ["forall A B : Prop, A -> (A -> B) -> B"], "goal_after": ["B"], "proof_term_before": [], "proof_term_after": ["(fun (A B : Prop) (H' : A) (H'0 : A -> B) => ?Goal)"]}, {"text": "apply H'0.", "goal_before": ["B"], "goal_after": ["A"], "proof_term_before": ["(fun (A B : Prop) (H' : A) (H'0 : A -> B) => ?Goal)"], "proof_term_after": ["(fun (A B : Prop) (H' : A) (H'0 : A -> B) => H'0 ?Goal)"]}, {"text": "exact H'.", "goal_before": ["A"], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (H' : A) (H'0 : A -> B) => H'0 ?Goal)"], "proof_term_after": ["(fun (A B : Prop) (H' : A) (H'0 : A -> B) => H'0 H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Prop) (H' : A) (H'0 : A -> B) => H'0 H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "S", "text": "Theorem S : forall A B C : Prop, (A -> B -> C) -> (A -> B) -> A -> C.\nintros A B C H' H'0 H'1.\napply H'.\nexact H'1.\napply H'0.\nexact H'1.\nQed.\n", "definition": " forall A B C : Prop, (A -> B -> C) -> (A -> B) -> A -> C.", "proof": "\nintros A B C H' H'0 H'1.\napply H'.\nexact H'1.\napply H'0.\nexact H'1.\n", "def_ranges": [32, 0, 32, 69], "proof_ranges": [33, 0, 38, 4], "proof_steps": [{"text": "intros A B C H' H'0 H'1.", "goal_before": ["forall A B C : Prop, (A -> B -> C) -> (A -> B) -> A -> C"], "goal_after": ["C"], "proof_term_before": [], "proof_term_after": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) => ?Goal)"]}, {"text": "apply H'.", "goal_before": ["C"], "goal_after": ["A", "B"], "proof_term_before": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) => ?Goal)"], "proof_term_after": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) =>\n H' ?Goal ?Goal0)"]}, {"text": "exact H'1.", "goal_before": ["A", "B"], "goal_after": ["B"], "proof_term_before": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) =>\n H' ?Goal ?Goal0)"], "proof_term_after": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) =>\n H' H'1 ?Goal)"]}, {"text": "apply H'0.", "goal_before": ["B"], "goal_after": ["A"], "proof_term_before": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) =>\n H' H'1 ?Goal)"], "proof_term_after": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) =>\n H' H'1 (H'0 ?Goal))"]}, {"text": "exact H'1.", "goal_before": ["A"], "goal_after": [], "proof_term_before": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) =>\n H' H'1 (H'0 ?Goal))"], "proof_term_after": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) =>\n H' H'1 (H'0 H'1))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B C : Prop) (H' : A -> B -> C) (H'0 : A -> B) (H'1 : A) =>\n H' H'1 (H'0 H'1))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "Praeclarum", "text": "Theorem Praeclarum :\n forall x y z t : Prop, (x -> z) /\\ (y -> t) -> x /\\ y -> z /\\ t.\nintros x y z t h; elim h; intros H' H'0; clear h.\nintro h; elim h; intros H'1 H'2; clear h.\nsplit.\napply H'; assumption.\napply H'0; assumption.\nQed.\n", "definition": "\n forall x y z t : Prop, (x -> z) /\\ (y -> t) -> x /\\ y -> z /\\ t.", "proof": "\nintros x y z t h; elim h; intros H' H'0; clear h.\nintro h; elim h; intros H'1 H'2; clear h.\nsplit.\napply H'; assumption.\napply H'0; assumption.\n", "def_ranges": [40, 0, 41, 65], "proof_ranges": [42, 0, 47, 4], "proof_steps": [{"text": "intros x y z t h; elim h; intros H' H'0; clear h.", "goal_before": ["forall x y z t : Prop, (x -> z) /\\ (y -> t) -> x /\\ y -> z /\\ t"], "goal_after": ["x /\\ y -> z /\\ t"], "proof_term_before": [], "proof_term_after": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind (fun (H' : x -> z) (H'0 : y -> t) => ?Goal) h)"]}, {"text": "intro h; elim h; intros H'1 H'2; clear h.", "goal_before": ["x /\\ y -> z /\\ t"], "goal_after": ["z /\\ t"], "proof_term_before": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind (fun (H' : x -> z) (H'0 : y -> t) => ?Goal) h)"], "proof_term_after": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H' : x -> z) (H'0 : y -> t) (h0 : x /\\ y) =>\n    and_ind (fun (H'1 : x) (H'2 : y) => ?Goal) h0) h)"]}, {"text": "split.", "goal_before": ["z /\\ t"], "goal_after": ["z", "t"], "proof_term_before": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H' : x -> z) (H'0 : y -> t) (h0 : x /\\ y) =>\n    and_ind (fun (H'1 : x) (H'2 : y) => ?Goal) h0) h)"], "proof_term_after": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H' : x -> z) (H'0 : y -> t) (h0 : x /\\ y) =>\n    and_ind (fun (H'1 : x) (H'2 : y) => conj ?Goal ?Goal0) h0) h)"]}, {"text": "apply H'; assumption.", "goal_before": ["z", "t"], "goal_after": ["t"], "proof_term_before": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H' : x -> z) (H'0 : y -> t) (h0 : x /\\ y) =>\n    and_ind (fun (H'1 : x) (H'2 : y) => conj ?Goal ?Goal0) h0) h)"], "proof_term_after": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H' : x -> z) (H'0 : y -> t) (h0 : x /\\ y) =>\n    and_ind (fun (H'1 : x) (H'2 : y) => conj (H' H'1) ?Goal) h0) h)"]}, {"text": "apply H'0; assumption.", "goal_before": ["t"], "goal_after": [], "proof_term_before": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H' : x -> z) (H'0 : y -> t) (h0 : x /\\ y) =>\n    and_ind (fun (H'1 : x) (H'2 : y) => conj (H' H'1) ?Goal) h0) h)"], "proof_term_after": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H' : x -> z) (H'0 : y -> t) (h0 : x /\\ y) =>\n    and_ind (fun (H'1 : x) (H'2 : y) => conj (H' H'1) (H'0 H'2)) h0) h)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y z t : Prop) (h : (x -> z) /\\ (y -> t)) =>\n and_ind\n   (fun (H' : x -> z) (H'0 : y -> t) (h0 : x /\\ y) =>\n    and_ind (fun (H'1 : x) (H'2 : y) => conj (H' H'1) (H'0 H'2)) h0) h)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "resolution", "text": "Theorem resolution :\n forall (p q : Type -> Prop) (a : Type),\n p a -> (forall x : Type, p x -> q x) -> q a.\nintros p q a H' H'0.\napply H'0.\nexact H'.\nQed.\n", "definition": "\n forall (p q : Type -> Prop) (a : Type),\n p a -> (forall x : Type, p x -> q x) -> q a.", "proof": "\nintros p q a H' H'0.\napply H'0.\nexact H'.\n", "def_ranges": [49, 0, 51, 45], "proof_ranges": [52, 0, 55, 4], "proof_steps": [{"text": "intros p q a H' H'0.", "goal_before": ["forall (p q : Type -> Prop) (a : Type),\np a -> (forall x : Type, p x -> q x) -> q a"], "goal_after": ["q a"], "proof_term_before": [], "proof_term_after": ["(fun (p q : Type -> Prop) (a : Type) (H' : p a)\n   (H'0 : forall x : Type, p x -> q x) => ?Goal)"]}, {"text": "apply H'0.", "goal_before": ["q a"], "goal_after": ["p a"], "proof_term_before": ["(fun (p q : Type -> Prop) (a : Type) (H' : p a)\n   (H'0 : forall x : Type, p x -> q x) => ?Goal)"], "proof_term_after": ["(fun (p q : Type -> Prop) (a : Type) (H' : p a)\n   (H'0 : forall x : Type, p x -> q x) => H'0 a ?Goal)"]}, {"text": "exact H'.", "goal_before": ["p a"], "goal_after": [], "proof_term_before": ["(fun (p q : Type -> Prop) (a : Type) (H' : p a)\n   (H'0 : forall x : Type, p x -> q x) => H'0 a ?Goal)"], "proof_term_after": ["(fun (p q : Type -> Prop) (a : Type) (H' : p a)\n   (H'0 : forall x : Type, p x -> q x) => H'0 a H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (p q : Type -> Prop) (a : Type) (H' : p a)\n   (H'0 : forall x : Type, p x -> q x) => H'0 a H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "Witnesses", "text": "Theorem Witnesses :\n forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x.\nintros a b p h; elim h; intro H'; clear h.\nexists a; assumption.\nexists b; assumption.\nQed.\n", "definition": "\n forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x.", "proof": "\nintros a b p h; elim h; intro H'; clear h.\nexists a; assumption.\nexists b; assumption.\n", "def_ranges": [57, 0, 58, 76], "proof_ranges": [59, 0, 62, 4], "proof_steps": [{"text": "intros a b p h; elim h; intro H'; clear h.", "goal_before": ["forall (a b : Type) (p : Type -> Prop), p a \\/ p b -> exists x : Type, p x"], "goal_after": ["exists x : Type, p x", "exists x : Type, p x"], "proof_term_before": [], "proof_term_after": ["(fun (a b : Type) (p : Type -> Prop) (h : p a \\/ p b) =>\n or_ind (fun H' : p a => ?Goal) (fun H' : p b => ?Goal0) h)"]}, {"text": "exists a; assumption.", "goal_before": ["exists x : Type, p x", "exists x : Type, p x"], "goal_after": ["exists x : Type, p x"], "proof_term_before": ["(fun (a b : Type) (p : Type -> Prop) (h : p a \\/ p b) =>\n or_ind (fun H' : p a => ?Goal) (fun H' : p b => ?Goal0) h)"], "proof_term_after": ["(fun (a b : Type) (p : Type -> Prop) (h : p a \\/ p b) =>\n or_ind (fun H' : p a => ex_intro (fun x : Type => p x) a H')\n   (fun H' : p b => ?Goal) h)"]}, {"text": "exists b; assumption.", "goal_before": ["exists x : Type, p x"], "goal_after": [], "proof_term_before": ["(fun (a b : Type) (p : Type -> Prop) (h : p a \\/ p b) =>\n or_ind (fun H' : p a => ex_intro (fun x : Type => p x) a H')\n   (fun H' : p b => ?Goal) h)"], "proof_term_after": ["(fun (a b : Type) (p : Type -> Prop) (h : p a \\/ p b) =>\n or_ind (fun H' : p a => ex_intro (fun x : Type => p x) a H')\n   (fun H' : p b => ex_intro (fun x : Type => p x) b H') h)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : Type) (p : Type -> Prop) (h : p a \\/ p b) =>\n or_ind (fun H' : p a => ex_intro (fun x : Type => p x) a H')\n   (fun H' : p b => ex_intro (fun x : Type => p x) b H') h)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "Simple", "text": "Theorem Simple :\n forall (A : Set) (R : A -> A -> Prop),\n (forall x y z : A, R x y /\\ R y z -> R x z) ->\n (forall x y : A, R x y -> R y x) ->\n forall x : A, (exists y : A, R x y) -> R x x.\nintros A R H' H'0 x h; elim h; intros y E; clear h.\napply H' with y.\nsplit; [ assumption | idtac ].\napply H'0; assumption.\nQed.\n", "definition": "\n forall (A : Set) (R : A -> A -> Prop),\n (forall x y z : A, R x y /\\ R y z -> R x z) ->\n (forall x y : A, R x y -> R y x) ->\n forall x : A, (exists y : A, R x y) -> R x x.", "proof": "\nintros A R H' H'0 x h; elim h; intros y E; clear h.\napply H' with y.\nsplit; [ assumption | idtac ].\napply H'0; assumption.\n", "def_ranges": [64, 0, 68, 46], "proof_ranges": [69, 0, 73, 4], "proof_steps": [{"text": "intros A R H' H'0 x h; elim h; intros y E; clear h.", "goal_before": ["forall (A : Set) (R : A -> A -> Prop),\n(forall x y z : A, R x y /\\ R y z -> R x z) ->\n(forall x y : A, R x y -> R y x) ->\nforall x : A, (exists y : A, R x y) -> R x x"], "goal_after": ["R x x"], "proof_term_before": [], "proof_term_after": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (h : exists y : A, R x y) => ex_ind (fun (y : A) (E : R x y) => ?Goal) h)"]}, {"text": "apply H' with y.", "goal_before": ["R x x"], "goal_after": ["R x y /\\ R y x"], "proof_term_before": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (h : exists y : A, R x y) => ex_ind (fun (y : A) (E : R x y) => ?Goal) h)"], "proof_term_after": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (h : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => H' x y x ?Goal) h)"]}, {"text": "split; [ assumption | idtac ].", "goal_before": ["R x y /\\ R y x"], "goal_after": ["R y x"], "proof_term_before": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (h : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => H' x y x ?Goal) h)"], "proof_term_after": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (h : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => H' x y x (conj E ?Goal)) h)"]}, {"text": "apply H'0; assumption.", "goal_before": ["R y x"], "goal_after": [], "proof_term_before": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (h : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => H' x y x (conj E ?Goal)) h)"], "proof_term_after": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (h : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => H' x y x (conj E (H'0 x y E))) h)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A : Set) (R : A -> A -> Prop)\n   (H' : forall x y z : A, R x y /\\ R y z -> R x z)\n   (H'0 : forall x y : A, R x y -> R y x) (x : A) \n   (h : exists y : A, R x y) =>\n ex_ind (fun (y : A) (E : R x y) => H' x y x (conj E (H'0 x y E))) h)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "not_not", "text": "Theorem not_not : forall a : Prop, a -> ~ ~ a.\nintros a H'; red in |- *; intro H'0; elim H'0; assumption.\nQed.\n", "definition": " forall a : Prop, a -> ~ ~ a.", "proof": "\nintros a H'; red in |- *; intro H'0; elim H'0; assumption.\n", "def_ranges": [75, 0, 75, 46], "proof_ranges": [76, 0, 77, 4], "proof_steps": [{"text": "intros a H'; red in |- *; intro H'0; elim H'0; assumption.", "goal_before": ["forall a : Prop, a -> ~ ~ a"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (a : Prop) (H' : a) =>\n (fun H'0 : ~ a => False_ind False (H'0 H')) : ~ ~ a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : Prop) (H' : a) =>\n (fun H'0 : ~ a => False_ind False (H'0 H')) : ~ ~ a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "mini_cases", "text": "Theorem mini_cases : forall x y : Prop, (x \\/ ~ y) /\\ y -> x.\nintros x y h; elim h; intros h0 H'; elim h0;\n [ intro H'0; clear h h0; try exact H'0 | clear h h0; intro H'0 ].\nelim H'0; try assumption.\nQed.\n", "definition": " forall x y : Prop, (x \\/ ~ y) /\\ y -> x.", "proof": "\nintros x y h; elim h; intros h0 H'; elim h0;\n [ intro H'0; clear h h0; try exact H'0 | clear h h0; intro H'0 ].\nelim H'0; try assumption.\n", "def_ranges": [79, 0, 79, 61], "proof_ranges": [80, 0, 83, 4], "proof_steps": [{"text": "intros x y h; elim h; intros h0 H'; elim h0;", "goal_before": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "goal_after": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'0; clear h h0; try exact H'0 | clear h h0; intro H'0 ].", "goal_before": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "goal_after": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0; try assumption.", "goal_before": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "goal_after": ["forall x y : Prop, (x \\/ ~ y) /\\ y -> x"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "not_not_converse", "text": "Theorem not_not_converse : forall a : Prop, ~ ~ a -> a.\nintros a H'.\ngeneralize (classic a); intro h; elim h;\n [ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ].\nelim H'; assumption.\nQed.\n", "definition": " forall a : Prop, ~ ~ a -> a.", "proof": "\nintros a H'.\ngeneralize (classic a); intro h; elim h;\n [ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ].\nelim H'; assumption.\n", "def_ranges": [88, 0, 88, 55], "proof_ranges": [89, 0, 93, 4], "proof_steps": [{"text": "intros a H'.", "goal_before": ["forall a : Prop, ~ ~ a -> a"], "goal_after": ["a"], "proof_term_before": [], "proof_term_after": ["(fun (a : Prop) (H' : ~ ~ a) => ?Goal)"]}, {"text": "generalize (classic a); intro h; elim h;", "goal_before": ["a"], "goal_after": ["a"], "proof_term_before": ["(fun (a : Prop) (H' : ~ ~ a) => ?Goal)"], "proof_term_after": []}, {"text": "[ intro H'0; clear h; try exact H'0 | clear h; intro H'0 ].", "goal_before": ["a"], "goal_after": ["a"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'; assumption.", "goal_before": ["a"], "goal_after": ["a"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cours-de-coq/ex1.v", "name": "not_quite_classic", "text": "Theorem not_quite_classic : forall a : Prop, ~ ~ (a \\/ ~ a).\nintro a; red in |- *; intro H'; elim H'; right; red in |- *; intro H'0.\nelim H'; left; try assumption.\nQed.\n", "definition": " forall a : Prop, ~ ~ (a \\/ ~ a).", "proof": "\nintro a; red in |- *; intro H'; elim H'; right; red in |- *; intro H'0.\nelim H'; left; try assumption.\n", "def_ranges": [95, 0, 95, 60], "proof_ranges": [96, 0, 98, 4], "proof_steps": [{"text": "intro a; red in |- *; intro H'; elim H'; right; red in |- *; intro H'0.", "goal_before": ["forall a : Prop, ~ ~ (a \\/ ~ a)"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": ["(fun a : Prop =>\n (fun H' : ~ (a \\/ ~ a) =>\n  False_ind False (H' (or_intror ((fun H'0 : a => ?Goal) : ~ a))))\n :\n ~ ~ (a \\/ ~ a))"]}, {"text": "elim H'; left; try assumption.", "goal_before": ["False"], "goal_after": [], "proof_term_before": ["(fun a : Prop =>\n (fun H' : ~ (a \\/ ~ a) =>\n  False_ind False (H' (or_intror ((fun H'0 : a => ?Goal) : ~ a))))\n :\n ~ ~ (a \\/ ~ a))"], "proof_term_after": ["(fun a : Prop =>\n (fun H' : ~ (a \\/ ~ a) =>\n  False_ind False\n    (H'\n       (or_intror\n          ((fun H'0 : a => False_ind False (H' (or_introl H'0))) : ~ a))))\n :\n ~ ~ (a \\/ ~ a))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun a : Prop =>\n (fun H' : ~ (a \\/ ~ a) =>\n  False_ind False\n    (H'\n       (or_intror\n          ((fun H'0 : a => False_ind False (H' (or_introl H'0))) : ~ a))))\n :\n ~ ~ (a \\/ ~ a))"], "proof_term_after": []}], "ends_qed": true}]