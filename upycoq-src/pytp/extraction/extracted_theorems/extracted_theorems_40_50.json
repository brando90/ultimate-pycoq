[{"path": "/home/jizej/proverbot9001/coq-projects/ails/constants.v", "name": "rho_ub_t_PI2", "text": "Theorem rho_ub_t_PI2 :\n forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.\nProof with trivial.\nintros; assert (H := cond_2 t)...\nunfold MaxT in H; apply Rlt_trans with (PI_lb / 2)%R...\nunfold rho_ub in |- *; cut (g < 33)%R...\ncut (tan_ub_MaxBank < 4 / 5)%R...\ncut (/ h < / 200)%R...\nintros; generalize g_pos; intro H3; generalize tan_ub_MaxBank_pos; intro H4;\n generalize (Rinv_0_lt_compat h (TypeSpeed_pos h)); \n intro H5...\ngeneralize\n (Rmult_le_0_lt_compat g 33 tan_ub_MaxBank (4 / 5) \n    (Rlt_le 0 g H3) (Rlt_le 0 tan_ub_MaxBank H4) H2 H1)...\nintro H6; generalize (Rmult_lt_0_compat g tan_ub_MaxBank H3 H4); intro H7...\nassert\n (H8 :=\n  Rmult_le_0_lt_compat (g * tan_ub_MaxBank) (33 * (4 / 5)) \n    (/ h) (/ 200) (Rlt_le 0 (g * tan_ub_MaxBank) H7) \n    (Rlt_le 0 (/ h) H5) H6 H0)...\napply Rlt_trans with (33 * / 200 * (4 / 5) * t)%R...\napply Rmult_lt_compat_r...\napply Rlt_le_trans with MinT...\napply MinT_is_pos...\napply (cond_1 t)...\nrewrite Rmult_assoc; rewrite (Rmult_comm (/ 200)); unfold Rdiv in |- *;\n do 2 rewrite <- Rmult_assoc...\napply Rle_lt_trans with (33 * / 200 * (4 / 5) * 10)%R...\napply Rmult_le_compat_l...\nleft; apply Rmult_lt_0_compat...\napply Rmult_lt_0_compat; [ prove_sup | apply Rinv_0_lt_compat; prove_sup ]...\nunfold Rdiv in |- *; apply Rmult_lt_0_compat;\n [ prove_sup | apply Rinv_0_lt_compat; prove_sup ]...\napply Rmult_lt_reg_l with 2%R...\nprove_sup...\napply Rmult_lt_reg_l with 200%R...\nprove_sup...\napply Rmult_lt_reg_l with 5%R...\nprove_sup...\nset (x := 200%R); set (y := 33%R); set (z := 10%R); set (u := 5%R);\n set (v := 4%R); set (w := 2%R)...\nunfold Rdiv in |- *;\n replace (u * (x * (w * (PI_lb * / w))))%R with (x * PI_lb * u * (w * / w))%R;\n [ idtac | ring ]...\nreplace (u * (x * (w * (y * / x * (v * / u) * z))))%R with\n (w * y * v * z * (u * / u) * (x * / x))%R; [ idtac | ring ]...\nrepeat rewrite <- Rinv_r_sym; unfold x, y, z, u, v, w in |- *; try discrR...\nunfold PI_lb in |- *; prove_sup...\napply Rinv_lt_contravar...\napply Rmult_lt_0_compat...\nprove_sup...\napply Rlt_le_trans with MinSpeed...\nunfold MinSpeed in |- *; prove_sup...\napply (v_cond1 h)...\napply Rlt_le_trans with MinSpeed...\nunfold MinSpeed in |- *; prove_sup...\napply (v_cond1 h)...\nunfold tan_ub_MaxBank in |- *; unfold Rdiv in |- *...\napply Rmult_lt_reg_l with 10%R...\nprove_sup...\nrewrite (Rmult_comm 10); rewrite Rmult_assoc; rewrite <- Rinv_l_sym...\nrewrite Rmult_1_r; apply Rmult_lt_reg_l with 5%R...\nprove_sup...\npattern 5%R at 1 in |- *; rewrite (Rmult_comm 5); do 2 rewrite Rmult_assoc;\n rewrite <- Rinv_l_sym...\nprove_sup...\ndiscrR...\ndiscrR...\nunfold g in |- *; unfold Rdiv in |- *; apply Rmult_lt_reg_l with 10%R...\nprove_sup...\nrewrite <- Rmult_comm; rewrite Rmult_assoc; rewrite <- Rinv_l_sym...\nrewrite Rmult_1_r; prove_sup...\ndiscrR...\nunfold Rdiv in |- *; repeat rewrite <- (Rmult_comm (/ 2));\n apply Rmult_lt_compat_l...\napply Rinv_0_lt_compat; prove_sup...\nassert (H0 := PI_approx); elim H0...\nQed.\n", "definition": "\n forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.", "proof": "\nProof with trivial.\nintros; assert (H := cond_2 t)...\nunfold MaxT in H; apply Rlt_trans with (PI_lb / 2)%R...\nunfold rho_ub in |- *; cut (g < 33)%R...\ncut (tan_ub_MaxBank < 4 / 5)%R...\ncut (/ h < / 200)%R...\nintros; generalize g_pos; intro H3; generalize tan_ub_MaxBank_pos; intro H4;\n generalize (Rinv_0_lt_compat h (TypeSpeed_pos h)); \n intro H5...\ngeneralize\n (Rmult_le_0_lt_compat g 33 tan_ub_MaxBank (4 / 5) \n    (Rlt_le 0 g H3) (Rlt_le 0 tan_ub_MaxBank H4) H2 H1)...\nintro H6; generalize (Rmult_lt_0_compat g tan_ub_MaxBank H3 H4); intro H7...\nassert\n (H8 :=\n  Rmult_le_0_lt_compat (g * tan_ub_MaxBank) (33 * (4 / 5)) \n    (/ h) (/ 200) (Rlt_le 0 (g * tan_ub_MaxBank) H7) \n    (Rlt_le 0 (/ h) H5) H6 H0)...\napply Rlt_trans with (33 * / 200 * (4 / 5) * t)%R...\napply Rmult_lt_compat_r...\napply Rlt_le_trans with MinT...\napply MinT_is_pos...\napply (cond_1 t)...\nrewrite Rmult_assoc; rewrite (Rmult_comm (/ 200)); unfold Rdiv in |- *;\n do 2 rewrite <- Rmult_assoc...\napply Rle_lt_trans with (33 * / 200 * (4 / 5) * 10)%R...\napply Rmult_le_compat_l...\nleft; apply Rmult_lt_0_compat...\napply Rmult_lt_0_compat; [ prove_sup | apply Rinv_0_lt_compat; prove_sup ]...\nunfold Rdiv in |- *; apply Rmult_lt_0_compat;\n [ prove_sup | apply Rinv_0_lt_compat; prove_sup ]...\napply Rmult_lt_reg_l with 2%R...\nprove_sup...\napply Rmult_lt_reg_l with 200%R...\nprove_sup...\napply Rmult_lt_reg_l with 5%R...\nprove_sup...\nset (x := 200%R); set (y := 33%R); set (z := 10%R); set (u := 5%R);\n set (v := 4%R); set (w := 2%R)...\nunfold Rdiv in |- *;\n replace (u * (x * (w * (PI_lb * / w))))%R with (x * PI_lb * u * (w * / w))%R;\n [ idtac | ring ]...\nreplace (u * (x * (w * (y * / x * (v * / u) * z))))%R with\n (w * y * v * z * (u * / u) * (x * / x))%R; [ idtac | ring ]...\nrepeat rewrite <- Rinv_r_sym; unfold x, y, z, u, v, w in |- *; try discrR...\nunfold PI_lb in |- *; prove_sup...\napply Rinv_lt_contravar...\napply Rmult_lt_0_compat...\nprove_sup...\napply Rlt_le_trans with MinSpeed...\nunfold MinSpeed in |- *; prove_sup...\napply (v_cond1 h)...\napply Rlt_le_trans with MinSpeed...\nunfold MinSpeed in |- *; prove_sup...\napply (v_cond1 h)...\nunfold tan_ub_MaxBank in |- *; unfold Rdiv in |- *...\napply Rmult_lt_reg_l with 10%R...\nprove_sup...\nrewrite (Rmult_comm 10); rewrite Rmult_assoc; rewrite <- Rinv_l_sym...\nrewrite Rmult_1_r; apply Rmult_lt_reg_l with 5%R...\nprove_sup...\npattern 5%R at 1 in |- *; rewrite (Rmult_comm 5); do 2 rewrite Rmult_assoc;\n rewrite <- Rinv_l_sym...\nprove_sup...\ndiscrR...\ndiscrR...\nunfold g in |- *; unfold Rdiv in |- *; apply Rmult_lt_reg_l with 10%R...\nprove_sup...\nrewrite <- Rmult_comm; rewrite Rmult_assoc; rewrite <- Rinv_l_sym...\nrewrite Rmult_1_r; prove_sup...\ndiscrR...\nunfold Rdiv in |- *; repeat rewrite <- (Rmult_comm (/ 2));\n apply Rmult_lt_compat_l...\napply Rinv_0_lt_compat; prove_sup...\nassert (H0 := PI_approx); elim H0...\n", "def_ranges": [64, 0, 65, 63], "proof_ranges": [66, 0, 141, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": ["forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R"], "goal_after": ["forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros; assert (H := cond_2 t)...", "goal_before": ["forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R"], "goal_after": ["forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "unfold MaxT in H; apply Rlt_trans with (PI_lb / 2)%R...", "goal_before": ["forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R"], "goal_after": ["(rho_ub h * t < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in ?Goal)"]}, {"text": "unfold rho_ub in |- *; cut (g < 33)%R...", "goal_before": ["(rho_ub h * t < PI / 2)%R"], "goal_after": ["(rho_ub h * t < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in ?Goal)"], "proof_term_after": []}, {"text": "cut (tan_ub_MaxBank < 4 / 5)%R...", "goal_before": ["(rho_ub h * t < PI / 2)%R"], "goal_after": ["(rho_ub h * t < PI_lb / 2)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2) ?Goal ?Goal0)"]}, {"text": "cut (/ h < / 200)%R...", "goal_before": ["(rho_ub h * t < PI_lb / 2)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(rho_ub h * t < PI_lb / 2)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2) ?Goal ?Goal0)"], "proof_term_after": []}, {"text": "intros; generalize g_pos; intro H3; generalize tan_ub_MaxBank_pos; intro H4;", "goal_before": ["(rho_ub h * t < PI_lb / 2)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal1 in ?Goal0 H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "generalize (Rinv_0_lt_compat h (TypeSpeed_pos h));", "goal_before": ["(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal1 in ?Goal0 H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "intro H5...", "goal_before": ["(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal2 in ?Goal1 H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "generalize", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal2 in ?Goal1 H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "(Rmult_le_0_lt_compat g 33 tan_ub_MaxBank (4 / 5)", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(/ h < / 200)%R ->\n(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal3 in ?Goal2 H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "(Rlt_le 0 g H3) (Rlt_le 0 tan_ub_MaxBank H4) H2 H1)...", "goal_before": ["(/ h < / 200)%R ->\n(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(/ h < / 200)%R ->\n(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal3 in ?Goal2 H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "intro H6; generalize (Rmult_lt_0_compat g tan_ub_MaxBank H3 H4); intro H7...", "goal_before": ["(/ h < / 200)%R ->\n(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(/ h < / 200)%R ->\n(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "assert", "goal_before": ["(/ h < / 200)%R ->\n(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "(H8 :=", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "Rmult_le_0_lt_compat (g * tan_ub_MaxBank) (33 * (4 / 5))", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(/ h) (/ 200) (Rlt_le 0 (g * tan_ub_MaxBank) H7)", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "(Rlt_le 0 (/ h) H5) H6 H0)...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "apply Rlt_trans with (33 * / 200 * (4 / 5) * t)%R...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply Rmult_lt_compat_r...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "apply Rlt_le_trans with MinT...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply MinT_is_pos...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (cond_1 t)...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "rewrite Rmult_assoc; rewrite (Rmult_comm (/ 200)); unfold Rdiv in |- *;", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "do 2 rewrite <- Rmult_assoc...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply Rle_lt_trans with (33 * / 200 * (4 / 5) * 10)%R...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "apply Rmult_le_compat_l...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "left; apply Rmult_lt_0_compat...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "apply Rmult_lt_0_compat; [ prove_sup | apply Rinv_0_lt_compat; prove_sup ]...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "unfold Rdiv in |- *; apply Rmult_lt_0_compat;", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "[ prove_sup | apply Rinv_0_lt_compat; prove_sup ]...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply Rmult_lt_reg_l with 2%R...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "prove_sup...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply Rmult_lt_reg_l with 200%R...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "prove_sup...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rmult_lt_reg_l with 5%R...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "prove_sup...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "set (x := 200%R); set (y := 33%R); set (z := 10%R); set (u := 5%R);", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "set (v := 4%R); set (w := 2%R)...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rdiv in |- *;", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (u * (x * (w * (PI_lb * / w))))%R with (x * PI_lb * u * (w * / w))%R;", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ idtac | ring ]...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (u * (x * (w * (y * / x * (v * / u) * z))))%R with", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(w * y * v * z * (u * / u) * (x * / x))%R; [ idtac | ring ]...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite <- Rinv_r_sym; unfold x, y, z, u, v, w in |- *; try discrR...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold PI_lb in |- *; prove_sup...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply Rinv_lt_contravar...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "apply Rmult_lt_0_compat...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "prove_sup...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "apply Rlt_le_trans with MinSpeed...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "unfold MinSpeed in |- *; prove_sup...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "apply (v_cond1 h)...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply Rlt_le_trans with MinSpeed...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "unfold MinSpeed in |- *; prove_sup...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply (v_cond1 h)...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "unfold tan_ub_MaxBank in |- *; unfold Rdiv in |- *...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply Rmult_lt_reg_l with 10%R...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "prove_sup...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "rewrite (Rmult_comm 10); rewrite Rmult_assoc; rewrite <- Rinv_l_sym...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => ?Goal3) H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "rewrite Rmult_1_r; apply Rmult_lt_reg_l with 5%R...", "goal_before": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < 4 / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / 2)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "prove_sup...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern 5%R at 1 in |- *; rewrite (Rmult_comm 5); do 2 rewrite Rmult_assoc;", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- Rinv_l_sym...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "prove_sup...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "discrR...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "discrR...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => let v := 4%R in let w := 2%R in ?Goal3)\n         H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "unfold g in |- *; unfold Rdiv in |- *; apply Rmult_lt_reg_l with 10%R...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => let v := 4%R in let w := 2%R in ?Goal3)\n         H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "prove_sup...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => let v := 4%R in let w := 2%R in ?Goal3)\n         H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "rewrite <- Rmult_comm; rewrite Rmult_assoc; rewrite <- Rinv_l_sym...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R => let v := 4%R in let w := 2%R in ?Goal3)\n         H2) H1) H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "rewrite Rmult_1_r; prove_sup...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R =>\n        let v0 := 4%R in\n        let w := 2%R in\n        ?Goal3\n        :\n        (tan_ub_MaxBank < v0 / 5)%R ->\n        (g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R) H2) H1)\n       H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "discrR...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R =>\n        let v0 := 4%R in\n        let w := 2%R in\n        ?Goal3\n        :\n        (tan_ub_MaxBank < v0 / 5)%R ->\n        (g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R) H2) H1)\n       H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "unfold Rdiv in |- *; repeat rewrite <- (Rmult_comm (/ 2));", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R =>\n        let v0 := 4%R in\n        let w := 2%R in\n        ?Goal3\n        :\n        (tan_ub_MaxBank < v0 / 5)%R ->\n        (g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R) H2) H1)\n       H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "apply Rmult_lt_compat_l...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R =>\n        let v0 := 4%R in\n        let w := 2%R in\n        ?Goal3\n        :\n        (tan_ub_MaxBank < v0 / 5)%R ->\n        (g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R) H2) H1)\n       H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "apply Rinv_0_lt_compat; prove_sup...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R =>\n        let v0 := 4%R in\n        let w := 2%R in\n        ?Goal3\n        :\n        (tan_ub_MaxBank < v0 / 5)%R ->\n        (g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R) H2) H1)\n       H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}, {"text": "assert (H0 := PI_approx); elim H0...", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R =>\n        let v0 := 4%R in\n        let w := 2%R in\n        ?Goal3\n        :\n        (tan_ub_MaxBank < v0 / 5)%R ->\n        (g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R) H2) H1)\n       H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "goal_after": ["(tan_ub_MaxBank < v / 5)%R ->\n(g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < 3 / w)%R", "(/ h < / 200)%R", "(tan_ub_MaxBank < 4 / 5)%R", "(g < 33)%R", "(PI_lb / 2 < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun (h : TypeSpeed) (t : TimeT) =>\n let H : (t <= MaxT)%R := cond_2 t in\n Rlt_trans (rho_ub h * t) (PI_lb / 2) (PI / 2)\n   ((let H0 : (g < 33)%R := ?Goal0 in\n     (let H1 : (tan_ub_MaxBank < 4 / 5)%R := ?Goal1 in\n      (let H2 : (/ h < / 200)%R := ?Goal2 in\n       (fun H5 : (/ h < / 200)%R =>\n        let v0 := 4%R in\n        let w := 2%R in\n        ?Goal3\n        :\n        (tan_ub_MaxBank < v0 / 5)%R ->\n        (g < 33)%R -> (g * (tan_ub_MaxBank / h) * t < PI_lb / w)%R) H2) H1)\n       H0)\n    :\n    (rho_ub h * t < PI_lb / 2)%R) ?Goal)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/constants.v", "name": "rho_t_PI2", "text": "Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.\nProof with trivial.\nintro; generalize (rho_ub_t_PI2 V t); intro; unfold rho_V in |- *...\napply Rlt_trans with (rho_ub V * t)%R...\napply Rmult_lt_compat_r...\napply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 t) ]...\napply rho_ub_0...\nQed.\n", "definition": " forall t : TimeT, (rho_V * t < PI / 2)%R.", "proof": "\nProof with trivial.\nintro; generalize (rho_ub_t_PI2 V t); intro; unfold rho_V in |- *...\napply Rlt_trans with (rho_ub V * t)%R...\napply Rmult_lt_compat_r...\napply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 t) ]...\napply rho_ub_0...\n", "def_ranges": [144, 0, 144, 61], "proof_ranges": [145, 0, 151, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": ["forall t : TimeT, (rho_V * t < PI / 2)%R"], "goal_after": ["forall t : TimeT, (rho_V * t < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intro; generalize (rho_ub_t_PI2 V t); intro; unfold rho_V in |- *...", "goal_before": ["forall t : TimeT, (rho_V * t < PI / 2)%R"], "goal_after": ["forall t : TimeT, (rho_V * t < PI / 2)%R"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "apply Rlt_trans with (rho_ub V * t)%R...", "goal_before": ["forall t : TimeT, (rho_V * t < PI / 2)%R"], "goal_after": ["(rho V * t < PI / 2)%R"], "proof_term_before": [], "proof_term_after": ["(fun t : TimeT =>\n (fun H : (rho_ub V * t < PI / 2)%R => ?Goal : (rho_V * t < PI / 2)%R)\n   (rho_ub_t_PI2 V t))"]}, {"text": "apply Rmult_lt_compat_r...", "goal_before": ["(rho V * t < PI / 2)%R"], "goal_after": ["(rho V * t < PI / 2)%R"], "proof_term_before": ["(fun t : TimeT =>\n (fun H : (rho_ub V * t < PI / 2)%R => ?Goal : (rho_V * t < PI / 2)%R)\n   (rho_ub_t_PI2 V t))"], "proof_term_after": []}, {"text": "apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 t) ]...", "goal_before": ["(rho V * t < PI / 2)%R"], "goal_after": ["(rho V * t < rho_ub V * t)%R"], "proof_term_before": [], "proof_term_after": ["(fun t : TimeT =>\n (fun H : (rho_ub V * t < PI / 2)%R =>\n  Rlt_trans (rho V * t) (rho_ub V * t) (PI / 2) ?Goal H\n  :\n  (rho_V * t < PI / 2)%R) (rho_ub_t_PI2 V t))"]}, {"text": "apply rho_ub_0...", "goal_before": ["(rho V * t < rho_ub V * t)%R"], "goal_after": ["(rho V * t < rho_ub V * t)%R"], "proof_term_before": ["(fun t : TimeT =>\n (fun H : (rho_ub V * t < PI / 2)%R =>\n  Rlt_trans (rho V * t) (rho_ub V * t) (PI / 2) ?Goal H\n  :\n  (rho_V * t < PI / 2)%R) (rho_ub_t_PI2 V t))"], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["(rho V * t < rho_ub V * t)%R"], "goal_after": ["(0 < t)%R", "(rho V < rho_ub V)%R"], "proof_term_before": [], "proof_term_after": ["(fun t : TimeT =>\n (fun H : (rho_ub V * t < PI / 2)%R =>\n  Rlt_trans (rho V * t) (rho_ub V * t) (PI / 2)\n    (Rmult_lt_compat_r t (rho V) (rho_ub V) ?Goal ?Goal0) H\n  :\n  (rho_V * t < PI / 2)%R) (rho_ub_t_PI2 V t))"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/trajectory.v", "name": "no_conflict_gt_max", "text": "Theorem no_conflict_gt_max :\n let MaxDistance := (vi intr * T + ConflictRange)%R in\n (MaxDistance < l)%R -> conflict T = false.\nProof with trivial.\nintros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);\n intro...\ncut (0 <= T)%R...\nintro; generalize (no_conflict_gt_max_t T H0 H); intro; cut (e T = Die T T)...\nintro; rewrite H2 in H1;\n elim\n  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H1))...\nleft; apply Rlt_le_trans with MinT...\napply MinT_is_pos...\napply (cond_1 T)...\nQed.\n", "definition": "\n let MaxDistance := (vi intr * T + ConflictRange)%R in\n (MaxDistance < l)%R -> conflict T = false.", "proof": "\nProof with trivial.\nintros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);\n intro...\ncut (0 <= T)%R...\nintro; generalize (no_conflict_gt_max_t T H0 H); intro; cut (e T = Die T T)...\nintro; rewrite H2 in H1;\n elim\n  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H1))...\nleft; apply Rlt_le_trans with MinT...\napply MinT_is_pos...\napply (cond_1 T)...\n", "def_ranges": [1123, 0, 1125, 43], "proof_ranges": [1126, 0, 1137, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": ["let MaxDistance := (vi intr * T + ConflictRange)%R in\n(MaxDistance < l)%R -> conflict T = false"], "goal_after": ["let MaxDistance := (vi intr * T + ConflictRange)%R in\n(MaxDistance < l)%R -> conflict T = false"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);", "goal_before": ["let MaxDistance := (vi intr * T + ConflictRange)%R in\n(MaxDistance < l)%R -> conflict T = false"], "goal_after": ["let MaxDistance := (vi intr * T + ConflictRange)%R in\n(MaxDistance < l)%R -> conflict T = false"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "intro...", "goal_before": ["let MaxDistance := (vi intr * T + ConflictRange)%R in\n(MaxDistance < l)%R -> conflict T = false"], "goal_after": ["let MaxDistance := (vi intr * T + ConflictRange)%R in\n(MaxDistance < l)%R -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (0 <= T)%R...", "goal_before": ["(MaxDistance < l)%R -> conflict T = false"], "goal_after": ["(MaxDistance < l)%R -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; generalize (no_conflict_gt_max_t T H0 H); intro; cut (e T = Die T T)...", "goal_before": ["(MaxDistance < l)%R -> conflict T = false"], "goal_after": ["(MaxDistance < l)%R -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; rewrite H2 in H1;", "goal_before": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim", "goal_before": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "(Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H1))...", "goal_before": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "left; apply Rlt_le_trans with MinT...", "goal_before": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply MinT_is_pos...", "goal_before": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (cond_1 T)...", "goal_before": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R -> (MaxDistance < l)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/trajectory.v", "name": "no_conflict_lt_min", "text": "Theorem no_conflict_lt_min :\n let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n (0 <= rho_vi * T)%R ->\n (rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false.\nProof with trivial.\nintros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);\n intro...\ncut (0 <= T)%R...\nintro; generalize (no_conflict_lt_min_t T H2 H H0 H1); intro;\n cut (e T = Die T T)...\nintro; rewrite H4 in H3;\n elim\n  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H3))...\nleft; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...\nQed.\n", "definition": "\n let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n (0 <= rho_vi * T)%R ->\n (rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false.", "proof": "\nProof with trivial.\nintros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);\n intro...\ncut (0 <= T)%R...\nintro; generalize (no_conflict_lt_min_t T H2 H H0 H1); intro;\n cut (e T = Die T T)...\nintro; rewrite H4 in H3;\n elim\n  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H3))...\nleft; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...\n", "def_ranges": [1139, 0, 1142, 65], "proof_ranges": [1143, 0, 1153, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": ["let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "goal_after": ["let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);", "goal_before": ["let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "goal_after": ["let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "intro...", "goal_before": ["let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "goal_after": ["let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (0 <= T)%R...", "goal_before": ["(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "goal_after": ["(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; generalize (no_conflict_lt_min_t T H2 H H0 H1); intro;", "goal_before": ["(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "goal_after": ["(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (e T = Die T T)...", "goal_before": ["(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; rewrite H4 in H3;", "goal_before": ["(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim", "goal_before": ["(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["e T = Die T T ->\n(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": ["(let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n let H : (0 <= T)%R := ?Goal in\n (let H0 : e T = Die T T := eq_refl in ?Goal0 H0) H)"]}, {"text": "(Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H3))...", "goal_before": ["e T = Die T T ->\n(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["e T = Die T T ->\n(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": ["(let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n let H : (0 <= T)%R := ?Goal in\n (let H0 : e T = Die T T := eq_refl in ?Goal0 H0) H)"], "proof_term_after": []}, {"text": "left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...", "goal_before": ["e T = Die T T ->\n(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["e T = Die T T ->\n(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["e T = Die T T ->\n(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "goal_after": ["e T = Die T T ->\n(0 <= T)%R ->\n(0 <= rho_vi * T)%R ->\n(rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": ["(let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in\n let H : (0 <= T)%R := ?Goal in\n (let H0 : e T = Die T T := eq_refl in ?Goal0 H0) H)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/trajectory.v", "name": "no_conflict_Omega", "text": "Theorem no_conflict_Omega :\n (ConflictRange + v (vi intr) < l)%R ->\n (rho_vi * T <= PI - rho_vi)%R ->\n Omega (beta + thetat intr 0) = true -> conflict T = false.\nProof with trivial.\nintros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);\n intro...\ncut (0 <= T)%R...\nintro; generalize (no_conflict_Omega_t T H H2 H0 H1); intro;\n cut (e T = Die T T)...\nintro; rewrite H4 in H3;\n elim\n  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H3))...\nleft; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...\nQed.\n", "definition": "\n (ConflictRange + v (vi intr) < l)%R ->\n (rho_vi * T <= PI - rho_vi)%R ->\n Omega (beta + thetat intr 0) = true -> conflict T = false.", "proof": "\nProof with trivial.\nintros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);\n intro...\ncut (0 <= T)%R...\nintro; generalize (no_conflict_Omega_t T H H2 H0 H1); intro;\n cut (e T = Die T T)...\nintro; rewrite H4 in H3;\n elim\n  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H3))...\nleft; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...\n", "def_ranges": [1155, 0, 1158, 59], "proof_ranges": [1159, 0, 1169, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": ["(ConflictRange + vi intr < l)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "goal_after": ["(ConflictRange + vi intr < l)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);", "goal_before": ["(ConflictRange + vi intr < l)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "goal_after": ["(ConflictRange + vi intr < l)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "intro...", "goal_before": ["(ConflictRange + vi intr < l)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "goal_after": ["(ConflictRange + vi intr < l)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (0 <= T)%R...", "goal_before": ["(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "goal_after": ["(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; generalize (no_conflict_Omega_t T H H2 H0 H1); intro;", "goal_before": ["(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "goal_after": ["(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false"], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (e T = Die T T)...", "goal_before": ["(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; rewrite H4 in H3;", "goal_before": ["(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "goal_after": ["(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim", "goal_before": ["(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "goal_after": ["e T = Die T T ->\n(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": ["(fun H : (ConflictRange + vi intr < l)%R =>\n let H0 : (0 <= T)%R := ?Goal in\n (let H1 : e T = Die T T := eq_refl in ?Goal0 H1) H0)"]}, {"text": "(Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H3))...", "goal_before": ["e T = Die T T ->\n(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "goal_after": ["e T = Die T T ->\n(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "proof_term_before": ["(fun H : (ConflictRange + vi intr < l)%R =>\n let H0 : (0 <= T)%R := ?Goal in\n (let H1 : e T = Die T T := eq_refl in ?Goal0 H1) H0)"], "proof_term_after": []}, {"text": "left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...", "goal_before": ["e T = Die T T ->\n(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "goal_after": ["e T = Die T T ->\n(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["e T = Die T T ->\n(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "goal_after": ["e T = Die T T ->\n(0 <= T)%R ->\n(rho_vi * T <= PI - rho_vi)%R ->\nOmega (beta + thetat intr 0) = true -> conflict T = false", "(0 <= T)%R"], "proof_term_before": [], "proof_term_after": ["(fun H : (ConflictRange + vi intr < l)%R =>\n let H0 : (0 <= T)%R := ?Goal in\n (let H1 : e T = Die T T := eq_refl in ?Goal0 H1) H0)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/correctness.v", "name": "ails_alarm_at_alerting_distance", "text": "Theorem ails_alarm_at_alerting_distance :\n forall (intr : Trajectory) (evad : EvaderTrajectory),\n (d intr evad <= AlertRange)%R ->\n ails_alert (measure2state intr 0) (measure2state (tr evad) 0).\nProof with trivial.\nintros; apply alarm_at_alerting_distance...\nQed.\n", "definition": "\n forall (intr : Trajectory) (evad : EvaderTrajectory),\n (d intr evad <= AlertRange)%R ->\n ails_alert (measure2state intr 0) (measure2state (tr evad) 0).", "proof": "\nProof with trivial.\nintros; apply alarm_at_alerting_distance...\n", "def_ranges": [39, 0, 42, 63], "proof_ranges": [43, 0, 45, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; apply alarm_at_alerting_distance...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/correctness.v", "name": "ails_alarm_when_conflict", "text": "Theorem ails_alarm_when_conflict :\n forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),\n h intr = V ->\n h (tr evad) = V ->\n (AlertRange < d intr evad)%R ->\n conflict intr evad T = true ->\n ails_alert (measure2state intr 0) (measure2state (tr evad) 0).\nProof with trivial.\nintros; cut (Die intr evad T T <= ConflictRange)%R...\nintro...\ncase (Rle_dec (l intr evad T) (MaxDistance T)); intro...\ncase (Rle_dec (MinDistance T) (l intr evad T)); intro...\ncut (Omega (beta intr evad T + thetat intr 0) = false)...\nintro; apply (ails_alarm_tau_gt0 intr evad T)...\ncase (Rle_dec (tau (measure2state intr 0) (measure2state (tr evad) 0) 0) 0);\n intro...\nrewrite Rplus_comm in H4;\n generalize (ails_no_conflict_tau_le0 intr evad T H H0 r0 r H1 H4 r1); \n intro; rewrite H5 in H2; elim diff_false_true...\nauto with real...\ncut\n (Omega (beta intr evad T + thetat intr 0) = false \\/\n  Omega (beta intr evad T + thetat intr 0) = true)...\nintro; elim H4; intro...\ncut (ConflictRange + vi intr < l intr evad T)%R...\ncut (rho_vi intr * T <= PI - rho_vi intr)%R...\nintros; generalize (no_conflict_Omega intr evad T H7 H6 H5); intro;\n rewrite H8 in H2; elim diff_false_true...\napply Rplus_le_reg_l with (rho_vi intr)...\nreplace (rho_vi intr + (PI - rho_vi intr))%R with PI...\ncut (rho_vi intr <= rho_vi intr * T)%R...\nintro; apply Rle_trans with (rho_vi intr * T + rho_vi intr * T)%R...\napply Rplus_le_compat_r...\ncut (rho_vi intr * T <= PI / 2)%R...\nintro; rewrite (double_var PI);\n apply Rle_trans with (rho_vi intr * T + PI / 2)%R...\napply Rplus_le_compat_l...\napply Rplus_le_compat_r...\nleft; replace (rho_vi intr) with rho_V...\napply rho_t_PI2...\nunfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...\npattern (rho_vi intr) at 1 in |- *; rewrite <- (Rmult_1_r (rho_vi intr));\n apply rho_t_le; left; apply Rlt_le_trans with MinT...\nunfold MinT in |- *; unfold MaxT, tstep in |- *;\n apply Rmult_lt_reg_l with 2%R...\nprove_sup...\nrewrite Rmult_1_r; rewrite Rmult_minus_distr_l...\nrewrite <- Rinv_r_sym; [ prove_sup | discrR ]...\napply (cond_1 T)...\nring...\napply Rlt_le_trans with (MinDistance T)...\napply Rlt_le_trans with MinDistance_lb...\nreplace (vi intr) with V...\nrewrite Rplus_comm...\napply MinDistance_lb_majoration...\napply MinDistance_lb_0...\nunfold Omega in |- *;\n case (Rle_dec (PI / 2) (beta intr evad T + thetat intr 0)); \n intro...\ncase (Rle_dec (beta intr evad T + thetat intr 0) (3 * (PI / 2))); intros...\nright...\nleft...\nleft...\ncut (l intr evad T < MinDistance T)%R...\ncut (0 <= rho_vi intr * T)%R...\ncut (rho_vi intr * T < 2)%R...\nintros; unfold MinDistance in H4; unfold m in H4...\ncut (r_V = r_vi intr)...\ncut (rho_V = rho_vi intr)...\nintros; unfold MinDistance in H6; unfold m in H6...\nrewrite H8 in H6; rewrite H7 in H6...\ngeneralize (no_conflict_lt_min intr evad T H5 H4 H6); intro...\nrewrite H9 in H2...\nelim diff_false_true...\nunfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...\nunfold r_V, r_vi in |- *; unfold vi in |- *; rewrite H...\nreplace (rho_vi intr) with rho_V...\napply rho_t_2...\nunfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...\nleft; apply Rmult_lt_0_compat...\nunfold rho_vi in |- *; apply rrho.rho_pos...\napply Rlt_le_trans with MinT...\napply MinT_is_pos...\napply (cond_1 T)...\nauto with real...\ncut (MaxDistance T < l intr evad T)%R...\nintro; unfold MaxDistance in H4; cut (V = vi intr)...\nintro; rewrite H5 in H4...\ngeneralize (no_conflict_gt_max intr evad T H4); intro...\nrewrite H6 in H2...\nelim diff_false_true...\nsymmetry  in |- *; unfold vi in |- *; rewrite H...\nauto with real...\napply (conflict_T_e_0 intr evad T)...\nQed.\n", "definition": "\n forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),\n h intr = V ->\n h (tr evad) = V ->\n (AlertRange < d intr evad)%R ->\n conflict intr evad T = true ->\n ails_alert (measure2state intr 0) (measure2state (tr evad) 0).", "proof": "\nProof with trivial.\nintros; cut (Die intr evad T T <= ConflictRange)%R...\nintro...\ncase (Rle_dec (l intr evad T) (MaxDistance T)); intro...\ncase (Rle_dec (MinDistance T) (l intr evad T)); intro...\ncut (Omega (beta intr evad T + thetat intr 0) = false)...\nintro; apply (ails_alarm_tau_gt0 intr evad T)...\ncase (Rle_dec (tau (measure2state intr 0) (measure2state (tr evad) 0) 0) 0);\n intro...\nrewrite Rplus_comm in H4;\n generalize (ails_no_conflict_tau_le0 intr evad T H H0 r0 r H1 H4 r1); \n intro; rewrite H5 in H2; elim diff_false_true...\nauto with real...\ncut\n (Omega (beta intr evad T + thetat intr 0) = false \\/\n  Omega (beta intr evad T + thetat intr 0) = true)...\nintro; elim H4; intro...\ncut (ConflictRange + vi intr < l intr evad T)%R...\ncut (rho_vi intr * T <= PI - rho_vi intr)%R...\nintros; generalize (no_conflict_Omega intr evad T H7 H6 H5); intro;\n rewrite H8 in H2; elim diff_false_true...\napply Rplus_le_reg_l with (rho_vi intr)...\nreplace (rho_vi intr + (PI - rho_vi intr))%R with PI...\ncut (rho_vi intr <= rho_vi intr * T)%R...\nintro; apply Rle_trans with (rho_vi intr * T + rho_vi intr * T)%R...\napply Rplus_le_compat_r...\ncut (rho_vi intr * T <= PI / 2)%R...\nintro; rewrite (double_var PI);\n apply Rle_trans with (rho_vi intr * T + PI / 2)%R...\napply Rplus_le_compat_l...\napply Rplus_le_compat_r...\nleft; replace (rho_vi intr) with rho_V...\napply rho_t_PI2...\nunfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...\npattern (rho_vi intr) at 1 in |- *; rewrite <- (Rmult_1_r (rho_vi intr));\n apply rho_t_le; left; apply Rlt_le_trans with MinT...\nunfold MinT in |- *; unfold MaxT, tstep in |- *;\n apply Rmult_lt_reg_l with 2%R...\nprove_sup...\nrewrite Rmult_1_r; rewrite Rmult_minus_distr_l...\nrewrite <- Rinv_r_sym; [ prove_sup | discrR ]...\napply (cond_1 T)...\nring...\napply Rlt_le_trans with (MinDistance T)...\napply Rlt_le_trans with MinDistance_lb...\nreplace (vi intr) with V...\nrewrite Rplus_comm...\napply MinDistance_lb_majoration...\napply MinDistance_lb_0...\nunfold Omega in |- *;\n case (Rle_dec (PI / 2) (beta intr evad T + thetat intr 0)); \n intro...\ncase (Rle_dec (beta intr evad T + thetat intr 0) (3 * (PI / 2))); intros...\nright...\nleft...\nleft...\ncut (l intr evad T < MinDistance T)%R...\ncut (0 <= rho_vi intr * T)%R...\ncut (rho_vi intr * T < 2)%R...\nintros; unfold MinDistance in H4; unfold m in H4...\ncut (r_V = r_vi intr)...\ncut (rho_V = rho_vi intr)...\nintros; unfold MinDistance in H6; unfold m in H6...\nrewrite H8 in H6; rewrite H7 in H6...\ngeneralize (no_conflict_lt_min intr evad T H5 H4 H6); intro...\nrewrite H9 in H2...\nelim diff_false_true...\nunfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...\nunfold r_V, r_vi in |- *; unfold vi in |- *; rewrite H...\nreplace (rho_vi intr) with rho_V...\napply rho_t_2...\nunfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...\nleft; apply Rmult_lt_0_compat...\nunfold rho_vi in |- *; apply rrho.rho_pos...\napply Rlt_le_trans with MinT...\napply MinT_is_pos...\napply (cond_1 T)...\nauto with real...\ncut (MaxDistance T < l intr evad T)%R...\nintro; unfold MaxDistance in H4; cut (V = vi intr)...\nintro; rewrite H5 in H4...\ngeneralize (no_conflict_gt_max intr evad T H4); intro...\nrewrite H6 in H2...\nelim diff_false_true...\nsymmetry  in |- *; unfold vi in |- *; rewrite H...\nauto with real...\napply (conflict_T_e_0 intr evad T)...\n", "def_ranges": [47, 0, 53, 63], "proof_ranges": [54, 0, 141, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; cut (Die intr evad T T <= ConflictRange)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (l intr evad T) (MaxDistance T)); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (MinDistance T) (l intr evad T)); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Omega (beta intr evad T + thetat intr 0) = false)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; apply (ails_alarm_tau_gt0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (tau (measure2state intr 0) (measure2state (tr evad) 0) 0) 0);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite Rplus_comm in H4;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (ails_no_conflict_tau_le0 intr evad T H H0 r0 r H1 H4 r1);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; rewrite H5 in H2; elim diff_false_true...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with real...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Omega (beta intr evad T + thetat intr 0) = false \\/", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Omega (beta intr evad T + thetat intr 0) = true)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; elim H4; intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (ConflictRange + vi intr < l intr evad T)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (rho_vi intr * T <= PI - rho_vi intr)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; generalize (no_conflict_Omega intr evad T H7 H6 H5); intro;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H8 in H2; elim diff_false_true...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rplus_le_reg_l with (rho_vi intr)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (rho_vi intr + (PI - rho_vi intr))%R with PI...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (rho_vi intr <= rho_vi intr * T)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; apply Rle_trans with (rho_vi intr * T + rho_vi intr * T)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rplus_le_compat_r...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (rho_vi intr * T <= PI / 2)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; rewrite (double_var PI);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rle_trans with (rho_vi intr * T + PI / 2)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rplus_le_compat_l...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rplus_le_compat_r...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left; replace (rho_vi intr) with rho_V...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply rho_t_PI2...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern (rho_vi intr) at 1 in |- *; rewrite <- (Rmult_1_r (rho_vi intr));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply rho_t_le; left; apply Rlt_le_trans with MinT...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold MinT in |- *; unfold MaxT, tstep in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rmult_lt_reg_l with 2%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "prove_sup...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite Rmult_1_r; rewrite Rmult_minus_distr_l...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- Rinv_r_sym; [ prove_sup | discrR ]...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (cond_1 T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "ring...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rlt_le_trans with (MinDistance T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rlt_le_trans with MinDistance_lb...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (vi intr) with V...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite Rplus_comm...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply MinDistance_lb_majoration...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply MinDistance_lb_0...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Omega in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (PI / 2) (beta intr evad T + thetat intr 0));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (beta intr evad T + thetat intr 0) (3 * (PI / 2))); intros...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "right...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (l intr evad T < MinDistance T)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (0 <= rho_vi intr * T)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (rho_vi intr * T < 2)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; unfold MinDistance in H4; unfold m in H4...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (r_V = r_vi intr)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (rho_V = rho_vi intr)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; unfold MinDistance in H6; unfold m in H6...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H8 in H6; rewrite H7 in H6...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (no_conflict_lt_min intr evad T H5 H4 H6); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H9 in H2...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim diff_false_true...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold r_V, r_vi in |- *; unfold vi in |- *; rewrite H...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (rho_vi intr) with rho_V...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply rho_t_2...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite H...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left; apply Rmult_lt_0_compat...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold rho_vi in |- *; apply rrho.rho_pos...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rlt_le_trans with MinT...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply MinT_is_pos...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (cond_1 T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with real...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (MaxDistance T < l intr evad T)%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; unfold MaxDistance in H4; cut (V = vi intr)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; rewrite H5 in H4...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (no_conflict_gt_max intr evad T H4); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H6 in H2...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim diff_false_true...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "symmetry  in |- *; unfold vi in |- *; rewrite H...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with real...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (conflict_T_e_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/correctness.v", "name": "ails_correctness", "text": "Theorem ails_correctness :\n forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),\n h intr = V ->\n h (tr evad) = V ->\n conflict intr evad T = true ->\n ails_alert (measure2state intr 0) (measure2state (tr evad) 0).\nProof with trivial.\nintros; case (Rle_dec (d intr evad) AlertRange); intro;\n [ apply (ails_alarm_at_alerting_distance _ _ r)\n | cut (AlertRange < d intr evad)%R;\n    [ intro; apply (ails_alarm_when_conflict intr evad T) | auto with real ] ]...\nQed.\n", "definition": "\n forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),\n h intr = V ->\n h (tr evad) = V ->\n conflict intr evad T = true ->\n ails_alert (measure2state intr 0) (measure2state (tr evad) 0).", "proof": "\nProof with trivial.\nintros; case (Rle_dec (d intr evad) AlertRange); intro;\n [ apply (ails_alarm_at_alerting_distance _ _ r)\n | cut (AlertRange < d intr evad)%R;\n    [ intro; apply (ails_alarm_when_conflict intr evad T) | auto with real ] ]...\n", "def_ranges": [143, 0, 148, 63], "proof_ranges": [149, 0, 154, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; case (Rle_dec (d intr evad) AlertRange); intro;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ apply (ails_alarm_at_alerting_distance _ _ r)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| cut (AlertRange < d intr evad)%R;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro; apply (ails_alarm_when_conflict intr evad T) | auto with real ] ]...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/ycngftys.v", "name": "YCNGFTYS", "text": "Theorem YCNGFTYS :\n forall t : R,\n (0 <= t)%R -> (sqrt (Rsqr (xi t - xi 0) + Rsqr (yi t - yi 0)) <= v vi * t)%R.\nintros; apply Rsqr_incr_0.\nrewrite Rsqr_mult; apply le_epsilon; intros;\n generalize (Rsqr_u_Rsqr_vt (mkposreal eps H0) t H); \n simpl in |- *; unfold u0 in |- *; unfold xP, yP in |- *; \n intro H1; assumption.\napply sqrt_positivity; apply Rplus_le_le_0_compat; apply Rle_0_sqr.\napply Rmult_le_pos; [ left; apply (TypeSpeed_pos vi) | assumption ].\nQed.\n", "definition": "\n forall t : R,\n (0 <= t)%R -> (sqrt (Rsqr (xi t - xi 0) + Rsqr (yi t - yi 0)) <= v vi * t)%R.", "proof": "\nintros; apply Rsqr_incr_0.\nrewrite Rsqr_mult; apply le_epsilon; intros;\n generalize (Rsqr_u_Rsqr_vt (mkposreal eps H0) t H); \n simpl in |- *; unfold u0 in |- *; unfold xP, yP in |- *; \n intro H1; assumption.\napply sqrt_positivity; apply Rplus_le_le_0_compat; apply Rle_0_sqr.\napply Rmult_le_pos; [ left; apply (TypeSpeed_pos vi) | assumption ].\n", "def_ranges": [368, 0, 370, 78], "proof_ranges": [371, 0, 378, 4], "proof_steps": [{"text": "intros; apply Rsqr_incr_0.", "goal_before": ["forall t : R,\n(0 <= t)%R -> (sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2) <= vi * t)%R"], "goal_after": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "proof_term_before": [], "proof_term_after": ["(fun (t : R) (H : (0 <= t)%R) =>\n Rsqr_incr_0 (sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2)) \n   (vi * t) ?Goal ?Goal0 ?Goal1)"]}, {"text": "rewrite Rsqr_mult; apply le_epsilon; intros;", "goal_before": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "goal_after": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "proof_term_before": ["(fun (t : R) (H : (0 <= t)%R) =>\n Rsqr_incr_0 (sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2)) \n   (vi * t) ?Goal ?Goal0 ?Goal1)"], "proof_term_after": []}, {"text": "generalize (Rsqr_u_Rsqr_vt (mkposreal eps H0) t H);", "goal_before": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "goal_after": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; unfold u0 in |- *; unfold xP, yP in |- *;", "goal_before": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "goal_after": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; assumption.", "goal_before": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "goal_after": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sqrt_positivity; apply Rplus_le_le_0_compat; apply Rle_0_sqr.", "goal_before": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "goal_after": ["((sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))\u00b2 <= (vi * t)\u00b2)%R", "(0 <= sqrt ((xi t - xi 0)\u00b2 + (yi t - yi 0)\u00b2))%R", "(0 <= vi * t)%R"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/alarm.v", "name": "ails_alarm_tau_gt0", "text": "Theorem ails_alarm_tau_gt0 :\n forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),\n h intr = V ->\n h (tr evad) = V ->\n (MinDistance T <= l intr evad T)%R ->\n (l intr evad T <= MaxDistance T)%R ->\n Omega (beta intr evad T + thetat intr 0) = false ->\n (0 < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->\n conflict intr evad T = true ->\n ails_alert (measure2state intr 0) (measure2state (tr evad) 0).\nProof with trivial.\nintros intr evad T hyp_intr hyp_evad; intros; unfold ails_alert in |- *;\n case (Req_EM_var (trkrate (bank (measure2state intr 0))) 0); \n intro...\napply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\ncase (Rle_dec 3 (trkrate (bank (measure2state intr 0)))); intro...\nunfold arc_loop in |- *; rewrite mod_eq_0...\ncase (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); intro...\nunfold INR in |- *; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;\n repeat rewrite Rplus_0_r; unfold intruderSpeed in |- *;\n replace (v V) with 250%R...\ncut\n (let z := 250%R in\n  mkState\n    (xt (measure2state intr 0) +\n     Rsqr z / (g * tand (bank (measure2state intr 0))) *\n     (sind (heading (measure2state intr 0)) -\n      sind (heading (measure2state intr 0))))\n    (yt (measure2state intr 0) +\n     Rsqr z / (g * tand (bank (measure2state intr 0))) *\n     (cosd (heading (measure2state intr 0)) -\n      cosd (heading (measure2state intr 0))))\n    (heading (measure2state intr 0)) (bank (measure2state intr 0)) =\n  measure2state intr 0)...\nintro; rewrite H4...\ncut\n (mkState (xt (measure2state (tr evad) 0)) (yt (measure2state (tr evad) 0))\n    (heading (measure2state (tr evad) 0)) (bank (measure2state (tr evad) 0)) =\n  measure2state (tr evad) 0)...\nintro; rewrite H5...\napply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nunfold Rminus in |- *; repeat rewrite Rplus_opp_r; repeat rewrite Rmult_0_r;\n repeat rewrite Rplus_0_r...\nunfold INR in |- *; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;\n repeat rewrite Rplus_0_r; unfold Rminus in |- *; repeat rewrite Rplus_opp_r;\n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\ncase (Rle_dec (3 / 2) (trkrate (bank (measure2state intr 0)))); intro...\nunfold arc_loop in |- *; rewrite mod_eq_0;\n case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); \n intro...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\ncase (Rle_dec (3 / 4) (trkrate (bank (measure2state intr 0)))); intro...\nunfold arc_loop in |- *; rewrite mod_eq_0;\n case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); \n intro...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nunfold arc_loop in |- *; rewrite mod_eq_0;\n case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); \n intro...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nQed.\n", "definition": "\n forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),\n h intr = V ->\n h (tr evad) = V ->\n (MinDistance T <= l intr evad T)%R ->\n (l intr evad T <= MaxDistance T)%R ->\n Omega (beta intr evad T + thetat intr 0) = false ->\n (0 < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->\n conflict intr evad T = true ->\n ails_alert (measure2state intr 0) (measure2state (tr evad) 0).", "proof": "\nProof with trivial.\nintros intr evad T hyp_intr hyp_evad; intros; unfold ails_alert in |- *;\n case (Req_EM_var (trkrate (bank (measure2state intr 0))) 0); \n intro...\napply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\ncase (Rle_dec 3 (trkrate (bank (measure2state intr 0)))); intro...\nunfold arc_loop in |- *; rewrite mod_eq_0...\ncase (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); intro...\nunfold INR in |- *; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;\n repeat rewrite Rplus_0_r; unfold intruderSpeed in |- *;\n replace (v V) with 250%R...\ncut\n (let z := 250%R in\n  mkState\n    (xt (measure2state intr 0) +\n     Rsqr z / (g * tand (bank (measure2state intr 0))) *\n     (sind (heading (measure2state intr 0)) -\n      sind (heading (measure2state intr 0))))\n    (yt (measure2state intr 0) +\n     Rsqr z / (g * tand (bank (measure2state intr 0))) *\n     (cosd (heading (measure2state intr 0)) -\n      cosd (heading (measure2state intr 0))))\n    (heading (measure2state intr 0)) (bank (measure2state intr 0)) =\n  measure2state intr 0)...\nintro; rewrite H4...\ncut\n (mkState (xt (measure2state (tr evad) 0)) (yt (measure2state (tr evad) 0))\n    (heading (measure2state (tr evad) 0)) (bank (measure2state (tr evad) 0)) =\n  measure2state (tr evad) 0)...\nintro; rewrite H5...\napply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nunfold Rminus in |- *; repeat rewrite Rplus_opp_r; repeat rewrite Rmult_0_r;\n repeat rewrite Rplus_0_r...\nunfold INR in |- *; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;\n repeat rewrite Rplus_0_r; unfold Rminus in |- *; repeat rewrite Rplus_opp_r;\n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\ncase (Rle_dec (3 / 2) (trkrate (bank (measure2state intr 0)))); intro...\nunfold arc_loop in |- *; rewrite mod_eq_0;\n case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); \n intro...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\ncase (Rle_dec (3 / 4) (trkrate (bank (measure2state intr 0)))); intro...\nunfold arc_loop in |- *; rewrite mod_eq_0;\n case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); \n intro...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nunfold arc_loop in |- *; rewrite mod_eq_0;\n case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); \n intro...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\nrepeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n unfold Rminus in |- *; repeat rewrite Rplus_opp_r; \n unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;\n apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...\n", "def_ranges": [242, 0, 251, 63], "proof_ranges": [252, 0, 324, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros intr evad T hyp_intr hyp_evad; intros; unfold ails_alert in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Req_EM_var (trkrate (bank (measure2state intr 0))) 0);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec 3 (trkrate (bank (measure2state intr 0)))); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold arc_loop in |- *; rewrite mod_eq_0...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold INR in |- *; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rplus_0_r; unfold intruderSpeed in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (v V) with 250%R...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(let z := 250%R in", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "mkState", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(xt (measure2state intr 0) +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Rsqr z / (g * tand (bank (measure2state intr 0))) *", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(sind (heading (measure2state intr 0)) -", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "sind (heading (measure2state intr 0))))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(yt (measure2state intr 0) +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Rsqr z / (g * tand (bank (measure2state intr 0))) *", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(cosd (heading (measure2state intr 0)) -", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cosd (heading (measure2state intr 0))))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(heading (measure2state intr 0)) (bank (measure2state intr 0)) =", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "measure2state intr 0)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; rewrite H4...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(mkState (xt (measure2state (tr evad) 0)) (yt (measure2state (tr evad) 0))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(heading (measure2state (tr evad) 0)) (bank (measure2state (tr evad) 0)) =", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "measure2state (tr evad) 0)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; rewrite H5...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rminus in |- *; repeat rewrite Rplus_opp_r; repeat rewrite Rmult_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rplus_0_r...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold INR in |- *; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rplus_0_r; unfold Rminus in |- *; repeat rewrite Rplus_opp_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (3 / 2) (trkrate (bank (measure2state intr 0)))); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold arc_loop in |- *; rewrite mod_eq_0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0))));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rminus in |- *; repeat rewrite Rplus_opp_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rminus in |- *; repeat rewrite Rplus_opp_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (3 / 4) (trkrate (bank (measure2state intr 0)))); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold arc_loop in |- *; rewrite mod_eq_0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0))));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rminus in |- *; repeat rewrite Rplus_opp_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rminus in |- *; repeat rewrite Rplus_opp_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold arc_loop in |- *; rewrite mod_eq_0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0))));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rminus in |- *; repeat rewrite Rplus_opp_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rminus in |- *; repeat rewrite Rplus_opp_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/ycngstys.v", "name": "YCNGSTYS", "text": "Theorem YCNGSTYS :\n forall t : R,\n (0 <= t)%R ->\n (rho (vi intr) * t < 2)%R ->\n (2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)))%R.\nintros; generalize (rho_pos (vi intr)); intro H1;\n generalize (Rinv_0_lt_compat (rho (vi intr)) H1); \n intro H2;\n generalize (Rmult_lt_compat_l (/ rho (vi intr)) (rho (vi intr) * t) 2 H2 H0);\n intro H3; rewrite <- Rmult_assoc in H3; rewrite <- Rinv_l_sym in H3.\nrewrite Rmult_1_l in H3; rewrite Rmult_comm in H3; generalize (G_pos t H H3);\n unfold G in |- *; intro H4;\n generalize (Rplus_le_compat_l (F t) 0 (Rs t - F t) H4); \n rewrite Rplus_0_r; intro H5; unfold Rminus in H5;\n rewrite <- Rplus_assoc in H5; rewrite Rplus_comm in H5;\n rewrite <- Rplus_assoc in H5; rewrite Rplus_opp_l in H5;\n rewrite Rplus_0_l in H5; unfold Rs, F in H5; unfold r in |- *; \n assumption.\nred in |- *; intro H4; rewrite H4 in H1; elim (Rlt_irrefl 0 H1).\nQed.\n", "definition": "\n forall t : R,\n (0 <= t)%R ->\n (rho (vi intr) * t < 2)%R ->\n (2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)))%R.", "proof": "\nintros; generalize (rho_pos (vi intr)); intro H1;\n generalize (Rinv_0_lt_compat (rho (vi intr)) H1); \n intro H2;\n generalize (Rmult_lt_compat_l (/ rho (vi intr)) (rho (vi intr) * t) 2 H2 H0);\n intro H3; rewrite <- Rmult_assoc in H3; rewrite <- Rinv_l_sym in H3.\nrewrite Rmult_1_l in H3; rewrite Rmult_comm in H3; generalize (G_pos t H H3);\n unfold G in |- *; intro H4;\n generalize (Rplus_le_compat_l (F t) 0 (Rs t - F t) H4); \n rewrite Rplus_0_r; intro H5; unfold Rminus in H5;\n rewrite <- Rplus_assoc in H5; rewrite Rplus_comm in H5;\n rewrite <- Rplus_assoc in H5; rewrite Rplus_opp_l in H5;\n rewrite Rplus_0_l in H5; unfold Rs, F in H5; unfold r in |- *; \n assumption.\nred in |- *; intro H4; rewrite H4 in H1; elim (Rlt_irrefl 0 H1).\n", "def_ranges": [1017, 0, 1022, 72], "proof_ranges": [1023, 0, 1037, 4], "proof_steps": [{"text": "intros; generalize (rho_pos (vi intr)); intro H1;", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Rinv_0_lt_compat (rho (vi intr)) H1);", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2;", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "generalize (Rmult_lt_compat_l (/ rho (vi intr)) (rho (vi intr) * t) 2 H2 H0);", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": ["?Goal"], "proof_term_after": []}, {"text": "intro H3; rewrite <- Rmult_assoc in H3; rewrite <- Rinv_l_sym in H3.", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite Rmult_1_l in H3; rewrite Rmult_comm in H3; generalize (G_pos t H H3);", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold G in |- *; intro H4;", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Rplus_le_compat_l (F t) 0 (Rs t - F t) H4);", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite Rplus_0_r; intro H5; unfold Rminus in H5;", "goal_before": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "goal_after": ["forall t : R,\n(0 <= t)%R ->\n(rho (vi intr) * t < 2)%R ->\n(2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=\n sqrt ((xi intr t - xi intr 0)\u00b2 + (yi intr t - yi intr 0)\u00b2))%R"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ails/ails.v", "name": "alarm_at_alerting_distance", "text": "Theorem alarm_at_alerting_distance :\n forall evader intruder : State,\n alerting_distance evader intruder -> ails_alert intruder evader.\nProof with trivial.\nintros; unfold ails_alert in |- *;\n case (Req_EM_var (trkrate (bank intruder)) 0); intro...\napply (step1 _ _ H)...\nunfold alerting_distance in H; case (Rle_dec 3 (trkrate (bank intruder)));\n intro...\napply step2...\ncase (Rle_dec (3 / 2) (trkrate (bank intruder))); intro...\napply step2...\ncase (Rle_dec (3 / 4) (trkrate (bank intruder))); intro; apply step2...\nQed.\n", "definition": "\n forall evader intruder : State,\n alerting_distance evader intruder -> ails_alert intruder evader.", "proof": "\nProof with trivial.\nintros; unfold ails_alert in |- *;\n case (Req_EM_var (trkrate (bank intruder)) 0); intro...\napply (step1 _ _ H)...\nunfold alerting_distance in H; case (Rle_dec 3 (trkrate (bank intruder)));\n intro...\napply step2...\ncase (Rle_dec (3 / 2) (trkrate (bank intruder))); intro...\napply step2...\ncase (Rle_dec (3 / 4) (trkrate (bank intruder))); intro; apply step2...\n", "def_ranges": [295, 0, 297, 65], "proof_ranges": [298, 0, 308, 4], "proof_steps": [{"text": "Proof with trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; unfold ails_alert in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Req_EM_var (trkrate (bank intruder)) 0); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (step1 _ _ H)...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold alerting_distance in H; case (Rle_dec 3 (trkrate (bank intruder)));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply step2...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (3 / 2) (trkrate (bank intruder))); intro...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply step2...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (Rle_dec (3 / 4) (trkrate (bank intruder))); intro; apply step2...", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/scratch/FunctorFromMonad.v", "name": "bind_law", "text": "Theorem bind_law : forall (f : A -> B) (g : B -> C),\n    proper f -> proper g ->\n    mleq (pfun_ext rC pA)\n         (fapply (fapply (pure (@compose A B C)) (pure f)) (pure g))\n         (pure (compose f g)).\n  Proof.\n    unfold fapply, pure, compose; simpl; intros.\n    propers. \n    (eapply ptransitive; [ | | | | eapply (@bind_associativity _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_associativity _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    eapply preflexive; eauto with typeclass_instances.\n  Qed.\n", "definition": " forall (f : A -> B) (g : B -> C),\n    proper f -> proper g ->\n    mleq (pfun_ext rC pA)\n         (fapply (fapply (pure (@compose A B C)) (pure f)) (pure g))\n         (pure (compose f g)).\n  ", "proof": "\n    unfold fapply, pure, compose; simpl; intros.\n    propers. \n    (eapply ptransitive; [ | | | | eapply (@bind_associativity _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_associativity _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    (eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.\n    eapply preflexive; eauto with typeclass_instances.\n  ", "def_ranges": [98, 0, 102, 30], "proof_ranges": [103, 0, 113, 6], "proof_steps": [{"text": "unfold fapply, pure, compose; simpl; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "propers.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(eapply ptransitive; [ | | | | eapply (@bind_associativity _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(eapply ptransitive; [ | | | | eapply (@bind_associativity _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(eapply ptransitive; [ | | | | eapply (@bind_of_return _ _ _ _ MonadLaws_mleq) | ]); eauto with typeclass_instances; propers.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply preflexive; eauto with typeclass_instances.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/PreFun.v", "name": "proper_fun", "text": "Polymorphic Theorem proper_fun : forall (f : T -> U),\n    (forall x y, equal x y -> equal (f x) (f y)) ->\n    proper f.\n  Proof.\n    intros. do 3 red. eauto.\n  Qed.\n", "definition": " forall (f : T -> U),\n    (forall x y, equal x y -> equal (f x) (f y)) ->\n    proper f.\n  ", "proof": "\n    intros. do 3 red. eauto.\n  ", "def_ranges": [51, 0, 53, 13], "proof_ranges": [54, 0, 56, 6], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "do 3 red.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eauto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/PreFun.v", "name": "equal_fun", "text": "Polymorphic Theorem equal_fun : forall (f g : T -> U),\n    (forall x y, equal x y -> equal (f x) (g y)) ->\n    equal f g.\n  Proof. intros. do 3 red. apply H. Qed.\n", "definition": " forall (f g : T -> U),\n    (forall x y, equal x y -> equal (f x) (g y)) ->\n    equal f g.\n  ", "proof": " intros. do 3 red. apply H. ", "def_ranges": [58, 0, 60, 14], "proof_ranges": [61, 0, 61, 40], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "do 3 red.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/PreFun.v", "name": "equal_app", "text": "Polymorphic Theorem equal_app : forall (f g : T -> U) (x y : T),\n    equal f g -> equal x y ->\n    equal (f x) (g y).\n  Proof.\n    clear. intros. do 3 red in H. auto.\n  Qed.\n", "definition": " forall (f g : T -> U) (x y : T),\n    equal f g -> equal x y ->\n    equal (f x) (g y).\n  ", "proof": "\n    clear. intros. do 3 red in H. auto.\n  ", "def_ranges": [63, 0, 65, 22], "proof_ranges": [66, 0, 68, 6], "proof_steps": [{"text": "clear.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "do 3 red in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Tuple.v", "name": "get_put_eq", "text": "Theorem get_put_eq : forall {T n} (v : vector T n) (f : fin n) val,\n  get f (put f val v) = val.\nProof.\n  induction n.\n  { inversion f. }\n  { remember (S n). destruct f.\n    inversion Heqn0; subst; intros; reflexivity.\n    inversion Heqn0; subst; simpl; auto. }\nQed.\n", "definition": " forall {T n} (v : vector T n) (f : fin n) val,\n  get f (put f val v) = val.\n", "proof": "\n  induction n.\n  { inversion f. }\n  { remember (S n). destruct f.\n    inversion Heqn0; subst; intros; reflexivity.\n    inversion Heqn0; subst; simpl; auto. }\n", "def_ranges": [24, 0, 25, 28], "proof_ranges": [26, 0, 32, 4], "proof_steps": [{"text": "induction n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "remember (S n).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0; subst; intros; reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0; subst; simpl; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Tuple.v", "name": "get_put_neq", "text": "Theorem get_put_neq : forall {T n} (v : vector T n) (f f' : fin n) val,\n  f <> f' ->\n  get f (put f' val v) = get f v.\nProof.\n  induction n.\n  { inversion f. }\n  { remember (S n); destruct f.\n    { inversion Heqn0; clear Heqn0; subst; intros.\n      destruct (fin_case f'); try congruence.\n      destruct H0; subst. auto. }\n    { inversion Heqn0; clear Heqn0; subst; intros.\n      destruct (fin_case f').\n      subst; auto.\n      destruct H0; subst. simpl.\n      eapply IHn. congruence. } }\nQed.\n", "definition": " forall {T n} (v : vector T n) (f f' : fin n) val,\n  f <> f' ->\n  get f (put f' val v) = get f v.\n", "proof": "\n  induction n.\n  { inversion f. }\n  { remember (S n); destruct f.\n    { inversion Heqn0; clear Heqn0; subst; intros.\n      destruct (fin_case f'); try congruence.\n      destruct H0; subst. auto. }\n    { inversion Heqn0; clear Heqn0; subst; intros.\n      destruct (fin_case f').\n      subst; auto.\n      destruct H0; subst. simpl.\n      eapply IHn. congruence. } }\n", "def_ranges": [34, 0, 36, 33], "proof_ranges": [37, 0, 49, 4], "proof_steps": [{"text": "induction n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "remember (S n); destruct f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0; clear Heqn0; subst; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (fin_case f'); try congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H0; subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0; clear Heqn0; subst; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (fin_case f').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "subst; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H0; subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHn.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/SumN.v", "name": "Outof_Into", "text": "Theorem Outof_Into : forall ts T p pf v,\n    @OutOf ts T p pf (@Into ts T p pf v) = Some v.\nProof using.\n  unfold OutOf, Into.\n  intros.\n  repeat rewrite (eq_Arr_eq pf).\n  repeat rewrite (eq_Const_eq pf).\n  repeat rewrite (eq_Const_eq (eq_sym pf)).\n  unfold asNth. simpl.\n  rewrite asNth'_get_lookup.\n  { generalize dependent (pmap_lookup' ts p).\n    intros. subst. reflexivity. }\nQed.\n", "definition": " forall ts T p pf v,\n    @OutOf ts T p pf (@Into ts T p pf v) = Some v.", "proof": "\nProof using.\n  unfold OutOf, Into.\n  intros.\n  repeat rewrite (eq_Arr_eq pf).\n  repeat rewrite (eq_Const_eq pf).\n  repeat rewrite (eq_Const_eq (eq_sym pf)).\n  unfold asNth. simpl.\n  rewrite asNth'_get_lookup.\n  { generalize dependent (pmap_lookup' ts p).\n    intros. subst. reflexivity. }\n", "def_ranges": [75, 0, 76, 50], "proof_ranges": [77, 0, 87, 4], "proof_steps": [{"text": "Proof using.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold OutOf, Into.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite (eq_Arr_eq pf).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite (eq_Const_eq pf).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite (eq_Const_eq (eq_sym pf)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold asNth.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite asNth'_get_lookup.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize dependent (pmap_lookup' ts p).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/SumN.v", "name": "asNth_eq", "text": "Theorem asNth_eq\n: forall ts p oe v,\n    @asNth ts p oe = Some v ->\n    oe = {| index := p ; value := v |}.\nProof.\n  unfold asNth.\n  destruct oe; simpl.\n  revert value0. revert index0. revert ts.\n  induction p; destruct index0; simpl; intros;\n  solve [ congruence | eapply IHp in H; inversion H; clear H IHp; subst; auto ].\nQed.\n", "definition": " forall ts p oe v,\n    @asNth ts p oe = Some v ->\n    oe = {| index := p ; value := v |}.\n", "proof": "\n  unfold asNth.\n  destruct oe; simpl.\n  revert value0. revert index0. revert ts.\n  induction p; destruct index0; simpl; intros;\n  solve [ congruence | eapply IHp in H; inversion H; clear H IHp; subst; auto ].\n", "def_ranges": [89, 0, 92, 39], "proof_ranges": [93, 0, 99, 4], "proof_steps": [{"text": "unfold asNth.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct oe; simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "revert value0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "revert index0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "revert ts.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction p; destruct index0; simpl; intros;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "solve [ congruence | eapply IHp in H; inversion H; clear H IHp; subst; auto ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/String.v", "name": "string_dec_sound", "text": "Theorem string_dec_sound : forall l r,\n  string_dec l r = true <-> l = r.\nProof.\n  induction l; destruct r; simpl; split; try solve [ intuition ; congruence ];\n  consider (ascii_dec a a0); intros; subst. f_equal. eapply IHl; auto.\n  apply IHl. congruence.\n  inversion H. congruence.\nQed.\n", "definition": " forall l r,\n  string_dec l r = true <-> l = r.\n", "proof": "\n  induction l; destruct r; simpl; split; try solve [ intuition ; congruence ];\n  consider (ascii_dec a a0); intros; subst. f_equal. eapply IHl; auto.\n  apply IHl. congruence.\n  inversion H. congruence.\n", "def_ranges": [45, 0, 46, 34], "proof_ranges": [47, 0, 52, 4], "proof_steps": [{"text": "induction l; destruct r; simpl; split; try solve [ intuition ; congruence ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (ascii_dec a a0); intros; subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "f_equal.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHl; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IHl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/String.v", "name": "wf_R_string_len", "text": "Theorem wf_R_string_len : well_founded R_string_len.\n  Proof.\n    constructor. intros.\n    refine (@Fix _ _ wf_R_lt (fun n : nat => forall ls : string, n = length ls -> Acc R_string_len ls)\n      (fun x rec ls pfls => Acc_intro _ _)\n      _ _ refl_equal).\n    refine (\n      match ls as ls return x = length ls -> forall z : string, R_string_len z ls -> Acc R_string_len z with\n        | EmptyString => fun (pfls : x = 0) z pf => _\n        | String l ls => fun pfls z pf =>\n          rec _ (match pf in R_string_len xs ys return x = length ys -> R_nat_lt (length xs) x with\n                   | R_s_len n m pf' => fun pf_eq => match eq_sym pf_eq in _ = x return R_nat_lt (length n) x with\n                                                     | refl_equal => R_lt pf'\n                                                   end\n                 end pfls) _ eq_refl\n      end pfls).\n    clear - pf; abstract (inversion pf; subst; simpl in *; inversion H).\n  Defined.\n", "definition": " well_founded R_string_len.\n  ", "proof": "\n    constructor. intros.\n    refine (@Fix _ _ wf_R_lt (fun n : nat => forall ls : string, n = length ls -> Acc R_string_len ls)\n      (fun x rec ls pfls => Acc_intro _ _)\n      _ _ refl_equal).\n    refine (\n      match ls as ls return x = length ls -> forall z : string, R_string_len z ls -> Acc R_string_len z with\n        | EmptyString => fun (pfls : x = 0) z pf => _\n        | String l ls => fun pfls z pf =>\n          rec _ (match pf in R_string_len xs ys return x = length ys -> R_nat_lt (length xs) x with\n                   | R_s_len n m pf' => fun pf_eq => match eq_sym pf_eq in _ = x return R_nat_lt (length n) x with\n                                                     | refl_equal => R_lt pf'\n                                                   end\n                 end pfls) _ eq_refl\n      end pfls).\n    clear - pf; abstract (inversion pf; subst; simpl in *; inversion H).\n  ", "def_ranges": [137, 0, 137, 54], "proof_ranges": [138, 0, 154, 10], "proof_steps": [{"text": "constructor.", "goal_before": ["well_founded R_string_len"], "goal_after": ["forall y : string, R_string_len y a -> Acc R_string_len y"], "proof_term_before": [], "proof_term_after": ["(fun a : string => Acc_intro a ?Goal)"]}, {"text": "intros.", "goal_before": ["forall y : string, R_string_len y a -> Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": ["(fun a : string => Acc_intro a ?Goal)"], "proof_term_after": ["(fun a : string =>\n Acc_intro a (fun (y : string) (H : R_string_len y a) => ?Goal))"]}, {"text": "refine (@Fix _ _ wf_R_lt (fun n : nat => forall ls : string, n = length ls -> Acc R_string_len ls)", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": ["(fun a : string =>\n Acc_intro a (fun (y : string) (H : R_string_len y a) => ?Goal))"], "proof_term_after": []}, {"text": "(fun x rec ls pfls => Acc_intro _ _)", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": [], "proof_term_after": ["(fun a : string =>\n Acc_intro a (fun (y : string) (H : R_string_len y a) => ?Goal))"]}, {"text": "_ _ refl_equal).", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": ["(fun a : string =>\n Acc_intro a (fun (y : string) (H : R_string_len y a) => ?Goal))"], "proof_term_after": []}, {"text": "refine (", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "match ls as ls return x = length ls -> forall z : string, R_string_len z ls -> Acc R_string_len z with", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "| EmptyString => fun (pfls : x = 0) z pf => _", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "| String l ls => fun pfls z pf =>", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "rec _ (match pf in R_string_len xs ys return x = length ys -> R_nat_lt (length xs) x with", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "| R_s_len n m pf' => fun pf_eq => match eq_sym pf_eq in _ = x return R_nat_lt (length n) x with", "goal_before": ["Acc R_string_len y"], "goal_after": ["Acc R_string_len y"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Vector.v", "name": "vector_eta", "text": "Theorem vector_eta : forall n (v : vector n),\n                         v = match n as n return vector n -> vector n with\n                               | 0 => fun _ => Vnil\n                               | S n => fun v => Vcons (vector_hd v) (vector_tl v)\n                             end v.\n  Proof.\n    destruct v; auto.\n  Qed.\n", "definition": " forall n (v : vector n),\n                         v = match n as n return vector n -> vector n with\n                               | 0 => fun _ => Vnil\n                               | S n => fun v => Vcons (vector_hd v) (vector_tl v)\n                             end v.\n  ", "proof": "\n    destruct v; auto.\n  ", "def_ranges": [31, 0, 35, 35], "proof_ranges": [36, 0, 38, 6], "proof_steps": [{"text": "destruct v; auto.", "goal_before": ["forall (n : nat) (v : vector n),\nv =\nmatch n as n0 return (vector n0 -> vector n0) with\n| 0 => fun _ : vector 0 => Vnil\n| S n0 => fun v0 : vector (S n0) => Vcons (vector_hd v0) (vector_tl v0)\nend v"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (n : nat) (v : vector n) =>\n match\n   v as v0 in (vector n0)\n   return\n     (v0 =\n      match n0 as n1 return (vector n1 -> vector n1) with\n      | 0 => fun _ : vector 0 => Vnil\n      | S n1 => fun v1 : vector (S n1) => Vcons (vector_hd v1) (vector_tl v1)\n      end v0)\n with\n | Vnil => eq_refl\n | @Vcons n0 t v0 =>\n     (fun (n1 : nat) (t0 : T) (v1 : vector n1) => eq_refl) n0 t v0\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n : nat) (v : vector n) =>\n match\n   v as v0 in (vector n0)\n   return\n     (v0 =\n      match n0 as n1 return (vector n1 -> vector n1) with\n      | 0 => fun _ : vector 0 => Vnil\n      | S n1 => fun v1 : vector (S n1) => Vcons (vector_hd v1) (vector_tl v1)\n      end v0)\n with\n | Vnil => eq_refl\n | @Vcons n0 t v0 =>\n     (fun (n1 : nat) (t0 : T) (v1 : vector n1) => eq_refl) n0 t v0\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Vector.v", "name": "get_put_eq", "text": "Theorem get_put_eq : forall {n} (v : vector n) (f : fin n) val,\n                         get f (put f val v) = val.\n  Proof.\n    induction n.\n    { inversion f. }\n    { remember (S n). destruct f.\n      inversion Heqn0; subst; intros; reflexivity.\n      inversion Heqn0; subst; simpl; auto. }\n  Qed.\n", "definition": " forall {n} (v : vector n) (f : fin n) val,\n                         get f (put f val v) = val.\n  ", "proof": "\n    induction n.\n    { inversion f. }\n    { remember (S n). destruct f.\n      inversion Heqn0; subst; intros; reflexivity.\n      inversion Heqn0; subst; simpl; auto. }\n  ", "def_ranges": [53, 0, 54, 51], "proof_ranges": [55, 0, 61, 6], "proof_steps": [{"text": "induction n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "remember (S n).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0; subst; intros; reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0; subst; simpl; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Vector.v", "name": "get_put_neq", "text": "Theorem get_put_neq : forall {n} (v : vector n) (f f' : fin n) val,\n                          f <> f' ->\n                          get f (put f' val v) = get f v.\n  Proof.\n    induction n.\n    { inversion f. }\n    { remember (S n); destruct f.\n      { inversion Heqn0; clear Heqn0; subst; intros.\n        destruct (fin_case f'); try congruence.\n        destruct H0; subst. auto. }\n      { inversion Heqn0; clear Heqn0; subst; intros.\n        destruct (fin_case f').\n        subst; auto.\n        destruct H0; subst. simpl.\n        eapply IHn. congruence. } }\n  Qed.\n", "definition": " forall {n} (v : vector n) (f f' : fin n) val,\n                          f <> f' ->\n                          get f (put f' val v) = get f v.\n  ", "proof": "\n    induction n.\n    { inversion f. }\n    { remember (S n); destruct f.\n      { inversion Heqn0; clear Heqn0; subst; intros.\n        destruct (fin_case f'); try congruence.\n        destruct H0; subst. auto. }\n      { inversion Heqn0; clear Heqn0; subst; intros.\n        destruct (fin_case f').\n        subst; auto.\n        destruct H0; subst. simpl.\n        eapply IHn. congruence. } }\n  ", "def_ranges": [63, 0, 65, 57], "proof_ranges": [66, 0, 78, 6], "proof_steps": [{"text": "induction n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "remember (S n); destruct f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0; clear Heqn0; subst; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (fin_case f'); try congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H0; subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0; clear Heqn0; subst; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (fin_case f').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "subst; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H0; subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHn.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Pair.v", "name": "wf_R_pair", "text": "Theorem wf_R_pair : well_founded R_pair.\n  Proof.\n    red. intro x.\n    destruct x. generalize dependent u.\n    apply (well_founded_ind wf_RT (fun t => forall u : U, Acc R_pair (t, u))) .\n    do 2 intro.\n\n    apply (well_founded_ind wf_RU (fun u => Acc R_pair (x,u))). intros.\n    constructor. destruct y.\n    remember (t0,u). remember (x,x0). inversion 1; subst;\n    inversion H4; inversion H3; clear H4 H3; subst; eauto.\n  Defined.\n", "definition": " well_founded R_pair.\n  ", "proof": "\n    red. intro x.\n    destruct x. generalize dependent u.\n    apply (well_founded_ind wf_RT (fun t => forall u : U, Acc R_pair (t, u))) .\n    do 2 intro.\n\n    apply (well_founded_ind wf_RU (fun u => Acc R_pair (x,u))). intros.\n    constructor. destruct y.\n    remember (t0,u). remember (x,x0). inversion 1; subst;\n    inversion H4; inversion H3; clear H4 H3; subst; eauto.\n  ", "def_ranges": [47, 0, 47, 42], "proof_ranges": [48, 0, 58, 10], "proof_steps": [{"text": "red.", "goal_before": ["well_founded R_pair"], "goal_after": ["forall a : T * U, Acc R_pair a"], "proof_term_before": [], "proof_term_after": ["(?Goal : well_founded R_pair)"]}, {"text": "intro x.", "goal_before": ["forall a : T * U, Acc R_pair a"], "goal_after": ["Acc R_pair x"], "proof_term_before": ["(?Goal : well_founded R_pair)"], "proof_term_after": ["((fun x : T * U => ?Goal) : well_founded R_pair)"]}, {"text": "destruct x.", "goal_before": ["Acc R_pair x"], "goal_after": ["Acc R_pair (t, u)"], "proof_term_before": ["((fun x : T * U => ?Goal) : well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) => ?Goal) a b)\n :\n well_founded R_pair)"]}, {"text": "generalize dependent u.", "goal_before": ["Acc R_pair (t, u)"], "goal_after": ["forall u : U, Acc R_pair (t, u)"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) => ?Goal) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) => ?Goal u) a b)\n :\n well_founded R_pair)"]}, {"text": "apply (well_founded_ind wf_RT (fun t => forall u : U, Acc R_pair (t, u))) .", "goal_before": ["forall u : U, Acc R_pair (t, u)"], "goal_after": ["forall x : T,\n(forall y : T, RT y x -> forall u : U, Acc R_pair (y, u)) ->\nforall u : U, Acc R_pair (x, u)"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) => ?Goal u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     ?Goal t u) a b)\n :\n well_founded R_pair)"]}, {"text": "do 2 intro.", "goal_before": ["forall x : T,\n(forall y : T, RT y x -> forall u : U, Acc R_pair (y, u)) ->\nforall u : U, Acc R_pair (x, u)"], "goal_after": ["forall u : U, Acc R_pair (x, u)"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     ?Goal t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      ?Goal@{x:=x0}) t u) a b)\n :\n well_founded R_pair)"]}, {"text": "apply (well_founded_ind wf_RU (fun u => Acc R_pair (x,u))).", "goal_before": ["forall u : U, Acc R_pair (x, u)"], "goal_after": ["forall x0 : U,\n(forall y : U, RU y x0 -> Acc R_pair (x, y)) -> Acc R_pair (x, x0)"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      ?Goal@{x:=x0}) t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        ?Goal@{x:=x0}) t u) a b)\n :\n well_founded R_pair)"]}, {"text": "intros.", "goal_before": ["forall x0 : U,\n(forall y : U, RU y x0 -> Acc R_pair (x, y)) -> Acc R_pair (x, x0)"], "goal_after": ["Acc R_pair (x, x0)"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        ?Goal@{x:=x0}) t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         ?Goal@{x:=x0; x0:=x1})) t u) a b)\n :\n well_founded R_pair)"]}, {"text": "constructor.", "goal_before": ["Acc R_pair (x, x0)"], "goal_after": ["forall y : T * U, R_pair y (x, x0) -> Acc R_pair y"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         ?Goal@{x:=x0; x0:=x1})) t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1) ?Goal@{x:=x0; x0:=x1})) t u) a b)\n :\n well_founded R_pair)"]}, {"text": "destruct y.", "goal_before": ["forall y : T * U, R_pair y (x, x0) -> Acc R_pair y"], "goal_after": ["R_pair (t0, u) (x, x0) -> Acc R_pair (t0, u)"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1) ?Goal@{x:=x0; x0:=x1})) t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1)\n           (fun y : T * U =>\n            let (a0, b0) as p return (R_pair p (x0, x1) -> Acc R_pair p) :=\n              y in\n            (fun (t0 : T) (u0 : U) => ?Goal@{x:=x0; x0:=x1; u:=u0}) a0 b0)))\n     t u) a b)\n :\n well_founded R_pair)"]}, {"text": "remember (t0,u).", "goal_before": ["R_pair (t0, u) (x, x0) -> Acc R_pair (t0, u)"], "goal_after": ["R_pair p (x, x0) -> Acc R_pair p"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1)\n           (fun y : T * U =>\n            let (a0, b0) as p return (R_pair p (x0, x1) -> Acc R_pair p) :=\n              y in\n            (fun (t0 : T) (u0 : U) => ?Goal@{x:=x0; x0:=x1; u:=u0}) a0 b0)))\n     t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1)\n           (fun y : T * U =>\n            let (a0, b0) as p return (R_pair p (x0, x1) -> Acc R_pair p) :=\n              y in\n            (fun (t0 : T) (u0 : U) =>\n             let p := (t0, u0) in\n             let Heqp : p = (t0, u0) := eq_refl in\n             ?Goal@{x:=x0; x0:=x1; u:=u0}) a0 b0))) t u) a b)\n :\n well_founded R_pair)"]}, {"text": "remember (x,x0).", "goal_before": ["R_pair p (x, x0) -> Acc R_pair p"], "goal_after": ["R_pair p p0 -> Acc R_pair p"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1)\n           (fun y : T * U =>\n            let (a0, b0) as p return (R_pair p (x0, x1) -> Acc R_pair p) :=\n              y in\n            (fun (t0 : T) (u0 : U) =>\n             let p := (t0, u0) in\n             let Heqp : p = (t0, u0) := eq_refl in\n             ?Goal@{x:=x0; x0:=x1; u:=u0}) a0 b0))) t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1)\n           (fun y : T * U =>\n            let (a0, b0) as p return (R_pair p (x0, x1) -> Acc R_pair p) :=\n              y in\n            (fun (t0 : T) (u0 : U) =>\n             let p := (t0, u0) in\n             let Heqp : p = (t0, u0) := eq_refl in\n             let p0 := (x0, x1) in\n             let Heqp0 : p0 = (x0, x1) := eq_refl in\n             ?Goal@{x:=x0; x0:=x1; u:=u0}) a0 b0))) t u) a b)\n :\n well_founded R_pair)"]}, {"text": "inversion H4; inversion H3; clear H4 H3; subst; eauto.", "goal_before": ["R_pair p p0 -> Acc R_pair p"], "goal_after": ["R_pair p p0 -> Acc R_pair p"], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1)\n           (fun y : T * U =>\n            let (a0, b0) as p return (R_pair p (x0, x1) -> Acc R_pair p) :=\n              y in\n            (fun (t0 : T) (u0 : U) =>\n             let p := (t0, u0) in\n             let Heqp : p = (t0, u0) := eq_refl in\n             let p0 := (x0, x1) in\n             let Heqp0 : p0 = (x0, x1) := eq_refl in\n             ?Goal@{x:=x0; x0:=x1; u:=u0}) a0 b0))) t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1)\n           (fun y : T * U =>\n            let (a0, b0) as p return (R_pair p (x0, x1) -> Acc R_pair p) :=\n              y in\n            (fun (t0 : T) (u0 : U) =>\n             let p := (t0, u0) in\n             let Heqp : p = (t0, u0) := eq_refl in\n             let p0 := (x0, x1) in\n             let Heqp0 : p0 = (x0, x1) := eq_refl in\n             ?Goal@{x:=x0; x0:=x1; u:=u0}) a0 b0))) t u) a b)\n :\n well_founded R_pair)"]}, {"text": "Qed.", "goal_before": ["R_pair p p0 -> Acc R_pair p"], "goal_after": [], "proof_term_before": ["((fun x : T * U =>\n  let (a, b) as p return (Acc R_pair p) := x in\n  (fun (t : T) (u : U) =>\n   well_founded_ind wf_RT (fun t0 : T => forall u0 : U, Acc R_pair (t0, u0))\n     (fun (x0 : T)\n        (H : forall y : T, RT y x0 -> forall u0 : U, Acc R_pair (y, u0)) =>\n      well_founded_ind wf_RU (fun u0 : U => Acc R_pair (x0, u0))\n        (fun (x1 : U) (H0 : forall y : U, RU y x1 -> Acc R_pair (x0, y)) =>\n         Acc_intro (x0, x1)\n           (fun y : T * U =>\n            let (a0, b0) as p return (R_pair p (x0, x1) -> Acc R_pair p) :=\n              y in\n            (fun (t0 : T) (u0 : U) =>\n             let p := (t0, u0) in\n             let Heqp : p = (t0, u0) := eq_refl in\n             let p0 := (x0, x1) in\n             let Heqp0 : p0 = (x0, x1) := eq_refl in\n             ?Goal@{x:=x0; x0:=x1; u:=u0}) a0 b0))) t u) a b)\n :\n well_founded R_pair)"], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/ListNth.v", "name": "nth_error_length_ge", "text": "Theorem nth_error_length_ge : forall T (ls : list T) n,\n    nth_error ls n = None -> length ls <= n.\n  Proof.\n    induction ls; destruct n; simpl in *; auto; simpl in *.\n    + intro. apply Le.le_0_n.\n    + inversion 1.\n    + intros. eapply Le.le_n_S. auto.\n  Qed.\n", "definition": " forall T (ls : list T) n,\n    nth_error ls n = None -> length ls <= n.\n  ", "proof": "\n    induction ls; destruct n; simpl in *; auto; simpl in *.\n    + intro. apply Le.le_0_n.\n    + inversion 1.\n    + intros. eapply Le.le_n_S. auto.\n  ", "def_ranges": [58, 0, 59, 44], "proof_ranges": [60, 0, 65, 6], "proof_steps": [{"text": "induction ls; destruct n; simpl in *; auto; simpl in *.", "goal_before": ["forall (T0 : Type) (ls : list T0) (n : nat),\nnth_error ls n = None -> length ls <= n"], "goal_after": ["None = None -> 0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "proof_term_before": [], "proof_term_after": ["(fun (T0 : Type) (ls : list T0) =>\n list_ind\n   (fun ls0 : list T0 =>\n    forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n   (fun n : nat =>\n    match n as n0 return (nth_error nil n0 = None -> length nil <= n0) with\n    | 0 =>\n        (fun _ : None = None => le_n 0)\n        :\n        nth_error nil 0 = None -> length nil <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal@{n:=n1} : None = None -> 0 <= S n1)\n         :\n         nth_error nil (S n1) = None -> length nil <= S n1) n0\n    end)\n   (fun (a : T0) (ls0 : list T0)\n      (IHls : forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n      (n : nat) =>\n    match\n      n as n0\n      return (nth_error (a :: ls0) n0 = None -> length (a :: ls0) <= n0)\n    with\n    | 0 =>\n        (?Goal0@{ls:=ls0} : Some a = None -> S (length ls0) <= 0)\n        :\n        nth_error (a :: ls0) 0 = None -> length (a :: ls0) <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal1@{ls:=ls0; n:=n1}\n          :\n          nth_error ls0 n1 = None -> S (length ls0) <= S n1)\n         :\n         nth_error (a :: ls0) (S n1) = None -> length (a :: ls0) <= S n1) n0\n    end) ls)"]}, {"text": "intro.", "goal_before": ["None = None -> 0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "goal_after": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "proof_term_before": ["(fun (T0 : Type) (ls : list T0) =>\n list_ind\n   (fun ls0 : list T0 =>\n    forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n   (fun n : nat =>\n    match n as n0 return (nth_error nil n0 = None -> length nil <= n0) with\n    | 0 =>\n        (fun _ : None = None => le_n 0)\n        :\n        nth_error nil 0 = None -> length nil <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal@{n:=n1} : None = None -> 0 <= S n1)\n         :\n         nth_error nil (S n1) = None -> length nil <= S n1) n0\n    end)\n   (fun (a : T0) (ls0 : list T0)\n      (IHls : forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n      (n : nat) =>\n    match\n      n as n0\n      return (nth_error (a :: ls0) n0 = None -> length (a :: ls0) <= n0)\n    with\n    | 0 =>\n        (?Goal0@{ls:=ls0} : Some a = None -> S (length ls0) <= 0)\n        :\n        nth_error (a :: ls0) 0 = None -> length (a :: ls0) <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal1@{ls:=ls0; n:=n1}\n          :\n          nth_error ls0 n1 = None -> S (length ls0) <= S n1)\n         :\n         nth_error (a :: ls0) (S n1) = None -> length (a :: ls0) <= S n1) n0\n    end) ls)"], "proof_term_after": ["(fun (T0 : Type) (ls : list T0) =>\n list_ind\n   (fun ls0 : list T0 =>\n    forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n   (fun n : nat =>\n    match n as n0 return (nth_error nil n0 = None -> length nil <= n0) with\n    | 0 =>\n        (fun _ : None = None => le_n 0)\n        :\n        nth_error nil 0 = None -> length nil <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         ((fun H : None = None => ?Goal1@{n:=n1}) : None = None -> 0 <= S n1)\n         :\n         nth_error nil (S n1) = None -> length nil <= S n1) n0\n    end)\n   (fun (a : T0) (ls0 : list T0)\n      (IHls : forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n      (n : nat) =>\n    match\n      n as n0\n      return (nth_error (a :: ls0) n0 = None -> length (a :: ls0) <= n0)\n    with\n    | 0 =>\n        (?Goal@{ls:=ls0} : Some a = None -> S (length ls0) <= 0)\n        :\n        nth_error (a :: ls0) 0 = None -> length (a :: ls0) <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal0@{ls:=ls0; n:=n1}\n          :\n          nth_error ls0 n1 = None -> S (length ls0) <= S n1)\n         :\n         nth_error (a :: ls0) (S n1) = None -> length (a :: ls0) <= S n1) n0\n    end) ls)"]}, {"text": "apply Le.le_0_n.", "goal_before": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "goal_after": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "proof_term_before": ["(fun (T0 : Type) (ls : list T0) =>\n list_ind\n   (fun ls0 : list T0 =>\n    forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n   (fun n : nat =>\n    match n as n0 return (nth_error nil n0 = None -> length nil <= n0) with\n    | 0 =>\n        (fun _ : None = None => le_n 0)\n        :\n        nth_error nil 0 = None -> length nil <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         ((fun H : None = None => ?Goal1@{n:=n1}) : None = None -> 0 <= S n1)\n         :\n         nth_error nil (S n1) = None -> length nil <= S n1) n0\n    end)\n   (fun (a : T0) (ls0 : list T0)\n      (IHls : forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n      (n : nat) =>\n    match\n      n as n0\n      return (nth_error (a :: ls0) n0 = None -> length (a :: ls0) <= n0)\n    with\n    | 0 =>\n        (?Goal@{ls:=ls0} : Some a = None -> S (length ls0) <= 0)\n        :\n        nth_error (a :: ls0) 0 = None -> length (a :: ls0) <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal0@{ls:=ls0; n:=n1}\n          :\n          nth_error ls0 n1 = None -> S (length ls0) <= S n1)\n         :\n         nth_error (a :: ls0) (S n1) = None -> length (a :: ls0) <= S n1) n0\n    end) ls)"], "proof_term_after": []}, {"text": "inversion 1.", "goal_before": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "goal_after": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "goal_after": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply Le.le_n_S.", "goal_before": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "goal_after": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "goal_after": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "proof_term_before": [], "proof_term_after": ["(fun (T0 : Type) (ls : list T0) =>\n list_ind\n   (fun ls0 : list T0 =>\n    forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n   (fun n : nat =>\n    match n as n0 return (nth_error nil n0 = None -> length nil <= n0) with\n    | 0 =>\n        (fun _ : None = None => le_n 0)\n        :\n        nth_error nil 0 = None -> length nil <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         ((fun H : None = None => ?Goal1@{n:=n1}) : None = None -> 0 <= S n1)\n         :\n         nth_error nil (S n1) = None -> length nil <= S n1) n0\n    end)\n   (fun (a : T0) (ls0 : list T0)\n      (IHls : forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n      (n : nat) =>\n    match\n      n as n0\n      return (nth_error (a :: ls0) n0 = None -> length (a :: ls0) <= n0)\n    with\n    | 0 =>\n        (?Goal@{ls:=ls0} : Some a = None -> S (length ls0) <= 0)\n        :\n        nth_error (a :: ls0) 0 = None -> length (a :: ls0) <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal0@{ls:=ls0; n:=n1}\n          :\n          nth_error ls0 n1 = None -> S (length ls0) <= S n1)\n         :\n         nth_error (a :: ls0) (S n1) = None -> length (a :: ls0) <= S n1) n0\n    end) ls)"]}, {"text": "Qed.", "goal_before": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "goal_after": ["0 <= S n", "Some a = None -> S (length ls) <= 0", "nth_error ls n = None -> S (length ls) <= S n"], "proof_term_before": ["(fun (T0 : Type) (ls : list T0) =>\n list_ind\n   (fun ls0 : list T0 =>\n    forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n   (fun n : nat =>\n    match n as n0 return (nth_error nil n0 = None -> length nil <= n0) with\n    | 0 =>\n        (fun _ : None = None => le_n 0)\n        :\n        nth_error nil 0 = None -> length nil <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         ((fun H : None = None => ?Goal1@{n:=n1}) : None = None -> 0 <= S n1)\n         :\n         nth_error nil (S n1) = None -> length nil <= S n1) n0\n    end)\n   (fun (a : T0) (ls0 : list T0)\n      (IHls : forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n      (n : nat) =>\n    match\n      n as n0\n      return (nth_error (a :: ls0) n0 = None -> length (a :: ls0) <= n0)\n    with\n    | 0 =>\n        (?Goal@{ls:=ls0} : Some a = None -> S (length ls0) <= 0)\n        :\n        nth_error (a :: ls0) 0 = None -> length (a :: ls0) <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal0@{ls:=ls0; n:=n1}\n          :\n          nth_error ls0 n1 = None -> S (length ls0) <= S n1)\n         :\n         nth_error (a :: ls0) (S n1) = None -> length (a :: ls0) <= S n1) n0\n    end) ls)"], "proof_term_after": ["(fun (T0 : Type) (ls : list T0) =>\n list_ind\n   (fun ls0 : list T0 =>\n    forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n   (fun n : nat =>\n    match n as n0 return (nth_error nil n0 = None -> length nil <= n0) with\n    | 0 =>\n        (fun _ : None = None => le_n 0)\n        :\n        nth_error nil 0 = None -> length nil <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         ((fun H : None = None => ?Goal1@{n:=n1}) : None = None -> 0 <= S n1)\n         :\n         nth_error nil (S n1) = None -> length nil <= S n1) n0\n    end)\n   (fun (a : T0) (ls0 : list T0)\n      (IHls : forall n : nat, nth_error ls0 n = None -> length ls0 <= n)\n      (n : nat) =>\n    match\n      n as n0\n      return (nth_error (a :: ls0) n0 = None -> length (a :: ls0) <= n0)\n    with\n    | 0 =>\n        (?Goal@{ls:=ls0} : Some a = None -> S (length ls0) <= 0)\n        :\n        nth_error (a :: ls0) 0 = None -> length (a :: ls0) <= 0\n    | S n0 =>\n        (fun n1 : nat =>\n         (?Goal0@{ls:=ls0; n:=n1}\n          :\n          nth_error ls0 n1 = None -> S (length ls0) <= S n1)\n         :\n         nth_error (a :: ls0) (S n1) = None -> length (a :: ls0) <= S n1) n0\n    end) ls)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/ListNth.v", "name": "nth_error_map", "text": "Theorem nth_error_map : forall U (f : T -> U) ls n,\n    nth_error (map f ls) n = match nth_error ls n with\n                               | None => None\n                               | Some x => Some (f x)\n                             end.\n  Proof.\n    induction ls; destruct n; simpl; auto.\n  Qed.\n", "definition": " forall U (f : T -> U) ls n,\n    nth_error (map f ls) n = match nth_error ls n with\n                               | None => None\n                               | Some x => Some (f x)\n                             end.\n  ", "proof": "\n    induction ls; destruct n; simpl; auto.\n  ", "def_ranges": [78, 0, 82, 33], "proof_ranges": [83, 0, 85, 6], "proof_steps": [{"text": "induction ls; destruct n; simpl; auto.", "goal_before": ["forall (U : Type) (f : T -> U) (ls : list T) (n : nat),\nnth_error (map f ls) n =\nmatch nth_error ls n with\n| Some x => Some (f x)\n| None => None\nend"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (f : T -> U) (ls : list T) =>\n list_ind\n   (fun ls0 : list T =>\n    forall n : nat,\n    nth_error (map f ls0) n =\n    match nth_error ls0 n with\n    | Some x => Some (f x)\n    | None => None\n    end)\n   (fun n : nat =>\n    match\n      n as n0\n      return\n        (nth_error (map f nil) n0 =\n         match nth_error nil n0 with\n         | Some x => Some (f x)\n         | None => None\n         end)\n    with\n    | 0 =>\n        eq_refl\n        :\n        nth_error (map f nil) 0 =\n        match nth_error nil 0 with\n        | Some x => Some (f x)\n        | None => None\n        end\n    | S n0 =>\n        (fun n1 : nat =>\n         eq_refl\n         :\n         nth_error (map f nil) (S n1) =\n         match nth_error nil (S n1) with\n         | Some x => Some (f x)\n         | None => None\n         end) n0\n    end)\n   (fun (a : T) (ls0 : list T)\n      (IHls : forall n : nat,\n              nth_error (map f ls0) n =\n              match nth_error ls0 n with\n              | Some x => Some (f x)\n              | None => None\n              end) (n : nat) =>\n    match\n      n as n0\n      return\n        (nth_error (map f (a :: ls0)) n0 =\n         match nth_error (a :: ls0) n0 with\n         | Some x => Some (f x)\n         | None => None\n         end)\n    with\n    | 0 =>\n        eq_refl\n        :\n        nth_error (map f (a :: ls0)) 0 =\n        match nth_error (a :: ls0) 0 with\n        | Some x => Some (f x)\n        | None => None\n        end\n    | S n0 =>\n        (fun n1 : nat =>\n         IHls n1\n         :\n         nth_error (map f (a :: ls0)) (S n1) =\n         match nth_error (a :: ls0) (S n1) with\n         | Some x => Some (f x)\n         | None => None\n         end) n0\n    end) ls)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (U : Type) (f : T -> U) (ls : list T) =>\n list_ind\n   (fun ls0 : list T =>\n    forall n : nat,\n    nth_error (map f ls0) n =\n    match nth_error ls0 n with\n    | Some x => Some (f x)\n    | None => None\n    end)\n   (fun n : nat =>\n    match\n      n as n0\n      return\n        (nth_error (map f nil) n0 =\n         match nth_error nil n0 with\n         | Some x => Some (f x)\n         | None => None\n         end)\n    with\n    | 0 =>\n        eq_refl\n        :\n        nth_error (map f nil) 0 =\n        match nth_error nil 0 with\n        | Some x => Some (f x)\n        | None => None\n        end\n    | S n0 =>\n        (fun n1 : nat =>\n         eq_refl\n         :\n         nth_error (map f nil) (S n1) =\n         match nth_error nil (S n1) with\n         | Some x => Some (f x)\n         | None => None\n         end) n0\n    end)\n   (fun (a : T) (ls0 : list T)\n      (IHls : forall n : nat,\n              nth_error (map f ls0) n =\n              match nth_error ls0 n with\n              | Some x => Some (f x)\n              | None => None\n              end) (n : nat) =>\n    match\n      n as n0\n      return\n        (nth_error (map f (a :: ls0)) n0 =\n         match nth_error (a :: ls0) n0 with\n         | Some x => Some (f x)\n         | None => None\n         end)\n    with\n    | 0 =>\n        eq_refl\n        :\n        nth_error (map f (a :: ls0)) 0 =\n        match nth_error (a :: ls0) 0 with\n        | Some x => Some (f x)\n        | None => None\n        end\n    | S n0 =>\n        (fun n1 : nat =>\n         IHls n1\n         :\n         nth_error (map f (a :: ls0)) (S n1) =\n         match nth_error (a :: ls0) (S n1) with\n         | Some x => Some (f x)\n         | None => None\n         end) n0\n    end) ls)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Char.v", "name": "ascii_dec_sound", "text": "Theorem ascii_dec_sound : forall l r,\n  ascii_dec l r = true <-> l = r.\nProof.\n  unfold ascii_dec. intros.\n  destruct l; destruct r.\n  repeat match goal with\n           | [ |- (if ?X then _ else _) = true <-> _ ] =>\n             consider X; intros; subst\n         end; split; congruence.\nQed.\n", "definition": " forall l r,\n  ascii_dec l r = true <-> l = r.\n", "proof": "\n  unfold ascii_dec. intros.\n  destruct l; destruct r.\n  repeat match goal with\n           | [ |- (if ?X then _ else _) = true <-> _ ] =>\n             consider X; intros; subst\n         end; split; congruence.\n", "def_ranges": [30, 0, 31, 33], "proof_ranges": [32, 0, 39, 4], "proof_steps": [{"text": "unfold ascii_dec.", "goal_before": ["forall l r : ascii, ascii_dec l r = true <-> l = r"], "goal_after": ["forall l r : ascii,\nmatch l with\n| Ascii l1 l2 l3 l4 l5 l6 l7 l8 =>\n    match r with\n    | Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>\n        if Bool.eqb l1 r1\n        then\n         if Bool.eqb l2 r2\n         then\n          if Bool.eqb l3 r3\n          then\n           if Bool.eqb l4 r4\n           then\n            if Bool.eqb l5 r5\n            then\n             if Bool.eqb l6 r6\n             then\n              if Bool.eqb l7 r7\n              then if Bool.eqb l8 r8 then true else false\n              else false\n             else false\n            else false\n           else false\n          else false\n         else false\n        else false\n    end\nend = true <-> l = r"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall l r : ascii, ascii_dec l r = true <-> l = r)"]}, {"text": "intros.", "goal_before": ["forall l r : ascii,\nmatch l with\n| Ascii l1 l2 l3 l4 l5 l6 l7 l8 =>\n    match r with\n    | Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>\n        if Bool.eqb l1 r1\n        then\n         if Bool.eqb l2 r2\n         then\n          if Bool.eqb l3 r3\n          then\n           if Bool.eqb l4 r4\n           then\n            if Bool.eqb l5 r5\n            then\n             if Bool.eqb l6 r6\n             then\n              if Bool.eqb l7 r7\n              then if Bool.eqb l8 r8 then true else false\n              else false\n             else false\n            else false\n           else false\n          else false\n         else false\n        else false\n    end\nend = true <-> l = r"], "goal_after": ["match l with\n| Ascii l1 l2 l3 l4 l5 l6 l7 l8 =>\n    match r with\n    | Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>\n        if Bool.eqb l1 r1\n        then\n         if Bool.eqb l2 r2\n         then\n          if Bool.eqb l3 r3\n          then\n           if Bool.eqb l4 r4\n           then\n            if Bool.eqb l5 r5\n            then\n             if Bool.eqb l6 r6\n             then\n              if Bool.eqb l7 r7\n              then if Bool.eqb l8 r8 then true else false\n              else false\n             else false\n            else false\n           else false\n          else false\n         else false\n        else false\n    end\nend = true <-> l = r"], "proof_term_before": ["(?Goal : forall l r : ascii, ascii_dec l r = true <-> l = r)"], "proof_term_after": ["((fun l r : ascii => ?Goal)\n :\n forall l r : ascii, ascii_dec l r = true <-> l = r)"]}, {"text": "destruct l; destruct r.", "goal_before": ["match l with\n| Ascii l1 l2 l3 l4 l5 l6 l7 l8 =>\n    match r with\n    | Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>\n        if Bool.eqb l1 r1\n        then\n         if Bool.eqb l2 r2\n         then\n          if Bool.eqb l3 r3\n          then\n           if Bool.eqb l4 r4\n           then\n            if Bool.eqb l5 r5\n            then\n             if Bool.eqb l6 r6\n             then\n              if Bool.eqb l7 r7\n              then if Bool.eqb l8 r8 then true else false\n              else false\n             else false\n            else false\n           else false\n          else false\n         else false\n        else false\n    end\nend = true <-> l = r"], "goal_after": ["(if Bool.eqb b b7\n then\n  if Bool.eqb b0 b8\n  then\n   if Bool.eqb b1 b9\n   then\n    if Bool.eqb b2 b10\n    then\n     if Bool.eqb b3 b11\n     then\n      if Bool.eqb b4 b12\n      then\n       if Bool.eqb b5 b13\n       then if Bool.eqb b6 b14 then true else false\n       else false\n      else false\n     else false\n    else false\n   else false\n  else false\n else false) = true <->\nAscii b b0 b1 b2 b3 b4 b5 b6 = Ascii b7 b8 b9 b10 b11 b12 b13 b14"], "proof_term_before": ["((fun l r : ascii => ?Goal)\n :\n forall l r : ascii, ascii_dec l r = true <-> l = r)"], "proof_term_after": ["((fun l r : ascii =>\n  match\n    l as a\n    return\n      (match a with\n       | Ascii l1 l2 l3 l4 l5 l6 l7 l8 =>\n           match r with\n           | Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>\n               if Bool.eqb l1 r1\n               then\n                if Bool.eqb l2 r2\n                then\n                 if Bool.eqb l3 r3\n                 then\n                  if Bool.eqb l4 r4\n                  then\n                   if Bool.eqb l5 r5\n                   then\n                    if Bool.eqb l6 r6\n                    then\n                     if Bool.eqb l7 r7\n                     then if Bool.eqb l8 r8 then true else false\n                     else false\n                    else false\n                   else false\n                  else false\n                 else false\n                else false\n               else false\n           end\n       end = true <-> a = r)\n  with\n  | Ascii b b0 b1 b2 b3 b4 b5 b6 =>\n      (fun b7 b8 b9 b10 b11 b12 b13 b14 : bool =>\n       match\n         r as a\n         return\n           (match a with\n            | Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>\n                if Bool.eqb b7 r1\n                then\n                 if Bool.eqb b8 r2\n                 then\n                  if Bool.eqb b9 r3\n                  then\n                   if Bool.eqb b10 r4\n                   then\n                    if Bool.eqb b11 r5\n                    then\n                     if Bool.eqb b12 r6\n                     then\n                      if Bool.eqb b13 r7\n                      then if Bool.eqb b14 r8 then true else false\n                      else false\n                     else false\n                    else false\n                   else false\n                  else false\n                 else false\n                else false\n            end = true <-> Ascii b7 b8 b9 b10 b11 b12 b13 b14 = a)\n       with\n       | Ascii b15 b16 b17 b18 b19 b20 b21 b22 =>\n           (fun b23 b24 b25 b26 b27 b28 b29 b30 : bool =>\n            ?Goal@{b:=b7; b0:=b8; b1:=b9; b2:=b10; b3:=b11; b4:=b12; b5:=b13;\n                   b6:=b14; b7:=b23; b8:=b24; b9:=b25; b10:=b26; b11:=b27;\n                   b12:=b28; b13:=b29; b14:=b30}) b15 b16 b17 b18 b19 b20 b21\n             b22\n       end) b b0 b1 b2 b3 b4 b5 b6\n  end)\n :\n forall l r : ascii, ascii_dec l r = true <-> l = r)"]}, {"text": "repeat match goal with", "goal_before": ["(if Bool.eqb b b7\n then\n  if Bool.eqb b0 b8\n  then\n   if Bool.eqb b1 b9\n   then\n    if Bool.eqb b2 b10\n    then\n     if Bool.eqb b3 b11\n     then\n      if Bool.eqb b4 b12\n      then\n       if Bool.eqb b5 b13\n       then if Bool.eqb b6 b14 then true else false\n       else false\n      else false\n     else false\n    else false\n   else false\n  else false\n else false) = true <->\nAscii b b0 b1 b2 b3 b4 b5 b6 = Ascii b7 b8 b9 b10 b11 b12 b13 b14"], "goal_after": ["(if Bool.eqb b b7\n then\n  if Bool.eqb b0 b8\n  then\n   if Bool.eqb b1 b9\n   then\n    if Bool.eqb b2 b10\n    then\n     if Bool.eqb b3 b11\n     then\n      if Bool.eqb b4 b12\n      then\n       if Bool.eqb b5 b13\n       then if Bool.eqb b6 b14 then true else false\n       else false\n      else false\n     else false\n    else false\n   else false\n  else false\n else false) = true <->\nAscii b b0 b1 b2 b3 b4 b5 b6 = Ascii b7 b8 b9 b10 b11 b12 b13 b14"], "proof_term_before": ["((fun l r : ascii =>\n  match\n    l as a\n    return\n      (match a with\n       | Ascii l1 l2 l3 l4 l5 l6 l7 l8 =>\n           match r with\n           | Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>\n               if Bool.eqb l1 r1\n               then\n                if Bool.eqb l2 r2\n                then\n                 if Bool.eqb l3 r3\n                 then\n                  if Bool.eqb l4 r4\n                  then\n                   if Bool.eqb l5 r5\n                   then\n                    if Bool.eqb l6 r6\n                    then\n                     if Bool.eqb l7 r7\n                     then if Bool.eqb l8 r8 then true else false\n                     else false\n                    else false\n                   else false\n                  else false\n                 else false\n                else false\n               else false\n           end\n       end = true <-> a = r)\n  with\n  | Ascii b b0 b1 b2 b3 b4 b5 b6 =>\n      (fun b7 b8 b9 b10 b11 b12 b13 b14 : bool =>\n       match\n         r as a\n         return\n           (match a with\n            | Ascii r1 r2 r3 r4 r5 r6 r7 r8 =>\n                if Bool.eqb b7 r1\n                then\n                 if Bool.eqb b8 r2\n                 then\n                  if Bool.eqb b9 r3\n                  then\n                   if Bool.eqb b10 r4\n                   then\n                    if Bool.eqb b11 r5\n                    then\n                     if Bool.eqb b12 r6\n                     then\n                      if Bool.eqb b13 r7\n                      then if Bool.eqb b14 r8 then true else false\n                      else false\n                     else false\n                    else false\n                   else false\n                  else false\n                 else false\n                else false\n            end = true <-> Ascii b7 b8 b9 b10 b11 b12 b13 b14 = a)\n       with\n       | Ascii b15 b16 b17 b18 b19 b20 b21 b22 =>\n           (fun b23 b24 b25 b26 b27 b28 b29 b30 : bool =>\n            ?Goal@{b:=b7; b0:=b8; b1:=b9; b2:=b10; b3:=b11; b4:=b12; b5:=b13;\n                   b6:=b14; b7:=b23; b8:=b24; b9:=b25; b10:=b26; b11:=b27;\n                   b12:=b28; b13:=b29; b14:=b30}) b15 b16 b17 b18 b19 b20 b21\n             b22\n       end) b b0 b1 b2 b3 b4 b5 b6\n  end)\n :\n forall l r : ascii, ascii_dec l r = true <-> l = r)"], "proof_term_after": []}, {"text": "| [ |- (if ?X then _ else _) = true <-> _ ] =>", "goal_before": ["(if Bool.eqb b b7\n then\n  if Bool.eqb b0 b8\n  then\n   if Bool.eqb b1 b9\n   then\n    if Bool.eqb b2 b10\n    then\n     if Bool.eqb b3 b11\n     then\n      if Bool.eqb b4 b12\n      then\n       if Bool.eqb b5 b13\n       then if Bool.eqb b6 b14 then true else false\n       else false\n      else false\n     else false\n    else false\n   else false\n  else false\n else false) = true <->\nAscii b b0 b1 b2 b3 b4 b5 b6 = Ascii b7 b8 b9 b10 b11 b12 b13 b14"], "goal_after": ["(if Bool.eqb b b7\n then\n  if Bool.eqb b0 b8\n  then\n   if Bool.eqb b1 b9\n   then\n    if Bool.eqb b2 b10\n    then\n     if Bool.eqb b3 b11\n     then\n      if Bool.eqb b4 b12\n      then\n       if Bool.eqb b5 b13\n       then if Bool.eqb b6 b14 then true else false\n       else false\n      else false\n     else false\n    else false\n   else false\n  else false\n else false) = true <->\nAscii b b0 b1 b2 b3 b4 b5 b6 = Ascii b7 b8 b9 b10 b11 b12 b13 b14"], "proof_term_before": [], "proof_term_after": []}, {"text": "consider X; intros; subst", "goal_before": ["(if Bool.eqb b b7\n then\n  if Bool.eqb b0 b8\n  then\n   if Bool.eqb b1 b9\n   then\n    if Bool.eqb b2 b10\n    then\n     if Bool.eqb b3 b11\n     then\n      if Bool.eqb b4 b12\n      then\n       if Bool.eqb b5 b13\n       then if Bool.eqb b6 b14 then true else false\n       else false\n      else false\n     else false\n    else false\n   else false\n  else false\n else false) = true <->\nAscii b b0 b1 b2 b3 b4 b5 b6 = Ascii b7 b8 b9 b10 b11 b12 b13 b14"], "goal_after": ["(if Bool.eqb b b7\n then\n  if Bool.eqb b0 b8\n  then\n   if Bool.eqb b1 b9\n   then\n    if Bool.eqb b2 b10\n    then\n     if Bool.eqb b3 b11\n     then\n      if Bool.eqb b4 b12\n      then\n       if Bool.eqb b5 b13\n       then if Bool.eqb b6 b14 then true else false\n       else false\n      else false\n     else false\n    else false\n   else false\n  else false\n else false) = true <->\nAscii b b0 b1 b2 b3 b4 b5 b6 = Ascii b7 b8 b9 b10 b11 b12 b13 b14"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Fin.v", "name": "fin_all_In", "text": "Theorem fin_all_In : forall {n} (f : fin n),\n  List.In f (fin_all n).\nProof.\n  induction n; intros.\n  inversion f.\n  remember (S n). destruct f.\n  simpl; firstorder.\n  inversion Heqn0. subst.\n  simpl. right. apply List.in_map. auto.\nQed.\n", "definition": " forall {n} (f : fin n),\n  List.In f (fin_all n).\n", "proof": "\n  induction n; intros.\n  inversion f.\n  remember (S n). destruct f.\n  simpl; firstorder.\n  inversion Heqn0. subst.\n  simpl. right. apply List.in_map. auto.\n", "def_ranges": [23, 0, 24, 24], "proof_ranges": [25, 0, 32, 4], "proof_steps": [{"text": "induction n; intros.", "goal_before": ["forall (n : nat) (f : fin n), List.In f (fin_all n)"], "goal_after": ["forall (n : nat) (f : fin n), List.In f (fin_all n)"], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion f.", "goal_before": ["List.In f (fin_all 0)", "List.In f (fin_all (S n))"], "goal_after": ["List.In f (fin_all 0)", "List.In f (fin_all (S n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "remember (S n).", "goal_before": ["List.In f (fin_all (S n))"], "goal_after": ["List.In f (fin_all (S n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct f.", "goal_before": ["List.In f (fin_all n0)"], "goal_after": ["List.In f (fin_all n0)"], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl; firstorder.", "goal_before": ["List.In F0 (fin_all (S n0))", "List.In (FS f) (fin_all (S n0))"], "goal_after": ["List.In F0 (fin_all (S n0))", "List.In (FS f) (fin_all (S n0))"], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion Heqn0.", "goal_before": ["List.In (FS f) (fin_all (S n0))"], "goal_after": ["List.In (FS f) (fin_all (S n0))"], "proof_term_before": [], "proof_term_after": []}, {"text": "subst.", "goal_before": ["List.In (FS f) (fin_all (S n0))"], "goal_after": ["List.In (FS f) (fin_all (S n0))"], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl.", "goal_before": ["List.In (FS f) (fin_all (S n))"], "goal_after": ["List.In (FS f) (fin_all (S n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "right.", "goal_before": ["F0 = FS f \\/ List.In (FS f) (List.map FS (fin_all n))"], "goal_after": ["F0 = FS f \\/ List.In (FS f) (List.map FS (fin_all n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply List.in_map.", "goal_before": ["List.In (FS f) (List.map FS (fin_all n))"], "goal_after": ["List.In (FS f) (List.map FS (fin_all n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": ["List.In (FS f) (List.map FS (fin_all n))"], "goal_after": ["List.In f (fin_all n)"], "proof_term_before": [], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall f : fin n0, List.In f (fin_all n0))\n   (fun f : fin 0 =>\n    let H : 0 = 0 -> List.In f (fin_all 0) :=\n      match f as _ in (fin n0) return (n0 = 0 -> List.In f (fin_all 0)) with\n      | @F0 n0 =>\n          (fun (n1 : nat) (H : S n1 = 0) =>\n           (fun H0 : S n1 = 0 =>\n            let H1 : False :=\n              eq_ind (S n1)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (List.In f (fin_all 0)) H1) H) n0\n      | @FS n0 x =>\n          (fun (n1 : nat) (H : fin n1) (H0 : S n1 = 0) =>\n           (fun H1 : S n1 = 0 =>\n            let H2 : False :=\n              eq_ind (S n1)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H1 in\n            False_ind (fin n1 -> List.In f (fin_all 0)) H2) H0 H) n0 x\n      end in\n    H eq_refl)\n   (fun (n0 : nat) (IHn : forall f : fin n0, List.In f (fin_all n0))\n      (f : fin (S n0)) =>\n    let n1 := S n0 in\n    let Heqn0 : n1 = S n0 := eq_refl in\n    match\n      f as f0 in (fin n2) return (n2 = S n0 -> List.In f0 (fin_all n2))\n    with\n    | @F0 n2 =>\n        (fun (n3 : nat) (_ : S n3 = S n0) =>\n         or_introl eq_refl : List.In F0 (fin_all (S n3))) n2\n    | @FS n2 f0 =>\n        (fun (n3 : nat) (f1 : fin n3) (Heqn1 : S n3 = S n0) =>\n         let H : S n0 = S n0 -> List.In (FS f1) (fin_all (S n3)) :=\n           match\n             Heqn1 in (_ = a)\n             return (a = S n0 -> List.In (FS f1) (fin_all (S n3)))\n           with\n           | eq_refl =>\n               fun H : S n3 = S n0 =>\n               (fun H0 : S n3 = S n0 =>\n                let H1 : n3 = n0 :=\n                  f_equal\n                    (fun e : nat => match e with\n                                    | 0 => n3\n                                    | S n4 => n4\n                                    end) H0 in\n                (fun H2 : n3 = n0 =>\n                 eq_ind_r\n                   (fun n4 : nat =>\n                    S n4 = S n0 ->\n                    forall f2 : fin n4, List.In (FS f2) (fin_all (S n4)))\n                   (fun (Heqn2 : S n0 = S n0) (f2 : fin n0) =>\n                    or_intror\n                      (List.in_map FS (fin_all n0) f2\n                         ?Goal@{n:=n0; f:=f2; Heqn0:=Heqn2})\n                    :\n                    List.In (FS f2) (fin_all (S n0))) H2 Heqn1 f1) H1) H\n           end in\n         H eq_refl) n2 f0\n    end Heqn0) n)"]}, {"text": "Qed.", "goal_before": ["List.In f (fin_all n)"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall f : fin n0, List.In f (fin_all n0))\n   (fun f : fin 0 =>\n    let H : 0 = 0 -> List.In f (fin_all 0) :=\n      match f as _ in (fin n0) return (n0 = 0 -> List.In f (fin_all 0)) with\n      | @F0 n0 =>\n          (fun (n1 : nat) (H : S n1 = 0) =>\n           (fun H0 : S n1 = 0 =>\n            let H1 : False :=\n              eq_ind (S n1)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (List.In f (fin_all 0)) H1) H) n0\n      | @FS n0 x =>\n          (fun (n1 : nat) (H : fin n1) (H0 : S n1 = 0) =>\n           (fun H1 : S n1 = 0 =>\n            let H2 : False :=\n              eq_ind (S n1)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H1 in\n            False_ind (fin n1 -> List.In f (fin_all 0)) H2) H0 H) n0 x\n      end in\n    H eq_refl)\n   (fun (n0 : nat) (IHn : forall f : fin n0, List.In f (fin_all n0))\n      (f : fin (S n0)) =>\n    let n1 := S n0 in\n    let Heqn0 : n1 = S n0 := eq_refl in\n    match\n      f as f0 in (fin n2) return (n2 = S n0 -> List.In f0 (fin_all n2))\n    with\n    | @F0 n2 =>\n        (fun (n3 : nat) (_ : S n3 = S n0) =>\n         or_introl eq_refl : List.In F0 (fin_all (S n3))) n2\n    | @FS n2 f0 =>\n        (fun (n3 : nat) (f1 : fin n3) (Heqn1 : S n3 = S n0) =>\n         let H : S n0 = S n0 -> List.In (FS f1) (fin_all (S n3)) :=\n           match\n             Heqn1 in (_ = a)\n             return (a = S n0 -> List.In (FS f1) (fin_all (S n3)))\n           with\n           | eq_refl =>\n               fun H : S n3 = S n0 =>\n               (fun H0 : S n3 = S n0 =>\n                let H1 : n3 = n0 :=\n                  f_equal\n                    (fun e : nat => match e with\n                                    | 0 => n3\n                                    | S n4 => n4\n                                    end) H0 in\n                (fun H2 : n3 = n0 =>\n                 eq_ind_r\n                   (fun n4 : nat =>\n                    S n4 = S n0 ->\n                    forall f2 : fin n4, List.In (FS f2) (fin_all (S n4)))\n                   (fun (Heqn2 : S n0 = S n0) (f2 : fin n0) =>\n                    or_intror\n                      (List.in_map FS (fin_all n0) f2\n                         ?Goal@{n:=n0; f:=f2; Heqn0:=Heqn2})\n                    :\n                    List.In (FS f2) (fin_all (S n0))) H2 Heqn1 f1) H1) H\n           end in\n         H eq_refl) n2 f0\n    end Heqn0) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall f : fin n0, List.In f (fin_all n0))\n   (fun f : fin 0 =>\n    let H : 0 = 0 -> List.In f (fin_all 0) :=\n      match f as _ in (fin n0) return (n0 = 0 -> List.In f (fin_all 0)) with\n      | @F0 n0 =>\n          (fun (n1 : nat) (H : S n1 = 0) =>\n           (fun H0 : S n1 = 0 =>\n            let H1 : False :=\n              eq_ind (S n1)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H0 in\n            False_ind (List.In f (fin_all 0)) H1) H) n0\n      | @FS n0 x =>\n          (fun (n1 : nat) (H : fin n1) (H0 : S n1 = 0) =>\n           (fun H1 : S n1 = 0 =>\n            let H2 : False :=\n              eq_ind (S n1)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H1 in\n            False_ind (fin n1 -> List.In f (fin_all 0)) H2) H0 H) n0 x\n      end in\n    H eq_refl)\n   (fun (n0 : nat) (IHn : forall f : fin n0, List.In f (fin_all n0))\n      (f : fin (S n0)) =>\n    let n1 := S n0 in\n    let Heqn0 : n1 = S n0 := eq_refl in\n    match\n      f as f0 in (fin n2) return (n2 = S n0 -> List.In f0 (fin_all n2))\n    with\n    | @F0 n2 =>\n        (fun (n3 : nat) (_ : S n3 = S n0) =>\n         or_introl eq_refl : List.In F0 (fin_all (S n3))) n2\n    | @FS n2 f0 =>\n        (fun (n3 : nat) (f1 : fin n3) (Heqn1 : S n3 = S n0) =>\n         let H : S n0 = S n0 -> List.In (FS f1) (fin_all (S n3)) :=\n           match\n             Heqn1 in (_ = a)\n             return (a = S n0 -> List.In (FS f1) (fin_all (S n3)))\n           with\n           | eq_refl =>\n               fun H : S n3 = S n0 =>\n               (fun H0 : S n3 = S n0 =>\n                let H1 : n3 = n0 :=\n                  f_equal\n                    (fun e : nat => match e with\n                                    | 0 => n3\n                                    | S n4 => n4\n                                    end) H0 in\n                (fun H2 : n3 = n0 =>\n                 eq_ind_r\n                   (fun n4 : nat =>\n                    S n4 = S n0 ->\n                    forall f2 : fin n4, List.In (FS f2) (fin_all (S n4)))\n                   (fun (_ : S n0 = S n0) (f2 : fin n0) =>\n                    or_intror (List.in_map FS (fin_all n0) f2 (IHn f2))\n                    :\n                    List.In (FS f2) (fin_all (S n0))) H2 Heqn1 f1) H1) H\n           end in\n         H eq_refl) n2 f0\n    end Heqn0) n)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Fin.v", "name": "fin_case", "text": "Theorem fin_case : forall n (f : fin (S n)),\n  f = F0 \\/ exists f', f = FS f'.\nProof.\n  intros. generalize (fin_all_In f). intros.\n  destruct H; auto.\n  eapply List.in_map_iff in H. right. destruct H.\n  exists x. intuition.\nQed.\n", "definition": " forall n (f : fin (S n)),\n  f = F0 \\/ exists f', f = FS f'.\n", "proof": "\n  intros. generalize (fin_all_In f). intros.\n  destruct H; auto.\n  eapply List.in_map_iff in H. right. destruct H.\n  exists x. intuition.\n", "def_ranges": [34, 0, 35, 33], "proof_ranges": [36, 0, 41, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall (n : nat) (f : fin (S n)), f = F0 \\/ (exists f' : fin n, f = FS f')"], "goal_after": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "proof_term_before": [], "proof_term_after": ["(fun (n : nat) (f : fin (S n)) => ?Goal)"]}, {"text": "generalize (fin_all_In f).", "goal_before": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "goal_after": ["List.In f (fin_all (S n)) -> f = F0 \\/ (exists f' : fin n, f = FS f')"], "proof_term_before": ["(fun (n : nat) (f : fin (S n)) => ?Goal)"], "proof_term_after": ["(fun (n : nat) (f : fin (S n)) => ?Goal (fin_all_In f))"]}, {"text": "intros.", "goal_before": ["List.In f (fin_all (S n)) -> f = F0 \\/ (exists f' : fin n, f = FS f')"], "goal_after": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "proof_term_before": ["(fun (n : nat) (f : fin (S n)) => ?Goal (fin_all_In f))"], "proof_term_after": ["(fun (n : nat) (f : fin (S n)) =>\n (fun H : List.In f (fin_all (S n)) => ?Goal) (fin_all_In f))"]}, {"text": "destruct H; auto.", "goal_before": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "goal_after": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "proof_term_before": ["(fun (n : nat) (f : fin (S n)) =>\n (fun H : List.In f (fin_all (S n)) => ?Goal) (fin_all_In f))"], "proof_term_after": ["(fun (n : nat) (f : fin (S n)) =>\n (fun H : List.In f (fin_all (S n)) =>\n  match H with\n  | or_introl x => (fun H0 : F0 = f => or_introl (eq_sym H0)) x\n  | or_intror x =>\n      (fun H0 : List.In f (List.map FS (fin_all n)) => ?Goal@{H:=H0}) x\n  end) (fin_all_In f))"]}, {"text": "eapply List.in_map_iff in H.", "goal_before": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "goal_after": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "proof_term_before": ["(fun (n : nat) (f : fin (S n)) =>\n (fun H : List.In f (fin_all (S n)) =>\n  match H with\n  | or_introl x => (fun H0 : F0 = f => or_introl (eq_sym H0)) x\n  | or_intror x =>\n      (fun H0 : List.In f (List.map FS (fin_all n)) => ?Goal@{H:=H0}) x\n  end) (fin_all_In f))"], "proof_term_after": []}, {"text": "right.", "goal_before": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "goal_after": ["f = F0 \\/ (exists f' : fin n, f = FS f')"], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H.", "goal_before": ["exists f' : fin n, f = FS f'"], "goal_after": ["exists f' : fin n, f = FS f'"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x.", "goal_before": ["exists f' : fin n, f = FS f'"], "goal_after": ["exists f' : fin n, f = FS f'"], "proof_term_before": [], "proof_term_after": []}, {"text": "intuition.", "goal_before": ["f = FS x"], "goal_after": ["f = FS x"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": ["fin_case is defined"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/List.v", "name": "wf_R_list_len", "text": "Theorem wf_R_list_len T : well_founded (@R_list_len T).\n  Proof.\n    constructor. intros.\n    refine (@Fix _ _ Nat.wf_R_lt (fun n : nat => forall ls : list T, n = length ls -> Acc R_list_len ls)\n      (fun x rec ls pfls => Acc_intro _ _)\n      _ _ refl_equal).\n    refine (\n      match ls as ls return x = length ls -> forall z : list T, R_list_len z ls -> Acc R_list_len z with\n        | nil => fun (pfls : x = 0) z pf => _\n        | cons l ls => fun pfls z pf =>\n          rec _ (match pf in R_list_len xs ys return x = length ys -> Nat.R_nat_lt (length xs) x with\n                   | R_l_len n m pf' => fun pf_eq => match eq_sym pf_eq in _ = x return Nat.R_nat_lt (length n) x with\n                                                     | refl_equal => Nat.R_lt pf'\n                                                   end\n                 end pfls) _ eq_refl\n      end pfls).\n    clear - pf; abstract (inversion pf; subst; simpl in *; inversion H).\n  Defined.\n", "definition": " well_founded (@R_list_len T).\n  ", "proof": "\n    constructor. intros.\n    refine (@Fix _ _ Nat.wf_R_lt (fun n : nat => forall ls : list T, n = length ls -> Acc R_list_len ls)\n      (fun x rec ls pfls => Acc_intro _ _)\n      _ _ refl_equal).\n    refine (\n      match ls as ls return x = length ls -> forall z : list T, R_list_len z ls -> Acc R_list_len z with\n        | nil => fun (pfls : x = 0) z pf => _\n        | cons l ls => fun pfls z pf =>\n          rec _ (match pf in R_list_len xs ys return x = length ys -> Nat.R_nat_lt (length xs) x with\n                   | R_l_len n m pf' => fun pf_eq => match eq_sym pf_eq in _ = x return Nat.R_nat_lt (length n) x with\n                                                     | refl_equal => Nat.R_lt pf'\n                                                   end\n                 end pfls) _ eq_refl\n      end pfls).\n    clear - pf; abstract (inversion pf; subst; simpl in *; inversion H).\n  ", "def_ranges": [164, 0, 164, 57], "proof_ranges": [165, 0, 181, 10], "proof_steps": [{"text": "constructor.", "goal_before": ["well_founded R_list_len"], "goal_after": ["forall y : list T, R_list_len y a -> Acc R_list_len y"], "proof_term_before": [], "proof_term_after": ["(fun (T : Type) (a : list T) => Acc_intro a ?Goal)"]}, {"text": "intros.", "goal_before": ["forall y : list T, R_list_len y a -> Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": ["(fun (T : Type) (a : list T) => Acc_intro a ?Goal)"], "proof_term_after": ["(fun (T : Type) (a : list T) =>\n Acc_intro a (fun (y : list T) (H : R_list_len y a) => ?Goal))"]}, {"text": "refine (@Fix _ _ Nat.wf_R_lt (fun n : nat => forall ls : list T, n = length ls -> Acc R_list_len ls)", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": ["(fun (T : Type) (a : list T) =>\n Acc_intro a (fun (y : list T) (H : R_list_len y a) => ?Goal))"], "proof_term_after": []}, {"text": "(fun x rec ls pfls => Acc_intro _ _)", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "_ _ refl_equal).", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "refine (", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "match ls as ls return x = length ls -> forall z : list T, R_list_len z ls -> Acc R_list_len z with", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "| nil => fun (pfls : x = 0) z pf => _", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "| cons l ls => fun pfls z pf =>", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "rec _ (match pf in R_list_len xs ys return x = length ys -> Nat.R_nat_lt (length xs) x with", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "| R_l_len n m pf' => fun pf_eq => match eq_sym pf_eq in _ = x return Nat.R_nat_lt (length n) x with", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "| refl_equal => Nat.R_lt pf'", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}, {"text": "end", "goal_before": ["Acc R_list_len y"], "goal_after": ["Acc R_list_len y"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Nat.v", "name": "wf_R_S", "text": "Theorem wf_R_S : well_founded R_nat_S.\nProof.\n  red; induction a; constructor; intros.\n    inversion H.\n    inversion H; subst; auto.\nDefined.\n", "definition": " well_founded R_nat_S.\n", "proof": "\n  red; induction a; constructor; intros.\n    inversion H.\n    inversion H; subst; auto.\n", "def_ranges": [75, 0, 75, 38], "proof_ranges": [76, 0, 80, 8], "proof_steps": [{"text": "red; induction a; constructor; intros.", "goal_before": ["well_founded R_nat_S"], "goal_after": ["Acc R_nat_S y", "Acc R_nat_S y"], "proof_term_before": [], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_S a0)\n    (Acc_intro 0 (fun (y : nat) (H : R_nat_S y 0) => ?Goal))\n    (fun (a0 : nat) (IHa : Acc R_nat_S a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_S y (S a0)) => ?Goal0@{a:=a0})) a)\n :\n well_founded R_nat_S)"]}, {"text": "inversion H.", "goal_before": ["Acc R_nat_S y", "Acc R_nat_S y"], "goal_after": ["Acc R_nat_S y"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_S a0)\n    (Acc_intro 0 (fun (y : nat) (H : R_nat_S y 0) => ?Goal))\n    (fun (a0 : nat) (IHa : Acc R_nat_S a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_S y (S a0)) => ?Goal0@{a:=a0})) a)\n :\n well_founded R_nat_S)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_S a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_S y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_S y :=\n          match\n            H in (R_nat_S n n0) return (n = y -> n0 = 0 -> Acc R_nat_S y)\n          with\n          | R_S n =>\n              (fun (n0 : nat) (H0 : n0 = y) (H1 : S n0 = 0) =>\n               (fun H2 : n0 = y =>\n                let H3 : n0 = y := H2 in\n                eq_ind_r (fun n1 : nat => S n1 = 0 -> Acc R_nat_S y)\n                  (fun H4 : S y = 0 =>\n                   let H5 : False :=\n                     eq_ind (S y)\n                       (fun e : nat =>\n                        match e with\n                        | 0 => False\n                        | S _ => True\n                        end) I 0 H4 in\n                   False_ind (Acc R_nat_S y) H5) H3) H0 H1) n\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_S a0) =>\n     Acc_intro (S a0) (fun (y : nat) (H : R_nat_S y (S a0)) => ?Goal@{a:=a0}))\n    a)\n :\n well_founded R_nat_S)"]}, {"text": "inversion H; subst; auto.", "goal_before": ["Acc R_nat_S y"], "goal_after": [], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_S a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_S y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_S y :=\n          match\n            H in (R_nat_S n n0) return (n = y -> n0 = 0 -> Acc R_nat_S y)\n          with\n          | R_S n =>\n              (fun (n0 : nat) (H0 : n0 = y) (H1 : S n0 = 0) =>\n               (fun H2 : n0 = y =>\n                let H3 : n0 = y := H2 in\n                eq_ind_r (fun n1 : nat => S n1 = 0 -> Acc R_nat_S y)\n                  (fun H4 : S y = 0 =>\n                   let H5 : False :=\n                     eq_ind (S y)\n                       (fun e : nat =>\n                        match e with\n                        | 0 => False\n                        | S _ => True\n                        end) I 0 H4 in\n                   False_ind (Acc R_nat_S y) H5) H3) H0 H1) n\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_S a0) =>\n     Acc_intro (S a0) (fun (y : nat) (H : R_nat_S y (S a0)) => ?Goal@{a:=a0}))\n    a)\n :\n well_founded R_nat_S)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_S a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_S y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_S y :=\n          match\n            H in (R_nat_S n n0) return (n = y -> n0 = 0 -> Acc R_nat_S y)\n          with\n          | R_S n =>\n              (fun (n0 : nat) (H0 : n0 = y) (H1 : S n0 = 0) =>\n               (fun H2 : n0 = y =>\n                let H3 : n0 = y := H2 in\n                eq_ind_r (fun n1 : nat => S n1 = 0 -> Acc R_nat_S y)\n                  (fun H4 : S y = 0 =>\n                   let H5 : False :=\n                     eq_ind (S y)\n                       (fun e : nat =>\n                        match e with\n                        | 0 => False\n                        | S _ => True\n                        end) I 0 H4 in\n                   False_ind (Acc R_nat_S y) H5) H3) H0 H1) n\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_S a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_S y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_S y :=\n          match\n            H in (R_nat_S n n0) return (n = y -> n0 = S a0 -> Acc R_nat_S y)\n          with\n          | R_S n =>\n              (fun (n0 : nat) (H0 : n0 = y) (H1 : S n0 = S a0) =>\n               (fun H2 : n0 = y =>\n                let H3 : n0 = y := H2 in\n                eq_ind_r (fun n1 : nat => S n1 = S a0 -> Acc R_nat_S y)\n                  (fun H4 : S y = S a0 =>\n                   let H5 : y = a0 :=\n                     f_equal\n                       (fun e : nat => match e with\n                                       | 0 => y\n                                       | S n1 => n1\n                                       end) H4 in\n                   (fun H6 : y = a0 =>\n                    let H7 : y = a0 := H6 in\n                    eq_ind_r (fun n1 : nat => Acc R_nat_S n1)\n                      (eq_ind_r\n                         (fun y0 : nat => R_nat_S y0 (S a0) -> Acc R_nat_S a0)\n                         (fun _ : R_nat_S a0 (S a0) => IHa) H6 H) H7) H5) H3)\n                 H0 H1) n\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_S)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_S a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_S y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_S y :=\n          match\n            H in (R_nat_S n n0) return (n = y -> n0 = 0 -> Acc R_nat_S y)\n          with\n          | R_S n =>\n              (fun (n0 : nat) (H0 : n0 = y) (H1 : S n0 = 0) =>\n               (fun H2 : n0 = y =>\n                let H3 : n0 = y := H2 in\n                eq_ind_r (fun n1 : nat => S n1 = 0 -> Acc R_nat_S y)\n                  (fun H4 : S y = 0 =>\n                   let H5 : False :=\n                     eq_ind (S y)\n                       (fun e : nat =>\n                        match e with\n                        | 0 => False\n                        | S _ => True\n                        end) I 0 H4 in\n                   False_ind (Acc R_nat_S y) H5) H3) H0 H1) n\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_S a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_S y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_S y :=\n          match\n            H in (R_nat_S n n0) return (n = y -> n0 = S a0 -> Acc R_nat_S y)\n          with\n          | R_S n =>\n              (fun (n0 : nat) (H0 : n0 = y) (H1 : S n0 = S a0) =>\n               (fun H2 : n0 = y =>\n                let H3 : n0 = y := H2 in\n                eq_ind_r (fun n1 : nat => S n1 = S a0 -> Acc R_nat_S y)\n                  (fun H4 : S y = S a0 =>\n                   let H5 : y = a0 :=\n                     f_equal\n                       (fun e : nat => match e with\n                                       | 0 => y\n                                       | S n1 => n1\n                                       end) H4 in\n                   (fun H6 : y = a0 =>\n                    let H7 : y = a0 := H6 in\n                    eq_ind_r (fun n1 : nat => Acc R_nat_S n1)\n                      (eq_ind_r\n                         (fun y0 : nat => R_nat_S y0 (S a0) -> Acc R_nat_S a0)\n                         (fun _ : R_nat_S a0 (S a0) => IHa) H6 H) H7) H5) H3)\n                 H0 H1) n\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_S)"], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Nat.v", "name": "wf_R_lt", "text": "Theorem wf_R_lt : well_founded R_nat_lt.\nProof.\n  red; induction a; constructor; intros.\n  { inversion H. exfalso. subst. inversion H0. }\n  { inversion H; clear H; subst. inversion H0; clear H0; subst; auto.\n    inversion IHa. eapply H. constructor. eapply H1. }\nDefined.\n", "definition": " well_founded R_nat_lt.\n", "proof": "\n  red; induction a; constructor; intros.\n  { inversion H. exfalso. subst. inversion H0. }\n  { inversion H; clear H; subst. inversion H0; clear H0; subst; auto.\n    inversion IHa. eapply H. constructor. eapply H1. }\n", "def_ranges": [85, 0, 85, 40], "proof_ranges": [86, 0, 91, 8], "proof_steps": [{"text": "red; induction a; constructor; intros.", "goal_before": ["well_founded R_nat_lt"], "goal_after": ["Acc R_nat_lt y", "Acc R_nat_lt y"], "proof_term_before": [], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0 (fun (y : nat) (H : R_nat_lt y 0) => ?Goal))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal0@{a:=a0})) a)\n :\n well_founded R_nat_lt)"]}, {"text": "inversion H.", "goal_before": ["Acc R_nat_lt y", "Acc R_nat_lt y"], "goal_after": ["Acc R_nat_lt y", "Acc R_nat_lt y"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0 (fun (y : nat) (H : R_nat_lt y 0) => ?Goal))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal0@{a:=a0})) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      ?Goal0@{n:=n0; m:=m0; H0:=H7; H1:=H3; H2:=H5}) H6) H4)\n                 H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal@{a:=a0})) a)\n :\n well_founded R_nat_lt)"]}, {"text": "exfalso.", "goal_before": ["Acc R_nat_lt y", "Acc R_nat_lt y"], "goal_after": ["False", "Acc R_nat_lt y"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      ?Goal0@{n:=n0; m:=m0; H0:=H7; H1:=H3; H2:=H5}) H6) H4)\n                 H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal@{a:=a0})) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        ?Goal0@{n:=n0; m:=m0; H0:=H7; H1:=H3; H2:=H5}) H6) H4)\n                 H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal@{a:=a0})) a)\n :\n well_founded R_nat_lt)"]}, {"text": "subst.", "goal_before": ["False", "Acc R_nat_lt y"], "goal_after": ["False", "Acc R_nat_lt y"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        ?Goal0@{n:=n0; m:=m0; H0:=H7; H1:=H3; H2:=H5}) H6) H4)\n                 H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal@{a:=a0})) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y) ?Goal0@{H0:=H7}) H6) H4) H1\n                 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal@{a:=a0})) a)\n :\n well_founded R_nat_lt)"]}, {"text": "inversion H0.", "goal_before": ["False", "Acc R_nat_lt y"], "goal_after": ["Acc R_nat_lt y"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y) ?Goal0@{H0:=H7}) H6) H4) H1\n                 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal@{a:=a0})) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal@{a:=a0})) a)\n :\n well_founded R_nat_lt)"]}, {"text": "inversion H; clear H; subst.", "goal_before": ["Acc R_nat_lt y"], "goal_after": ["Acc R_nat_lt y"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) => ?Goal@{a:=a0})) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 => ?Goal@{a:=a0; H0:=H7}) H6) H4) H1\n                 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"]}, {"text": "inversion H0; clear H0; subst; auto.", "goal_before": ["Acc R_nat_lt y"], "goal_after": ["Acc R_nat_lt y"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 => ?Goal@{a:=a0; H0:=H7}) H6) H4) H1\n                 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  ?Goal@{a:=a0; H1:=H14}) H13) H11) H9 H8) m1\n                              x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"]}, {"text": "inversion IHa.", "goal_before": ["Acc R_nat_lt y"], "goal_after": ["Acc R_nat_lt y"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  ?Goal@{a:=a0; H1:=H14}) H13) H11) H9 H8) m1\n                              x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  let H15 : Acc R_nat_lt y :=\n                                    match IHa with\n                                    | Acc_intro _ x1 =>\n                                        (fun\n                                           H15 : forall y0 : nat,\n                                                 R_nat_lt y0 a0 ->\n                                                 Acc R_nat_lt y0 =>\n                                         (fun\n                                            H16 : \n                                             forall y0 : nat,\n                                             R_nat_lt y0 a0 ->\n                                             Acc R_nat_lt y0 =>\n                                          ?Goal@{a:=a0; H1:=H14; H:=H16}) H15)\n                                          x1\n                                    end in\n                                  H15) H13) H11) H9 H8) m1 x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"]}, {"text": "eapply H.", "goal_before": ["Acc R_nat_lt y"], "goal_after": ["R_nat_lt y a"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  let H15 : Acc R_nat_lt y :=\n                                    match IHa with\n                                    | Acc_intro _ x1 =>\n                                        (fun\n                                           H15 : forall y0 : nat,\n                                                 R_nat_lt y0 a0 ->\n                                                 Acc R_nat_lt y0 =>\n                                         (fun\n                                            H16 : \n                                             forall y0 : nat,\n                                             R_nat_lt y0 a0 ->\n                                             Acc R_nat_lt y0 =>\n                                          ?Goal@{a:=a0; H1:=H14; H:=H16}) H15)\n                                          x1\n                                    end in\n                                  H15) H13) H11) H9 H8) m1 x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  let H15 : Acc R_nat_lt y :=\n                                    match IHa with\n                                    | Acc_intro _ x1 =>\n                                        (fun\n                                           H15 : forall y0 : nat,\n                                                 R_nat_lt y0 a0 ->\n                                                 Acc R_nat_lt y0 =>\n                                         (fun\n                                            H16 : \n                                             forall y0 : nat,\n                                             R_nat_lt y0 a0 ->\n                                             Acc R_nat_lt y0 =>\n                                          H16 y\n                                            ?Goal@{a:=a0; H1:=H14; H:=H16})\n                                           H15) x1\n                                    end in\n                                  H15) H13) H11) H9 H8) m1 x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"]}, {"text": "constructor.", "goal_before": ["R_nat_lt y a"], "goal_after": ["y < a"], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  let H15 : Acc R_nat_lt y :=\n                                    match IHa with\n                                    | Acc_intro _ x1 =>\n                                        (fun\n                                           H15 : forall y0 : nat,\n                                                 R_nat_lt y0 a0 ->\n                                                 Acc R_nat_lt y0 =>\n                                         (fun\n                                            H16 : \n                                             forall y0 : nat,\n                                             R_nat_lt y0 a0 ->\n                                             Acc R_nat_lt y0 =>\n                                          H16 y\n                                            ?Goal@{a:=a0; H1:=H14; H:=H16})\n                                           H15) x1\n                                    end in\n                                  H15) H13) H11) H9 H8) m1 x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  let H15 : Acc R_nat_lt y :=\n                                    match IHa with\n                                    | Acc_intro _ x1 =>\n                                        (fun\n                                           H15 : forall y0 : nat,\n                                                 R_nat_lt y0 a0 ->\n                                                 Acc R_nat_lt y0 =>\n                                         (fun\n                                            H16 : \n                                             forall y0 : nat,\n                                             R_nat_lt y0 a0 ->\n                                             Acc R_nat_lt y0 =>\n                                          H16 y\n                                            (R_lt\n                                               ?Goal@{a:=a0; H1:=H14; H:=H16}))\n                                           H15) x1\n                                    end in\n                                  H15) H13) H11) H9 H8) m1 x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"]}, {"text": "eapply H1.", "goal_before": ["y < a"], "goal_after": [], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  let H15 : Acc R_nat_lt y :=\n                                    match IHa with\n                                    | Acc_intro _ x1 =>\n                                        (fun\n                                           H15 : forall y0 : nat,\n                                                 R_nat_lt y0 a0 ->\n                                                 Acc R_nat_lt y0 =>\n                                         (fun\n                                            H16 : \n                                             forall y0 : nat,\n                                             R_nat_lt y0 a0 ->\n                                             Acc R_nat_lt y0 =>\n                                          H16 y\n                                            (R_lt\n                                               ?Goal@{a:=a0; H1:=H14; H:=H16}))\n                                           H15) x1\n                                    end in\n                                  H15) H13) H11) H9 H8) m1 x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  let H15 : Acc R_nat_lt y :=\n                                    match IHa with\n                                    | Acc_intro _ x1 =>\n                                        (fun\n                                           H15 : forall y0 : nat,\n                                                 R_nat_lt y0 a0 ->\n                                                 Acc R_nat_lt y0 =>\n                                         (fun\n                                            H16 : \n                                             forall y0 : nat,\n                                             R_nat_lt y0 a0 ->\n                                             Acc R_nat_lt y0 =>\n                                          H16 y (R_lt H14)) H15) x1\n                                    end in\n                                  H15) H13) H11) H9 H8) m1 x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun a : nat =>\n  nat_ind (fun a0 : nat => Acc R_nat_lt a0)\n    (Acc_intro 0\n       (fun (y : nat) (H : R_nat_lt y 0) =>\n        let H0 : y = y -> 0 = 0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0) return (n = y -> n0 = 0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y) (H2 : m0 = 0)\n               =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = 0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = 0 =>\n                   let H6 : m0 = 0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < 0 =>\n                      False_ind (Acc R_nat_lt y)\n                        (let H8 : 0 = 0 -> False :=\n                           match\n                             H7 in (_ <= n1) return (n1 = 0 -> False)\n                           with\n                           | le_n _ =>\n                               fun H8 : S y = 0 =>\n                               (fun H9 : S y = 0 =>\n                                let H10 : False :=\n                                  eq_ind (S y)\n                                    (fun e : nat =>\n                                     match e with\n                                     | 0 => False\n                                     | S _ => True\n                                     end) I 0 H9 in\n                                False_ind False H10) H8\n                           | le_S _ m1 x0 =>\n                               (fun (m2 : nat) (H8 : S y <= m2)\n                                  (H9 : S m2 = 0) =>\n                                (fun H10 : S m2 = 0 =>\n                                 let H11 : False :=\n                                   eq_ind (S m2)\n                                     (fun e : nat =>\n                                      match e with\n                                      | 0 => False\n                                      | S _ => True\n                                      end) I 0 H10 in\n                                 False_ind (S y <= m2 -> False) H11) H9 H8)\n                                 m1 x0\n                           end in\n                         H8 eq_refl)) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl))\n    (fun (a0 : nat) (IHa : Acc R_nat_lt a0) =>\n     Acc_intro (S a0)\n       (fun (y : nat) (H : R_nat_lt y (S a0)) =>\n        let H0 : y = y -> S a0 = S a0 -> Acc R_nat_lt y :=\n          match\n            H in (R_nat_lt n n0)\n            return (n = y -> n0 = S a0 -> Acc R_nat_lt y)\n          with\n          | @R_lt n m x =>\n              (fun (n0 m0 : nat) (H0 : n0 < m0) (H1 : n0 = y)\n                 (H2 : m0 = S a0) =>\n               (fun H3 : n0 = y =>\n                let H4 : n0 = y := H3 in\n                eq_ind_r\n                  (fun n1 : nat => m0 = S a0 -> n1 < m0 -> Acc R_nat_lt y)\n                  (fun H5 : m0 = S a0 =>\n                   let H6 : m0 = S a0 := H5 in\n                   eq_ind_r (fun n1 : nat => y < n1 -> Acc R_nat_lt y)\n                     (fun H7 : y < S a0 =>\n                      let H8 : S a0 = S a0 -> Acc R_nat_lt y :=\n                        match\n                          H7 in (_ <= n1)\n                          return (n1 = S a0 -> Acc R_nat_lt y)\n                        with\n                        | le_n _ =>\n                            fun H8 : S y = S a0 =>\n                            (fun H9 : S y = S a0 =>\n                             let H10 : y = a0 :=\n                               f_equal\n                                 (fun e : nat =>\n                                  match e with\n                                  | 0 => y\n                                  | S n1 => n1\n                                  end) H9 in\n                             (fun H11 : y = a0 =>\n                              let H12 : y = a0 := H11 in\n                              eq_ind_r (fun n1 : nat => Acc R_nat_lt n1) IHa\n                                H12) H10) H8\n                        | le_S _ m1 x0 =>\n                            (fun (m2 : nat) (H8 : S y <= m2)\n                               (H9 : S m2 = S a0) =>\n                             (fun H10 : S m2 = S a0 =>\n                              let H11 : m2 = a0 :=\n                                f_equal\n                                  (fun e : nat =>\n                                   match e with\n                                   | 0 => m2\n                                   | S n1 => n1\n                                   end) H10 in\n                              (fun H12 : m2 = a0 =>\n                               let H13 : m2 = a0 := H12 in\n                               eq_ind_r\n                                 (fun n1 : nat => S y <= n1 -> Acc R_nat_lt y)\n                                 (fun H14 : S y <= a0 =>\n                                  let H15 : Acc R_nat_lt y :=\n                                    match IHa with\n                                    | Acc_intro _ x1 =>\n                                        (fun\n                                           H15 : forall y0 : nat,\n                                                 R_nat_lt y0 a0 ->\n                                                 Acc R_nat_lt y0 =>\n                                         (fun\n                                            H16 : \n                                             forall y0 : nat,\n                                             R_nat_lt y0 a0 ->\n                                             Acc R_nat_lt y0 =>\n                                          H16 y (R_lt H14)) H15) x1\n                                    end in\n                                  H15) H13) H11) H9 H8) m1 x0\n                        end in\n                      H8 eq_refl) H6) H4) H1 H2 H0) n m x\n          end in\n        H0 eq_refl eq_refl)) a)\n :\n well_founded R_nat_lt)"], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Map/FMapAList.v", "name": "mapsto_lookup_alist", "text": "Theorem mapsto_lookup_alist : forall (k : K) (v : V) (m : list (K * V)),\n                                   lookup k m = Some v <-> mapsto_alist m k v.\n    Proof.\n      reflexivity.\n    Qed.\n", "definition": " forall (k : K) (v : V) (m : list (K * V)),\n                                   lookup k m = Some v <-> mapsto_alist m k v.\n    ", "proof": "\n      reflexivity.\n    ", "def_ranges": [87, 0, 88, 78], "proof_ranges": [89, 0, 91, 8], "proof_steps": [{"text": "reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Map/FMapAList.v", "name": "mapsto_remove_eq_alist", "text": "Theorem mapsto_remove_eq_alist : forall (m : list (K * V)) (k : K) (v : V),\n                                       ~mapsto_alist (remove k m) k v.\n    Proof.\n      unfold mapsto_alist, remove, alist_remove; simpl. intros.\n      induction m; simpl; auto.\n      { congruence. }\n      { destruct a; simpl in *.\n        consider (k ?[ R ] k0); auto; intros.\n        simpl. consider (k ?[ R ] k0); auto. }\n    Qed.\n", "definition": " forall (m : list (K * V)) (k : K) (v : V),\n                                       ~mapsto_alist (remove k m) k v.\n    ", "proof": "\n      unfold mapsto_alist, remove, alist_remove; simpl. intros.\n      induction m; simpl; auto.\n      { congruence. }\n      { destruct a; simpl in *.\n        consider (k ?[ R ] k0); auto; intros.\n        simpl. consider (k ?[ R ] k0); auto. }\n    ", "def_ranges": [93, 0, 94, 70], "proof_ranges": [95, 0, 102, 8], "proof_steps": [{"text": "unfold mapsto_alist, remove, alist_remove; simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction m; simpl; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct a; simpl in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k ?[ R ] k0); auto; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k ?[ R ] k0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Map/FMapAList.v", "name": "mapsto_remove_neq_alist", "text": "Theorem mapsto_remove_neq_alist : forall (m : list (K * V)) (k : K),\n                                      forall k', ~ R k k' -> forall v', (mapsto_alist m k' v' <-> mapsto_alist (remove k m) k' v').\n    Proof.\n      unfold mapsto_alist, add; simpl. intros.\n      induction m; simpl in *.\n      { intuition. }\n      { destruct a. simpl in *.\n        consider (k' ?[ R ] k0); intros.\n        { consider (k ?[ R ] k0); intros.\n          { exfalso. eauto. }\n          { simpl. consider (k' ?[ R ] k0); intros.\n            { intuition. }\n            { exfalso; auto. } } }\n        { rewrite IHm.\n          consider (k ?[ R ] k0); simpl; intros.\n          { intuition. }\n          { consider (k' ?[ R ] k0); intros.\n            { exfalso; auto. }\n            { intuition. } } } }\n    Qed.\n", "definition": " forall (m : list (K * V)) (k : K),\n                                      forall k', ~ R k k' -> forall v', (mapsto_alist m k' v' <-> mapsto_alist (remove k m) k' v').\n    ", "proof": "\n      unfold mapsto_alist, add; simpl. intros.\n      induction m; simpl in *.\n      { intuition. }\n      { destruct a. simpl in *.\n        consider (k' ?[ R ] k0); intros.\n        { consider (k ?[ R ] k0); intros.\n          { exfalso. eauto. }\n          { simpl. consider (k' ?[ R ] k0); intros.\n            { intuition. }\n            { exfalso; auto. } } }\n        { rewrite IHm.\n          consider (k ?[ R ] k0); simpl; intros.\n          { intuition. }\n          { consider (k' ?[ R ] k0); intros.\n            { exfalso; auto. }\n            { intuition. } } } }\n    ", "def_ranges": [104, 0, 105, 131], "proof_ranges": [106, 0, 123, 8], "proof_steps": [{"text": "unfold mapsto_alist, add; simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction m; simpl in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intuition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k' ?[ R ] k0); intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k ?[ R ] k0); intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exfalso.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eauto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k' ?[ R ] k0); intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intuition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exfalso; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite IHm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k ?[ R ] k0); simpl; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intuition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k' ?[ R ] k0); intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exfalso; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intuition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Map/FMapAList.v", "name": "mapsto_add_eq_alist", "text": "Theorem mapsto_add_eq_alist : forall (m : list (K * V)) (k : K) (v : V),\n                                 mapsto_alist (add k v m) k v.\n    Proof.\n      unfold mapsto_alist, add, alist_add; simpl. intros.\n      consider (k ?[ R ] k); auto.\n      intro. exfalso. apply H. reflexivity.\n    Qed.\n", "definition": " forall (m : list (K * V)) (k : K) (v : V),\n                                 mapsto_alist (add k v m) k v.\n    ", "proof": "\n      unfold mapsto_alist, add, alist_add; simpl. intros.\n      consider (k ?[ R ] k); auto.\n      intro. exfalso. apply H. reflexivity.\n    ", "def_ranges": [125, 0, 126, 62], "proof_ranges": [127, 0, 131, 8], "proof_steps": [{"text": "unfold mapsto_alist, add, alist_add; simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k ?[ R ] k); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exfalso.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Map/FMapAList.v", "name": "mapsto_add_neq_alist", "text": "Theorem mapsto_add_neq_alist : forall (m : list (K * V)) (k : K) (v : V),\n                                     forall k', ~ R k k' -> forall v', (mapsto_alist m k' v' <-> mapsto_alist (add k v m) k' v').\n    Proof.\n      unfold mapsto_alist, add; simpl. intros.\n      consider (k' ?[ R ] k); try solve [ intros; exfalso; auto ].\n      intros. eapply mapsto_remove_neq_alist in H. eapply H.\n    Qed.\n", "definition": " forall (m : list (K * V)) (k : K) (v : V),\n                                     forall k', ~ R k k' -> forall v', (mapsto_alist m k' v' <-> mapsto_alist (add k v m) k' v').\n    ", "proof": "\n      unfold mapsto_alist, add; simpl. intros.\n      consider (k' ?[ R ] k); try solve [ intros; exfalso; auto ].\n      intros. eapply mapsto_remove_neq_alist in H. eapply H.\n    ", "def_ranges": [133, 0, 134, 129], "proof_ranges": [135, 0, 139, 8], "proof_steps": [{"text": "unfold mapsto_alist, add; simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (k' ?[ R ] k); try solve [ intros; exfalso; auto ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply mapsto_remove_neq_alist in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Map/FMapPositive.v", "name": "fmap_lookup", "text": "Theorem fmap_lookup : forall a b m,\n    mapsto a b m ->\n    mapsto a (f b) (fmap_pmap m).\n  Proof.\n    induction a; destruct m; simpl; intros; try congruence.\n    { eapply IHa. eapply H. }\n    { eapply IHa; eapply H. }\n    { subst. auto. }\n  Qed.\n", "definition": " forall a b m,\n    mapsto a b m ->\n    mapsto a (f b) (fmap_pmap m).\n  ", "proof": "\n    induction a; destruct m; simpl; intros; try congruence.\n    { eapply IHa. eapply H. }\n    { eapply IHa; eapply H. }\n    { subst. auto. }\n  ", "def_ranges": [219, 0, 221, 33], "proof_ranges": [222, 0, 227, 6], "proof_steps": [{"text": "induction a; destruct m; simpl; intros; try congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHa.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHa; eapply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Data/Map/FMapPositive.v", "name": "fmap_lookup_bk", "text": "Theorem fmap_lookup_bk : forall a b m,\n    mapsto a b (fmap_pmap m) ->\n    exists b', mapsto a b' m /\\ f b' = b.\n  Proof.\n    induction a; destruct m; simpl; intros; try congruence.\n    { eapply IHa. eapply H. }\n    { eapply IHa. eapply H. }\n    { destruct o; try congruence. eexists; split; eauto. inversion H; auto. }\n  Qed.\n", "definition": " forall a b m,\n    mapsto a b (fmap_pmap m) ->\n    exists b', mapsto a b' m /\\ f b' = b.\n  ", "proof": "\n    induction a; destruct m; simpl; intros; try congruence.\n    { eapply IHa. eapply H. }\n    { eapply IHa. eapply H. }\n    { destruct o; try congruence. eexists; split; eauto. inversion H; auto. }\n  ", "def_ranges": [229, 0, 231, 41], "proof_ranges": [232, 0, 237, 6], "proof_steps": [{"text": "induction a; destruct m; simpl; intros; try congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHa.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHa.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct o; try congruence.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eexists; split; eauto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Tactics/Parametric.v", "name": "Proper_red", "text": "Theorem Proper_red : forall T U (rT : relation T) (rU : relation U) (f : T -> U),\n  (forall x x', rT x x' -> rU (f x) (f x')) ->\n  Proper (rT ==> rU) f.\nintuition.\nQed.\n", "definition": " forall T U (rT : relation T) (rU : relation U) (f : T -> U),\n  (forall x x', rT x x' -> rU (f x) (f x')) ->\n  Proper (rT ==> rU) f.", "proof": "\nintuition.\n", "def_ranges": [11, 0, 13, 23], "proof_ranges": [14, 0, 15, 4], "proof_steps": [{"text": "intuition.", "goal_before": ["forall (T U : Type) (rT : relation T) (rU : relation U) (f : T -> U),\n(forall x x' : T, rT x x' -> rU (f x) (f x')) -> Proper (rT ==> rU) f"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (T U : Type) (rT : relation T) (rU : relation U) \n   (f : T -> U) (H : forall x x' : T, rT x x' -> rU (f x) (f x')) => H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (T U : Type) (rT : relation T) (rU : relation U) \n   (f : T -> U) (H : forall x x' : T, rT x x' -> rU (f x) (f x')) => H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Tactics/Parametric.v", "name": "respectful_red", "text": "Theorem respectful_red : forall T U (rT : relation T) (rU : relation U) (f g : T -> U),\n  (forall x x', rT x x' -> rU (f x) (g x')) ->\n  respectful rT rU f g.\nintuition.\nQed.\n", "definition": " forall T U (rT : relation T) (rU : relation U) (f g : T -> U),\n  (forall x x', rT x x' -> rU (f x) (g x')) ->\n  respectful rT rU f g.", "proof": "\nintuition.\n", "def_ranges": [17, 0, 19, 23], "proof_ranges": [20, 0, 21, 4], "proof_steps": [{"text": "intuition.", "goal_before": ["forall (T U : Type) (rT : relation T) (rU : relation U) (f g : T -> U),\n(forall x x' : T, rT x x' -> rU (f x) (g x')) -> (rT ==> rU)%signature f g"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (T U : Type) (rT : relation T) (rU : relation U) \n   (f g : T -> U) (H : forall x x' : T, rT x x' -> rU (f x) (g x')) => H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (T U : Type) (rT : relation T) (rU : relation U) \n   (f g : T -> U) (H : forall x x' : T, rT x x' -> rU (f x) (g x')) => H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Tactics/Parametric.v", "name": "respectful_if_bool", "text": "Theorem respectful_if_bool T : forall (x x' : bool) (t t' f f' : T) eqT,\n  x = x' ->\n  eqT t t' -> eqT f f' ->\n  eqT (if x then t else f) (if x' then t' else f') .\nintros; subst; auto; destruct x'; auto.\nQed.\n", "definition": " forall (x x' : bool) (t t' f f' : T) eqT,\n  x = x' ->\n  eqT t t' -> eqT f f' ->\n  eqT (if x then t else f) (if x' then t' else f') .", "proof": "\nintros; subst; auto; destruct x'; auto.\n", "def_ranges": [22, 0, 25, 52], "proof_ranges": [26, 0, 27, 4], "proof_steps": [{"text": "intros; subst; auto; destruct x'; auto.", "goal_before": ["forall (x x' : bool) (t t' f f' : T) (eqT : T -> T -> Type),\nx = x' ->\neqT t t' -> eqT f f' -> eqT (if x then t else f) (if x' then t' else f')"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (T : Type) (x x' : bool) (t t' f f' : T) (eqT : T -> T -> Type)\n   (H : x = x') (H0 : eqT t t') (H1 : eqT f f') =>\n eq_rect_r\n   (fun x0 : bool => eqT (if x0 then t else f) (if x' then t' else f'))\n   (if x' as b return (eqT (if b then t else f) (if b then t' else f'))\n    then H0\n    else H1) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (T : Type) (x x' : bool) (t t' f f' : T) (eqT : T -> T -> Type)\n   (H : x = x') (H0 : eqT t t') (H1 : eqT f f') =>\n eq_rect_r\n   (fun x0 : bool => eqT (if x0 then t else f) (if x' then t' else f'))\n   (if x' as b return (eqT (if b then t else f) (if b then t' else f'))\n    then H0\n    else H1) H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Tactics/Parametric.v", "name": "listEq_match", "text": "Theorem listEq_match V U (eqV : relation V) (eqU : relation U) : forall x x' : list V,\n    forall X X' Y Y',\n    eqU X X' ->\n    (eqV ==> listEq eqV ==> eqU)%signature Y Y' ->\n    listEq eqV x x' ->\n    eqU (match x with\n           | nil => X\n           | x :: xs => Y x xs\n         end)\n        (match x' with\n           | nil => X'\n           | x :: xs => Y' x xs\n         end).\n  Proof.\n    intros. induction H1; auto. derive_morph; auto.\n  Qed.\n", "definition": " relation V) (eqU : relation U) : forall x x' : list V,\n    forall X X' Y Y',\n    eqU X X' ->\n    (eqV ==> listEq eqV ==> eqU)%signature Y Y' ->\n    listEq eqV x x' ->\n    eqU (match x with\n           | nil => X\n           | x :: xs => Y x xs\n         end)\n        (match x' with\n           | nil => X'\n           | x :: xs => Y' x xs\n         end).\n  ", "proof": "\n    intros. induction H1; auto. derive_morph; auto.\n  ", "def_ranges": [89, 0, 101, 14], "proof_ranges": [102, 0, 104, 6], "proof_steps": [{"text": "intros.", "goal_before": ["forall (x x' : list V) (X X' : U) (Y Y' : V -> list V -> U),\neqU X X' ->\n(eqV ==> listEq eqV ==> eqU)%signature Y Y' ->\nlistEq eqV x x' ->\neqU match x with\n    | nil => X\n    | x0 :: xs => Y x0 xs\n    end match x' with\n        | nil => X'\n        | x0 :: xs => Y' x0 xs\n        end"], "goal_after": ["eqU match x with\n    | nil => X\n    | x0 :: xs => Y x0 xs\n    end match x' with\n        | nil => X'\n        | x0 :: xs => Y' x0 xs\n        end"], "proof_term_before": [], "proof_term_after": ["(fun (V U : Type) (eqV : relation V) (eqU : relation U) \n   (x x' : list V) (X X' : U) (Y Y' : V -> list V -> U) \n   (H : eqU X X') (H0 : (eqV ==> listEq eqV ==> eqU)%signature Y Y')\n   (H1 : listEq eqV x x') => ?Goal)"]}, {"text": "induction H1; auto.", "goal_before": ["eqU match x with\n    | nil => X\n    | x0 :: xs => Y x0 xs\n    end match x' with\n        | nil => X'\n        | x0 :: xs => Y' x0 xs\n        end"], "goal_after": ["eqU (Y x y) (Y' x' y')"], "proof_term_before": ["(fun (V U : Type) (eqV : relation V) (eqU : relation U) \n   (x x' : list V) (X X' : U) (Y Y' : V -> list V -> U) \n   (H : eqU X X') (H0 : (eqV ==> listEq eqV ==> eqU)%signature Y Y')\n   (H1 : listEq eqV x x') => ?Goal)"], "proof_term_after": ["(fun (V U : Type) (eqV : relation V) (eqU : relation U) \n   (x x' : list V) (X X' : U) (Y Y' : V -> list V -> U) \n   (H : eqU X X') (H0 : (eqV ==> listEq eqV ==> eqU)%signature Y Y')\n   (H1 : listEq eqV x x') =>\n listEq_ind\n   (fun x0 x'0 : list V =>\n    eqU match x0 with\n        | nil => X\n        | x1 :: xs => Y x1 xs\n        end match x'0 with\n            | nil => X'\n            | x1 :: xs => Y' x1 xs\n            end) H\n   (fun (x0 x'0 : V) (y y' : list V) (H2 : eqV x0 x'0) \n      (H3 : listEq eqV y y')\n      (IHlistEq : eqU match y with\n                      | nil => X\n                      | x1 :: xs => Y x1 xs\n                      end\n                    match y' with\n                    | nil => X'\n                    | x1 :: xs => Y' x1 xs\n                    end) => ?Goal@{x:=x0; x':=x'0; H1:=H2; H2:=H3}) H1)"]}, {"text": "derive_morph; auto.", "goal_before": ["eqU (Y x y) (Y' x' y')"], "goal_after": [], "proof_term_before": ["(fun (V U : Type) (eqV : relation V) (eqU : relation U) \n   (x x' : list V) (X X' : U) (Y Y' : V -> list V -> U) \n   (H : eqU X X') (H0 : (eqV ==> listEq eqV ==> eqU)%signature Y Y')\n   (H1 : listEq eqV x x') =>\n listEq_ind\n   (fun x0 x'0 : list V =>\n    eqU match x0 with\n        | nil => X\n        | x1 :: xs => Y x1 xs\n        end match x'0 with\n            | nil => X'\n            | x1 :: xs => Y' x1 xs\n            end) H\n   (fun (x0 x'0 : V) (y y' : list V) (H2 : eqV x0 x'0) \n      (H3 : listEq eqV y y')\n      (IHlistEq : eqU match y with\n                      | nil => X\n                      | x1 :: xs => Y x1 xs\n                      end\n                    match y' with\n                    | nil => X'\n                    | x1 :: xs => Y' x1 xs\n                    end) => ?Goal@{x:=x0; x':=x'0; H1:=H2; H2:=H3}) H1)"], "proof_term_after": ["(fun (V U : Type) (eqV : relation V) (eqU : relation U) \n   (x x' : list V) (X X' : U) (Y Y' : V -> list V -> U) \n   (H : eqU X X') (H0 : (eqV ==> listEq eqV ==> eqU)%signature Y Y')\n   (H1 : listEq eqV x x') =>\n listEq_ind\n   (fun x0 x'0 : list V =>\n    eqU match x0 with\n        | nil => X\n        | x1 :: xs => Y x1 xs\n        end match x'0 with\n            | nil => X'\n            | x1 :: xs => Y' x1 xs\n            end) H\n   (fun (x0 x'0 : V) (y y' : list V) (H2 : eqV x0 x'0) \n      (H3 : listEq eqV y y')\n      (_ : eqU match y with\n               | nil => X\n               | x1 :: xs => Y x1 xs\n               end match y' with\n                   | nil => X'\n                   | x1 :: xs => Y' x1 xs\n                   end) => H0 x0 x'0 H2 y y' H3) H1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (V U : Type) (eqV : relation V) (eqU : relation U) \n   (x x' : list V) (X X' : U) (Y Y' : V -> list V -> U) \n   (H : eqU X X') (H0 : (eqV ==> listEq eqV ==> eqU)%signature Y Y')\n   (H1 : listEq eqV x x') =>\n listEq_ind\n   (fun x0 x'0 : list V =>\n    eqU match x0 with\n        | nil => X\n        | x1 :: xs => Y x1 xs\n        end match x'0 with\n            | nil => X'\n            | x1 :: xs => Y' x1 xs\n            end) H\n   (fun (x0 x'0 : V) (y y' : list V) (H2 : eqV x0 x'0) \n      (H3 : listEq eqV y y')\n      (_ : eqU match y with\n               | nil => X\n               | x1 :: xs => Y x1 xs\n               end match y' with\n                   | nil => X'\n                   | x1 :: xs => Y' x1 xs\n                   end) => H0 x0 x'0 H2 y y' H3) H1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Tactics/EqDep.v", "name": "UIP_refl", "text": "Theorem UIP_refl : forall {x : A} (p1 : x = x), p1 = refl_equal _.\n    intros.\n    eapply Eqdep_dec.UIP_dec. apply equiv_dec.\n  Qed.\n", "definition": " forall {x : A} (p1 : x = x), p1 = refl_equal _.", "proof": "\n    intros.\n    eapply Eqdep_dec.UIP_dec. apply equiv_dec.\n  ", "def_ranges": [11, 0, 11, 68], "proof_ranges": [12, 0, 14, 6], "proof_steps": [{"text": "intros.", "goal_before": ["forall (x : A) (p1 : x = x), p1 = eq_refl"], "goal_after": ["p1 = eq_refl"], "proof_term_before": [], "proof_term_after": ["(fun (x : A) (p1 : x = x) => ?Goal)"]}, {"text": "eapply Eqdep_dec.UIP_dec.", "goal_before": ["p1 = eq_refl"], "goal_after": ["p1 = eq_refl"], "proof_term_before": ["(fun (x : A) (p1 : x = x) => ?Goal)"], "proof_term_after": []}, {"text": "apply equiv_dec.", "goal_before": ["forall x0 y : A, {x0 = y} + {x0 <> y}"], "goal_after": ["forall x0 y : A, {x0 = y} + {x0 <> y}"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": ["UIP_refl is defined"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Tactics/EqDep.v", "name": "UIP_equal", "text": "Theorem UIP_equal : forall {x y : A} (p1 p2 : x = y), p1 = p2.\n    eapply Eqdep_dec.UIP_dec. apply equiv_dec.\n  Qed.\n", "definition": " forall {x y : A} (p1 p2 : x = y), p1 = p2.", "proof": "\n    eapply Eqdep_dec.UIP_dec. apply equiv_dec.\n  ", "def_ranges": [16, 0, 16, 64], "proof_ranges": [17, 0, 18, 6], "proof_steps": [{"text": "eapply Eqdep_dec.UIP_dec.", "goal_before": ["forall (x y : A) (p1 p2 : x = y), p1 = p2"], "goal_after": ["forall (x y : A) (p1 p2 : x = y), p1 = p2"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply equiv_dec.", "goal_before": ["forall x y : A, {x = y} + {x <> y}"], "goal_after": ["forall x y : A, {x = y} + {x <> y}"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": ["UIP_equal is defined"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Structures/EqDep.v", "name": "UIP_refl", "text": "Theorem UIP_refl : forall {x : A} (p1 : x = x), p1 = refl_equal _.\n    intros.\n    eapply Coq.Logic.Eqdep_dec.UIP_dec. apply EquivDec.equiv_dec.\n  Qed.\n", "definition": " forall {x : A} (p1 : x = x), p1 = refl_equal _.", "proof": "\n    intros.\n    eapply Coq.Logic.Eqdep_dec.UIP_dec. apply EquivDec.equiv_dec.\n  ", "def_ranges": [12, 0, 12, 68], "proof_ranges": [13, 0, 15, 6], "proof_steps": [{"text": "intros.", "goal_before": ["forall (x : A) (p1 : x = x), p1 = eq_refl"], "goal_after": ["p1 = eq_refl"], "proof_term_before": [], "proof_term_after": ["(fun (x : A) (p1 : x = x) => ?Goal)"]}, {"text": "eapply Coq.Logic.Eqdep_dec.UIP_dec.", "goal_before": ["p1 = eq_refl"], "goal_after": ["p1 = eq_refl"], "proof_term_before": ["(fun (x : A) (p1 : x = x) => ?Goal)"], "proof_term_after": []}, {"text": "apply EquivDec.equiv_dec.", "goal_before": ["p1 = eq_refl"], "goal_after": ["p1 = eq_refl"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["forall x0 y : A, {x0 = y} + {x0 <> y}"], "goal_after": ["forall x0 y : A, {x0 = y} + {x0 <> y}"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Structures/EqDep.v", "name": "UIP_equal", "text": "Theorem UIP_equal : forall {x y : A} (p1 p2 : x = y), p1 = p2.\n    eapply Coq.Logic.Eqdep_dec.UIP_dec. apply EquivDec.equiv_dec.\n  Qed.\n", "definition": " forall {x y : A} (p1 p2 : x = y), p1 = p2.", "proof": "\n    eapply Coq.Logic.Eqdep_dec.UIP_dec. apply EquivDec.equiv_dec.\n  ", "def_ranges": [17, 0, 17, 64], "proof_ranges": [18, 0, 19, 6], "proof_steps": [{"text": "eapply Coq.Logic.Eqdep_dec.UIP_dec.", "goal_before": ["forall (x y : A) (p1 p2 : x = y), p1 = p2"], "goal_after": ["forall (x y : A) (p1 p2 : x = y), p1 = p2"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EquivDec.equiv_dec.", "goal_before": ["forall (x y : A) (p1 p2 : x = y), p1 = p2"], "goal_after": ["forall (x y : A) (p1 p2 : x = y), p1 = p2"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["forall x y : A, {x = y} + {x <> y}"], "goal_after": ["forall x y : A, {x = y} + {x <> y}"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Structures/EqDep.v", "name": "equiv_dec_refl_left", "text": "Theorem equiv_dec_refl_left : forall a, @EquivDec.equiv_dec _ _ _ dec a a = left eq_refl.\n  Proof.\n    intros. destruct (EquivDec.equiv_dec a a); try congruence.\n    f_equal. apply UIP_equal.\n  Qed.\n", "definition": " forall a, @EquivDec.equiv_dec _ _ _ dec a a = left eq_refl.\n  ", "proof": "\n    intros. destruct (EquivDec.equiv_dec a a); try congruence.\n    f_equal. apply UIP_equal.\n  ", "def_ranges": [28, 0, 28, 91], "proof_ranges": [29, 0, 32, 6], "proof_steps": [{"text": "intros.", "goal_before": ["forall a : A, EquivDec.equiv_dec a a = left eq_refl"], "goal_after": ["forall a : A, EquivDec.equiv_dec a a = left eq_refl"], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (EquivDec.equiv_dec a a); try congruence.", "goal_before": ["EquivDec.equiv_dec a a = left eq_refl"], "goal_after": ["EquivDec.equiv_dec a a = left eq_refl"], "proof_term_before": [], "proof_term_after": []}, {"text": "f_equal.", "goal_before": ["EquivDec.equiv_dec a a = left eq_refl"], "goal_after": ["left e = left eq_refl"], "proof_term_before": [], "proof_term_after": ["(fun a : A =>\n let s := EquivDec.equiv_dec a a in\n match s as s0 return (s0 = left eq_refl) with\n | left a0 => (fun e : Equivalence.equiv a a => ?Goal) a0\n | right b =>\n     (fun c : RelationClasses.complement Equivalence.equiv a a =>\n      let Heq : a = a := eq_refl in\n      False_ind (right c = left eq_refl) (c Heq)) b\n end)"]}, {"text": "apply UIP_equal.", "goal_before": ["left e = left eq_refl"], "goal_after": ["e = eq_refl"], "proof_term_before": ["(fun a : A =>\n let s := EquivDec.equiv_dec a a in\n match s as s0 return (s0 = left eq_refl) with\n | left a0 => (fun e : Equivalence.equiv a a => ?Goal) a0\n | right b =>\n     (fun c : RelationClasses.complement Equivalence.equiv a a =>\n      let Heq : a = a := eq_refl in\n      False_ind (right c = left eq_refl) (c Heq)) b\n end)"], "proof_term_after": ["(fun a : A =>\n let s := EquivDec.equiv_dec a a in\n match s as s0 return (s0 = left eq_refl) with\n | left a0 =>\n     (fun e : Equivalence.equiv a a =>\n      let H : e = eq_refl := ?Goal in\n      (let H0 :\n         RelationClasses.complement Equivalence.equiv a a =\n         RelationClasses.complement Equivalence.equiv a a := eq_refl in\n       (let H1 : Equivalence.equiv a a = (a = a) := eq_refl in\n        (fun (_ : Equivalence.equiv a a = (a = a))\n           (_ : RelationClasses.complement Equivalence.equiv a a =\n                RelationClasses.complement Equivalence.equiv a a)\n           (H4 : e = eq_refl) =>\n         eq_trans\n           (f_equal\n              (fun\n                 f : Equivalence.equiv a a ->\n                     {Equivalence.equiv a a} +\n                     {RelationClasses.complement Equivalence.equiv a a} =>\n               f e)\n              (eq_trans\n                 (f_equal\n                    (fun\n                       f : forall B : Prop,\n                           Equivalence.equiv a a ->\n                           {Equivalence.equiv a a} + {B} =>\n                     f (RelationClasses.complement Equivalence.equiv a a))\n                    (eq_trans\n                       (f_equal\n                          (fun f : forall A B : Prop, A -> {A} + {B} =>\n                           f (Equivalence.equiv a a)) eq_refl) eq_refl))\n                 eq_refl)) (f_equal left H4)) H1) H0) H) a0\n | right b =>\n     (fun c : RelationClasses.complement Equivalence.equiv a a =>\n      let Heq : a = a := eq_refl in\n      False_ind (right c = left eq_refl) (c Heq)) b\n end)"]}, {"text": "Qed.", "goal_before": ["e = eq_refl"], "goal_after": [], "proof_term_before": ["(fun a : A =>\n let s := EquivDec.equiv_dec a a in\n match s as s0 return (s0 = left eq_refl) with\n | left a0 =>\n     (fun e : Equivalence.equiv a a =>\n      let H : e = eq_refl := ?Goal in\n      (let H0 :\n         RelationClasses.complement Equivalence.equiv a a =\n         RelationClasses.complement Equivalence.equiv a a := eq_refl in\n       (let H1 : Equivalence.equiv a a = (a = a) := eq_refl in\n        (fun (_ : Equivalence.equiv a a = (a = a))\n           (_ : RelationClasses.complement Equivalence.equiv a a =\n                RelationClasses.complement Equivalence.equiv a a)\n           (H4 : e = eq_refl) =>\n         eq_trans\n           (f_equal\n              (fun\n                 f : Equivalence.equiv a a ->\n                     {Equivalence.equiv a a} +\n                     {RelationClasses.complement Equivalence.equiv a a} =>\n               f e)\n              (eq_trans\n                 (f_equal\n                    (fun\n                       f : forall B : Prop,\n                           Equivalence.equiv a a ->\n                           {Equivalence.equiv a a} + {B} =>\n                     f (RelationClasses.complement Equivalence.equiv a a))\n                    (eq_trans\n                       (f_equal\n                          (fun f : forall A B : Prop, A -> {A} + {B} =>\n                           f (Equivalence.equiv a a)) eq_refl) eq_refl))\n                 eq_refl)) (f_equal left H4)) H1) H0) H) a0\n | right b =>\n     (fun c : RelationClasses.complement Equivalence.equiv a a =>\n      let Heq : a = a := eq_refl in\n      False_ind (right c = left eq_refl) (c Heq)) b\n end)"], "proof_term_after": ["(fun a : A =>\n let s := EquivDec.equiv_dec a a in\n match s as s0 return (s0 = left eq_refl) with\n | left a0 =>\n     (fun e : Equivalence.equiv a a =>\n      let H : e = eq_refl := UIP_equal e eq_refl in\n      (let H0 :\n         RelationClasses.complement Equivalence.equiv a a =\n         RelationClasses.complement Equivalence.equiv a a := eq_refl in\n       (let H1 : Equivalence.equiv a a = (a = a) := eq_refl in\n        (fun (_ : Equivalence.equiv a a = (a = a))\n           (_ : RelationClasses.complement Equivalence.equiv a a =\n                RelationClasses.complement Equivalence.equiv a a)\n           (H4 : e = eq_refl) =>\n         eq_trans\n           (f_equal\n              (fun\n                 f : Equivalence.equiv a a ->\n                     {Equivalence.equiv a a} +\n                     {RelationClasses.complement Equivalence.equiv a a} =>\n               f e)\n              (eq_trans\n                 (f_equal\n                    (fun\n                       f : forall B : Prop,\n                           Equivalence.equiv a a ->\n                           {Equivalence.equiv a a} + {B} =>\n                     f (RelationClasses.complement Equivalence.equiv a a))\n                    (eq_trans\n                       (f_equal\n                          (fun f : forall A B : Prop, A -> {A} + {B} =>\n                           f (Equivalence.equiv a a)) eq_refl) eq_refl))\n                 eq_refl)) (f_equal left H4)) H1) H0) H) a0\n | right b =>\n     (fun c : RelationClasses.complement Equivalence.equiv a a =>\n      let Heq : a = a := eq_refl in\n      False_ind (right c = left eq_refl) (c Heq)) b\n end)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Recur/GenRec.v", "name": "Fix_equiv", "text": "Theorem Fix_equiv\n  : forall x : A,\n      r (Fix Rwf P F x) (@F x (fun (y : A) (_ : R y x) => Fix Rwf P F y)).\n  Proof.\n    intro x; unfold Fix.\n    rewrite <- Fix_F_eq.\n    apply Hstep; intros.\n    apply Fix_F_equiv_inv.\n  Qed.\n", "definition": " forall x : A,\n      r (Fix Rwf P F x) (@F x (fun (y : A) (_ : R y x) => Fix Rwf P F y)).\n  ", "proof": "\n    intro x; unfold Fix.\n    rewrite <- Fix_F_eq.\n    apply Hstep; intros.\n    apply Fix_F_equiv_inv.\n  ", "def_ranges": [31, 0, 33, 74], "proof_ranges": [34, 0, 39, 6], "proof_steps": [{"text": "intro x; unfold Fix.", "goal_before": ["forall x : A,\nr (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y))"], "goal_after": ["r (Fix_F P F (Rwf x)) (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y)))"], "proof_term_before": [], "proof_term_after": ["(fun x : A =>\n ?Goal : r (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y)))"]}, {"text": "rewrite <- Fix_F_eq.", "goal_before": ["r (Fix_F P F (Rwf x)) (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y)))"], "goal_after": ["r (F (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p)))\n  (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y)))"], "proof_term_before": ["(fun x : A =>\n ?Goal : r (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y)))"], "proof_term_after": ["(fun x : A =>\n eq_ind (F (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p)))\n   (fun p : P x => r p (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))))\n   ?Goal (Fix_F P F (Rwf x)) (Fix_F_eq P F (Rwf x))\n :\n r (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y)))"]}, {"text": "apply Hstep; intros.", "goal_before": ["r (F (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p)))\n  (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y)))"], "goal_after": ["r (Fix_F P F (Acc_inv (Rwf x) p)) (Fix_F P F (Rwf y))"], "proof_term_before": ["(fun x : A =>\n eq_ind (F (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p)))\n   (fun p : P x => r p (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))))\n   ?Goal (Fix_F P F (Rwf x)) (Fix_F_eq P F (Rwf x))\n :\n r (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y)))"], "proof_term_after": ["(fun x : A =>\n eq_ind (F (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p)))\n   (fun p : P x => r p (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))))\n   (Hstep (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p))\n      (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))\n      (fun (y : A) (p : R y x) => ?Goal)) (Fix_F P F (Rwf x))\n   (Fix_F_eq P F (Rwf x))\n :\n r (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y)))"]}, {"text": "apply Fix_F_equiv_inv.", "goal_before": ["r (Fix_F P F (Acc_inv (Rwf x) p)) (Fix_F P F (Rwf y))"], "goal_after": [], "proof_term_before": ["(fun x : A =>\n eq_ind (F (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p)))\n   (fun p : P x => r p (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))))\n   (Hstep (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p))\n      (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))\n      (fun (y : A) (p : R y x) => ?Goal)) (Fix_F P F (Rwf x))\n   (Fix_F_eq P F (Rwf x))\n :\n r (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y)))"], "proof_term_after": ["(fun x : A =>\n eq_ind (F (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p)))\n   (fun p : P x => r p (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))))\n   (Hstep (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p))\n      (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))\n      (fun (y : A) (p : R y x) => Fix_F_equiv_inv (Acc_inv (Rwf x) p) (Rwf y)))\n   (Fix_F P F (Rwf x)) (Fix_F_eq P F (Rwf x))\n :\n r (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : A =>\n eq_ind (F (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p)))\n   (fun p : P x => r p (F (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))))\n   (Hstep (fun (y : A) (p : R y x) => Fix_F P F (Acc_inv (Rwf x) p))\n      (fun (y : A) (_ : R y x) => Fix_F P F (Rwf y))\n      (fun (y : A) (p : R y x) => Fix_F_equiv_inv (Acc_inv (Rwf x) p) (Rwf y)))\n   (Fix_F P F (Rwf x)) (Fix_F_eq P F (Rwf x))\n :\n r (Fix Rwf P F x) (F (fun (y : A) (_ : R y x) => Fix Rwf P F y)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Recur/Relation.v", "name": "wf_rightTrans", "text": "Theorem wf_rightTrans : well_founded (rightTrans R).\n  Proof.\n    red.\n    eapply Fix. eapply wf_R. clear.\n    intros. constructor. intros.\n    revert H.\n    induction H0.\n    { intros. eauto. }\n    { intros.\n      eapply IHrightTrans; clear IHrightTrans.\n      specialize (H1 _ H). inversion H1.\n      intros. eapply H2. eapply RTFin. eassumption. }\n  Defined.\n", "definition": " well_founded (rightTrans R).\n  ", "proof": "\n    red.\n    eapply Fix. eapply wf_R. clear.\n    intros. constructor. intros.\n    revert H.\n    induction H0.\n    { intros. eauto. }\n    { intros.\n      eapply IHrightTrans; clear IHrightTrans.\n      specialize (H1 _ H). inversion H1.\n      intros. eapply H2. eapply RTFin. eassumption. }\n  ", "def_ranges": [10, 0, 10, 54], "proof_ranges": [11, 0, 22, 10], "proof_steps": [{"text": "red.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply Fix.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply wf_R.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "constructor.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "revert H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eauto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHrightTrans; clear IHrightTrans.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "specialize (H1 _ H).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply RTFin.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eassumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Recur/Relation.v", "name": "wf_leftTrans", "text": "Theorem wf_leftTrans : well_founded (leftTrans R).\n  Proof.\n    red.\n    eapply Fix. eapply wf_R. clear.\n    intros. constructor. intros.\n    revert H.\n    induction H0.\n    { intros. eauto. }\n    { intros.\n      eapply IHleftTrans; clear IHleftTrans.\n      intros. eapply H1. auto.\n      eapply LTFin. auto. }\n  Defined.\n", "definition": " well_founded (leftTrans R).\n  ", "proof": "\n    red.\n    eapply Fix. eapply wf_R. clear.\n    intros. constructor. intros.\n    revert H.\n    induction H0.\n    { intros. eauto. }\n    { intros.\n      eapply IHleftTrans; clear IHleftTrans.\n      intros. eapply H1. auto.\n      eapply LTFin. auto. }\n  ", "def_ranges": [24, 0, 24, 52], "proof_ranges": [25, 0, 36, 10], "proof_steps": [{"text": "red.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply Fix.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply wf_R.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "constructor.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "revert H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eauto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply IHleftTrans; clear IHleftTrans.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply LTFin.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Core/Type.v", "name": "typeOk_from_equal", "text": "Theorem typeOk_from_equal  : typeOk (type_from_equal r).\n  Proof.\n    constructor; auto.\n    { simpl. red. auto. }\n  Qed.\n", "definition": " typeOk (type_from_equal r).\n  ", "proof": "\n    constructor; auto.\n    { simpl. red. auto. }\n  ", "def_ranges": [116, 0, 116, 58], "proof_ranges": [117, 0, 120, 6], "proof_steps": [{"text": "constructor; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Core/Type.v", "name": "typeOk_libniz", "text": "Theorem typeOk_libniz T : typeOk (type_libniz T).\nProof.\n  constructor; unfold equal, type_libniz; auto with typeclass_instances.\n  { split; exact I. }\nQed.\n", "definition": " typeOk (type_libniz T).\n", "proof": "\n  constructor; unfold equal, type_libniz; auto with typeclass_instances.\n  { split; exact I. }\n", "def_ranges": [123, 0, 123, 49], "proof_ranges": [124, 0, 127, 4], "proof_steps": [{"text": "constructor; unfold equal, type_libniz; auto with typeclass_instances.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; exact I.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Core/RelDec.v", "name": "rel_dec_eq_true", "text": "Theorem rel_dec_eq_true : forall x y,\n    eqt x y -> rel_dec x y = true.\n  Proof.\n    intros. eapply rel_dec_correct in H. assumption.\n  Qed.\n", "definition": " forall x y,\n    eqt x y -> rel_dec x y = true.\n  ", "proof": "\n    intros. eapply rel_dec_correct in H. assumption.\n  ", "def_ranges": [58, 0, 59, 34], "proof_ranges": [60, 0, 62, 6], "proof_steps": [{"text": "intros.", "goal_before": ["forall x y : T, eqt x y -> x ?[ eqt ] y = true"], "goal_after": ["x ?[ eqt ] y = true"], "proof_term_before": [], "proof_term_after": ["(fun (x y : T) (H : eqt x y) => ?Goal)"]}, {"text": "eapply rel_dec_correct in H.", "goal_before": ["x ?[ eqt ] y = true"], "goal_after": ["x ?[ eqt ] y = true"], "proof_term_before": ["(fun (x y : T) (H : eqt x y) => ?Goal)"], "proof_term_after": ["(fun (x y : T) (H : eqt x y) =>\n let H0 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n   fun x0 y0 : T =>\n   match rel_dec_correct x0 y0 with\n   | conj x1 x2 =>\n       (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n          (H0 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H0) x1 x2\n   end in\n let H1 : x ?[ eqt ] y = true := H0 x y H in ?Goal@{H:=H1})"]}, {"text": "assumption.", "goal_before": ["x ?[ eqt ] y = true"], "goal_after": [], "proof_term_before": ["(fun (x y : T) (H : eqt x y) =>\n let H0 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n   fun x0 y0 : T =>\n   match rel_dec_correct x0 y0 with\n   | conj x1 x2 =>\n       (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n          (H0 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H0) x1 x2\n   end in\n let H1 : x ?[ eqt ] y = true := H0 x y H in ?Goal@{H:=H1})"], "proof_term_after": ["(fun (x y : T) (H : eqt x y) =>\n let H0 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n   fun x0 y0 : T =>\n   match rel_dec_correct x0 y0 with\n   | conj x1 x2 =>\n       (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n          (H0 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H0) x1 x2\n   end in\n let H1 : x ?[ eqt ] y = true := H0 x y H in H1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : T) (H : eqt x y) =>\n let H0 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n   fun x0 y0 : T =>\n   match rel_dec_correct x0 y0 with\n   | conj x1 x2 =>\n       (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n          (H0 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H0) x1 x2\n   end in\n let H1 : x ?[ eqt ] y = true := H0 x y H in H1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Core/RelDec.v", "name": "rel_dec_neq_false", "text": "Theorem rel_dec_neq_false : forall x y,\n    ~eqt x y -> rel_dec x y = false.\n  Proof.\n    intros. remember (x ?[ eqt ] y).\n    symmetry in Heqb.\n    destruct b; try reflexivity.\n    exfalso. eapply (@rel_dec_correct _ _ _ rc) in Heqb. auto.\n  Qed.\n", "definition": " forall x y,\n    ~eqt x y -> rel_dec x y = false.\n  ", "proof": "\n    intros. remember (x ?[ eqt ] y).\n    symmetry in Heqb.\n    destruct b; try reflexivity.\n    exfalso. eapply (@rel_dec_correct _ _ _ rc) in Heqb. auto.\n  ", "def_ranges": [64, 0, 65, 36], "proof_ranges": [66, 0, 71, 6], "proof_steps": [{"text": "intros.", "goal_before": ["forall x y : T, ~ eqt x y -> x ?[ eqt ] y = false"], "goal_after": ["x ?[ eqt ] y = false"], "proof_term_before": [], "proof_term_after": ["(fun (x y : T) (H : ~ eqt x y) => ?Goal)"]}, {"text": "remember (x ?[ eqt ] y).", "goal_before": ["x ?[ eqt ] y = false"], "goal_after": ["b = false"], "proof_term_before": ["(fun (x y : T) (H : ~ eqt x y) => ?Goal)"], "proof_term_after": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in let Heqb : b = x ?[ eqt ] y := eq_refl in ?Goal)"]}, {"text": "symmetry in Heqb.", "goal_before": ["b = false"], "goal_after": ["b = false"], "proof_term_before": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in let Heqb : b = x ?[ eqt ] y := eq_refl in ?Goal)"], "proof_term_after": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b => ?Goal@{Heqb:=Heqb0}) H0)"]}, {"text": "destruct b; try reflexivity.", "goal_before": ["b = false"], "goal_after": ["true = false"], "proof_term_before": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b => ?Goal@{Heqb:=Heqb0}) H0)"], "proof_term_after": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b =>\n  (if b as b0 return (x ?[ eqt ] y = b0 -> b0 = false)\n   then fun Heqb1 : x ?[ eqt ] y = true => ?Goal@{Heqb:=Heqb1}\n   else fun _ : x ?[ eqt ] y = false => eq_refl) Heqb0) H0)"]}, {"text": "exfalso.", "goal_before": ["true = false"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b =>\n  (if b as b0 return (x ?[ eqt ] y = b0 -> b0 = false)\n   then fun Heqb1 : x ?[ eqt ] y = true => ?Goal@{Heqb:=Heqb1}\n   else fun _ : x ?[ eqt ] y = false => eq_refl) Heqb0) H0)"], "proof_term_after": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b =>\n  (if b as b0 return (x ?[ eqt ] y = b0 -> b0 = false)\n   then\n    fun Heqb1 : x ?[ eqt ] y = true =>\n    False_ind (true = false) ?Goal@{Heqb:=Heqb1}\n   else fun _ : x ?[ eqt ] y = false => eq_refl) Heqb0) H0)"]}, {"text": "eapply (@rel_dec_correct _ _ _ rc) in Heqb.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b =>\n  (if b as b0 return (x ?[ eqt ] y = b0 -> b0 = false)\n   then\n    fun Heqb1 : x ?[ eqt ] y = true =>\n    False_ind (true = false) ?Goal@{Heqb:=Heqb1}\n   else fun _ : x ?[ eqt ] y = false => eq_refl) Heqb0) H0)"], "proof_term_after": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b =>\n  (if b as b0 return (x ?[ eqt ] y = b0 -> b0 = false)\n   then\n    fun Heqb1 : x ?[ eqt ] y = true =>\n    False_ind (true = false)\n      (let H1 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H1 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H1) x1 x2\n         end in\n       let Heqb2 : eqt x y := H1 x y Heqb1 in ?Goal@{Heqb:=Heqb2})\n   else fun _ : x ?[ eqt ] y = false => eq_refl) Heqb0) H0)"]}, {"text": "auto.", "goal_before": ["False"], "goal_after": [], "proof_term_before": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b =>\n  (if b as b0 return (x ?[ eqt ] y = b0 -> b0 = false)\n   then\n    fun Heqb1 : x ?[ eqt ] y = true =>\n    False_ind (true = false)\n      (let H1 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H1 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H1) x1 x2\n         end in\n       let Heqb2 : eqt x y := H1 x y Heqb1 in ?Goal@{Heqb:=Heqb2})\n   else fun _ : x ?[ eqt ] y = false => eq_refl) Heqb0) H0)"], "proof_term_after": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b =>\n  (if b as b0 return (x ?[ eqt ] y = b0 -> b0 = false)\n   then\n    fun Heqb1 : x ?[ eqt ] y = true =>\n    False_ind (true = false)\n      (let H1 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H1 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H1) x1 x2\n         end in\n       let Heqb2 : eqt x y := H1 x y Heqb1 in H Heqb2)\n   else fun _ : x ?[ eqt ] y = false => eq_refl) Heqb0) H0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : T) (H : ~ eqt x y) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let H0 : x ?[ eqt ] y = b := eq_sym Heqb in\n (fun Heqb0 : x ?[ eqt ] y = b =>\n  (if b as b0 return (x ?[ eqt ] y = b0 -> b0 = false)\n   then\n    fun Heqb1 : x ?[ eqt ] y = true =>\n    False_ind (true = false)\n      (let H1 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H1 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H1) x1 x2\n         end in\n       let Heqb2 : eqt x y := H1 x y Heqb1 in H Heqb2)\n   else fun _ : x ?[ eqt ] y = false => eq_refl) Heqb0) H0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Core/RelDec.v", "name": "rel_dec_sym", "text": "Theorem rel_dec_sym : Symmetric eqt -> forall x y,\n    x ?[ eqt ] y = y ?[ eqt ] x.\n  Proof.\n    intros.\n    remember (x ?[ eqt ] y); remember (y ?[ eqt ] x); intuition.\n    destruct b; destruct b0; auto.\n    { symmetry in Heqb; symmetry in Heqb0.\n      eapply (@rel_dec_correct _ _ _ rc) in Heqb.\n      symmetry in Heqb.\n      eapply (@rel_dec_correct _ _ _ rc) in Heqb.\n      congruence. }\n    { symmetry in Heqb; symmetry in Heqb0.\n      eapply (@rel_dec_correct _ _ _ rc) in Heqb0.\n      symmetry in Heqb0.\n      eapply (@rel_dec_correct _ _ _ rc) in Heqb0.\n      congruence. }\n  Qed.\n", "definition": " Symmetric eqt -> forall x y,\n    x ?[ eqt ] y = y ?[ eqt ] x.\n  ", "proof": "\n    intros.\n    remember (x ?[ eqt ] y); remember (y ?[ eqt ] x); intuition.\n    destruct b; destruct b0; auto.\n    { symmetry in Heqb; symmetry in Heqb0.\n      eapply (@rel_dec_correct _ _ _ rc) in Heqb.\n      symmetry in Heqb.\n      eapply (@rel_dec_correct _ _ _ rc) in Heqb.\n      congruence. }\n    { symmetry in Heqb; symmetry in Heqb0.\n      eapply (@rel_dec_correct _ _ _ rc) in Heqb0.\n      symmetry in Heqb0.\n      eapply (@rel_dec_correct _ _ _ rc) in Heqb0.\n      congruence. }\n  ", "def_ranges": [73, 0, 74, 32], "proof_ranges": [75, 0, 89, 6], "proof_steps": [{"text": "intros.", "goal_before": ["Symmetric eqt -> forall x y : T, x ?[ eqt ] y = y ?[ eqt ] x"], "goal_after": ["x ?[ eqt ] y = y ?[ eqt ] x"], "proof_term_before": [], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) => ?Goal)"]}, {"text": "remember (x ?[ eqt ] y); remember (y ?[ eqt ] x); intuition.", "goal_before": ["x ?[ eqt ] y = y ?[ eqt ] x"], "goal_after": ["b = b0"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) => ?Goal)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in ?Goal)"]}, {"text": "destruct b; destruct b0; auto.", "goal_before": ["b = b0"], "goal_after": ["true = false", "false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in ?Goal)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2})\n     Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x => ?Goal0@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "symmetry in Heqb; symmetry in Heqb0.", "goal_before": ["true = false", "false = true"], "goal_after": ["true = false", "false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2})\n     Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x => ?Goal0@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false => ?Goal0@{Heqb:=Heqb3; Heqb0:=Heqb4})\n        H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "eapply (@rel_dec_correct _ _ _ rc) in Heqb.", "goal_before": ["true = false", "false = true"], "goal_after": ["true = false", "false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false => ?Goal0@{Heqb:=Heqb3; Heqb0:=Heqb4})\n        H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       ?Goal0@{Heqb:=Heqb5; Heqb0:=Heqb4}) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "symmetry in Heqb.", "goal_before": ["true = false", "false = true"], "goal_after": ["true = false", "false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       ?Goal0@{Heqb:=Heqb5; Heqb0:=Heqb4}) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       ?Goal0@{Heqb:=Heqb6; Heqb0:=Heqb4}) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "eapply (@rel_dec_correct _ _ _ rc) in Heqb.", "goal_before": ["true = false", "false = true"], "goal_after": ["true = false", "false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       ?Goal0@{Heqb:=Heqb6; Heqb0:=Heqb4}) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       ?Goal0@{Heqb:=Heqb7; Heqb0:=Heqb4}) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "congruence.", "goal_before": ["true = false", "false = true"], "goal_after": ["false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       ?Goal0@{Heqb:=Heqb7; Heqb0:=Heqb4}) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "symmetry in Heqb; symmetry in Heqb0.", "goal_before": ["false = true"], "goal_after": ["false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then fun Heqb2 : true = y ?[ eqt ] x => ?Goal@{Heqb:=Heqb1; Heqb0:=Heqb2}\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true => ?Goal@{Heqb:=Heqb3; Heqb0:=Heqb4})\n        H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "eapply (@rel_dec_correct _ _ _ rc) in Heqb0.", "goal_before": ["false = true"], "goal_after": ["false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true => ?Goal@{Heqb:=Heqb3; Heqb0:=Heqb4})\n        H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt y x := H2 y x Heqb4 in\n       ?Goal@{Heqb:=Heqb3; Heqb0:=Heqb5}) H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "symmetry in Heqb0.", "goal_before": ["false = true"], "goal_after": ["false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt y x := H2 y x Heqb4 in\n       ?Goal@{Heqb:=Heqb3; Heqb0:=Heqb5}) H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt y x := H2 y x Heqb4 in\n       let Heqb6 : eqt x y := symmetry Heqb5 in\n       ?Goal@{Heqb:=Heqb3; Heqb0:=Heqb6}) H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "eapply (@rel_dec_correct _ _ _ rc) in Heqb0.", "goal_before": ["false = true"], "goal_after": ["false = true"], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt y x := H2 y x Heqb4 in\n       let Heqb6 : eqt x y := symmetry Heqb5 in\n       ?Goal@{Heqb:=Heqb3; Heqb0:=Heqb6}) H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt y x := H2 y x Heqb4 in\n       let Heqb6 : eqt x y := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : x ?[ eqt ] y = true := H3 x y Heqb6 in\n       ?Goal@{Heqb:=Heqb3; Heqb0:=Heqb7}) H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "congruence.", "goal_before": ["false = true"], "goal_after": [], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt y x := H2 y x Heqb4 in\n       let Heqb6 : eqt x y := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : x ?[ eqt ] y = true := H3 x y Heqb6 in\n       ?Goal@{Heqb:=Heqb3; Heqb0:=Heqb7}) H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt y x := H2 y x Heqb4 in\n       let Heqb6 : eqt x y := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : x ?[ eqt ] y = true := H3 x y Heqb6 in\n       let Heq : true = false := eq_trans (eq_sym Heqb7) Heqb3 in\n       let H4 : False :=\n         eq_ind true (fun e : bool => if e then True else False) I false Heq\n         in\n       False_ind (false = true) H4) H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (H : Symmetric eqt) (x y : T) =>\n let b := x ?[ eqt ] y in\n let Heqb : b = x ?[ eqt ] y := eq_refl in\n let b0 := y ?[ eqt ] x in\n let Heqb0 : b0 = y ?[ eqt ] x := eq_refl in\n (if b as b1 return (b1 = x ?[ eqt ] y -> b1 = b0)\n  then\n   fun Heqb1 : true = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> true = b1)\n    then fun _ : true = y ?[ eqt ] x => eq_refl\n    else\n     fun Heqb2 : false = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = true := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = true =>\n      let H1 : y ?[ eqt ] x = false := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = false =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt x y := H2 x y Heqb3 in\n       let Heqb6 : eqt y x := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : y ?[ eqt ] x = true := H3 y x Heqb6 in\n       let Heq : false = true := eq_trans (eq_sym Heqb4) Heqb7 in\n       let H4 : False :=\n         eq_ind false (fun e : bool => if e then False else True) I true Heq\n         in\n       False_ind (true = false) H4) H1) H0) Heqb0\n  else\n   fun Heqb1 : false = x ?[ eqt ] y =>\n   (if b0 as b1 return (b1 = y ?[ eqt ] x -> false = b1)\n    then\n     fun Heqb2 : true = y ?[ eqt ] x =>\n     let H0 : x ?[ eqt ] y = false := eq_sym Heqb1 in\n     (fun Heqb3 : x ?[ eqt ] y = false =>\n      let H1 : y ?[ eqt ] x = true := eq_sym Heqb2 in\n      (fun Heqb4 : y ?[ eqt ] x = true =>\n       let H2 : forall x0 y0 : T, x0 ?[ eqt ] y0 = true -> eqt x0 y0 :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (H2 : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (_ : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H2) x1 x2\n         end in\n       let Heqb5 : eqt y x := H2 y x Heqb4 in\n       let Heqb6 : eqt x y := symmetry Heqb5 in\n       let H3 : forall x0 y0 : T, eqt x0 y0 -> x0 ?[ eqt ] y0 = true :=\n         fun x0 y0 : T =>\n         match rel_dec_correct x0 y0 with\n         | conj x1 x2 =>\n             (fun (_ : x0 ?[ eqt ] y0 = true -> eqt x0 y0)\n                (H3 : eqt x0 y0 -> x0 ?[ eqt ] y0 = true) => H3) x1 x2\n         end in\n       let Heqb7 : x ?[ eqt ] y = true := H3 x y Heqb6 in\n       let Heq : true = false := eq_trans (eq_sym Heqb7) Heqb3 in\n       let H4 : False :=\n         eq_ind true (fun e : bool => if e then True else False) I false Heq\n         in\n       False_ind (false = true) H4) H1) H0\n    else fun _ : false = y ?[ eqt ] x => eq_refl) Heqb0) Heqb)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Core/EquivDec.v", "name": "EquivDec_refl_left", "text": "Theorem EquivDec_refl_left {T : Type} {c : EqDec T (@eq T)} :\n  forall (n : T), equiv_dec n n = left (refl_equal _).\nProof.\n  intros. destruct (equiv_dec n n); try congruence.\n  Require Eqdep_dec.\n  rewrite (Eqdep_dec.UIP_dec (A := T) (@equiv_dec _ _ _ c) e (refl_equal _)).\n  reflexivity.\nQed.\n", "definition": " Type} {c : EqDec T (@eq T)} :\n  forall (n : T), equiv_dec n n = left (refl_equal _).\n", "proof": "\n  intros. destruct (equiv_dec n n); try congruence.\n  Require Eqdep_dec.\n  rewrite (Eqdep_dec.UIP_dec (A := T) (@equiv_dec _ _ _ c) e (refl_equal _)).\n  reflexivity.\n", "def_ranges": [2, 0, 3, 54], "proof_ranges": [4, 0, 9, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall n : T, (n == n) = left eq_refl"], "goal_after": ["(n == n) = left eq_refl"], "proof_term_before": [], "proof_term_after": ["(fun (T : Type) (c : EqDec T eq) (n : T) => ?Goal)"]}, {"text": "destruct (equiv_dec n n); try congruence.", "goal_before": ["(n == n) = left eq_refl"], "goal_after": ["left e = left eq_refl"], "proof_term_before": ["(fun (T : Type) (c : EqDec T eq) (n : T) => ?Goal)"], "proof_term_after": ["(fun (T : Type) (c : EqDec T eq) (n : T) =>\n let s := n == n in\n match s as s0 return (s0 = left eq_refl) with\n | left a => (fun e : n === n => ?Goal) a\n | right b =>\n     (fun c0 : n =/= n =>\n      let Heq : n = n := eq_refl in\n      False_ind (right c0 = left eq_refl) (c0 Heq)) b\n end)"]}, {"text": "Require Eqdep_dec.", "goal_before": ["left e = left eq_refl"], "goal_after": ["left e = left eq_refl"], "proof_term_before": ["(fun (T : Type) (c : EqDec T eq) (n : T) =>\n let s := n == n in\n match s as s0 return (s0 = left eq_refl) with\n | left a => (fun e : n === n => ?Goal) a\n | right b =>\n     (fun c0 : n =/= n =>\n      let Heq : n = n := eq_refl in\n      False_ind (right c0 = left eq_refl) (c0 Heq)) b\n end)"], "proof_term_after": ["(fun (T : Type) (c : EqDec T eq) (n : T) =>\n let s := n == n in\n match s as s0 return (s0 = left eq_refl) with\n | left a => (fun e : n === n => ?Goal) a\n | right b =>\n     (fun c0 : n =/= n =>\n      let Heq : n = n := eq_refl in\n      False_ind (right c0 = left eq_refl) (c0 Heq)) b\n end)"]}, {"text": "rewrite (Eqdep_dec.UIP_dec (A := T) (@equiv_dec _ _ _ c) e (refl_equal _)).", "goal_before": ["left e = left eq_refl"], "goal_after": ["left e = left eq_refl"], "proof_term_before": ["(fun (T : Type) (c : EqDec T eq) (n : T) =>\n let s := n == n in\n match s as s0 return (s0 = left eq_refl) with\n | left a => (fun e : n === n => ?Goal) a\n | right b =>\n     (fun c0 : n =/= n =>\n      let Heq : n = n := eq_refl in\n      False_ind (right c0 = left eq_refl) (c0 Heq)) b\n end)"], "proof_term_after": []}, {"text": "reflexivity.", "goal_before": ["left eq_refl = left eq_refl"], "goal_after": ["left eq_refl = left eq_refl"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": ["EquivDec_refl_left is defined"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Relations/TransitiveClosure.v", "name": "leftTrans_rightTrans", "text": "Theorem leftTrans_rightTrans : forall x y,\n    leftTrans x y <-> rightTrans x y.\n  Proof.\n    split.\n    { destruct 1. apply RTFin; assumption.\n      eapply leftTrans_rightTrans_acc. eassumption. eapply RTFin. eassumption. }\n    { destruct 1. apply LTFin. assumption.\n      eapply rightTrans_leftTrans_acc. eassumption. eapply LTFin. eassumption. }\n  Qed.\n", "definition": " forall x y,\n    leftTrans x y <-> rightTrans x y.\n  ", "proof": "\n    split.\n    { destruct 1. apply RTFin; assumption.\n      eapply leftTrans_rightTrans_acc. eassumption. eapply RTFin. eassumption. }\n    { destruct 1. apply LTFin. assumption.\n      eapply rightTrans_leftTrans_acc. eassumption. eapply LTFin. eassumption. }\n  ", "def_ranges": [66, 0, 67, 37], "proof_ranges": [68, 0, 74, 6], "proof_steps": [{"text": "split.", "goal_before": ["forall x y : T, leftTrans x y <-> rightTrans x y"], "goal_after": ["leftTrans x y -> rightTrans x y", "rightTrans x y -> leftTrans x y"], "proof_term_before": [], "proof_term_after": ["(fun x y : T => conj ?Goal ?Goal0)"]}, {"text": "destruct 1.", "goal_before": ["leftTrans x y -> rightTrans x y", "rightTrans x y -> leftTrans x y"], "goal_after": ["rightTrans x y", "rightTrans x y", "rightTrans x y -> leftTrans x y"], "proof_term_before": ["(fun x y : T => conj ?Goal ?Goal0)"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => ?Goal0@{H:=H0}) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         ?Goal1@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end) ?Goal)"]}, {"text": "apply RTFin; assumption.", "goal_before": ["rightTrans x y", "rightTrans x y", "rightTrans x y -> leftTrans x y"], "goal_after": ["rightTrans x y", "rightTrans x y -> leftTrans x y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => ?Goal0@{H:=H0}) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         ?Goal1@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end) ?Goal)"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         ?Goal0@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end) ?Goal)"]}, {"text": "eapply leftTrans_rightTrans_acc.", "goal_before": ["rightTrans x y", "rightTrans x y -> leftTrans x y"], "goal_after": ["leftTrans ?y y", "rightTrans x ?y", "rightTrans x y -> leftTrans x y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         ?Goal0@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end) ?Goal)"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc ?Goal0@{z:=z0; H:=H0; H0:=H1}\n           ?Goal1@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end) ?Goal)"]}, {"text": "eassumption.", "goal_before": ["leftTrans ?y y", "rightTrans x ?y", "rightTrans x y -> leftTrans x y"], "goal_after": ["rightTrans x z", "rightTrans x y -> leftTrans x y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc ?Goal0@{z:=z0; H:=H0; H0:=H1}\n           ?Goal1@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end) ?Goal)"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 ?Goal0@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end) ?Goal)"]}, {"text": "eapply RTFin.", "goal_before": ["rightTrans x z", "rightTrans x y -> leftTrans x y"], "goal_after": ["R x z", "rightTrans x y -> leftTrans x y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 ?Goal0@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end) ?Goal)"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin ?Goal0@{z:=z0; H:=H0; H0:=H1})) z\n          x0 x1\n    end) ?Goal)"]}, {"text": "eassumption.", "goal_before": ["R x z", "rightTrans x y -> leftTrans x y"], "goal_after": ["rightTrans x y -> leftTrans x y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin ?Goal0@{z:=z0; H:=H0; H0:=H1})) z\n          x0 x1\n    end) ?Goal)"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end) ?Goal)"]}, {"text": "destruct 1.", "goal_before": ["rightTrans x y -> leftTrans x y"], "goal_after": ["leftTrans x y", "leftTrans x y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end) ?Goal)"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => ?Goal@{H:=H0}) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         ?Goal0@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"]}, {"text": "apply LTFin.", "goal_before": ["leftTrans x y", "leftTrans x y"], "goal_after": ["R x y", "leftTrans x y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => ?Goal@{H:=H0}) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         ?Goal0@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin ?Goal0@{H:=H0}) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         ?Goal@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"]}, {"text": "assumption.", "goal_before": ["R x y", "leftTrans x y"], "goal_after": ["leftTrans x y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin ?Goal0@{H:=H0}) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         ?Goal@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         ?Goal@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"]}, {"text": "eapply rightTrans_leftTrans_acc.", "goal_before": ["leftTrans x y"], "goal_after": ["rightTrans x ?y", "leftTrans ?y y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         ?Goal@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         rightTrans_leftTrans_acc ?Goal@{z:=z0; H:=H0; H0:=H1}\n           ?Goal0@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"]}, {"text": "eassumption.", "goal_before": ["rightTrans x ?y", "leftTrans ?y y"], "goal_after": ["leftTrans z y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         rightTrans_leftTrans_acc ?Goal@{z:=z0; H:=H0; H0:=H1}\n           ?Goal0@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         rightTrans_leftTrans_acc H0 ?Goal@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"]}, {"text": "eapply LTFin.", "goal_before": ["leftTrans z y"], "goal_after": ["R z y"], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         rightTrans_leftTrans_acc H0 ?Goal@{z:=z0; H:=H0; H0:=H1}) z x0 x1\n    end))"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         rightTrans_leftTrans_acc H0 (LTFin ?Goal@{z:=z0; H:=H0; H0:=H1})) z\n          x0 x1\n    end))"]}, {"text": "eassumption.", "goal_before": ["R z y"], "goal_after": [], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         rightTrans_leftTrans_acc H0 (LTFin ?Goal@{z:=z0; H:=H0; H0:=H1})) z\n          x0 x1\n    end))"], "proof_term_after": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         rightTrans_leftTrans_acc H0 (LTFin H1)) z x0 x1\n    end))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x y : T =>\n conj\n   (fun H : leftTrans x y =>\n    match H with\n    | LTFin x0 => (fun H0 : R x y => RTFin H0) x0\n    | @LTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : R x z0) (H1 : leftTrans z0 y) =>\n         leftTrans_rightTrans_acc H1 (RTFin H0)) z x0 x1\n    end)\n   (fun H : rightTrans x y =>\n    match H with\n    | RTFin x0 => (fun H0 : R x y => LTFin H0) x0\n    | @RTStep _ _ z x0 x1 =>\n        (fun (z0 : T) (H0 : rightTrans x z0) (H1 : R z0 y) =>\n         rightTrans_leftTrans_acc H0 (LTFin H1)) z x0 x1\n    end))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Relations/TransitiveClosure.v", "name": "makeTrans_leftTrans", "text": "Theorem makeTrans_leftTrans : forall s s',\n    makeTrans s s' <-> leftTrans s s'.\n  Proof.\n    split; intros.\n    { induction H. eapply LTFin. eassumption.\n      eapply leftTrans_trans; eassumption. }\n    { apply leftTrans_makeTrans_acc. assumption. }\n  Qed.\n", "definition": " forall s s',\n    makeTrans s s' <-> leftTrans s s'.\n  ", "proof": "\n    split; intros.\n    { induction H. eapply LTFin. eassumption.\n      eapply leftTrans_trans; eassumption. }\n    { apply leftTrans_makeTrans_acc. assumption. }\n  ", "def_ranges": [89, 0, 90, 38], "proof_ranges": [91, 0, 96, 6], "proof_steps": [{"text": "split; intros.", "goal_before": ["forall s s' : T, makeTrans s s' <-> leftTrans s s'"], "goal_after": ["leftTrans s s'", "makeTrans s s'"], "proof_term_before": [], "proof_term_after": ["(fun s s' : T =>\n conj (fun H : makeTrans s s' => ?Goal) (fun H : leftTrans s s' => ?Goal0))"]}, {"text": "induction H.", "goal_before": ["leftTrans s s'", "makeTrans s s'"], "goal_after": ["leftTrans x y", "leftTrans x y", "makeTrans s s'"], "proof_term_before": ["(fun s s' : T =>\n conj (fun H : makeTrans s s' => ?Goal) (fun H : leftTrans s s' => ?Goal0))"], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => ?Goal0@{H:=H0})\n      (fun (x y z : T) (H0 : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (H1 : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       ?Goal1@{H:=H0; H0:=H1}) H) (fun H : leftTrans s s' => ?Goal))"]}, {"text": "eapply LTFin.", "goal_before": ["leftTrans x y", "leftTrans x y", "makeTrans s s'"], "goal_after": ["R x y", "leftTrans x y", "makeTrans s s'"], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => ?Goal0@{H:=H0})\n      (fun (x y z : T) (H0 : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (H1 : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       ?Goal1@{H:=H0; H0:=H1}) H) (fun H : leftTrans s s' => ?Goal))"], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin ?Goal1@{H:=H0})\n      (fun (x y z : T) (H0 : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (H1 : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       ?Goal0@{H:=H0; H0:=H1}) H) (fun H : leftTrans s s' => ?Goal))"]}, {"text": "eassumption.", "goal_before": ["R x y", "leftTrans x y", "makeTrans s s'"], "goal_after": ["leftTrans x y", "makeTrans s s'"], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin ?Goal1@{H:=H0})\n      (fun (x y z : T) (H0 : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (H1 : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       ?Goal0@{H:=H0; H0:=H1}) H) (fun H : leftTrans s s' => ?Goal))"], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin H0)\n      (fun (x y z : T) (H0 : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (H1 : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       ?Goal0@{H:=H0; H0:=H1}) H) (fun H : leftTrans s s' => ?Goal))"]}, {"text": "eapply leftTrans_trans; eassumption.", "goal_before": ["leftTrans x y", "makeTrans s s'"], "goal_after": ["makeTrans s s'"], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin H0)\n      (fun (x y z : T) (H0 : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (H1 : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       ?Goal0@{H:=H0; H0:=H1}) H) (fun H : leftTrans s s' => ?Goal))"], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin H0)\n      (fun (x y z : T) (_ : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (_ : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       leftTrans_trans IHmakeTrans1 IHmakeTrans2) H)\n   (fun H : leftTrans s s' => ?Goal))"]}, {"text": "apply leftTrans_makeTrans_acc.", "goal_before": ["makeTrans s s'"], "goal_after": ["leftTrans s s'"], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin H0)\n      (fun (x y z : T) (_ : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (_ : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       leftTrans_trans IHmakeTrans1 IHmakeTrans2) H)\n   (fun H : leftTrans s s' => ?Goal))"], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin H0)\n      (fun (x y z : T) (_ : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (_ : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       leftTrans_trans IHmakeTrans1 IHmakeTrans2) H)\n   (fun H : leftTrans s s' => leftTrans_makeTrans_acc ?Goal))"]}, {"text": "assumption.", "goal_before": ["leftTrans s s'"], "goal_after": [], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin H0)\n      (fun (x y z : T) (_ : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (_ : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       leftTrans_trans IHmakeTrans1 IHmakeTrans2) H)\n   (fun H : leftTrans s s' => leftTrans_makeTrans_acc ?Goal))"], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin H0)\n      (fun (x y z : T) (_ : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (_ : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       leftTrans_trans IHmakeTrans1 IHmakeTrans2) H)\n   (fun H : leftTrans s s' => leftTrans_makeTrans_acc H))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans s s' =>\n    makeTrans_ind (fun s0 s'0 : T => leftTrans s0 s'0)\n      (fun (x y : T) (H0 : R x y) => LTFin H0)\n      (fun (x y z : T) (_ : makeTrans x z) (IHmakeTrans1 : leftTrans x z)\n         (_ : makeTrans z y) (IHmakeTrans2 : leftTrans z y) =>\n       leftTrans_trans IHmakeTrans1 IHmakeTrans2) H)\n   (fun H : leftTrans s s' => leftTrans_makeTrans_acc H))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Relations/TransitiveClosure.v", "name": "makeTrans_rightTrans", "text": "Theorem makeTrans_rightTrans : forall s s',\n    makeTrans s s' <-> rightTrans s s'.\n  Proof.\n    intros. etransitivity. apply makeTrans_leftTrans. apply leftTrans_rightTrans.\n  Qed.\n", "definition": " forall s s',\n    makeTrans s s' <-> rightTrans s s'.\n  ", "proof": "\n    intros. etransitivity. apply makeTrans_leftTrans. apply leftTrans_rightTrans.\n  ", "def_ranges": [98, 0, 99, 39], "proof_ranges": [100, 0, 102, 6], "proof_steps": [{"text": "intros.", "goal_before": ["forall s s' : T, makeTrans s s' <-> rightTrans s s'"], "goal_after": ["makeTrans s s' <-> rightTrans s s'"], "proof_term_before": [], "proof_term_after": ["(fun s s' : T => ?Goal)"]}, {"text": "etransitivity.", "goal_before": ["makeTrans s s' <-> rightTrans s s'"], "goal_after": ["makeTrans s s' <-> ?y", "?y <-> rightTrans s s'"], "proof_term_before": ["(fun s s' : T => ?Goal)"], "proof_term_after": ["(fun s s' : T => transitivity ?Goal ?Goal0)"]}, {"text": "apply makeTrans_leftTrans.", "goal_before": ["makeTrans s s' <-> ?y", "?y <-> rightTrans s s'"], "goal_after": ["leftTrans s s' <-> rightTrans s s'"], "proof_term_before": ["(fun s s' : T => transitivity ?Goal ?Goal0)"], "proof_term_after": ["(fun s s' : T => transitivity (makeTrans_leftTrans s s') ?Goal)"]}, {"text": "apply leftTrans_rightTrans.", "goal_before": ["leftTrans s s' <-> rightTrans s s'"], "goal_after": [], "proof_term_before": ["(fun s s' : T => transitivity (makeTrans_leftTrans s s') ?Goal)"], "proof_term_after": ["(fun s s' : T =>\n transitivity (makeTrans_leftTrans s s') (leftTrans_rightTrans s s'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun s s' : T =>\n transitivity (makeTrans_leftTrans s s') (leftTrans_rightTrans s s'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Relations/TransitiveClosure.v", "name": "makeTrans_idem", "text": "Theorem makeTrans_idem : forall s s',\n    makeTrans (makeTrans R) s s' <-> makeTrans R s s'.\n  Proof.\n    split.\n    { induction 1; eauto using TTrans. }\n    { eapply TStep. }\n  Qed.\n", "definition": " forall s s',\n    makeTrans (makeTrans R) s s' <-> makeTrans R s s'.\n  ", "proof": "\n    split.\n    { induction 1; eauto using TTrans. }\n    { eapply TStep. }\n  ", "def_ranges": [117, 0, 118, 54], "proof_ranges": [119, 0, 123, 6], "proof_steps": [{"text": "split.", "goal_before": ["forall s s' : T, makeTrans (makeTrans R) s s' <-> makeTrans R s s'"], "goal_after": ["makeTrans (makeTrans R) s s' -> makeTrans R s s'", "makeTrans R s s' -> makeTrans (makeTrans R) s s'"], "proof_term_before": [], "proof_term_after": ["(fun s s' : T => conj ?Goal ?Goal0)"]}, {"text": "induction 1; eauto using TTrans.", "goal_before": ["makeTrans (makeTrans R) s s' -> makeTrans R s s'", "makeTrans R s s' -> makeTrans (makeTrans R) s s'"], "goal_after": ["makeTrans R s s' -> makeTrans (makeTrans R) s s'"], "proof_term_before": ["(fun s s' : T => conj ?Goal ?Goal0)"], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans (makeTrans R) s s' =>\n    makeTrans_ind (fun s0 s'0 : T => makeTrans R s0 s'0)\n      (fun (x y : T) (H0 : makeTrans R x y) => H0)\n      (fun (x y z : T) (_ : makeTrans (makeTrans R) x z)\n         (IHmakeTrans1 : makeTrans R x z) (_ : makeTrans (makeTrans R) z y)\n         (IHmakeTrans2 : makeTrans R z y) => TTrans IHmakeTrans1 IHmakeTrans2)\n      H) ?Goal)"]}, {"text": "eapply TStep.", "goal_before": ["makeTrans R s s' -> makeTrans (makeTrans R) s s'"], "goal_after": [], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans (makeTrans R) s s' =>\n    makeTrans_ind (fun s0 s'0 : T => makeTrans R s0 s'0)\n      (fun (x y : T) (H0 : makeTrans R x y) => H0)\n      (fun (x y z : T) (_ : makeTrans (makeTrans R) x z)\n         (IHmakeTrans1 : makeTrans R x z) (_ : makeTrans (makeTrans R) z y)\n         (IHmakeTrans2 : makeTrans R z y) => TTrans IHmakeTrans1 IHmakeTrans2)\n      H) ?Goal)"], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans (makeTrans R) s s' =>\n    makeTrans_ind (fun s0 s'0 : T => makeTrans R s0 s'0)\n      (fun (x y : T) (H0 : makeTrans R x y) => H0)\n      (fun (x y z : T) (_ : makeTrans (makeTrans R) x z)\n         (IHmakeTrans1 : makeTrans R x z) (_ : makeTrans (makeTrans R) z y)\n         (IHmakeTrans2 : makeTrans R z y) => TTrans IHmakeTrans1 IHmakeTrans2)\n      H) (TStep (makeTrans R) s s'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeTrans (makeTrans R) s s' =>\n    makeTrans_ind (fun s0 s'0 : T => makeTrans R s0 s'0)\n      (fun (x y : T) (H0 : makeTrans R x y) => H0)\n      (fun (x y z : T) (_ : makeTrans (makeTrans R) x z)\n         (IHmakeTrans1 : makeTrans R x z) (_ : makeTrans (makeTrans R) z y)\n         (IHmakeTrans2 : makeTrans R z y) => TTrans IHmakeTrans1 IHmakeTrans2)\n      H) (TStep (makeTrans R) s s'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Relations/TransitiveClosure.v", "name": "makeTrans_makeRefl_comm", "text": "Theorem makeTrans_makeRefl_comm : forall s s',\n    makeTrans (makeRefl R) s s' <-> makeRefl (makeTrans R) s s'.\n  Proof.\n    split.\n    { induction 1;\n      repeat match goal with\n               | [ H : makeRefl _ _ _ |- _ ] => inversion H; clear H; subst\n             end; eauto using RRefl, RStep, TStep, TTrans. }\n    { intros. inversion H; clear H; subst; auto. apply TStep. apply RRefl.\n      induction H0; eauto using RStep, TStep, TTrans. }\n  Qed.\n", "definition": " forall s s',\n    makeTrans (makeRefl R) s s' <-> makeRefl (makeTrans R) s s'.\n  ", "proof": "\n    split.\n    { induction 1;\n      repeat match goal with\n               | [ H : makeRefl _ _ _ |- _ ] => inversion H; clear H; subst\n             end; eauto using RRefl, RStep, TStep, TTrans. }\n    { intros. inversion H; clear H; subst; auto. apply TStep. apply RRefl.\n      induction H0; eauto using RStep, TStep, TTrans. }\n  ", "def_ranges": [125, 0, 126, 64], "proof_ranges": [127, 0, 135, 6], "proof_steps": [{"text": "split.", "goal_before": ["forall s s' : T, makeTrans (makeRefl R) s s' <-> makeRefl (makeTrans R) s s'"], "goal_after": ["makeTrans (makeRefl R) s s' -> makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": [], "proof_term_after": ["(fun s s' : T => conj ?Goal ?Goal0)"]}, {"text": "induction 1;", "goal_before": ["makeTrans (makeRefl R) s s' -> makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "goal_after": ["makeTrans (makeRefl R) s s' -> makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": ["(fun s s' : T => conj ?Goal ?Goal0)"], "proof_term_after": []}, {"text": "repeat match goal with", "goal_before": ["makeTrans (makeRefl R) s s' -> makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "goal_after": ["makeTrans (makeRefl R) s s' -> makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": [], "proof_term_after": []}, {"text": "| [ H : makeRefl _ _ _ |- _ ] => inversion H; clear H; subst", "goal_before": ["makeTrans (makeRefl R) s s' -> makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "goal_after": ["makeTrans (makeRefl R) s s' -> makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": [], "proof_term_after": []}, {"text": "end; eauto using RRefl, RStep, TStep, TTrans.", "goal_before": ["makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "goal_after": ["makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": ["makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "goal_after": ["makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": [], "proof_term_after": []}, {"text": "inversion H; clear H; subst; auto.", "goal_before": ["makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "goal_after": ["makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply TStep.", "goal_before": ["makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "goal_after": ["makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply RRefl.", "goal_before": ["makeRefl (makeTrans R) s s", "makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "goal_after": ["makeRefl (makeTrans R) s s", "makeRefl (makeTrans R) s s'", "makeRefl (makeTrans R) s s' -> makeTrans (makeRefl R) s s'"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Relations/TransitiveClosure.v", "name": "makeRefl_idem", "text": "Theorem makeRefl_idem : forall s s',\n    makeRefl (makeRefl R) s s' <-> makeRefl R s s'.\n  Proof.\n    split; inversion 1; subst; eauto using RStep, RRefl.\n  Qed.\n", "definition": " forall s s',\n    makeRefl (makeRefl R) s s' <-> makeRefl R s s'.\n  ", "proof": "\n    split; inversion 1; subst; eauto using RStep, RRefl.\n  ", "def_ranges": [137, 0, 138, 51], "proof_ranges": [139, 0, 141, 6], "proof_steps": [{"text": "split; inversion 1; subst; eauto using RStep, RRefl.", "goal_before": ["forall s s' : T, makeRefl (makeRefl R) s s' <-> makeRefl R s s'"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun s s' : T =>\n conj\n   (fun H : makeRefl (makeRefl R) s s' =>\n    let H0 : s' = s' -> makeRefl R s s' :=\n      match H in (makeRefl _ _ t) return (t = s' -> makeRefl R s s') with\n      | @RRefl _ _ _ =>\n          fun H0 : s = s' =>\n          (fun H1 : s = s' =>\n           let H2 : s = s' := H1 in\n           eq_ind_r (fun t : T => makeRefl R t s')\n             (eq_ind_r\n                (fun s0 : T =>\n                 makeRefl (makeRefl R) s0 s' -> makeRefl R s' s')\n                (fun _ : makeRefl (makeRefl R) s' s' => RRefl R s') H1 H) H2)\n            H0\n      | @RStep _ _ _ y x =>\n          (fun (y0 : T) (H0 : makeRefl R s y0) (H1 : y0 = s') =>\n           (fun H2 : y0 = s' =>\n            let H3 : y0 = s' := H2 in\n            eq_ind_r (fun t : T => makeRefl R s t -> makeRefl R s s')\n              (fun H4 : makeRefl R s s' => H4) H3) H1 H0) y x\n      end in\n    H0 eq_refl)\n   (fun H : makeRefl R s s' =>\n    let H0 : s' = s' -> makeRefl (makeRefl R) s s' :=\n      match\n        H in (makeRefl _ _ t) return (t = s' -> makeRefl (makeRefl R) s s')\n      with\n      | @RRefl _ _ _ =>\n          fun H0 : s = s' =>\n          (fun H1 : s = s' =>\n           let H2 : s = s' := H1 in\n           eq_ind_r (fun t : T => makeRefl (makeRefl R) t s')\n             (eq_ind_r\n                (fun s0 : T =>\n                 makeRefl R s0 s' -> makeRefl (makeRefl R) s' s')\n                (fun _ : makeRefl R s' s' => RRefl (makeRefl R) s') H1 H) H2)\n            H0\n      | @RStep _ _ _ y x =>\n          (fun (y0 : T) (H0 : R s y0) (H1 : y0 = s') =>\n           (fun H2 : y0 = s' =>\n            let H3 : y0 = s' := H2 in\n            eq_ind_r (fun t : T => R s t -> makeRefl (makeRefl R) s s')\n              (fun _ : R s s' => RStep (makeRefl R) s s' H) H3) H1 H0) y x\n      end in\n    H0 eq_refl))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun s s' : T =>\n conj\n   (fun H : makeRefl (makeRefl R) s s' =>\n    let H0 : s' = s' -> makeRefl R s s' :=\n      match H in (makeRefl _ _ t) return (t = s' -> makeRefl R s s') with\n      | @RRefl _ _ _ =>\n          fun H0 : s = s' =>\n          (fun H1 : s = s' =>\n           let H2 : s = s' := H1 in\n           eq_ind_r (fun t : T => makeRefl R t s')\n             (eq_ind_r\n                (fun s0 : T =>\n                 makeRefl (makeRefl R) s0 s' -> makeRefl R s' s')\n                (fun _ : makeRefl (makeRefl R) s' s' => RRefl R s') H1 H) H2)\n            H0\n      | @RStep _ _ _ y x =>\n          (fun (y0 : T) (H0 : makeRefl R s y0) (H1 : y0 = s') =>\n           (fun H2 : y0 = s' =>\n            let H3 : y0 = s' := H2 in\n            eq_ind_r (fun t : T => makeRefl R s t -> makeRefl R s s')\n              (fun H4 : makeRefl R s s' => H4) H3) H1 H0) y x\n      end in\n    H0 eq_refl)\n   (fun H : makeRefl R s s' =>\n    let H0 : s' = s' -> makeRefl (makeRefl R) s s' :=\n      match\n        H in (makeRefl _ _ t) return (t = s' -> makeRefl (makeRefl R) s s')\n      with\n      | @RRefl _ _ _ =>\n          fun H0 : s = s' =>\n          (fun H1 : s = s' =>\n           let H2 : s = s' := H1 in\n           eq_ind_r (fun t : T => makeRefl (makeRefl R) t s')\n             (eq_ind_r\n                (fun s0 : T =>\n                 makeRefl R s0 s' -> makeRefl (makeRefl R) s' s')\n                (fun _ : makeRefl R s' s' => RRefl (makeRefl R) s') H1 H) H2)\n            H0\n      | @RStep _ _ _ y x =>\n          (fun (y0 : T) (H0 : R s y0) (H1 : y0 = s') =>\n           (fun H2 : y0 = s' =>\n            let H3 : y0 = s' := H2 in\n            eq_ind_r (fun t : T => R s t -> makeRefl (makeRefl R) s s')\n              (fun _ : R s s' => RStep (makeRefl R) s s' H) H3) H1 H0) y x\n      end in\n    H0 eq_refl))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Generic/DerivingData.v", "name": "dataList_to_list", "text": "Theorem dataList_to_list : forall T (x : dataD (dataList T)), list T.\n  simpl. intros.\n  destruct x. destruct x.\n  apply nil.\n  simpl in *.\n  apply (fst d :: snd d).\nDefined.\n", "definition": " forall T (x : dataD (dataList T)), list T.", "proof": "\n  simpl. intros.\n  destruct x. destruct x.\n  apply nil.\n  simpl in *.\n  apply (fst d :: snd d).\n", "def_ranges": [29, 0, 29, 69], "proof_ranges": [30, 0, 35, 8], "proof_steps": [{"text": "simpl.", "goal_before": ["forall T : Type, dataD (dataList T) -> list T"], "goal_after": ["forall T : Type,\n{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))} ->\nlist T"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall T : Type, dataD (dataList T) -> list T)"]}, {"text": "intros.", "goal_before": ["forall T : Type,\n{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))} ->\nlist T"], "goal_after": ["list T"], "proof_term_before": ["(?Goal : forall T : Type, dataD (dataList T) -> list T)"], "proof_term_after": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) => \n  ?Goal)\n :\n forall T : Type, dataD (dataList T) -> list T)"]}, {"text": "destruct x.", "goal_before": ["list T"], "goal_after": ["list T"], "proof_term_before": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) => \n  ?Goal)\n :\n forall T : Type, dataD (dataList T) -> list T)"], "proof_term_after": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) => \n   ?Goal@{x:=x1}) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"]}, {"text": "destruct x.", "goal_before": ["list T"], "goal_after": ["list T", "list T"], "proof_term_before": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) => \n   ?Goal@{x:=x1}) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"], "proof_term_after": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) =>\n   (if x1 as b\n     return\n       (dataD\n          (if b\n           then Inj (fun _ : unit => list T) unit\n           else\n            Prod (Inj (fun _ : unit => list T) T)\n              (Get (fun _ : unit => list T) tt)) -> \n        list T)\n    then fun d0 : dataD (Inj (fun _ : unit => list T) unit) => ?Goal@{d:=d0}\n    else\n     fun\n       d0 : dataD\n              (Prod (Inj (fun _ : unit => list T) T)\n                 (Get (fun _ : unit => list T) tt)) => \n     ?Goal0@{d:=d0}) d) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"]}, {"text": "apply nil.", "goal_before": ["list T", "list T"], "goal_after": ["list T"], "proof_term_before": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) =>\n   (if x1 as b\n     return\n       (dataD\n          (if b\n           then Inj (fun _ : unit => list T) unit\n           else\n            Prod (Inj (fun _ : unit => list T) T)\n              (Get (fun _ : unit => list T) tt)) -> \n        list T)\n    then fun d0 : dataD (Inj (fun _ : unit => list T) unit) => ?Goal@{d:=d0}\n    else\n     fun\n       d0 : dataD\n              (Prod (Inj (fun _ : unit => list T) T)\n                 (Get (fun _ : unit => list T) tt)) => \n     ?Goal0@{d:=d0}) d) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"], "proof_term_after": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) =>\n   (if x1 as b\n     return\n       (dataD\n          (if b\n           then Inj (fun _ : unit => list T) unit\n           else\n            Prod (Inj (fun _ : unit => list T) T)\n              (Get (fun _ : unit => list T) tt)) -> \n        list T)\n    then fun _ : dataD (Inj (fun _ : unit => list T) unit) => nil\n    else\n     fun\n       d0 : dataD\n              (Prod (Inj (fun _ : unit => list T) T)\n                 (Get (fun _ : unit => list T) tt)) => \n     ?Goal@{d:=d0}) d) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"]}, {"text": "simpl in *.", "goal_before": ["list T"], "goal_after": ["list T"], "proof_term_before": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) =>\n   (if x1 as b\n     return\n       (dataD\n          (if b\n           then Inj (fun _ : unit => list T) unit\n           else\n            Prod (Inj (fun _ : unit => list T) T)\n              (Get (fun _ : unit => list T) tt)) -> \n        list T)\n    then fun _ : dataD (Inj (fun _ : unit => list T) unit) => nil\n    else\n     fun\n       d0 : dataD\n              (Prod (Inj (fun _ : unit => list T) T)\n                 (Get (fun _ : unit => list T) tt)) => \n     ?Goal@{d:=d0}) d) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"], "proof_term_after": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) =>\n   (if x1 as b\n     return\n       (dataD\n          (if b\n           then Inj (fun _ : unit => list T) unit\n           else\n            Prod (Inj (fun _ : unit => list T) T)\n              (Get (fun _ : unit => list T) tt)) -> \n        list T)\n    then fun _ : dataD (Inj (fun _ : unit => list T) unit) => nil\n    else\n     fun\n       d0 : dataD\n              (Prod (Inj (fun _ : unit => list T) T)\n                 (Get (fun _ : unit => list T) tt)) => \n     ?Goal@{d:=d0} : list T) d) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"]}, {"text": "apply (fst d :: snd d).", "goal_before": ["list T"], "goal_after": [], "proof_term_before": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) =>\n   (if x1 as b\n     return\n       (dataD\n          (if b\n           then Inj (fun _ : unit => list T) unit\n           else\n            Prod (Inj (fun _ : unit => list T) T)\n              (Get (fun _ : unit => list T) tt)) -> \n        list T)\n    then fun _ : dataD (Inj (fun _ : unit => list T) unit) => nil\n    else\n     fun\n       d0 : dataD\n              (Prod (Inj (fun _ : unit => list T) T)\n                 (Get (fun _ : unit => list T) tt)) => \n     ?Goal@{d:=d0} : list T) d) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"], "proof_term_after": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) =>\n   (if x1 as b\n     return\n       (dataD\n          (if b\n           then Inj (fun _ : unit => list T) unit\n           else\n            Prod (Inj (fun _ : unit => list T) T)\n              (Get (fun _ : unit => list T) tt)) -> \n        list T)\n    then fun _ : dataD (Inj (fun _ : unit => list T) unit) => nil\n    else\n     fun\n       d0 : dataD\n              (Prod (Inj (fun _ : unit => list T) T)\n                 (Get (fun _ : unit => list T) tt)) =>\n     fst d0 :: snd d0 : list T) d) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (T : Type)\n    (x : {v : bool &\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))}) =>\n  let (x0, p) := x in\n  (fun (x1 : bool)\n     (d : dataD\n            (if x1\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) =>\n   (if x1 as b\n     return\n       (dataD\n          (if b\n           then Inj (fun _ : unit => list T) unit\n           else\n            Prod (Inj (fun _ : unit => list T) T)\n              (Get (fun _ : unit => list T) tt)) -> \n        list T)\n    then fun _ : dataD (Inj (fun _ : unit => list T) unit) => nil\n    else\n     fun\n       d0 : dataD\n              (Prod (Inj (fun _ : unit => list T) T)\n                 (Get (fun _ : unit => list T) tt)) =>\n     fst d0 :: snd d0 : list T) d) x0 p)\n :\n forall T : Type, dataD (dataList T) -> list T)"], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/coq-ext-lib/theories/Generic/DerivingData.v", "name": "list_to_dataList", "text": "Theorem list_to_dataList : forall T (ls : list T), dataD (dataList T).\n  simpl. destruct 1.\n  exists true. apply tt.\n  exists false. apply (t, ls).\nDefined.\n", "definition": " forall T (ls : list T), dataD (dataList T).", "proof": "\n  simpl. destruct 1.\n  exists true. apply tt.\n  exists false. apply (t, ls).\n", "def_ranges": [37, 0, 37, 70], "proof_ranges": [38, 0, 41, 8], "proof_steps": [{"text": "simpl.", "goal_before": ["forall T : Type, list T -> dataD (dataList T)"], "goal_after": ["forall T : Type,\nlist T ->\n{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall T : Type, list T -> dataD (dataList T))"]}, {"text": "destruct 1.", "goal_before": ["forall T : Type,\nlist T ->\n{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}"], "goal_after": ["{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}", "{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}"], "proof_term_before": ["(?Goal : forall T : Type, list T -> dataD (dataList T))"], "proof_term_after": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil => ?Goal\n  | a :: l => (fun (t : T) (ls0 : list T) => ?Goal0@{ls:=ls0}) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"]}, {"text": "exists true.", "goal_before": ["{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}", "{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}"], "goal_after": ["dataD (Inj (fun _ : unit => list T) unit)", "{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}"], "proof_term_before": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil => ?Goal\n  | a :: l => (fun (t : T) (ls0 : list T) => ?Goal0@{ls:=ls0}) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"], "proof_term_after": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil =>\n      existT\n        (fun v : bool =>\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))) true \n        ?Goal0\n  | a :: l => (fun (t : T) (ls0 : list T) => ?Goal@{ls:=ls0}) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"]}, {"text": "apply tt.", "goal_before": ["dataD (Inj (fun _ : unit => list T) unit)", "{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}"], "goal_after": ["{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}"], "proof_term_before": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil =>\n      existT\n        (fun v : bool =>\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))) true \n        ?Goal0\n  | a :: l => (fun (t : T) (ls0 : list T) => ?Goal@{ls:=ls0}) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"], "proof_term_after": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil =>\n      existT\n        (fun v : bool =>\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))) true tt\n  | a :: l => (fun (t : T) (ls0 : list T) => ?Goal@{ls:=ls0}) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"]}, {"text": "exists false.", "goal_before": ["{v : bool &\ndataD\n  (if v\n   then Inj (fun _ : unit => list T) unit\n   else\n    Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))}"], "goal_after": ["dataD\n  (Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))"], "proof_term_before": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil =>\n      existT\n        (fun v : bool =>\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))) true tt\n  | a :: l => (fun (t : T) (ls0 : list T) => ?Goal@{ls:=ls0}) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"], "proof_term_after": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil =>\n      existT\n        (fun v : bool =>\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))) true tt\n  | a :: l =>\n      (fun (t : T) (ls0 : list T) =>\n       existT\n         (fun v : bool =>\n          dataD\n            (if v\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) false \n         ?Goal@{ls:=ls0}) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"]}, {"text": "apply (t, ls).", "goal_before": ["dataD\n  (Prod (Inj (fun _ : unit => list T) T) (Get (fun _ : unit => list T) tt))"], "goal_after": [], "proof_term_before": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil =>\n      existT\n        (fun v : bool =>\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))) true tt\n  | a :: l =>\n      (fun (t : T) (ls0 : list T) =>\n       existT\n         (fun v : bool =>\n          dataD\n            (if v\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) false \n         ?Goal@{ls:=ls0}) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"], "proof_term_after": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil =>\n      existT\n        (fun v : bool =>\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))) true tt\n  | a :: l =>\n      (fun (t : T) (ls0 : list T) =>\n       existT\n         (fun v : bool =>\n          dataD\n            (if v\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) false (\n         t, ls0)) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (T : Type) (ls : list T) =>\n  match ls with\n  | nil =>\n      existT\n        (fun v : bool =>\n         dataD\n           (if v\n            then Inj (fun _ : unit => list T) unit\n            else\n             Prod (Inj (fun _ : unit => list T) T)\n               (Get (fun _ : unit => list T) tt))) true tt\n  | a :: l =>\n      (fun (t : T) (ls0 : list T) =>\n       existT\n         (fun v : bool =>\n          dataD\n            (if v\n             then Inj (fun _ : unit => list T) unit\n             else\n              Prod (Inj (fun _ : unit => list T) T)\n                (Get (fun _ : unit => list T) tt))) false (\n         t, ls0)) a l\n  end)\n :\n forall T : Type, list T -> dataD (dataList T))"], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Replacement.v", "name": "Choice_Collection", "text": "Theorem Choice_Collection : choice -> collection.\nunfold collection in |- *; intro; intros P comp G E.\ncut (EXType _ (fun f : Ens -> Ens => forall B : Ens, P B (f B))).\nsimple induction 1; intros f pf.\nelim E; intros A g hr; intros.\nexists (sup A (fun a : A => f (g a))).\nsimpl in |- *; intros X i.\nelim i; intros a ea.\nexists (f (g a)).\nsplit.\nexists a; auto with zfc.\napply comp with (g a); auto with zfc.\nunfold choice in H.\napply H; intros.\nelim (G a); intros b hb; exists b; auto with zfc.\nQed.\n", "definition": " choice -> collection.", "proof": "\nunfold collection in |- *; intro; intros P comp G E.\ncut (EXType _ (fun f : Ens -> Ens => forall B : Ens, P B (f B))).\nsimple induction 1; intros f pf.\nelim E; intros A g hr; intros.\nexists (sup A (fun a : A => f (g a))).\nsimpl in |- *; intros X i.\nelim i; intros a ea.\nexists (f (g a)).\nsplit.\nexists a; auto with zfc.\napply comp with (g a); auto with zfc.\nunfold choice in H.\napply H; intros.\nelim (G a); intros b hb; exists b; auto with zfc.\n", "def_ranges": [43, 0, 43, 49], "proof_ranges": [44, 0, 58, 4], "proof_steps": [{"text": "unfold collection in |- *; intro; intros P comp G E.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (EXType _ (fun f : Ens -> Ens => forall B : Ens, P B (f B))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1; intros f pf.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; intros A g hr; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (sup A (fun a : A => f (g a))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros X i.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim i; intros a ea.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (f (g a)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists a; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply comp with (g a); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold choice in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (G a); intros b hb; exists b; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Replacement.v", "name": "classical_Collection_Replacement", "text": "Theorem classical_Collection_Replacement :\n (forall S : Prop, S \\/ (S -> False)) -> collection -> replacement.\n\nunfold replacement in |- *; intros EM Collection P fp comp_r comp_l X.\ncut\n (EXType _\n    (fun Y : Ens =>\n     forall y : Ens, EXType _ (fun x : Ens => IN x X /\\ P x y) -> IN y Y)).\nsimple induction 1; intros Y HY.\nexists (Comp Y (fun y : Ens => EXType _ (fun x : Ens => IN x X /\\ P x y))).\nintros y; split.\nintros HC.\napply\n (IN_Comp_P Y y\n    (fun y0 : Ens => EXType Ens (fun x : Ens => IN x X /\\ P x y0)));\n auto with zfc.\nintros w1 w2; simple induction 1; intros x; simple induction 1;\n intros Ix Px e.\nexists x; split; auto with zfc.\napply comp_r with w1; auto with zfc.\nintros He.\napply IN_P_Comp.\n\nintros w1 w2; simple induction 1; intros x; simple induction 1;\n intros Ix Px e.\nexists x; split; auto with zfc.\napply comp_r with w1; auto with zfc.\napply HY; auto with zfc.\nauto with zfc.\n\nelim\n (Collection\n    (fun x y : Ens =>\n     P x y \\/ (forall y' : Ens, P x y' -> False) /\\ EQ y Vide)) \n  with X.\nintros Y HY.\nelim (EM (EXType _ (fun x : Ens => IN x X /\\ P x Vide))).\nintros Hvide; elim Hvide; intros xv Hxv; exists Y.\nintros y; simple induction 1; intros x; simple induction 1; intros Hx1 Hx2.\nelim (HY x Hx1).\nintros y'; simple induction 1; intros Hy'1 Hy'2.\nelim Hy'2.\nintros Hy'3; apply IN_sound_left with y'; auto with zfc.\napply fp with x; auto with zfc.\nsimple induction 1; intros Hy'3 Hy'4.\nelim (Hy'3 y Hx2).\nintros HP; exists (Comp Y (fun y : Ens => EQ y Vide -> False)).\nintros y; simple induction 1; intros x; simple induction 1; intros Hx1 Hx2.\napply IN_P_Comp.\nintros w1 w2 Hw1 Hw Hw2; apply Hw1; apply EQ_tran with w2; auto with zfc.\nelim (HY x).\nintros y'; simple induction 1; intros Hy'1 Hy'2.\nelim Hy'2; intros Hy'3.\napply IN_sound_left with y'; auto with zfc.\napply fp with x; auto with zfc.\nelim Hy'3; intros Hy'4 Hy'5.\nelim (Hy'4 y); auto with zfc.\nassumption.\nintros e; apply HP; exists x; split; auto with zfc; apply comp_r with y;\n auto with zfc; apply fp; auto with zfc.\nintros x x' y e Hx; elim Hx; intros Hx1.\nleft; apply comp_l with x; auto with zfc.\nright; elim Hx1; intros Hx2 Hx3; split.\n2: assumption.\nintros y' Hy'; apply (Hx2 y'); apply comp_l with x'; auto with zfc.\nintros x; elim (EM (EXType _ (fun y : Ens => P x y))); intros Hx.\nelim Hx; intros x0 Hx0; exists x0; left; assumption.\nexists Vide; right; split; auto with zfc.\nintros y Hy; elim Hx; exists y; auto with zfc.\nQed.\n", "definition": "\n (forall S : Prop, S \\/ (S -> False)) -> collection -> replacement.", "proof": "\n\nunfold replacement in |- *; intros EM Collection P fp comp_r comp_l X.\ncut\n (EXType _\n    (fun Y : Ens =>\n     forall y : Ens, EXType _ (fun x : Ens => IN x X /\\ P x y) -> IN y Y)).\nsimple induction 1; intros Y HY.\nexists (Comp Y (fun y : Ens => EXType _ (fun x : Ens => IN x X /\\ P x y))).\nintros y; split.\nintros HC.\napply\n (IN_Comp_P Y y\n    (fun y0 : Ens => EXType Ens (fun x : Ens => IN x X /\\ P x y0)));\n auto with zfc.\nintros w1 w2; simple induction 1; intros x; simple induction 1;\n intros Ix Px e.\nexists x; split; auto with zfc.\napply comp_r with w1; auto with zfc.\nintros He.\napply IN_P_Comp.\n\nintros w1 w2; simple induction 1; intros x; simple induction 1;\n intros Ix Px e.\nexists x; split; auto with zfc.\napply comp_r with w1; auto with zfc.\napply HY; auto with zfc.\nauto with zfc.\n\nelim\n (Collection\n    (fun x y : Ens =>\n     P x y \\/ (forall y' : Ens, P x y' -> False) /\\ EQ y Vide)) \n  with X.\nintros Y HY.\nelim (EM (EXType _ (fun x : Ens => IN x X /\\ P x Vide))).\nintros Hvide; elim Hvide; intros xv Hxv; exists Y.\nintros y; simple induction 1; intros x; simple induction 1; intros Hx1 Hx2.\nelim (HY x Hx1).\nintros y'; simple induction 1; intros Hy'1 Hy'2.\nelim Hy'2.\nintros Hy'3; apply IN_sound_left with y'; auto with zfc.\napply fp with x; auto with zfc.\nsimple induction 1; intros Hy'3 Hy'4.\nelim (Hy'3 y Hx2).\nintros HP; exists (Comp Y (fun y : Ens => EQ y Vide -> False)).\nintros y; simple induction 1; intros x; simple induction 1; intros Hx1 Hx2.\napply IN_P_Comp.\nintros w1 w2 Hw1 Hw Hw2; apply Hw1; apply EQ_tran with w2; auto with zfc.\nelim (HY x).\nintros y'; simple induction 1; intros Hy'1 Hy'2.\nelim Hy'2; intros Hy'3.\napply IN_sound_left with y'; auto with zfc.\napply fp with x; auto with zfc.\nelim Hy'3; intros Hy'4 Hy'5.\nelim (Hy'4 y); auto with zfc.\nassumption.\nintros e; apply HP; exists x; split; auto with zfc; apply comp_r with y;\n auto with zfc; apply fp; auto with zfc.\nintros x x' y e Hx; elim Hx; intros Hx1.\nleft; apply comp_l with x; auto with zfc.\nright; elim Hx1; intros Hx2 Hx3; split.\n2: assumption.\nintros y' Hy'; apply (Hx2 y'); apply comp_l with x'; auto with zfc.\nintros x; elim (EM (EXType _ (fun y : Ens => P x y))); intros Hx.\nelim Hx; intros x0 Hx0; exists x0; left; assumption.\nexists Vide; right; split; auto with zfc.\nintros y Hy; elim Hx; exists y; auto with zfc.\n", "def_ranges": [81, 0, 82, 67], "proof_ranges": [83, 0, 150, 4], "proof_steps": [{"text": "unfold replacement in |- *; intros EM Collection P fp comp_r comp_l X.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(EXType _", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun Y : Ens =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "forall y : Ens, EXType _ (fun x : Ens => IN x X /\\ P x y) -> IN y Y)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1; intros Y HY.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (Comp Y (fun y : Ens => EXType _ (fun x : Ens => IN x X /\\ P x y))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HC.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(IN_Comp_P Y y", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun y0 : Ens => EXType Ens (fun x : Ens => IN x X /\\ P x y0)));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros w1 w2; simple induction 1; intros x; simple induction 1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Ix Px e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; split; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply comp_r with w1; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros He.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_P_Comp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros w1 w2; simple induction 1; intros x; simple induction 1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Ix Px e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; split; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply comp_r with w1; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply HY; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Collection", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun x y : Ens =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "P x y \\/ (forall y' : Ens, P x y' -> False) /\\ EQ y Vide))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with X.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Y HY.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (EM (EXType _ (fun x : Ens => IN x X /\\ P x Vide))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Hvide; elim Hvide; intros xv Hxv; exists Y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y; simple induction 1; intros x; simple induction 1; intros Hx1 Hx2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (HY x Hx1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y'; simple induction 1; intros Hy'1 Hy'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim Hy'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Hy'3; apply IN_sound_left with y'; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply fp with x; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1; intros Hy'3 Hy'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (Hy'3 y Hx2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HP; exists (Comp Y (fun y : Ens => EQ y Vide -> False)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y; simple induction 1; intros x; simple induction 1; intros Hx1 Hx2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_P_Comp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros w1 w2 Hw1 Hw Hw2; apply Hw1; apply EQ_tran with w2; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (HY x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y'; simple induction 1; intros Hy'1 Hy'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim Hy'2; intros Hy'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_left with y'; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply fp with x; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim Hy'3; intros Hy'4 Hy'5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (Hy'4 y); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e; apply HP; exists x; split; auto with zfc; apply comp_r with y;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc; apply fp; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x x' y e Hx; elim Hx; intros Hx1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left; apply comp_l with x; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "right; elim Hx1; intros Hx2 Hx3; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "EQ_refl", "text": "Theorem EQ_refl : forall E : Ens, EQ E E.\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto.\n\nexists y; auto.\nQed.\n", "definition": " forall E : Ens, EQ E E.", "proof": "\nsimple induction E.\nintros A f HR.\nsimpl in |- *.\nsplit; intros.\nexists x; auto.\n\nexists y; auto.\n", "def_ranges": [71, 0, 71, 41], "proof_ranges": [72, 0, 79, 4], "proof_steps": [{"text": "simple induction E.", "goal_before": ["forall E : Ens, EQ E E"], "goal_after": ["forall (A : Type) (e : A -> Ens),\n(forall a : A, EQ (e a) (e a)) -> EQ (sup A e) (sup A e)"], "proof_term_before": [], "proof_term_after": ["(fun E : Ens => Ens_ind (fun E0 : Ens => EQ E0 E0) ?Goal E)"]}, {"text": "intros A f HR.", "goal_before": ["forall (A : Type) (e : A -> Ens),\n(forall a : A, EQ (e a) (e a)) -> EQ (sup A e) (sup A e)"], "goal_after": ["EQ (sup A f) (sup A f)"], "proof_term_before": ["(fun E : Ens => Ens_ind (fun E0 : Ens => EQ E0 E0) ?Goal E)"], "proof_term_after": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    ?Goal) E)"]}, {"text": "simpl in |- *.", "goal_before": ["EQ (sup A f) (sup A f)"], "goal_after": ["(forall x : A, EXType A (fun y : A => EQ (f x) (f y))) /\\\n(forall y : A, EXType A (fun x : A => EQ (f x) (f y)))"], "proof_term_before": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    ?Goal) E)"], "proof_term_after": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    ?Goal : EQ (sup A f) (sup A f)) E)"]}, {"text": "split; intros.", "goal_before": ["(forall x : A, EXType A (fun y : A => EQ (f x) (f y))) /\\\n(forall y : A, EXType A (fun x : A => EQ (f x) (f y)))"], "goal_after": ["EXType A (fun y : A => EQ (f x) (f y))", "EXType A (fun x : A => EQ (f x) (f y))"], "proof_term_before": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    ?Goal : EQ (sup A f) (sup A f)) E)"], "proof_term_after": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    conj (fun x : A => ?Goal) (fun y : A => ?Goal0) : EQ (sup A f) (sup A f))\n   E)"]}, {"text": "exists x; auto.", "goal_before": ["EXType A (fun y : A => EQ (f x) (f y))", "EXType A (fun x : A => EQ (f x) (f y))"], "goal_after": ["EXType A (fun x : A => EQ (f x) (f y))"], "proof_term_before": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    conj (fun x : A => ?Goal) (fun y : A => ?Goal0) : EQ (sup A f) (sup A f))\n   E)"], "proof_term_after": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    conj (fun x : A => EXTypei A (fun y : A => EQ (f x) (f y)) x (HR x))\n      (fun y : A => ?Goal)\n    :\n    EQ (sup A f) (sup A f)) E)"]}, {"text": "exists y; auto.", "goal_before": ["EXType A (fun x : A => EQ (f x) (f y))"], "goal_after": [], "proof_term_before": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    conj (fun x : A => EXTypei A (fun y : A => EQ (f x) (f y)) x (HR x))\n      (fun y : A => ?Goal)\n    :\n    EQ (sup A f) (sup A f)) E)"], "proof_term_after": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    conj (fun x : A => EXTypei A (fun y : A => EQ (f x) (f y)) x (HR x))\n      (fun y : A => EXTypei A (fun x : A => EQ (f x) (f y)) y (HR y))\n    :\n    EQ (sup A f) (sup A f)) E)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun E : Ens =>\n Ens_ind (fun E0 : Ens => EQ E0 E0)\n   (fun (A : Type) (f : A -> Ens) (HR : forall a : A, EQ (f a) (f a)) =>\n    conj (fun x : A => EXTypei A (fun y : A => EQ (f x) (f y)) x (HR x))\n      (fun y : A => EXTypei A (fun x : A => EQ (f x) (f y)) y (HR y))\n    :\n    EQ (sup A f) (sup A f)) E)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "EQ_tran", "text": "Theorem EQ_tran : forall E1 E2 E3 : Ens, EQ E1 E2 -> EQ E2 E3 -> EQ E1 E3.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2;\n simple induction E3; intros A3 f3 r3; simpl in |- *; \n intros e1 e2.\nsplit; (elim e1; intros I1 I2; elim e2; intros I3 I4).\nintros a1; elim (I1 a1); intros a2.\nelim (I3 a2); intros a3.\nexists a3.\napply r1 with (f2 a2); auto.\nintros a3; elim (I4 a3); intros a2; elim (I2 a2); intros a1; exists a1.\napply r1 with (f2 a2); auto.\nQed.\n", "definition": " forall E1 E2 E3 : Ens, EQ E1 E2 -> EQ E2 E3 -> EQ E1 E3.", "proof": "\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2;\n simple induction E3; intros A3 f3 r3; simpl in |- *; \n intros e1 e2.\nsplit; (elim e1; intros I1 I2; elim e2; intros I3 I4).\nintros a1; elim (I1 a1); intros a2.\nelim (I3 a2); intros a3.\nexists a3.\napply r1 with (f2 a2); auto.\nintros a3; elim (I4 a3); intros a2; elim (I2 a2); intros a1; exists a1.\napply r1 with (f2 a2); auto.\n", "def_ranges": [81, 0, 81, 74], "proof_ranges": [82, 0, 92, 4], "proof_steps": [{"text": "simple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2;", "goal_before": ["forall E1 E2 E3 : Ens, EQ E1 E2 -> EQ E2 E3 -> EQ E1 E3"], "goal_after": ["forall E1 E2 E3 : Ens, EQ E1 E2 -> EQ E2 E3 -> EQ E1 E3"], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction E3; intros A3 f3 r3; simpl in |- *;", "goal_before": ["forall E1 E2 E3 : Ens, EQ E1 E2 -> EQ E2 E3 -> EQ E1 E3"], "goal_after": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "proof_term_before": [], "proof_term_after": ["(fun e1 e2 : Ens => ?Goal)"]}, {"text": "intros e1 e2.", "goal_before": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "goal_after": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "proof_term_before": ["(fun e1 e2 : Ens => ?Goal)"], "proof_term_after": ["(fun e1 e2 : Ens => ?Goal)"]}, {"text": "split; (elim e1; intros I1 I2; elim e2; intros I3 I4).", "goal_before": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "goal_after": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "proof_term_before": ["(fun e1 e2 : Ens => ?Goal)"], "proof_term_after": ["(fun e1 e2 : Ens => ?Goal)"]}, {"text": "intros a1; elim (I1 a1); intros a2.", "goal_before": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "goal_after": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "proof_term_before": ["(fun e1 e2 : Ens => ?Goal)"], "proof_term_after": ["(fun e1 e2 : Ens => ?Goal)"]}, {"text": "elim (I3 a2); intros a3.", "goal_before": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "goal_after": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "proof_term_before": ["(fun e1 e2 : Ens => ?Goal)"], "proof_term_after": ["(fun e1 e2 : Ens => ?Goal)"]}, {"text": "exists a3.", "goal_before": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "goal_after": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "proof_term_before": ["(fun e1 e2 : Ens => ?Goal)"], "proof_term_after": ["(fun e1 e2 : Ens => ?Goal)"]}, {"text": "apply r1 with (f2 a2); auto.", "goal_before": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "goal_after": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "proof_term_before": ["(fun e1 e2 : Ens => ?Goal)"], "proof_term_after": ["(fun e1 e2 : Ens => ?Goal)"]}, {"text": "intros a3; elim (I4 a3); intros a2; elim (I2 a2); intros a1; exists a1.", "goal_before": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "goal_after": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "proof_term_before": ["(fun e1 e2 : Ens => ?Goal)"], "proof_term_after": ["(fun e1 e2 : Ens => ?Goal)"]}, {"text": "apply r1 with (f2 a2); auto.", "goal_before": ["forall E3 : Ens, EQ e1 e2 -> EQ e2 E3 -> EQ e1 E3"], "goal_after": [], "proof_term_before": ["(fun e1 e2 : Ens => ?Goal)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "EQ_sym", "text": "Theorem EQ_sym : forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2;\n simpl in |- *; simple induction 1; intros e1 e2; split.\nintros a2; elim (e2 a2); intros a1 H1; exists a1; auto.\nintros a1; elim (e1 a1); intros a2 H2; exists a2; auto.\nQed.\n", "definition": " forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1.", "proof": "\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2;\n simpl in |- *; simple induction 1; intros e1 e2; split.\nintros a2; elim (e2 a2); intros a1 H1; exists a1; auto.\nintros a1; elim (e1 a1); intros a2 H2; exists a2; auto.\n", "def_ranges": [94, 0, 94, 58], "proof_ranges": [95, 0, 99, 4], "proof_steps": [{"text": "simple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2;", "goal_before": ["forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1"], "goal_after": ["forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1"], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; simple induction 1; intros e1 e2; split.", "goal_before": ["forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1"], "goal_after": ["forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a2; elim (e2 a2); intros a1 H1; exists a1; auto.", "goal_before": ["forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1"], "goal_after": ["forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a1; elim (e1 a1); intros a2 H2; exists a2; auto.", "goal_before": ["forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1"], "goal_after": ["forall E1 E2 : Ens, EQ E1 E2 -> EQ E2 E1"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "EQ_INC", "text": "Theorem EQ_INC : forall E E' : Ens, EQ E E' -> INC E E'.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r';\n simpl in |- *; simple induction 1; intros e1 e2; unfold INC in |- *;\n simpl in |- *.\nintros C; simple induction 1; intros a ea; elim (e1 a); intros a' ea';\n exists a'.\napply EQ_tran with (f a); assumption.\nQed.\n", "definition": " forall E E' : Ens, EQ E E' -> INC E E'.", "proof": "\nsimple induction E; intros A f r; simple induction E'; intros A' f' r';\n simpl in |- *; simple induction 1; intros e1 e2; unfold INC in |- *;\n simpl in |- *.\nintros C; simple induction 1; intros a ea; elim (e1 a); intros a' ea';\n exists a'.\napply EQ_tran with (f a); assumption.\n", "def_ranges": [101, 0, 101, 56], "proof_ranges": [102, 0, 108, 4], "proof_steps": [{"text": "simple induction E; intros A f r; simple induction E'; intros A' f' r';", "goal_before": ["forall E E' : Ens, EQ E E' -> INC E E'"], "goal_after": ["forall E E' : Ens, EQ E E' -> INC E E'"], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; simple induction 1; intros e1 e2; unfold INC in |- *;", "goal_before": ["forall E E' : Ens, EQ E E' -> INC E E'"], "goal_after": ["forall E E' : Ens, EQ E E' -> INC E E'"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall E E' : Ens, EQ E E' -> INC E E')"]}, {"text": "simpl in |- *.", "goal_before": ["forall E E' : Ens, EQ E E' -> INC E E'"], "goal_after": ["forall E E' : Ens, EQ E E' -> INC E E'"], "proof_term_before": ["(?Goal : forall E E' : Ens, EQ E E' -> INC E E')"], "proof_term_after": []}, {"text": "intros C; simple induction 1; intros a ea; elim (e1 a); intros a' ea';", "goal_before": ["forall E E' : Ens, EQ E E' -> INC E E'"], "goal_after": ["forall E E' : Ens, EQ E E' -> INC E E'"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists a'.", "goal_before": ["forall E E' : Ens, EQ E E' -> INC E E'"], "goal_after": ["forall E E' : Ens, EQ E E' -> INC E E'"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "INC_EQ", "text": "Theorem INC_EQ : forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'.\nsimple induction E; intros A f r; simple induction E'; intros A' f' r';\n unfold INC in |- *; simpl in |- *; intros I1 I2; split.\nintros a; apply I1.\nexists a; auto with zfc.\nintros a'; cut (EXType A (fun x : A => EQ (f' a') (f x))).\nsimple induction 1; intros a ea; exists a; auto with zfc.\napply I2; exists a'; auto with zfc.\nQed.\n", "definition": " forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'.", "proof": "\nsimple induction E; intros A f r; simple induction E'; intros A' f' r';\n unfold INC in |- *; simpl in |- *; intros I1 I2; split.\nintros a; apply I1.\nexists a; auto with zfc.\nintros a'; cut (EXType A (fun x : A => EQ (f' a') (f x))).\nsimple induction 1; intros a ea; exists a; auto with zfc.\napply I2; exists a'; auto with zfc.\n", "def_ranges": [114, 0, 114, 68], "proof_ranges": [115, 0, 122, 4], "proof_steps": [{"text": "simple induction E; intros A f r; simple induction E'; intros A' f' r';", "goal_before": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "goal_after": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold INC in |- *; simpl in |- *; intros I1 I2; split.", "goal_before": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "goal_after": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a; apply I1.", "goal_before": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "goal_after": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists a; auto with zfc.", "goal_before": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "goal_after": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a'; cut (EXType A (fun x : A => EQ (f' a') (f x))).", "goal_before": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "goal_after": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1; intros a ea; exists a; auto with zfc.", "goal_before": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "goal_after": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply I2; exists a'; auto with zfc.", "goal_before": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "goal_after": ["forall E E' : Ens, INC E E' -> INC E' E -> EQ E E'"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "IN_sound_left", "text": "Theorem IN_sound_left :\n forall E E' E'' : Ens, EQ E E' -> IN E E'' -> IN E' E''.\nsimple induction E''; intros A'' f'' r'' e; simpl in |- *; simple induction 1;\n intros a'' p; exists a''; apply EQ_tran with E; auto with zfc.\nQed.\n", "definition": "\n forall E E' E'' : Ens, EQ E E' -> IN E E'' -> IN E' E''.", "proof": "\nsimple induction E''; intros A'' f'' r'' e; simpl in |- *; simple induction 1;\n intros a'' p; exists a''; apply EQ_tran with E; auto with zfc.\n", "def_ranges": [129, 0, 130, 57], "proof_ranges": [131, 0, 133, 4], "proof_steps": [{"text": "simple induction E''; intros A'' f'' r'' e; simpl in |- *; simple induction 1;", "goal_before": ["forall E E' E'' : Ens, EQ E E' -> IN E E'' -> IN E' E''"], "goal_after": ["forall E E' E'' : Ens, EQ E E' -> IN E E'' -> IN E' E''"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a'' p; exists a''; apply EQ_tran with E; auto with zfc.", "goal_before": ["forall E E' E'' : Ens, EQ E E' -> IN E E'' -> IN E' E''"], "goal_after": ["forall E E' E'' : Ens, EQ E E' -> IN E E'' -> IN E' E''"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "IN_sound_right", "text": "Theorem IN_sound_right :\n forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''.\nsimple induction E'; intros A' f' r'; simple induction E'';\n intros A'' f'' r''; simpl in |- *; simple induction 1; \n intros e1 e2; simple induction 1; intros a' e'; elim (e1 a'); \n intros a'' e''; exists a''; apply EQ_tran with (f' a'); \n assumption.\n\nQed.\n", "definition": "\n forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''.", "proof": "\nsimple induction E'; intros A' f' r'; simple induction E'';\n intros A'' f'' r''; simpl in |- *; simple induction 1; \n intros e1 e2; simple induction 1; intros a' e'; elim (e1 a'); \n intros a'' e''; exists a''; apply EQ_tran with (f' a'); \n assumption.\n\n", "def_ranges": [135, 0, 136, 57], "proof_ranges": [137, 0, 143, 4], "proof_steps": [{"text": "simple induction E'; intros A' f' r'; simple induction E'';", "goal_before": ["forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''"], "goal_after": ["forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A'' f'' r''; simpl in |- *; simple induction 1;", "goal_before": ["forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''"], "goal_after": ["forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e1 e2; simple induction 1; intros a' e'; elim (e1 a');", "goal_before": ["forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''"], "goal_after": ["forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros a'' e''; exists a''; apply EQ_tran with (f' a');", "goal_before": ["forall E E' E'' : Ens, EQ E' E'' -> IN E E' -> IN E E''"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "INC_refl", "text": "Theorem INC_refl : forall E : Ens, INC E E.\nunfold INC in |- *; auto with zfc.\nQed.\n", "definition": " forall E : Ens, INC E E.", "proof": "\nunfold INC in |- *; auto with zfc.\n", "def_ranges": [147, 0, 147, 43], "proof_ranges": [148, 0, 149, 4], "proof_steps": [{"text": "unfold INC in |- *; auto with zfc.", "goal_before": ["forall E : Ens, INC E E"], "goal_after": ["forall E : Ens, INC E E"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall E : Ens, INC E E"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "INC_tran", "text": "Theorem INC_tran : forall E E' E'' : Ens, INC E E' -> INC E' E'' -> INC E E''.\nunfold INC in |- *; auto with zfc.\nQed.\n", "definition": " forall E E' E'' : Ens, INC E E' -> INC E' E'' -> INC E E''.", "proof": "\nunfold INC in |- *; auto with zfc.\n", "def_ranges": [151, 0, 151, 78], "proof_ranges": [152, 0, 153, 4], "proof_steps": [{"text": "unfold INC in |- *; auto with zfc.", "goal_before": ["forall E E' E'' : Ens, INC E E' -> INC E' E'' -> INC E E''"], "goal_after": ["forall E E' E'' : Ens, INC E E' -> INC E' E'' -> INC E E''"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "Qed.", "goal_before": ["forall E E' E'' : Ens, INC E E' -> INC E' E'' -> INC E E''"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "INC_sound_left", "text": "Theorem INC_sound_left :\n forall E E' E'' : Ens, EQ E E' -> INC E E'' -> INC E' E''.\nsimple induction E''; unfold INC in |- *; simpl in |- *;\n intros A f HR e H1 E0 i; apply H1.\napply IN_sound_right with E'; auto with zfc.\nQed.\n", "definition": "\n forall E E' E'' : Ens, EQ E E' -> INC E E'' -> INC E' E''.", "proof": "\nsimple induction E''; unfold INC in |- *; simpl in |- *;\n intros A f HR e H1 E0 i; apply H1.\napply IN_sound_right with E'; auto with zfc.\n", "def_ranges": [156, 0, 157, 59], "proof_ranges": [158, 0, 161, 4], "proof_steps": [{"text": "simple induction E''; unfold INC in |- *; simpl in |- *;", "goal_before": ["forall E E' E'' : Ens, EQ E E' -> INC E E'' -> INC E' E''"], "goal_after": ["forall E E' E'' : Ens, EQ E E' -> INC E E'' -> INC E' E''"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A f HR e H1 E0 i; apply H1.", "goal_before": ["IN E0 A"], "goal_after": ["IN E0 A"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with E'; auto with zfc.", "goal_before": ["IN E0 A"], "goal_after": ["IN E0 A"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Sets.v", "name": "INC_sound_right", "text": "Theorem INC_sound_right :\n forall E E' E'' : Ens, EQ E' E'' -> INC E E' -> INC E E''.\nsimple induction E'; simple induction E''; unfold INC in |- *; simpl in |- *;\n intros.\nelim (H2 E0); try assumption; intros.\nelim H1; intros HA HB; elim (HA x); intros.\nexists x0; apply EQ_tran with (e x); auto with zfc.\nQed.\n", "definition": "\n forall E E' E'' : Ens, EQ E' E'' -> INC E E' -> INC E E''.", "proof": "\nsimple induction E'; simple induction E''; unfold INC in |- *; simpl in |- *;\n intros.\nelim (H2 E0); try assumption; intros.\nelim H1; intros HA HB; elim (HA x); intros.\nexists x0; apply EQ_tran with (e x); auto with zfc.\n", "def_ranges": [163, 0, 164, 59], "proof_ranges": [165, 0, 170, 4], "proof_steps": [{"text": "simple induction E'; simple induction E''; unfold INC in |- *; simpl in |- *;", "goal_before": ["forall E E' E'' : Ens, EQ E' E'' -> INC E E' -> INC E E''"], "goal_after": ["forall E E' E'' : Ens, EQ E' E'' -> INC E E' -> INC E E''"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": ["INC E E''"], "goal_after": ["INC E E''"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H2 E0); try assumption; intros.", "goal_before": ["INC E E''"], "goal_after": ["INC E E''"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H1; intros HA HB; elim (HA x); intros.", "goal_before": ["INC E E''"], "goal_after": ["INC E E''"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x0; apply EQ_tran with (e x); auto with zfc.", "goal_before": ["INC E E''"], "goal_after": ["INC E E''"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Omega.v", "name": "IN_Class_succ", "text": "Theorem IN_Class_succ : forall E : Ens, IN E (Class_succ E).\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\nQed.\n", "definition": " forall E : Ens, IN E (Class_succ E).", "proof": "\nintros E; unfold Class_succ in |- *; unfold Sing in |- *;\n apply IN_Union with (Paire E E); auto with zfc.\n", "def_ranges": [50, 0, 50, 60], "proof_ranges": [51, 0, 53, 4], "proof_steps": [{"text": "intros E; unfold Class_succ in |- *; unfold Sing in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_Union with (Paire E E); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Omega.v", "name": "INC_Class_succ", "text": "Theorem INC_Class_succ : forall E : Ens, INC E (Class_succ E).\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\nQed.\n", "definition": " forall E : Ens, INC E (Class_succ E).", "proof": "\nunfold INC in |- *; unfold Class_succ in |- *.\nintros.\napply IN_Union with E; auto with zfc.\n", "def_ranges": [56, 0, 56, 62], "proof_ranges": [57, 0, 60, 4], "proof_steps": [{"text": "unfold INC in |- *; unfold Class_succ in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_Union with E; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Omega.v", "name": "IN_Class_succ_or", "text": "Theorem IN_Class_succ_or :\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\nQed.\n", "definition": "\n forall E E' : Ens, IN E' (Class_succ E) -> EQ E E' \\/ IN E' E.", "proof": "\nintros E E' i.\nunfold Class_succ in i.\nelim (Union_IN (Paire E (Sing E)) E' i).\nintros E1; simple induction 1; intros i1 i2.\nelim (Paire_IN E (Sing E) E1 i1).\nintros; right; apply IN_sound_right with E1; auto with zfc.\nintros; left; cut (IN E' (Sing E)).\nauto with zfc.\napply IN_sound_right with E1; auto with zfc.\n\n", "def_ranges": [65, 0, 66, 63], "proof_ranges": [67, 0, 77, 4], "proof_steps": [{"text": "intros E E' i.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Class_succ in i.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (Union_IN (Paire E (Sing E)) E' i).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros E1; simple induction 1; intros i1 i2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (Paire_IN E (Sing E) E1 i1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; right; apply IN_sound_right with E1; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; left; cut (IN E' (Sing E)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with E1; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Omega.v", "name": "E_not_IN_E", "text": "Theorem E_not_IN_E : forall E : Ens, IN E E -> F.\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\nQed.\n", "definition": " forall E : Ens, IN E E -> F.", "proof": "\nsimple induction E; intros A f r i.\ncut False.\nsimple induction 1.\nelim (IN_EXType (sup A f) (sup A f) i); intros a e.\n\nsimpl in a.\nchange (EQ (sup A f) (f a)) in e.\nelim (r a).\napply IN_sound_right with (sup A f); auto with zfc.\nexists a; auto with zfc.\n", "def_ranges": [80, 0, 80, 49], "proof_ranges": [81, 0, 91, 4], "proof_steps": [{"text": "simple induction E; intros A f r i.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut False.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (IN_EXType (sup A f) (sup A f) i); intros a e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (EQ (sup A f) (f a)) in e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (r a).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with (sup A f); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists a; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Omega.v", "name": "Nat_IN_Omega", "text": "Theorem Nat_IN_Omega : forall n : nat, IN (Nat n) Omega.\nintros; simpl in |- *; exists n; auto with zfc.\nQed.\n", "definition": " forall n : nat, IN (Nat n) Omega.", "proof": "\nintros; simpl in |- *; exists n; auto with zfc.\n", "def_ranges": [94, 0, 94, 56], "proof_ranges": [95, 0, 96, 4], "proof_steps": [{"text": "intros; simpl in |- *; exists n; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Omega.v", "name": "IN_Omega_EXType", "text": "Theorem IN_Omega_EXType :\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\nQed.\n", "definition": "\n forall E : Ens, IN E Omega -> EXType _ (fun n : nat => EQ (Nat n) E).", "proof": "\nsimpl in |- *; simple induction 1.\nintros n e.\nexists n; auto with zfc.\n", "def_ranges": [100, 0, 101, 70], "proof_ranges": [102, 0, 105, 4], "proof_steps": [{"text": "simpl in |- *; simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists n; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Omega.v", "name": "IN_Nat_EXType", "text": "Theorem IN_Nat_EXType :\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\nQed.\n", "definition": "\n forall (n : nat) (E : Ens),\n IN E (Nat n) -> EXType _ (fun p : nat => EQ E (Nat p)).", "proof": "\nsimple induction n.\nsimpl in |- *.\nsimple induction 1.\nsimple induction x.\n\nintros.\nchange (IN E (Class_succ (Nat n0))) in H0.\nelim (IN_Class_succ_or (Nat n0) E H0).\nintros; exists n0.\nauto with zfc.\n\nintros.\nelim (H E); auto with zfc.\n", "def_ranges": [107, 0, 109, 56], "proof_ranges": [110, 0, 123, 4], "proof_steps": [{"text": "simple induction n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (IN E (Class_succ (Nat n0))) in H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (IN_Class_succ_or (Nat n0) E H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; exists n0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H E); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Omega.v", "name": "Omega_EQ_Union", "text": "Theorem Omega_EQ_Union : EQ Omega (Union Omega).\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\n\napply IN_sound_left with (Nat n).\nauto with zfc.\n\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\n\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\n\napply IN_sound_right with e; auto with zfc.\nQed.\n", "definition": " EQ Omega (Union Omega).", "proof": "\napply INC_EQ; unfold INC in |- *.\nintros.\nelim (IN_Omega_EXType E H); intros n e.\napply IN_Union with (Nat (S n)).\nauto with zfc.\n\napply IN_sound_left with (Nat n).\nauto with zfc.\n\nauto with zfc.\nchange (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.\n\nintros.\nelim (Union_IN Omega E H).\nintros e h.\nelim h.\nintros i1 i2.\nelim (IN_Omega_EXType e i1).\nintros n e1.\ncut (IN E (Nat n)).\nintros.\nelim (IN_Nat_EXType n E H0); intros.\napply IN_sound_left with (Nat x); auto with zfc.\n\napply IN_sound_right with e; auto with zfc.\n", "def_ranges": [126, 0, 126, 48], "proof_ranges": [127, 0, 152, 4], "proof_steps": [{"text": "apply INC_EQ; unfold INC in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (IN_Omega_EXType E H); intros n e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_Union with (Nat (S n)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_left with (Nat n).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (IN (Nat n) (Class_succ (Nat n))) in |- *; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (Union_IN Omega E H).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e h.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim h.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros i1 i2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (IN_Omega_EXType e i1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n e1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (IN E (Nat n)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (IN_Nat_EXType n E H0); intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_left with (Nat x); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with e; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Russell.v", "name": "Russell", "text": "Theorem Russell : forall E : Ens, (forall E' : Ens, IN E' E) -> False.\nintros U HU.\ncut\n ((fun x : Ens => IN x x -> False) (Comp U (fun x : Ens => IN x x -> False))).\nintros HR.\napply HR.\napply IN_P_Comp; auto with zfc.\nintros w1 w2 HF e i; apply HF; apply IN_sound_left with w2; auto with zfc;\n apply IN_sound_right with w2; auto with zfc.\nintros H.\ncut\n (IN (Comp U (fun x : Ens => IN x x -> False))\n    (Comp U (fun x : Ens => IN x x -> False))).\nchange\n  ((fun x : Ens => IN x x -> False) (Comp U (fun x : Ens => IN x x -> False)))\n in |- *.\ncut\n (forall w1 w2 : Ens, (IN w1 w1 -> False) -> EQ w1 w2 -> IN w2 w2 -> False).\nintros ww.\nexact\n (IN_Comp_P U (Comp U (fun x : Ens => IN x x -> False))\n    (fun x : Ens => IN x x -> False) ww H).\nintros w1 w2 HF e i; apply HF; apply IN_sound_left with w2; auto with zfc;\n apply IN_sound_right with w2; auto with zfc.\nassumption.\n\nQed.\n", "definition": " forall E : Ens, (forall E' : Ens, IN E' E) -> False.", "proof": "\nintros U HU.\ncut\n ((fun x : Ens => IN x x -> False) (Comp U (fun x : Ens => IN x x -> False))).\nintros HR.\napply HR.\napply IN_P_Comp; auto with zfc.\nintros w1 w2 HF e i; apply HF; apply IN_sound_left with w2; auto with zfc;\n apply IN_sound_right with w2; auto with zfc.\nintros H.\ncut\n (IN (Comp U (fun x : Ens => IN x x -> False))\n    (Comp U (fun x : Ens => IN x x -> False))).\nchange\n  ((fun x : Ens => IN x x -> False) (Comp U (fun x : Ens => IN x x -> False)))\n in |- *.\ncut\n (forall w1 w2 : Ens, (IN w1 w1 -> False) -> EQ w1 w2 -> IN w2 w2 -> False).\nintros ww.\nexact\n (IN_Comp_P U (Comp U (fun x : Ens => IN x x -> False))\n    (fun x : Ens => IN x x -> False) ww H).\nintros w1 w2 HF e i; apply HF; apply IN_sound_left with w2; auto with zfc;\n apply IN_sound_right with w2; auto with zfc.\nassumption.\n\n", "def_ranges": [26, 0, 26, 70], "proof_ranges": [27, 0, 52, 4], "proof_steps": [{"text": "intros U HU.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((fun x : Ens => IN x x -> False) (Comp U (fun x : Ens => IN x x -> False))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HR.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply HR.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_P_Comp; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros w1 w2 HF e i; apply HF; apply IN_sound_left with w2; auto with zfc;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with w2; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(IN (Comp U (fun x : Ens => IN x x -> False))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Comp U (fun x : Ens => IN x x -> False))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((fun x : Ens => IN x x -> False) (Comp U (fun x : Ens => IN x x -> False)))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(forall w1 w2 : Ens, (IN w1 w1 -> False) -> EQ w1 w2 -> IN w2 w2 -> False).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros ww.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(IN_Comp_P U (Comp U (fun x : Ens => IN x x -> False))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Hierarchy.v", "name": "inj_sound", "text": "Theorem inj_sound : forall E1 E2 : Ens', EQ' E1 E2 -> EQ (inj E1) (inj E2).\nsimple induction E1; intros A1 f1 fr1; simple induction E2; intros A2 f2 r2;\n simpl in |- *.\nsimple induction 1; intros HR1 HR2; split.\nintros a1; elim (HR1 a1); intros a2 Ha2; exists a2; auto with zfc.\nintros a2; elim (HR2 a2); intros a1 Ha1; exists a1; auto with zfc.\nQed.\n", "definition": " forall E1 E2 : Ens', EQ' E1 E2 -> EQ (inj E1) (inj E2).", "proof": "\nsimple induction E1; intros A1 f1 fr1; simple induction E2; intros A2 f2 r2;\n simpl in |- *.\nsimple induction 1; intros HR1 HR2; split.\nintros a1; elim (HR1 a1); intros a2 Ha2; exists a2; auto with zfc.\nintros a2; elim (HR2 a2); intros a1 Ha1; exists a1; auto with zfc.\n", "def_ranges": [67, 0, 67, 75], "proof_ranges": [68, 0, 73, 4], "proof_steps": [{"text": "simple induction E1; intros A1 f1 fr1; simple induction E2; intros A2 f2 r2;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1; intros HR1 HR2; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a1; elim (HR1 a1); intros a2 Ha2; exists a2; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a2; elim (HR2 a2); intros a1 Ha1; exists a1; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Hierarchy.v", "name": "Power_sound_inj", "text": "Theorem Power_sound_inj :\n forall E : Ens', EQ (inj (Power' E)) (Power (inj E)).\nsimple induction E; intros A f HR.\nsimpl in |- *; split.\nintros P; exists P; split.\nintros c; elim c; intros a p.\nexists (dep_i A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.\nintros c; elim c; intros a p.\nexists (dep_i'' A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.\nintros P; exists P; split.\nintros c; elim c; intros a p.\nexists (dep_i A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.\nintros c; elim c; intros a p.\nexists (dep_i'' A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.\nQed.\n", "definition": "\n forall E : Ens', EQ (inj (Power' E)) (Power (inj E)).", "proof": "\nsimple induction E; intros A f HR.\nsimpl in |- *; split.\nintros P; exists P; split.\nintros c; elim c; intros a p.\nexists (dep_i A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.\nintros c; elim c; intros a p.\nexists (dep_i'' A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.\nintros P; exists P; split.\nintros c; elim c; intros a p.\nexists (dep_i A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.\nintros c; elim c; intros a p.\nexists (dep_i'' A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.\n", "def_ranges": [89, 0, 90, 54], "proof_ranges": [91, 0, 103, 4], "proof_steps": [{"text": "simple induction E; intros A f HR.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros P; exists P; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c; elim c; intros a p.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (dep_i A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c; elim c; intros a p.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (dep_i'' A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros P; exists P; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c; elim c; intros a p.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (dep_i A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros c; elim c; intros a p.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (dep_i'' A (fun a0 : A => P a0) a p); simpl in |- *; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Hierarchy.v", "name": "Big_is_big", "text": "Theorem Big_is_big : forall E : Ens', IN (inj E) Big.\nintros E; unfold Big in |- *; simpl in |- *; exists E; auto with zfc.\nQed.\n", "definition": " forall E : Ens', IN (inj E) Big.", "proof": "\nintros E; unfold Big in |- *; simpl in |- *; exists E; auto with zfc.\n", "def_ranges": [110, 0, 110, 53], "proof_ranges": [111, 0, 112, 4], "proof_steps": [{"text": "intros E; unfold Big in |- *; simpl in |- *; exists E; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Hierarchy.v", "name": "IN_Big_small", "text": "Theorem IN_Big_small :\n forall E : Ens, IN E Big -> EXType' _ (fun E' : Ens' => EQ E (inj E')).\nunfold Big in |- *; simpl in |- *; simple induction 1; intros E' HE';\n exists E'; auto with zfc.\nQed.\n", "definition": "\n forall E : Ens, IN E Big -> EXType' _ (fun E' : Ens' => EQ E (inj E')).", "proof": "\nunfold Big in |- *; simpl in |- *; simple induction 1; intros E' HE';\n exists E'; auto with zfc.\n", "def_ranges": [114, 0, 115, 72], "proof_ranges": [116, 0, 118, 4], "proof_steps": [{"text": "unfold Big in |- *; simpl in |- *; simple induction 1; intros E' HE';", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists E'; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Hierarchy.v", "name": "IN_small_small", "text": "Theorem IN_small_small :\n forall (E : Ens) (E' : Ens'),\n IN E (inj E') -> EXType' _ (fun E1 : Ens' => EQ E (inj E1)).\nsimple induction E'; intros A' f' HR'; simpl in |- *; simple induction 1;\n intros a' e'; exists (f' a'); auto with zfc.\nQed.\n", "definition": "\n forall (E : Ens) (E' : Ens'),\n IN E (inj E') -> EXType' _ (fun E1 : Ens' => EQ E (inj E1)).", "proof": "\nsimple induction E'; intros A' f' HR'; simpl in |- *; simple induction 1;\n intros a' e'; exists (f' a'); auto with zfc.\n", "def_ranges": [121, 0, 123, 61], "proof_ranges": [124, 0, 126, 4], "proof_steps": [{"text": "simple induction E'; intros A' f' HR'; simpl in |- *; simple induction 1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a' e'; exists (f' a'); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Hierarchy.v", "name": "Big_closed_for_power", "text": "Theorem Big_closed_for_power : forall E : Ens, IN E Big -> IN (Power E) Big.\nunfold Big in |- *; simpl in |- *; intros E; simple induction 1;\n intros E' HE'; exists (Power' E').\napply EQ_tran with (Power (inj E')).\napply Power_sound; assumption.\napply EQ_sym; apply Power_sound_inj.\nQed.\n", "definition": " forall E : Ens, IN E Big -> IN (Power E) Big.", "proof": "\nunfold Big in |- *; simpl in |- *; intros E; simple induction 1;\n intros E' HE'; exists (Power' E').\napply EQ_tran with (Power (inj E')).\napply Power_sound; assumption.\napply EQ_sym; apply Power_sound_inj.\n", "def_ranges": [130, 0, 130, 76], "proof_ranges": [131, 0, 136, 4], "proof_steps": [{"text": "unfold Big in |- *; simpl in |- *; intros E; simple induction 1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros E' HE'; exists (Power' E').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_tran with (Power (inj E')).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Power_sound; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_sym; apply Power_sound_inj.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Cartesian.v", "name": "Couple_inj_left", "text": "Theorem Couple_inj_left :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\nQed.\n", "definition": "\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A B.", "proof": "\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1.\nintros HA HB; elim (HA true).\nintros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;\n elim (H3 true); simpl in |- *; intros xx; elim xx; \n simpl in |- *; auto with zfc.\nelim (H4 false); simpl in |- *.\nsimple induction x0; simpl in |- *.\nintros.\ncut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros; cut (EQ (Sing B') Vide).\nsimpl in |- *.\nsimple induction 1.\nintros yy; elim (yy true).\nsimple induction x1.\n\napply EQ_tran with A; auto with zfc.\n\nintros yy.\nelim (HB true); simpl in |- *.\nsimple induction x0.\nchange (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.\napply IN_Sing_EQ.\napply IN_sound_right with (Sing A); auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.\nintros zz.\nelimtype F.\napply (not_EQ_Sing_Vide A').\napply EQ_tran with B.\napply IN_Sing_EQ.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\n\n", "def_ranges": [32, 0, 33, 66], "proof_ranges": [34, 0, 76, 4], "proof_steps": [{"text": "unfold Couple in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HA HB; elim (HA true).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x; elim x; simpl in |- *; simple induction 1; intros H3 H4;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H3 true); simpl in |- *; intros xx; elim xx;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H4 false); simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x0; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (EQ (Sing B') Vide).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros yy; elim (yy true).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_tran with A; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; cut (EQ (Sing B') Vide).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros yy; elim (yy true).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_tran with A; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros yy.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (HB true); simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (EQ (Sing A) (Sing B) -> EQ A B) in |- *; intros EE.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_Sing_EQ.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with (Sing A); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (EQ (Paire Vide (Sing A')) (Sing B) -> EQ A B) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros zz.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elimtype F.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (not_EQ_Sing_Vide A').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_tran with B.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_Sing_EQ.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_sym; apply IN_Sing_EQ;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with (Paire Vide (Sing A'));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Cartesian.v", "name": "Couple_inj_right", "text": "Theorem Couple_inj_right :\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\nQed.\n", "definition": "\n forall A A' B B' : Ens, EQ (Couple A A') (Couple B B') -> EQ A' B'.", "proof": "\nunfold Couple in |- *; simpl in |- *.\nsimple induction 1; intros H1 H2.\nelim (H1 false).\nintros bb1; elim bb1.\nintros HF.\nchange (EQ (Paire Vide (Sing A')) (Sing B)) in HF.\ncut F.\nsimple induction 1.\napply (not_EQ_Vide_Sing A').\napply EQ_tran with B.\napply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));\n auto with zfc.\napply EQ_sym; apply IN_Sing_EQ;\n apply IN_sound_right with (Paire Vide (Sing A')); \n auto with zfc.\nchange (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.\nintros HP; cut (EQ (Sing A') (Sing B')).\nintros; auto with zfc.\ncut (IN (Sing A') (Paire Vide (Sing B'))).\nintros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).\nintros; cut F.\nsimple induction 1.\napply not_EQ_Sing_Vide with A'; assumption.\ntrivial with zfc.\napply IN_sound_right with (Paire Vide (Sing A')); auto with zfc.\n\n", "def_ranges": [80, 0, 81, 68], "proof_ranges": [82, 0, 108, 4], "proof_steps": [{"text": "unfold Couple in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1; intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 false).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros bb1; elim bb1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HF.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (EQ (Paire Vide (Sing A')) (Sing B)) in HF.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut F.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (not_EQ_Vide_Sing A').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_tran with B.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_Sing_EQ; apply IN_sound_right with (Paire Vide (Sing A'));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_sym; apply IN_Sing_EQ;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_right with (Paire Vide (Sing A'));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (EQ (Paire Vide (Sing A')) (Paire Vide (Sing B')) -> EQ A' B') in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HP; cut (EQ (Sing A') (Sing B')).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (IN (Sing A') (Paire Vide (Sing B'))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros HI; elim (Paire_IN Vide (Sing B') (Sing A') HI).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; cut F.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply not_EQ_Sing_Vide with A'; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Cartesian.v", "name": "Couple_sound_left", "text": "Theorem Couple_sound_left :\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n", "definition": "\n forall A A' B : Ens, EQ A A' -> EQ (Couple A B) (Couple A' B).", "proof": "\n unfold Couple in |- *; intros; auto with zfc.\n", "def_ranges": [134, 0, 135, 63], "proof_ranges": [136, 0, 137, 4], "proof_steps": [{"text": "unfold Couple in |- *; intros; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Cartesian.v", "name": "Couple_sound_right", "text": "Theorem Couple_sound_right :\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').\n unfold Couple in |- *; intros; auto with zfc.\nQed.\n", "definition": "\n forall A B B' : Ens, EQ B B' -> EQ (Couple A B) (Couple A B').", "proof": "\n unfold Couple in |- *; intros; auto with zfc.\n", "def_ranges": [139, 0, 140, 63], "proof_ranges": [141, 0, 142, 4], "proof_steps": [{"text": "unfold Couple in |- *; intros; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Cartesian.v", "name": "Couple_IN_Prod", "text": "Theorem Couple_IN_Prod :\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\nQed.\n", "definition": "\n forall E1 E2 E1' E2' : Ens,\n IN E1' E1 -> IN E2' E2 -> IN (Couple E1' E2') (Prod E1 E2).", "proof": "\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i1 i2.\nelim (IN_EXType (sup A1 f1) E1').\nintros x e1; simpl in x.\nelim (IN_EXType (sup A2 f2) E2').\nintros x0 e2; simpl in x.\napply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));\n auto with zfc.\napply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.\napply Couple_sound_right.\nauto with zfc.\n\napply Couple_sound_left; auto with zfc.\n\nsimpl in |- *.\nsimpl in |- *.\nexists (pair_t _ _ x x0).\nsimpl in |- *.\nsplit.\nsimple induction x1; simpl in |- *.\nexists true; simpl in |- *.\nsplit.\nsimple induction x2; simpl in |- *.\nexists true; auto with zfc.\n\nexists true; auto with zfc.\n\nsimple induction y; exists true; auto with zfc.\n\nexists false; simpl in |- *.\nsplit.\nsimple induction x2.\nexists true; simpl in |- *; auto with zfc.\nsplit.\nsimple induction x3.\n\nsimple induction y.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nsimple induction y; simpl in |- *.\nexists true; auto with zfc.\n\nexists false; auto with zfc.\n\nauto with zfc.\n\nauto with zfc.\n", "def_ranges": [145, 0, 147, 60], "proof_ranges": [148, 0, 201, 4], "proof_steps": [{"text": "simple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros E1' E2' i1 i2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (IN_EXType (sup A1 f1) E1').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x e1; simpl in x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (IN_EXType (sup A2 f2) E2').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 e2; simpl in x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_left with (Couple (pi2 (sup A1 f1) x) (pi2 (sup A2 f2) x0));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EQ_tran with (Couple (pi2 (sup A1 f1) x) E2'); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Couple_sound_right.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Couple_sound_left; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (pair_t _ _ x x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x1; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists true; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x2; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists true; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists true; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction y; exists true; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists false; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists true; simpl in |- *; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists false; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction y; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists true; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists false; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction y; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists true; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists false; auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Cartesian.v", "name": "Couple_Prod_IN", "text": "Theorem Couple_Prod_IN :\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\nQed.\n", "definition": "\n forall E1 E2 E1' E2' : Ens,\n IN (Couple E1' E2') (Prod E1 E2) -> IN E1' E1 /\\ IN E2' E2.", "proof": "\nsimple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.\nintros E1' E2' i.\nelim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).\nintros xx; elim xx; intros a1 a2 e.\nchange (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.\ncut (EQ E1' (f1 a1)).\ncut (EQ E2' (f2 a2)).\nintros e1 e2.\nsplit.\napply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;\n auto with zfc.\napply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;\n auto with zfc.\napply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.\napply Couple_inj_left with E2' (f2 a2); auto with zfc.\n", "def_ranges": [204, 0, 206, 60], "proof_ranges": [207, 0, 222, 4], "proof_steps": [{"text": "simple induction E1; intros A1 f1 r1; simple induction E2; intros A2 f2 r2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros E1' E2' i.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (IN_EXType (Prod (sup A1 f1) (sup A2 f2)) (Couple E1' E2') i).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros xx; elim xx; intros a1 a2 e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (EQ (Couple E1' E2') (Couple (f1 a1) (f2 a2))) in e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (EQ E1' (f1 a1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (EQ E2' (f2 a2)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e1 e2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_left with (f1 a1); auto with zfc; simpl in |- *; exists a1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IN_sound_left with (f2 a2); auto with zfc; simpl in |- *; exists a2;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Couple_inj_right with (A := E1') (B := f1 a1); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Couple_inj_left with E2' (f2 a2); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/zfc/Cartesian.v", "name": "IN_Prod_EXType", "text": "Theorem IN_Prod_EXType :\n forall E E' E'' : Ens,\n IN E'' (Prod E E') ->\n EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\nQed.\n", "definition": "\n forall E E' E'' : Ens,\n IN E'' (Prod E E') ->\n EXType _ (fun A : Ens => EXType _ (fun B : Ens => EQ (Couple A B) E'')).", "proof": "\nsimple induction E; intros A f r; simple induction E'; intros A' f' r'.\nintros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').\nsimple induction x.\nintros; exists (f a); exists (f' b); auto with zfc.\nauto with zfc.\n", "def_ranges": [226, 0, 229, 73], "proof_ranges": [230, 0, 235, 4], "proof_steps": [{"text": "simple induction E; intros A f r; simple induction E'; intros A' f' r'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim (IN_EXType (Prod (sup A f) (sup A' f')) E'').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; exists (f a); exists (f' b); auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with zfc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/f_cut_elimination.v", "name": "G_to_Gcf", "text": "Theorem G_to_Gcf : forall \u0393 \u0394, \u0393 \u2283c \u0394 -> \u0393 \u2283 \u0394.\ninduction 1;[econstructor|constructor|constr..];eassumption.\nQed.\n", "definition": " forall \u0393 \u0394, \u0393 \u2283c \u0394 -> \u0393 \u2283 \u0394.", "proof": "\ninduction 1;[econstructor|constructor|constr..];eassumption.\n", "def_ranges": [49, 0, 49, 47], "proof_ranges": [50, 0, 51, 4], "proof_steps": [{"text": "induction 1;[econstructor|constructor|constr..];eassumption.", "goal_before": ["forall \u0393 \u0394 : list PropF, \u0393 \u2283c \u0394 -> \u0393 \u2283 \u0394"], "goal_after": ["forall \u0393 \u0394 : list PropF, \u0393 \u2283c \u0394 -> \u0393 \u2283 \u0394"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["forall \u0393 \u0394 : list PropF, \u0393 \u2283c \u0394 -> \u0393 \u2283 \u0394"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283c \u0394) =>\n Gcf_ind (fun \u03930 \u03940 : list PropF => \u03930 \u2283 \u03940)\n   (fun (v : PropVars) (\u03930 \u03940 : list PropF) (H0 : In # v \u03930) (H1 : In # v \u03940)\n    => Gax # v \u03930 \u03940 H0 H1)\n   (fun (\u03930 \u03940 : list PropF) (H0 : In \u22a5 \u03930) => GBot \u03930 \u03940 H0)\n   (fun (A B : PropF) (\u03931 \u03932 \u03940 : list PropF) (_ : \u03931 ++ A :: B :: \u03932 \u2283c \u03940)\n      (IHGcf : \u03931 ++ A :: B :: \u03932 \u2283 \u03940) => AndL A B \u03931 \u03932 IHGcf)\n   (fun (A B : PropF) (\u03930 \u03941 \u03942 : list PropF) (_ : \u03930 \u2283c \u03941 ++ A :: \u03942)\n      (IHGcf1 : \u03930 \u2283 \u03941 ++ A :: \u03942) (_ : \u03930 \u2283c \u03941 ++ B :: \u03942)\n      (IHGcf2 : \u03930 \u2283 \u03941 ++ B :: \u03942) => AndR A B \u03941 \u03942 IHGcf1 IHGcf2)\n   (fun (A B : PropF) (\u03931 \u03932 \u03940 : list PropF) (_ : \u03931 ++ A :: \u03932 \u2283c \u03940)\n      (IHGcf1 : \u03931 ++ A :: \u03932 \u2283 \u03940) (_ : \u03931 ++ B :: \u03932 \u2283c \u03940)\n      (IHGcf2 : \u03931 ++ B :: \u03932 \u2283 \u03940) => OrL A B \u03931 \u03932 IHGcf1 IHGcf2)\n   (fun (A B : PropF) (\u03930 \u03941 \u03942 : list PropF) (_ : \u03930 \u2283c \u03941 ++ A :: B :: \u03942)\n      (IHGcf : \u03930 \u2283 \u03941 ++ A :: B :: \u03942) => OrR A B \u03941 \u03942 IHGcf)\n   (fun (A B : PropF) (\u03931 \u03932 \u03940 : list PropF) (_ : \u03931 ++ B :: \u03932 \u2283c \u03940)\n      (IHGcf1 : \u03931 ++ B :: \u03932 \u2283 \u03940) (_ : \u03931 ++ \u03932 \u2283c A :: \u03940)\n      (IHGcf2 : \u03931 ++ \u03932 \u2283 A :: \u03940) => ImpL B \u03931 \u03932 IHGcf1 IHGcf2)\n   (fun (A B : PropF) (\u03930 \u03941 \u03942 : list PropF) (_ : A :: \u03930 \u2283c \u03941 ++ B :: \u03942)\n      (IHGcf : A :: \u03930 \u2283 \u03941 ++ B :: \u03942) => ImpR B \u03941 \u03942 IHGcf) H)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/f_cut_elimination.v", "name": "G_sound", "text": "Theorem G_sound : forall \u0393 \u0394, \u0393 \u2283 \u0394 -> \u0393 =\u2283 \u0394.\nintros. apply G_to_Nc in H. apply Soundness_general in H. \nremember (H v H0). clear -i H0.\ninduction \u0394.\n contradiction.\n simpl in i. case_eq (TrueQ v a);intro K;rewrite K in *;simpl in *.\n   exists a;split;[in_solve|rewrite K;trivial].\n   destruct (IH\u0394 i) as (?&?&?). exists x;split;[in_solve|assumption].\nQed.\n", "definition": " forall \u0393 \u0394, \u0393 \u2283 \u0394 -> \u0393 =\u2283 \u0394.", "proof": "\nintros. apply G_to_Nc in H. apply Soundness_general in H. \nremember (H v H0). clear -i H0.\ninduction \u0394.\n contradiction.\n simpl in i. case_eq (TrueQ v a);intro K;rewrite K in *;simpl in *.\n   exists a;split;[in_solve|rewrite K;trivial].\n   destruct (IH\u0394 i) as (?&?&?). exists x;split;[in_solve|assumption].\n", "def_ranges": [55, 0, 55, 46], "proof_ranges": [56, 0, 63, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall \u0393 \u0394 : list PropF, \u0393 \u2283 \u0394 -> \u0393 =\u2283 \u0394"], "goal_after": ["Validates v \u0394"], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) => ?Goal)"]}, {"text": "apply G_to_Nc in H.", "goal_before": ["Validates v \u0394"], "goal_after": ["Validates v \u0394"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) => ?Goal)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) => let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in ?Goal@{H:=H1})"]}, {"text": "apply Soundness_general in H.", "goal_before": ["Validates v \u0394"], "goal_after": ["Validates v \u0394"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) => let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in ?Goal@{H:=H1})"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in ?Goal@{H:=H2})"]}, {"text": "remember (H v H0).", "goal_before": ["Validates v \u0394"], "goal_after": ["Validates v \u0394"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in ?Goal@{H:=H2})"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in ?Goal@{H:=H2})"]}, {"text": "clear -i H0.", "goal_before": ["Validates v \u0394"], "goal_after": ["Validates v \u0394"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in ?Goal@{H:=H2})"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in ?Goal)"]}, {"text": "induction \u0394.", "goal_before": ["Validates v \u0394"], "goal_after": ["Validates v []", "Validates v (a :: \u0394)"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in ?Goal)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => ?Goal@{i:=i0})\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) => ?Goal0@{\u0394:=\u03940; i:=i0}) \u0394 i)"]}, {"text": "contradiction.", "goal_before": ["Validates v []", "Validates v (a :: \u0394)"], "goal_after": ["Validates v (a :: \u0394)"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => ?Goal@{i:=i0})\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) => ?Goal0@{\u0394:=\u03940; i:=i0}) \u0394 i)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) => ?Goal@{\u0394:=\u03940; i:=i0}) \u0394 i)"]}, {"text": "simpl in i.", "goal_before": ["Validates v (a :: \u0394)"], "goal_after": ["Validates v (a :: \u0394)"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) => ?Goal@{\u0394:=\u03940; i:=i0}) \u0394 i)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) => ?Goal@{\u0394:=\u03940; i:=i0}) \u0394 i)"]}, {"text": "case_eq (TrueQ v a);intro K;rewrite K in *;simpl in *.", "goal_before": ["Validates v (a :: \u0394)"], "goal_after": ["Validates v (a :: \u0394)", "Validates v (a :: \u0394)"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) => ?Goal@{\u0394:=\u03940; i:=i0}) \u0394 i)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) =>\n    ((if TrueQ v a as b return (TrueQ v a = b -> Validates v (a :: \u03940))\n      then\n       fun K : TrueQ v a = true =>\n       let i1 : Is_true (true || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 true K in\n       ?Goal@{\u0394:=\u03940; i:=i1} : Validates v (a :: \u03940)\n      else\n       fun K : TrueQ v a = false =>\n       let i1 : Is_true (false || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 false K in\n       ?Goal0@{\u0394:=\u03940; i:=i1} : Validates v (a :: \u03940))\n     :\n     TrueQ v a = TrueQ v a -> Validates v (a :: \u03940)) eq_refl) \u0394 i)"]}, {"text": "exists a;split;[in_solve|rewrite K;trivial].", "goal_before": ["Validates v (a :: \u0394)", "Validates v (a :: \u0394)"], "goal_after": ["Validates v (a :: \u0394)"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) =>\n    ((if TrueQ v a as b return (TrueQ v a = b -> Validates v (a :: \u03940))\n      then\n       fun K : TrueQ v a = true =>\n       let i1 : Is_true (true || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 true K in\n       ?Goal@{\u0394:=\u03940; i:=i1} : Validates v (a :: \u03940)\n      else\n       fun K : TrueQ v a = false =>\n       let i1 : Is_true (false || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 false K in\n       ?Goal0@{\u0394:=\u03940; i:=i1} : Validates v (a :: \u03940))\n     :\n     TrueQ v a = TrueQ v a -> Validates v (a :: \u03940)) eq_refl) \u0394 i)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) =>\n    ((if TrueQ v a as b return (TrueQ v a = b -> Validates v (a :: \u03940))\n      then\n       fun K : TrueQ v a = true =>\n       let i1 : Is_true (true || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 true K in\n       ex_intro (fun A : PropF => In A (a :: \u03940) /\\ Is_true (TrueQ v A)) a\n         (conj (or_introl eq_refl)\n            (eq_ind_r (fun b : bool => Is_true b) i1 K))\n       :\n       Validates v (a :: \u03940)\n      else\n       fun K : TrueQ v a = false =>\n       let i1 : Is_true (false || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 false K in\n       ?Goal@{\u0394:=\u03940; i:=i1} : Validates v (a :: \u03940))\n     :\n     TrueQ v a = TrueQ v a -> Validates v (a :: \u03940)) eq_refl) \u0394 i)"]}, {"text": "destruct (IH\u0394 i) as (?&?&?).", "goal_before": ["Validates v (a :: \u0394)"], "goal_after": ["Validates v (a :: \u0394)"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) =>\n    ((if TrueQ v a as b return (TrueQ v a = b -> Validates v (a :: \u03940))\n      then\n       fun K : TrueQ v a = true =>\n       let i1 : Is_true (true || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 true K in\n       ex_intro (fun A : PropF => In A (a :: \u03940) /\\ Is_true (TrueQ v A)) a\n         (conj (or_introl eq_refl)\n            (eq_ind_r (fun b : bool => Is_true b) i1 K))\n       :\n       Validates v (a :: \u03940)\n      else\n       fun K : TrueQ v a = false =>\n       let i1 : Is_true (false || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 false K in\n       ?Goal@{\u0394:=\u03940; i:=i1} : Validates v (a :: \u03940))\n     :\n     TrueQ v a = TrueQ v a -> Validates v (a :: \u03940)) eq_refl) \u0394 i)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) =>\n    ((if TrueQ v a as b return (TrueQ v a = b -> Validates v (a :: \u03940))\n      then\n       fun K : TrueQ v a = true =>\n       let i1 : Is_true (true || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 true K in\n       ex_intro (fun A : PropF => In A (a :: \u03940) /\\ Is_true (TrueQ v A)) a\n         (conj (or_introl eq_refl)\n            (eq_ind_r (fun b : bool => Is_true b) i1 K))\n       :\n       Validates v (a :: \u03940)\n      else\n       fun K : TrueQ v a = false =>\n       let i1 : Is_true (false || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 false K in\n       (let v0 : exists A : PropF, In A \u03940 /\\ Is_true (TrueQ v A) := \n          IH\u0394 i1 in\n        match v0 with\n        | ex_intro _ x x0 =>\n            (fun (x1 : PropF) (H3 : In x1 \u03940 /\\ Is_true (TrueQ v x1)) =>\n             match H3 with\n             | conj x2 x3 =>\n                 (fun (H4 : In x1 \u03940) (H5 : Is_true (TrueQ v x1)) =>\n                  ?Goal@{\u0394:=\u03940; i:=i1; x:=x1; H:=H4; H1:=H5}) x2 x3\n             end) x x0\n        end)\n       :\n       Validates v (a :: \u03940))\n     :\n     TrueQ v a = TrueQ v a -> Validates v (a :: \u03940)) eq_refl) \u0394 i)"]}, {"text": "exists x;split;[in_solve|assumption].", "goal_before": ["Validates v (a :: \u0394)"], "goal_after": [], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) =>\n    ((if TrueQ v a as b return (TrueQ v a = b -> Validates v (a :: \u03940))\n      then\n       fun K : TrueQ v a = true =>\n       let i1 : Is_true (true || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 true K in\n       ex_intro (fun A : PropF => In A (a :: \u03940) /\\ Is_true (TrueQ v A)) a\n         (conj (or_introl eq_refl)\n            (eq_ind_r (fun b : bool => Is_true b) i1 K))\n       :\n       Validates v (a :: \u03940)\n      else\n       fun K : TrueQ v a = false =>\n       let i1 : Is_true (false || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 false K in\n       (let v0 : exists A : PropF, In A \u03940 /\\ Is_true (TrueQ v A) := \n          IH\u0394 i1 in\n        match v0 with\n        | ex_intro _ x x0 =>\n            (fun (x1 : PropF) (H3 : In x1 \u03940 /\\ Is_true (TrueQ v x1)) =>\n             match H3 with\n             | conj x2 x3 =>\n                 (fun (H4 : In x1 \u03940) (H5 : Is_true (TrueQ v x1)) =>\n                  ?Goal@{\u0394:=\u03940; i:=i1; x:=x1; H:=H4; H1:=H5}) x2 x3\n             end) x x0\n        end)\n       :\n       Validates v (a :: \u03940))\n     :\n     TrueQ v a = TrueQ v a -> Validates v (a :: \u03940)) eq_refl) \u0394 i)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) =>\n    ((if TrueQ v a as b return (TrueQ v a = b -> Validates v (a :: \u03940))\n      then\n       fun K : TrueQ v a = true =>\n       let i1 : Is_true (true || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 true K in\n       ex_intro (fun A : PropF => In A (a :: \u03940) /\\ Is_true (TrueQ v A)) a\n         (conj (or_introl eq_refl)\n            (eq_ind_r (fun b : bool => Is_true b) i1 K))\n       :\n       Validates v (a :: \u03940)\n      else\n       fun K : TrueQ v a = false =>\n       let i1 : Is_true (false || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 false K in\n       (let v0 : exists A : PropF, In A \u03940 /\\ Is_true (TrueQ v A) := \n          IH\u0394 i1 in\n        match v0 with\n        | ex_intro _ x x0 =>\n            (fun (x1 : PropF) (H3 : In x1 \u03940 /\\ Is_true (TrueQ v x1)) =>\n             match H3 with\n             | conj x2 x3 =>\n                 (fun (H4 : In x1 \u03940) (H5 : Is_true (TrueQ v x1)) =>\n                  ex_intro\n                    (fun A : PropF => In A (a :: \u03940) /\\ Is_true (TrueQ v A))\n                    x1 (conj (or_intror H4) H5)) x2 x3\n             end) x x0\n        end)\n       :\n       Validates v (a :: \u03940))\n     :\n     TrueQ v a = TrueQ v a -> Validates v (a :: \u03940)) eq_refl) \u0394 i)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) (v : PropVars -> bool)\n   (H0 : Satisfies v \u0393) =>\n let H1 : \u0393 \u22a2 \u22c1 \u0394 := G_to_Nc H in\n let H2 : \u0393 \u22a8 \u22c1 \u0394 := Soundness_general H1 in\n let i : Is_true (TrueQ v (\u22c1 \u0394)) := H2 v H0 in\n let Heqi : i = H2 v H0 := eq_refl in\n list_ind (fun \u03940 : list PropF => Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n   (fun i0 : Is_true (TrueQ v (\u22c1 [])) => False_ind (Validates v []) i0)\n   (fun (a : PropF) (\u03940 : list PropF)\n      (IH\u0394 : Is_true (TrueQ v (\u22c1 \u03940)) -> Validates v \u03940)\n      (i0 : Is_true (TrueQ v (\u22c1 (a :: \u03940)))) =>\n    ((if TrueQ v a as b return (TrueQ v a = b -> Validates v (a :: \u03940))\n      then\n       fun K : TrueQ v a = true =>\n       let i1 : Is_true (true || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 true K in\n       ex_intro (fun A : PropF => In A (a :: \u03940) /\\ Is_true (TrueQ v A)) a\n         (conj (or_introl eq_refl)\n            (eq_ind_r (fun b : bool => Is_true b) i1 K))\n       :\n       Validates v (a :: \u03940)\n      else\n       fun K : TrueQ v a = false =>\n       let i1 : Is_true (false || TrueQ v (\u22c1 \u03940)) :=\n         eq_ind (TrueQ v a) (fun b : bool => Is_true (b || TrueQ v (\u22c1 \u03940)))\n           i0 false K in\n       (let v0 : exists A : PropF, In A \u03940 /\\ Is_true (TrueQ v A) := \n          IH\u0394 i1 in\n        match v0 with\n        | ex_intro _ x x0 =>\n            (fun (x1 : PropF) (H3 : In x1 \u03940 /\\ Is_true (TrueQ v x1)) =>\n             match H3 with\n             | conj x2 x3 =>\n                 (fun (H4 : In x1 \u03940) (H5 : Is_true (TrueQ v x1)) =>\n                  ex_intro\n                    (fun A : PropF => In A (a :: \u03940) /\\ Is_true (TrueQ v A))\n                    x1 (conj (or_intror H4) H5)) x2 x3\n             end) x x0\n        end)\n       :\n       Validates v (a :: \u03940))\n     :\n     TrueQ v a = TrueQ v a -> Validates v (a :: \u03940)) eq_refl) \u0394 i)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/f_cut_elimination.v", "name": "Gcf_complete_induction", "text": "Theorem Gcf_complete_induction : forall n \u0393 \u0394, sizes \u0393 \u0394 <= n -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394.\ninduction n;intros.\n inversion H. apply plus_is_O in H2 as (?&?). \n  apply size_O_atomic in H1 as (?&?);apply size_O_atomic in H2 as (?&?);subst.\n   remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.\n    destruct (in_dec Atomic_eqdec ABot x).\n      constructor 2;change \u22a5 with (AtomicF ABot);eapply in_map;assumption.\n      destruct (H0 v) as (?&?&?). \n        intros ? ?. apply in_map_iff in H1 as (?&?&?);subst A;simpl;destruct x1. \n          rewrite Heqv;simpl. destruct (in_dec Atomic_eqdec (AVar p) x);[exact I|contradiction].\n          contradiction.\n        apply in_map_iff in H1 as (?&?&?);subst x1. destruct x2.\n          constructor 1 with p. \n            change #p with (AtomicF (AVar p));apply in_map.\n             simpl in H2;rewrite Heqv in H2. destruct (in_dec Atomic_eqdec (AVar p));[assumption|contradiction].\n            change #p with (AtomicF (AVar p)). apply in_map. assumption.\n          contradiction.\n inversion H;[clear H|apply IHn;assumption];destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]);\n  apply in_split in H as (?&?&?);subst;constr;apply IHn;\n   try (apply le_S_n;rewrite <- H2;apply sizes_decr);temp5 A B H0.\nQed.\n", "definition": " forall n \u0393 \u0394, sizes \u0393 \u0394 <= n -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394.", "proof": "\ninduction n;intros.\n inversion H. apply plus_is_O in H2 as (?&?). \n  apply size_O_atomic in H1 as (?&?);apply size_O_atomic in H2 as (?&?);subst.\n   remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.\n    destruct (in_dec Atomic_eqdec ABot x).\n      constructor 2;change \u22a5 with (AtomicF ABot);eapply in_map;assumption.\n      destruct (H0 v) as (?&?&?). \n        intros ? ?. apply in_map_iff in H1 as (?&?&?);subst A;simpl;destruct x1. \n          rewrite Heqv;simpl. destruct (in_dec Atomic_eqdec (AVar p) x);[exact I|contradiction].\n          contradiction.\n        apply in_map_iff in H1 as (?&?&?);subst x1. destruct x2.\n          constructor 1 with p. \n            change #p with (AtomicF (AVar p));apply in_map.\n             simpl in H2;rewrite Heqv in H2. destruct (in_dec Atomic_eqdec (AVar p));[assumption|contradiction].\n            change #p with (AtomicF (AVar p)). apply in_map. assumption.\n          contradiction.\n inversion H;[clear H|apply IHn;assumption];destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]);\n  apply in_split in H as (?&?&?);subst;constr;apply IHn;\n   try (apply le_S_n;rewrite <- H2;apply sizes_decr);temp5 A B H0.\n", "def_ranges": [144, 0, 144, 82], "proof_ranges": [145, 0, 164, 4], "proof_steps": [{"text": "induction n;intros.", "goal_before": ["forall (n : nat) (\u0393 \u0394 : list PropF), sizes \u0393 \u0394 <= n -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394"], "goal_after": ["\u0393 \u2283c \u0394", "\u0393 \u2283c \u0394"], "proof_term_before": [], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) => ?Goal)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal0@{n:=n0}) n)"]}, {"text": "inversion H.", "goal_before": ["\u0393 \u2283c \u0394", "\u0393 \u2283c \u0394"], "goal_after": ["\u0393 \u2283c \u0394", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) => ?Goal)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal0@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394) ?Goal0@{H2:=H4} 0 H5)\n             H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "apply plus_is_O in H2 as (?&?).", "goal_before": ["\u0393 \u2283c \u0394", "\u0393 \u2283c \u0394"], "goal_after": ["\u0393 \u2283c \u0394", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394) ?Goal0@{H2:=H4} 0 H5)\n             H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    ?Goal0@{H1:=H7; H2:=H8}) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "apply size_O_atomic in H1 as (?&?);apply size_O_atomic in H2 as (?&?);subst.", "goal_before": ["\u0393 \u2283c \u0394", "\u0393 \u2283c \u0394"], "goal_after": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    ?Goal0@{H1:=H7; H2:=H8}) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    ?Goal0@{x:=x3; x0:=x6; H:=H16; H0:=H15})\n                                   H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "remember (fun P => if (in_dec Atomic_eqdec (AVar P) x) then true else false) as v.", "goal_before": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    ?Goal0@{x:=x3; x0:=x6; H:=H16; H0:=H15})\n                                   H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    ?Goal0@{x:=x3; x0:=x6; H:=H16; H0:=H15})\n                                   H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "destruct (in_dec Atomic_eqdec ABot x).", "goal_before": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["map AtomicF x \u2283c map AtomicF x0", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    ?Goal0@{x:=x3; x0:=x6; H:=H16; H0:=H15})\n                                   H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         ?Goal0@{x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15}) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         ?Goal1@{x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0}) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "constructor 2;change \u22a5 with (AtomicF ABot);eapply in_map;assumption.", "goal_before": ["map AtomicF x \u2283c map AtomicF x0", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         ?Goal0@{x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15}) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         ?Goal1@{x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0}) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         ?Goal0@{x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0}) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "destruct (H0 v) as (?&?&?).", "goal_before": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["Satisfies v (map AtomicF x)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         ?Goal0@{x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0}) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ?Goal0@{\n                                             x:=x3; x0:=x6; H:=H16; H0:=H15;\n                                             n:=n0} in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "intros ? ?.", "goal_before": ["Satisfies v (map AtomicF x)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["Is_true (TrueQ v A)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ?Goal0@{\n                                             x:=x3; x0:=x6; H:=H16; H0:=H15;\n                                             n:=n0} in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               ?Goal1@{\n                                               x:=x3; x0:=x6; H:=H16;\n                                               H0:=H15; n:=n0; H1:=H17})\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "apply in_map_iff in H1 as (?&?&?);subst A;simpl;destruct x1.", "goal_before": ["Is_true (TrueQ v A)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["Is_true (TrueQ v (AtomicF (AVar p)))", "Is_true (TrueQ v (AtomicF ABot))", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               ?Goal1@{\n                                               x:=x3; x0:=x6; H:=H16;\n                                               H0:=H15; n:=n0; H1:=H17})\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H2:=H23}) p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 ?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H2:=H23}\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "rewrite Heqv;simpl.", "goal_before": ["Is_true (TrueQ v (AtomicF (AVar p)))", "Is_true (TrueQ v (AtomicF ABot))", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["Is_true (if in_dec Atomic_eqdec (AVar p) x then true else false)", "Is_true (TrueQ v (AtomicF ABot))", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H2:=H23}) p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 ?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H2:=H23}\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 (?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H2:=H23}\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H2:=H23}\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "destruct (in_dec Atomic_eqdec (AVar p) x);[exact I|contradiction].", "goal_before": ["Is_true (if in_dec Atomic_eqdec (AVar p) x then true else false)", "Is_true (TrueQ v (AtomicF ABot))", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["Is_true (TrueQ v (AtomicF ABot))", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 (?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H2:=H23}\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H2:=H23}\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H2:=H23}\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "contradiction.", "goal_before": ["Is_true (TrueQ v (AtomicF ABot))", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H2:=H23}\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "apply in_map_iff in H1 as (?&?&?);subst x1.", "goal_before": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x1:=x9;\n                                                 H1:=H18; H2:=H19}) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x2:=x14;\n                                                 H3:=H24; H2:=H25}) x9 H23\n                                                 H19) x15 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "destruct x2.", "goal_before": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["map AtomicF x \u2283c map AtomicF x0", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; x2:=x14;\n                                                 H3:=H24; H2:=H25}) x9 H23\n                                                 H19) x15 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "constructor 1 with p.", "goal_before": ["map AtomicF x \u2283c map AtomicF x0", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["In # p (map AtomicF x)", "In # p (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}\n                                                 ?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "change #p with (AtomicF (AVar p));apply in_map.", "goal_before": ["In # p (map AtomicF x)", "In # p (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["In (AVar p) x", "In # p (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}\n                                                 ?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 ?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27})\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "simpl in H2;rewrite Heqv in H2.", "goal_before": ["In (AVar p) x", "In # p (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["In (AVar p) x", "In # p (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 ?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27})\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 ?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H28}))\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "destruct (in_dec Atomic_eqdec (AVar p));[assumption|contradiction].", "goal_before": ["In (AVar p) x", "In # p (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["In # p (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 ?Goal2@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H28}))\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "change #p with (AtomicF (AVar p)).", "goal_before": ["In # p (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["In (AtomicF (AVar p)) (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "apply in_map.", "goal_before": ["In (AtomicF (AVar p)) (map AtomicF x0)", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["In (AVar p) x0", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27}) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 (in_map AtomicF x6 \n                                                 (AVar p0)\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27})) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "assumption.", "goal_before": ["In (AVar p) x0", "map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 (in_map AtomicF x6 \n                                                 (AVar p0)\n                                                 ?Goal1@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; p:=p0;\n                                                 H3:=H26; H2:=H27})) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 (in_map AtomicF x6 \n                                                 (AVar p0) H26)) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "contradiction.", "goal_before": ["map AtomicF x \u2283c map AtomicF x0", "\u0393 \u2283c \u0394"], "goal_after": ["\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (H16 : sizes \n                                               (map AtomicF x3)\n                                               (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 (in_map AtomicF x6 \n                                                 (AVar p0) H26)) p\n                                                 | ABot =>\n                                                 fun \n                                                 (H26 : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 ?Goal0@{\n                                                 x:=x3; x0:=x6; H:=H16;\n                                                 H0:=H15; n:=n0; H3:=H26;\n                                                 H2:=H27}\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (_ : sizes (map AtomicF x3)\n                                             (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 (in_map AtomicF x6 \n                                                 (AVar p0) H26)) p\n                                                 | ABot =>\n                                                 fun \n                                                 (_ : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 False_ind\n                                                 (map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6) H27\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "inversion H;[clear H|apply IHn;assumption];destruct (size_S _ _ H2) as (A&B&[|[|[|[|[]]]]]);", "goal_before": ["\u0393 \u2283c \u0394"], "goal_after": ["\u0393 \u2283c \u0394"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (_ : sizes (map AtomicF x3)\n                                             (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 (in_map AtomicF x6 \n                                                 (AVar p0) H26)) p\n                                                 | ABot =>\n                                                 fun \n                                                 (_ : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 False_ind\n                                                 (map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6) H27\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": []}, {"text": "apply in_split in H as (?&?&?);subst;constr;apply IHn;", "goal_before": ["\u0393 \u2283c \u0394"], "goal_after": ["\u0393 \u2283c \u0394"], "proof_term_before": [], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (_ : sizes (map AtomicF x3)\n                                             (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 (in_map AtomicF x6 \n                                                 (AVar p0) H26)) p\n                                                 | ABot =>\n                                                 fun \n                                                 (_ : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 False_ind\n                                                 (map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6) H27\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"]}, {"text": "try (apply le_S_n;rewrite <- H2;apply sizes_decr);temp5 A B H0.", "goal_before": ["\u0393 \u2283c \u0394"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n   (fun (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= 0) (H0 : \u0393 =\u2283 \u0394) =>\n    let H1 : 0 = 0 -> \u0393 \u2283c \u0394 :=\n      match H in (_ <= n0) return (n0 = 0 -> \u0393 \u2283c \u0394) with\n      | le_n _ =>\n          fun H1 : sizes \u0393 \u0394 = 0 =>\n          (fun H2 : sizes \u0393 \u0394 = 0 =>\n           let H3 : sizes \u0393 \u0394 = 0 := f_equal (fun e : nat => e) H2 in\n           (fun H4 : sizes \u0393 \u0394 = 0 =>\n            let H5 : sizes \u0393 \u0394 = 0 := H4 in\n            eq_ind (sizes \u0393 \u0394) (fun _ : nat => \u0393 \u2283c \u0394)\n              (let H6 : sizel \u0393 = 0 /\\ sizel \u0394 = 0 :=\n                 plus_is_O (sizel \u0393) (sizel \u0394) H4 in\n               match H6 with\n               | conj x x0 =>\n                   (fun (H7 : sizel \u0393 = 0) (H8 : sizel \u0394 = 0) =>\n                    let H9 : exists l : list Atomic, \u0393 = map AtomicF l :=\n                      size_O_atomic \u0393 H7 in\n                    match H9 with\n                    | ex_intro _ x1 x2 =>\n                        (fun (x3 : list Atomic) (H10 : \u0393 = map AtomicF x3) =>\n                         let H11 :\n                           exists l : list Atomic, \u0394 = map AtomicF l :=\n                           size_O_atomic \u0394 H8 in\n                         match H11 with\n                         | ex_intro _ x4 x5 =>\n                             (fun (x6 : list Atomic)\n                                (H12 : \u0394 = map AtomicF x6) =>\n                              eq_ind_r\n                                (fun \u03930 : list PropF =>\n                                 sizes \u03930 \u0394 <= 0 -> \u03930 =\u2283 \u0394 -> \u03930 \u2283c \u0394)\n                                (fun (H13 : sizes (map AtomicF x3) \u0394 <= 0)\n                                   (H14 : map AtomicF x3 =\u2283 \u0394) =>\n                                 eq_ind_r\n                                   (fun \u03940 : list PropF =>\n                                    map AtomicF x3 =\u2283 \u03940 ->\n                                    sizes (map AtomicF x3) \u03940 <= 0 ->\n                                    map AtomicF x3 \u2283c \u03940)\n                                   (fun\n                                      (H15 : map AtomicF x3 =\u2283 map AtomicF x6)\n                                      (_ : sizes (map AtomicF x3)\n                                             (map AtomicF x6) <= 0) =>\n                                    let v :=\n                                      fun P : PropVars =>\n                                      if in_dec Atomic_eqdec (AVar P) x3\n                                      then true\n                                      else false in\n                                    let Heqv :\n                                      v =\n                                      (fun P : PropVars =>\n                                       if in_dec Atomic_eqdec (AVar P) x3\n                                       then true\n                                       else false) := eq_refl in\n                                    let s := in_dec Atomic_eqdec ABot x3 in\n                                    match s with\n                                    | left a =>\n                                        (fun i : In ABot x3 =>\n                                         GcBot (map AtomicF x3)\n                                           (map AtomicF x6)\n                                           (in_map AtomicF x3 ABot i)) a\n                                    | right b =>\n                                        (fun n0 : ~ In ABot x3 =>\n                                         let v0 :\n                                           exists \n                                           A : PropF,\n                                             In A (map AtomicF x6) /\\\n                                             Is_true (TrueQ v A) :=\n                                           H15 v\n                                             ((fun \n                                                 (A : PropF)\n                                                 (H17 : \n                                                 In A (map AtomicF x3)) =>\n                                               let H18 :\n                                                 forall \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x7 : A0, \n                                                 f x7 = y /\\ In x7 l :=\n                                                 fun \n                                                 (A0 B : Type) \n                                                 (f : A0 -> B) \n                                                 (l : list A0) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x7 x8 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l)\n                                                 (_ : \n                                                 (exists \n                                                 x9 : A0, \n                                                 f x9 = y /\\ In x9 l) ->\n                                                 In y (map f l)) => H18) x7\n                                                 x8\n                                                 end in\n                                               let H19 :\n                                                 exists \n                                                 x7 : Atomic,\n                                                 AtomicF x7 = A /\\ In x7 x3 :=\n                                                 H18 Atomic PropF AtomicF x3\n                                                 A H17 in\n                                               match H19 with\n                                               | ex_intro _ x7 x8 =>\n                                                 (fun \n                                                 (x9 : Atomic)\n                                                 (H20 : \n                                                 AtomicF x9 = A /\\ \n                                                 In x9 x3) =>\n                                                 match H20 with\n                                                 | conj x10 x11 =>\n                                                 (fun \n                                                 (H21 : AtomicF x9 = A)\n                                                 (H22 : In x9 x3) =>\n                                                 eq_ind \n                                                 (AtomicF x9)\n                                                 (fun A0 : PropF =>\n                                                 Is_true (TrueQ v A0))\n                                                 (match\n                                                 x9 as a\n                                                 return\n                                                 (In a x3 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)))\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H23 : In (AVar p0) x3) =>\n                                                 eq_ind_r\n                                                 (fun v0 : PropVars -> bool\n                                                 =>\n                                                 Is_true\n                                                 (TrueQ v0\n                                                 (AtomicF (AVar p0))))\n                                                 ((let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false))\n                                                 with\n                                                 | left a =>\n                                                 (fun _ : In (AVar p0) x3 =>\n                                                 I) a\n                                                 | right b0 =>\n                                                 (fun n1 : ~ In (AVar p0) x3\n                                                 =>\n                                                 False_ind \n                                                 (Is_true false) \n                                                 (n1 H23)) b0\n                                                 end)\n                                                 :\n                                                 Is_true\n                                                 (TrueQ\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false)\n                                                 (AtomicF (AVar p0)))) Heqv)\n                                                 p\n                                                 | ABot =>\n                                                 fun H23 : In ABot x3 =>\n                                                 False_ind\n                                                 (Is_true\n                                                 (TrueQ v (AtomicF ABot)))\n                                                 (n0 H23)\n                                                 end H22\n                                                 :\n                                                 Is_true\n                                                 (TrueQ v (AtomicF x9))) A\n                                                 H21) x10 x11\n                                                 end) x7 x8\n                                               end)\n                                              :\n                                              Satisfies v (map AtomicF x3))\n                                           in\n                                         match v0 with\n                                         | ex_intro _ x7 x8 =>\n                                             (fun \n                                                (x9 : PropF)\n                                                (H17 : \n                                                 In x9 (map AtomicF x6) /\\\n                                                 Is_true (TrueQ v x9)) =>\n                                              match H17 with\n                                              | conj x10 x11 =>\n                                                 (fun\n                                                 (H18 : \n                                                 In x9 \n                                                 (map AtomicF x6))\n                                                 (H19 : Is_true (TrueQ v x9))\n                                                 =>\n                                                 let H20 :\n                                                 forall \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B),\n                                                 In y (map f l) ->\n                                                 exists \n                                                 x12 : A,\n                                                 f x12 = y /\\ In x12 l :=\n                                                 fun \n                                                 (A B : Type) \n                                                 (f : A -> B) \n                                                 (l : list A) \n                                                 (y : B) =>\n                                                 match in_map_iff f l y with\n                                                 | conj x12 x13 =>\n                                                 (fun\n                                                 (H20 : \n                                                 In y (map f l) ->\n                                                 exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l)\n                                                 (_ : \n                                                 (exists \n                                                 x14 : A,\n                                                 f x14 = y /\\ In x14 l) ->\n                                                 In y (map f l)) => H20) x12\n                                                 x13\n                                                 end in\n                                                 let H21 :\n                                                 exists \n                                                 x12 : Atomic,\n                                                 AtomicF x12 = x9 /\\\n                                                 In x12 x6 :=\n                                                 H20 Atomic PropF AtomicF x6\n                                                 x9 H18 in\n                                                 match H21 with\n                                                 | ex_intro _ x12 x13 =>\n                                                 (fun \n                                                 (x14 : Atomic)\n                                                 (H22 : \n                                                 AtomicF x14 = x9 /\\\n                                                 In x14 x6) =>\n                                                 match H22 with\n                                                 | conj x15 x16 =>\n                                                 (fun\n                                                 (H23 : AtomicF x14 = x9)\n                                                 (H24 : In x14 x6) =>\n                                                 eq_ind \n                                                 (AtomicF x14)\n                                                 (fun x17 : PropF =>\n                                                 Is_true (TrueQ v x17) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 (fun\n                                                 H25 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF x14)) =>\n                                                 match\n                                                 x14 as a\n                                                 return\n                                                 (In a x6 ->\n                                                 Is_true\n                                                 (TrueQ v (AtomicF a)) ->\n                                                 map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6)\n                                                 with\n                                                 | AVar p =>\n                                                 (fun \n                                                 (p0 : PropVars)\n                                                 (H26 : In (AVar p0) x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF (AVar p0))))\n                                                 =>\n                                                 Gcax p0 \n                                                 (map AtomicF x3)\n                                                 (map AtomicF x6)\n                                                 (in_map AtomicF x3 \n                                                 (AVar p0)\n                                                 (let H28 :\n                                                 Is_true\n                                                 (if\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3\n                                                 then true\n                                                 else false) :=\n                                                 eq_ind v\n                                                 (fun v1 : PropVars -> bool\n                                                 => \n                                                 Is_true (v1 p0)) H27\n                                                 (fun P : PropVars =>\n                                                 if\n                                                 in_dec Atomic_eqdec \n                                                 (AVar P) x3\n                                                 then true\n                                                 else false) Heqv in\n                                                 let s0 :=\n                                                 in_dec Atomic_eqdec\n                                                 (AVar p0) x3 in\n                                                 match\n                                                 s0 as s1\n                                                 return\n                                                 (Is_true\n                                                 (if s1 then true else false) ->\n                                                 In (AVar p0) x3)\n                                                 with\n                                                 | left a =>\n                                                 (fun \n                                                 (i : In (AVar p0) x3)\n                                                 (_ : Is_true true) => i) a\n                                                 | right b0 =>\n                                                 (fun \n                                                 (_ : ~ In (AVar p0) x3)\n                                                 (H29 : Is_true false) =>\n                                                 False_ind \n                                                 (In (AVar p0) x3) H29) b0\n                                                 end H28))\n                                                 (in_map AtomicF x6 \n                                                 (AVar p0) H26)) p\n                                                 | ABot =>\n                                                 fun \n                                                 (_ : In ABot x6)\n                                                 (H27 : \n                                                 Is_true\n                                                 (TrueQ v (AtomicF ABot))) =>\n                                                 False_ind\n                                                 (map AtomicF x3\n                                                 \u2283c \n                                                 map AtomicF x6) H27\n                                                 end H24 H25) x9 H23 H19) x15\n                                                 x16\n                                                 end) x12 x13\n                                                 end) x10 x11\n                                              end) x7 x8\n                                         end) b\n                                    end) H12 H14 H13) H10 H H0) x4 x5\n                         end) x1 x2\n                    end) x x0\n               end) 0 H5) H3) H1\n      | le_S _ m x =>\n          (fun (m0 : nat) (H1 : sizes \u0393 \u0394 <= m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (sizes \u0393 \u0394 <= m0 -> \u0393 \u2283c \u0394) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat)\n      (IHn : forall \u0393 \u0394 : list PropF, sizes \u0393 \u0394 <= n0 -> \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394)\n      (\u0393 \u0394 : list PropF) (H : sizes \u0393 \u0394 <= S n0) (H0 : \u0393 =\u2283 \u0394) =>\n    ?Goal@{n:=n0}) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/f_cut_elimination.v", "name": "Gcf_complete", "text": "Theorem Gcf_complete : forall \u0393 \u0394, \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394.\nintros;eapply Gcf_complete_induction;[constructor|assumption].\nQed.\n", "definition": " forall \u0393 \u0394, \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394.", "proof": "\nintros;eapply Gcf_complete_induction;[constructor|assumption].\n", "def_ranges": [166, 0, 166, 52], "proof_ranges": [167, 0, 168, 4], "proof_steps": [{"text": "intros;eapply Gcf_complete_induction;[constructor|assumption].", "goal_before": ["forall \u0393 \u0394 : list PropF, \u0393 =\u2283 \u0394 -> \u0393 \u2283c \u0394"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 =\u2283 \u0394) =>\n Gcf_complete_induction (le_n (sizes \u0393 \u0394)) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 =\u2283 \u0394) =>\n Gcf_complete_induction (le_n (sizes \u0393 \u0394)) H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/f_cut_elimination.v", "name": "Cut_elimination", "text": "Theorem Cut_elimination : forall \u0393 \u0394, \u0393 \u2283 \u0394 -> \u0393 \u2283c \u0394.\nintros.\napply Gcf_complete. \napply G_sound. \nassumption. \nQed.\n", "definition": " forall \u0393 \u0394, \u0393 \u2283 \u0394 -> \u0393 \u2283c \u0394.", "proof": "\nintros.\napply Gcf_complete. \napply G_sound. \nassumption. \n", "def_ranges": [170, 0, 170, 54], "proof_ranges": [171, 0, 175, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall \u0393 \u0394 : list PropF, \u0393 \u2283 \u0394 -> \u0393 \u2283c \u0394"], "goal_after": ["\u0393 \u2283c \u0394"], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => ?Goal)"]}, {"text": "apply Gcf_complete.", "goal_before": ["\u0393 \u2283c \u0394"], "goal_after": ["\u0393 =\u2283 \u0394"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => ?Goal)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => Gcf_complete ?Goal)"]}, {"text": "apply G_sound.", "goal_before": ["\u0393 =\u2283 \u0394"], "goal_after": ["\u0393 \u2283 \u0394"], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => Gcf_complete ?Goal)"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => Gcf_complete (G_sound ?Goal))"]}, {"text": "assumption.", "goal_before": ["\u0393 \u2283 \u0394"], "goal_after": [], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => Gcf_complete (G_sound ?Goal))"], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => Gcf_complete (G_sound H))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => Gcf_complete (G_sound H))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/d_hilbert_calculus.v", "name": "Hc_to_Nc", "text": "Theorem Hc_to_Nc : forall \u0393 A, \u0393 \u22a2H A -> \u0393 \u22a2 A.\ninduction 1. \n is_ass.\n AddnilL;eapply weakening;apply Nc_AxiomH;assumption.\n mp;eassumption.\nQed.\n", "definition": " forall \u0393 A, \u0393 \u22a2H A -> \u0393 \u22a2 A.", "proof": "\ninduction 1. \n is_ass.\n AddnilL;eapply weakening;apply Nc_AxiomH;assumption.\n mp;eassumption.\n", "def_ranges": [52, 0, 52, 47], "proof_ranges": [53, 0, 57, 4], "proof_steps": [{"text": "induction 1.", "goal_before": ["forall (\u0393 : list PropF) (A : PropF), \u0393 \u22a2H A -> \u0393 \u22a2 A"], "goal_after": ["\u0393 \u22a2 A", "\u0393 \u22a2 A", "\u0393 \u22a2 B"], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2H A) =>\n Hc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2 A0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) =>\n    ?Goal@{A:=A0; \u0393:=\u03930; H:=H0})\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) =>\n    ?Goal0@{A:=A0; \u0393:=\u03930; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B)\n      (IHHc1 : \u03930 \u22a2 A0 \u2192 B) (H1 : \u03930 \u22a2H A0) (IHHc2 : \u03930 \u22a2 A0) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}) H)"]}, {"text": "is_ass.", "goal_before": ["\u0393 \u22a2 A", "\u0393 \u22a2 A", "\u0393 \u22a2 B"], "goal_after": ["\u0393 \u22a2 A", "\u0393 \u22a2 B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2H A) =>\n Hc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2 A0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) =>\n    ?Goal@{A:=A0; \u0393:=\u03930; H:=H0})\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) =>\n    ?Goal0@{A:=A0; \u0393:=\u03930; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B)\n      (IHHc1 : \u03930 \u22a2 A0 \u2192 B) (H1 : \u03930 \u22a2H A0) (IHHc2 : \u03930 \u22a2 A0) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2H A) =>\n Hc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2 A0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) => Nax \u03930 A0 H0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) =>\n    ?Goal@{A:=A0; \u0393:=\u03930; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B)\n      (IHHc1 : \u03930 \u22a2 A0 \u2192 B) (H1 : \u03930 \u22a2H A0) (IHHc2 : \u03930 \u22a2 A0) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}) H)"]}, {"text": "AddnilL;eapply weakening;apply Nc_AxiomH;assumption.", "goal_before": ["\u0393 \u22a2 A", "\u0393 \u22a2 B"], "goal_after": ["\u0393 \u22a2 B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2H A) =>\n Hc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2 A0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) => Nax \u03930 A0 H0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) =>\n    ?Goal@{A:=A0; \u0393:=\u03930; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B)\n      (IHHc1 : \u03930 \u22a2 A0 \u2192 B) (H1 : \u03930 \u22a2H A0) (IHHc2 : \u03930 \u22a2 A0) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2H A) =>\n Hc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2 A0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) => Nax \u03930 A0 H0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) =>\n    weakening \u03930 (Nc_AxiomH H0))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B)\n      (IHHc1 : \u03930 \u22a2 A0 \u2192 B) (H1 : \u03930 \u22a2H A0) (IHHc2 : \u03930 \u22a2 A0) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}) H)"]}, {"text": "mp;eassumption.", "goal_before": ["\u0393 \u22a2 B"], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2H A) =>\n Hc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2 A0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) => Nax \u03930 A0 H0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) =>\n    weakening \u03930 (Nc_AxiomH H0))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B)\n      (IHHc1 : \u03930 \u22a2 A0 \u2192 B) (H1 : \u03930 \u22a2H A0) (IHHc2 : \u03930 \u22a2 A0) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2H A) =>\n Hc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2 A0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) => Nax \u03930 A0 H0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) =>\n    weakening \u03930 (Nc_AxiomH H0))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2H A0 \u2192 B)\n      (IHHc1 : \u03930 \u22a2 A0 \u2192 B) (_ : \u03930 \u22a2H A0) (IHHc2 : \u03930 \u22a2 A0) =>\n    ImpE IHHc1 IHHc2) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2H A) =>\n Hc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2 A0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) => Nax \u03930 A0 H0)\n   (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) =>\n    weakening \u03930 (Nc_AxiomH H0))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2H A0 \u2192 B)\n      (IHHc1 : \u03930 \u22a2 A0 \u2192 B) (_ : \u03930 \u22a2H A0) (IHHc2 : \u03930 \u22a2 A0) =>\n    ImpE IHHc1 IHHc2) H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/d_hilbert_calculus.v", "name": "H_Deduction_Theorem", "text": "Theorem H_Deduction_Theorem : forall \u0393 A B, A::\u0393 \u22a2H B <-> \u0393 \u22a2H A \u2192 B.\nsplit;intro.\n remember (A::\u0393). revert \u0393 Heql. induction H;intros;subst.\n  destruct H.\n    subst. do 2 (Hmp;[|aK]). instantiate (2:=\u22a5). aS.\n    Hmp;[aK|is_ass].\n  Hmp;[aK|is_ax].\n  Hmp;[Hmp;[aS|]|];auto.\n Hmp;[|is_ass]. eapply H_weakening;[|eassumption].\n  intros;in_solve.\nQed.\n", "definition": " forall \u0393 A B, A::\u0393 \u22a2H B <-> \u0393 \u22a2H A \u2192 B.", "proof": "\nsplit;intro.\n remember (A::\u0393). revert \u0393 Heql. induction H;intros;subst.\n  destruct H.\n    subst. do 2 (Hmp;[|aK]). instantiate (2:=\u22a5). aS.\n    Hmp;[aK|is_ass].\n  Hmp;[aK|is_ax].\n  Hmp;[Hmp;[aS|]|];auto.\n Hmp;[|is_ass]. eapply H_weakening;[|eassumption].\n  intros;in_solve.\n", "def_ranges": [68, 0, 68, 69], "proof_ranges": [69, 0, 78, 4], "proof_steps": [{"text": "split;intro.", "goal_before": ["forall (\u0393 : list PropF) (A B : PropF), A :: \u0393 \u22a2H B <-> \u0393 \u22a2H A \u2192 B"], "goal_after": ["\u0393 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj (fun H : A :: \u0393 \u22a2H B => ?Goal) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal0))"]}, {"text": "remember (A::\u0393).", "goal_before": ["\u0393 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u0393 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj (fun H : A :: \u0393 \u22a2H B => ?Goal) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal0))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in let Heql : l = A :: \u0393 := eq_refl in ?Goal0)\n   (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "revert \u0393 Heql.", "goal_before": ["\u0393 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["forall \u0393 : list PropF, l = A :: \u0393 -> \u0393 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in let Heql : l = A :: \u0393 := eq_refl in ?Goal0)\n   (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in let Heql : l = A :: \u0393 := eq_refl in ?Goal0 \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "induction H;intros;subst.", "goal_before": ["forall \u0393 : list PropF, l = A :: \u0393 -> \u0393 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in let Heql : l = A :: \u0393 := eq_refl in ?Goal0 \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) => ?Goal0@{\u03930:=\u03931; H:=H1}) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal1@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal2@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "destruct H.", "goal_before": ["\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) => ?Goal0@{\u03930:=\u03931; H:=H1}) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal1@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal2@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x => (fun H2 : A = A0 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal3@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "subst.", "goal_before": ["\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u03930 \u22a2H A0 \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x => (fun H2 : A = A0 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal3@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0) ?Goal3@{\u03930:=\u03931} H2)\n                x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "do 2 (Hmp;[|aK]).", "goal_before": ["\u03930 \u22a2H A0 \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u03930 \u22a2H (?A0 \u2192 ?B0 \u2192 ?A0) \u2192 (?A \u2192 ?B \u2192 ?A) \u2192 A0 \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0) ?Goal3@{\u03930:=\u03931} H2)\n                x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE ?Goal3@{\u03930:=\u03931}\n                       (Hax \u03931 (HK ?A0@{\u03930:=\u03931} ?B0@{\u03930:=\u03931})))\n                    (Hax \u03931 (HK ?A@{\u03930:=\u03931} ?B@{\u03930:=\u03931}))) H2) x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "instantiate (2:=\u22a5).", "goal_before": ["\u03930 \u22a2H (?A0 \u2192 ?B0 \u2192 ?A0) \u2192 (?A \u2192 ?B \u2192 ?A) \u2192 A0 \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u03930 \u22a2H (?A0 \u2192 ?B \u2192 ?A0) \u2192 (?A \u2192 \u22a5 \u2192 ?A) \u2192 A0 \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE ?Goal3@{\u03930:=\u03931}\n                       (Hax \u03931 (HK ?A0@{\u03930:=\u03931} ?B0@{\u03930:=\u03931})))\n                    (Hax \u03931 (HK ?A@{\u03930:=\u03931} ?B@{\u03930:=\u03931}))) H2) x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE ?Goal3@{\u03930:=\u03931}\n                       (Hax \u03931 (HK ?A0@{\u03930:=\u03931} ?B@{\u03930:=\u03931})))\n                    (Hax \u03931 (HK ?A@{\u03930:=\u03931} \u22a5))) H2) x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "aS.", "goal_before": ["\u03930 \u22a2H (?A0 \u2192 ?B \u2192 ?A0) \u2192 (?A \u2192 \u22a5 \u2192 ?A) \u2192 A0 \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE ?Goal3@{\u03930:=\u03931}\n                       (Hax \u03931 (HK ?A0@{\u03930:=\u03931} ?B@{\u03930:=\u03931})))\n                    (Hax \u03931 (HK ?A@{\u03930:=\u03931} \u22a5))) H2) x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "Hmp;[aK|is_ass].", "goal_before": ["\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x => (fun H2 : In A0 \u03931 => ?Goal2@{\u03930:=\u03931; H:=H2}) x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "Hmp;[aK|is_ax].", "goal_before": ["\u03930 \u22a2H A \u2192 A0", "\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) => ?Goal0@{H:=H0; \u03930:=\u03931})\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal1@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal0@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "Hmp;[Hmp;[aS|]|];auto.", "goal_before": ["\u03930 \u22a2H A \u2192 B", "A :: \u0393 \u22a2H B"], "goal_after": ["A :: \u0393 \u22a2H B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (H2 : A :: \u03931 \u22a2H A0 \u2192 B0) (H3 : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          ?Goal0@{B:=B0; \u03930:=\u03931; IHHc2:=IHHc4; IHHc1:=IHHc3; H0:=H3; H:=H2})\n         Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql) (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (_ : A :: \u03931 \u22a2H A0 \u2192 B0) (_ : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          HImpE (HImpE (Hax \u03931 (HS A A0 B0)) (IHHc3 \u03931 eq_refl))\n            (IHHc4 \u03931 eq_refl)) Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"]}, {"text": "Hmp;[|is_ass].", "goal_before": ["A :: \u0393 \u22a2H B"], "goal_after": ["A :: \u0393 \u22a2H A \u2192 B"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (_ : A :: \u03931 \u22a2H A0 \u2192 B0) (_ : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          HImpE (HImpE (Hax \u03931 (HS A A0 B0)) (IHHc3 \u03931 eq_refl))\n            (IHHc4 \u03931 eq_refl)) Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B => ?Goal))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (_ : A :: \u03931 \u22a2H A0 \u2192 B0) (_ : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          HImpE (HImpE (Hax \u03931 (HS A A0 B0)) (IHHc3 \u03931 eq_refl))\n            (IHHc4 \u03931 eq_refl)) Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B => HImpE ?Goal (Hass A (A :: \u0393) (or_introl eq_refl))))"]}, {"text": "eapply H_weakening;[|eassumption].", "goal_before": ["A :: \u0393 \u22a2H A \u2192 B"], "goal_after": ["forall B0 : PropF, In B0 \u0393 -> In B0 (A :: \u0393)"], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (_ : A :: \u03931 \u22a2H A0 \u2192 B0) (_ : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          HImpE (HImpE (Hax \u03931 (HS A A0 B0)) (IHHc3 \u03931 eq_refl))\n            (IHHc4 \u03931 eq_refl)) Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B => HImpE ?Goal (Hass A (A :: \u0393) (or_introl eq_refl))))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (_ : A :: \u03931 \u22a2H A0 \u2192 B0) (_ : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          HImpE (HImpE (Hax \u03931 (HS A A0 B0)) (IHHc3 \u03931 eq_refl))\n            (IHHc4 \u03931 eq_refl)) Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B =>\n    HImpE (H_weakening (A :: \u0393) ?Goal H)\n      (Hass A (A :: \u0393) (or_introl eq_refl))))"]}, {"text": "intros;in_solve.", "goal_before": ["forall B0 : PropF, In B0 \u0393 -> In B0 (A :: \u0393)"], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (_ : A :: \u03931 \u22a2H A0 \u2192 B0) (_ : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          HImpE (HImpE (Hax \u03931 (HS A A0 B0)) (IHHc3 \u03931 eq_refl))\n            (IHHc4 \u03931 eq_refl)) Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B =>\n    HImpE (H_weakening (A :: \u0393) ?Goal H)\n      (Hass A (A :: \u0393) (or_introl eq_refl))))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (_ : A :: \u03931 \u22a2H A0 \u2192 B0) (_ : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          HImpE (HImpE (Hax \u03931 (HS A A0 B0)) (IHHc3 \u03931 eq_refl))\n            (IHHc4 \u03931 eq_refl)) Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B =>\n    HImpE\n      (H_weakening (A :: \u0393) (fun (B0 : PropF) (H0 : In B0 \u0393) => or_intror H0)\n         H) (Hass A (A :: \u0393) (or_introl eq_refl))))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A B : PropF) =>\n conj\n   (fun H : A :: \u0393 \u22a2H B =>\n    let l := A :: \u0393 in\n    let Heql : l = A :: \u0393 := eq_refl in\n    Hc_ind\n      (fun (l0 : list PropF) (B0 : PropF) =>\n       forall \u03930 : list PropF, l0 = A :: \u03930 -> \u03930 \u22a2H A \u2192 B0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : In A0 \u03930) \n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r (fun \u03932 : list PropF => In A0 \u03932 -> \u03931 \u22a2H A \u2192 A0)\n         (fun H1 : In A0 (A :: \u03931) =>\n          match H1 with\n          | or_introl x =>\n              (fun H2 : A = A0 =>\n               eq_ind_r (fun A1 : PropF => \u03931 \u22a2H A1 \u2192 A0)\n                 (HImpE\n                    (HImpE (Hax \u03931 (HS A0 (\u22a5 \u2192 A0) A0))\n                       (Hax \u03931 (HK A0 (\u22a5 \u2192 A0)))) \n                    (Hax \u03931 (HK A0 \u22a5))) H2) x\n          | or_intror x =>\n              (fun H2 : In A0 \u03931 => HImpE (Hax \u03931 (HK A0 A)) (Hass A0 \u03931 H2))\n                x\n          end) Heql0 H0)\n      (fun (A0 : PropF) (\u03930 : list PropF) (H0 : AxiomH A0) \n         (\u03931 : list PropF) (_ : \u03930 = A :: \u03931) =>\n       HImpE (Hax \u03931 (HK A0 A)) (Hax \u03931 H0))\n      (fun (\u03930 : list PropF) (A0 B0 : PropF) (H0 : \u03930 \u22a2H A0 \u2192 B0)\n         (IHHc1 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0 \u2192 B0)\n         (H1 : \u03930 \u22a2H A0)\n         (IHHc2 : forall \u03931 : list PropF, \u03930 = A :: \u03931 -> \u03931 \u22a2H A \u2192 A0)\n         (\u03931 : list PropF) (Heql0 : \u03930 = A :: \u03931) =>\n       eq_ind_r\n         (fun \u03932 : list PropF =>\n          \u03932 \u22a2H A0 \u2192 B0 ->\n          \u03932 \u22a2H A0 ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0 \u2192 B0) ->\n          (forall \u03933 : list PropF, \u03932 = A :: \u03933 -> \u03933 \u22a2H A \u2192 A0) ->\n          \u03931 \u22a2H A \u2192 B0)\n         (fun (_ : A :: \u03931 \u22a2H A0 \u2192 B0) (_ : A :: \u03931 \u22a2H A0)\n            (IHHc3 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0 \u2192 B0)\n            (IHHc4 : forall \u03932 : list PropF,\n                     A :: \u03931 = A :: \u03932 -> \u03932 \u22a2H A \u2192 A0) =>\n          HImpE (HImpE (Hax \u03931 (HS A A0 B0)) (IHHc3 \u03931 eq_refl))\n            (IHHc4 \u03931 eq_refl)) Heql0 H0 H1 IHHc1 IHHc2) H \u0393 Heql)\n   (fun H : \u0393 \u22a2H A \u2192 B =>\n    HImpE\n      (H_weakening (A :: \u0393) (fun (B0 : PropF) (H0 : In B0 \u0393) => or_intror H0)\n         H) (Hass A (A :: \u0393) (or_introl eq_refl))))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/d_hilbert_calculus.v", "name": "Nc_to_Hc", "text": "Theorem Nc_to_Hc : forall \u0393 A, \u0393 \u22a2 A -> \u0393 \u22a2H A.\ninduction 1;try (Hmp;[|eassumption];is_ax;fail).\n is_ass.\n HImpI;assumption.\n Hmp;eassumption.\n Hmp;[aC|HImpI;assumption]. \n Hmp;[Hmp;[is_ax|]|];assumption.\n Hmp;[Hmp;[Hmp|]|]. \n   is_ax.\n   eassumption.\n   HImpI;assumption.\n   HImpI;assumption.\nQed.\n", "definition": " forall \u0393 A, \u0393 \u22a2 A -> \u0393 \u22a2H A.", "proof": "\ninduction 1;try (Hmp;[|eassumption];is_ax;fail).\n is_ass.\n HImpI;assumption.\n Hmp;eassumption.\n Hmp;[aC|HImpI;assumption]. \n Hmp;[Hmp;[is_ax|]|];assumption.\n Hmp;[Hmp;[Hmp|]|]. \n   is_ax.\n   eassumption.\n   HImpI;assumption.\n   HImpI;assumption.\n", "def_ranges": [81, 0, 81, 47], "proof_ranges": [82, 0, 93, 4], "proof_steps": [{"text": "induction 1;try (Hmp;[|eassumption];is_ax;fail).", "goal_before": ["forall (\u0393 : list PropF) (A : PropF), \u0393 \u22a2 A -> \u0393 \u22a2H A"], "goal_after": ["\u0393 \u22a2H A", "\u0393 \u22a2H A \u2192 B", "\u0393 \u22a2H B", "\u0393 \u22a2H A", "\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "is_ass.", "goal_before": ["\u0393 \u22a2H A", "\u0393 \u22a2H A \u2192 B", "\u0393 \u22a2H B", "\u0393 \u22a2H A", "\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "goal_after": ["\u0393 \u22a2H A \u2192 B", "\u0393 \u22a2H B", "\u0393 \u22a2H A", "\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "HImpI;assumption.", "goal_before": ["\u0393 \u22a2H A \u2192 B", "\u0393 \u22a2H B", "\u0393 \u22a2H A", "\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "goal_after": ["\u0393 \u22a2H B", "\u0393 \u22a2H A", "\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "Hmp;eassumption.", "goal_before": ["\u0393 \u22a2H B", "\u0393 \u22a2H A", "\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "goal_after": ["\u0393 \u22a2H A", "\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "Hmp;[aC|HImpI;assumption].", "goal_before": ["\u0393 \u22a2H A", "\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "goal_after": ["\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "Hmp;[Hmp;[is_ax|]|];assumption.", "goal_before": ["\u0393 \u22a2H A \u2227 B", "\u0393 \u22a2H C"], "goal_after": ["\u0393 \u22a2H C"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "Hmp;[Hmp;[Hmp|]|].", "goal_before": ["\u0393 \u22a2H C"], "goal_after": ["\u0393 \u22a2H ?A1 \u2192 ?A0 \u2192 ?A \u2192 C", "\u0393 \u22a2H ?A1", "\u0393 \u22a2H ?A0", "\u0393 \u22a2H ?A"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE\n         (HImpE ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}\n            ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n         ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n      ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "is_ax.", "goal_before": ["\u0393 \u22a2H ?A1 \u2192 ?A0 \u2192 ?A \u2192 C", "\u0393 \u22a2H ?A1", "\u0393 \u22a2H ?A0", "\u0393 \u22a2H ?A"], "goal_after": ["\u0393 \u22a2H ?A \u2228 ?B", "\u0393 \u22a2H ?A \u2192 C", "\u0393 \u22a2H ?B \u2192 C"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE\n         (HImpE ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}\n            ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n         ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n      ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE\n         (HImpE\n            (Hax \u03930\n               (HOrE ?A@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}\n                  ?B@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2} C))\n            ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n         ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n      ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "eassumption.", "goal_before": ["\u0393 \u22a2H ?A \u2228 ?B", "\u0393 \u22a2H ?A \u2192 C", "\u0393 \u22a2H ?B \u2192 C"], "goal_after": ["\u0393 \u22a2H A \u2192 C", "\u0393 \u22a2H B \u2192 C"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE\n         (HImpE\n            (Hax \u03930\n               (HOrE ?A@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}\n                  ?B@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2} C))\n            ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n         ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n      ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE (HImpE (Hax \u03930 (HOrE A0 B C)) IHNc1)\n         ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n      ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "HImpI;assumption.", "goal_before": ["\u0393 \u22a2H A \u2192 C", "\u0393 \u22a2H B \u2192 C"], "goal_after": ["\u0393 \u22a2H B \u2192 C"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE (HImpE (Hax \u03930 (HOrE A0 B C)) IHNc1)\n         ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n      ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE (HImpE (Hax \u03930 (HOrE A0 B C)) IHNc1)\n         (let H3 :\n            forall (\u03931 : list PropF) (A1 B0 : PropF),\n            A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n            fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n            match H_Deduction_Theorem \u03931 A1 B0 with\n            | conj x x0 =>\n                (fun (H3 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n                   (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H3) x x0\n            end in\n          H3 \u03930 A0 C IHNc2)) ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "HImpI;assumption.", "goal_before": ["\u0393 \u22a2H B \u2192 C"], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (H1 : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (H2 : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE (HImpE (Hax \u03930 (HOrE A0 B C)) IHNc1)\n         (let H3 :\n            forall (\u03931 : list PropF) (A1 B0 : PropF),\n            A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n            fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n            match H_Deduction_Theorem \u03931 A1 B0 with\n            | conj x x0 =>\n                (fun (H3 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n                   (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H3) x x0\n            end in\n          H3 \u03930 A0 C IHNc2)) ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (_ : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (_ : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (_ : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE (HImpE (Hax \u03930 (HOrE A0 B C)) IHNc1)\n         (let H3 :\n            forall (\u03931 : list PropF) (A1 B0 : PropF),\n            A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n            fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n            match H_Deduction_Theorem \u03931 A1 B0 with\n            | conj x x0 =>\n                (fun (H3 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n                   (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H3) x x0\n            end in\n          H3 \u03930 A0 C IHNc2))\n      (let H3 :\n         forall (\u03931 : list PropF) (A1 B0 : PropF),\n         A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n         fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B0 with\n         | conj x x0 =>\n             (fun (H3 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n                (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H3) x x0\n         end in\n       H3 \u03930 B C IHNc3)) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u22a2H A0)\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) => Hass A0 \u03930 H0)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u22a2H B) =>\n    let H1 :\n      forall (\u03931 : list PropF) (A1 B0 : PropF),\n      A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n      fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n      match H_Deduction_Theorem \u03931 A1 B0 with\n      | conj x x0 =>\n          (fun (H1 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n             (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H1) x x0\n      end in\n    H1 \u03930 A0 B IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2192 B) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u22a2H A0) =>\n    HImpE IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u22a2H \u22a5) =>\n    HImpE (Hax \u03930 (HClas A0))\n      (let H1 :\n         forall (\u03931 : list PropF) (A1 B : PropF),\n         A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B :=\n         fun (\u03931 : list PropF) (A1 B : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B with\n         | conj x x0 =>\n             (fun (H1 : A1 :: \u03931 \u22a2H B -> \u03931 \u22a2H A1 \u2192 B)\n                (_ : \u03931 \u22a2H A1 \u2192 B -> A1 :: \u03931 \u22a2H B) => H1) x x0\n         end in\n       H1 \u03930 \u00ac A0 \u22a5 IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u22a2H A0) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u22a2H B) =>\n    HImpE (HImpE (Hax \u03930 (HAndI A0 B)) IHNc1) IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u22a2H A0 \u2227 B) => HImpE (Hax \u03930 (HAndE2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u22a2H A0) =>\n    HImpE (Hax \u03930 (HOrI1 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u22a2H B) =>\n    HImpE (Hax \u03930 (HOrI2 A0 B)) IHNc)\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (_ : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u22a2H A0 \u2228 B) (_ : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u22a2H C)\n      (_ : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u22a2H C) =>\n    HImpE\n      (HImpE (HImpE (Hax \u03930 (HOrE A0 B C)) IHNc1)\n         (let H3 :\n            forall (\u03931 : list PropF) (A1 B0 : PropF),\n            A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n            fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n            match H_Deduction_Theorem \u03931 A1 B0 with\n            | conj x x0 =>\n                (fun (H3 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n                   (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H3) x x0\n            end in\n          H3 \u03930 A0 C IHNc2))\n      (let H3 :\n         forall (\u03931 : list PropF) (A1 B0 : PropF),\n         A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0 :=\n         fun (\u03931 : list PropF) (A1 B0 : PropF) =>\n         match H_Deduction_Theorem \u03931 A1 B0 with\n         | conj x x0 =>\n             (fun (H3 : A1 :: \u03931 \u22a2H B0 -> \u03931 \u22a2H A1 \u2192 B0)\n                (_ : \u03931 \u22a2H A1 \u2192 B0 -> A1 :: \u03931 \u22a2H B0) => H3) x x0\n         end in\n       H3 \u03930 B C IHNc3)) H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/d_hilbert_calculus.v", "name": "Nc_equiv_Hc", "text": "Theorem Nc_equiv_Hc : forall \u0393 A, \u0393 \u22a2 A <-> \u0393 \u22a2H A.\nsplit;[apply Nc_to_Hc|apply Hc_to_Nc]. \nQed.\n", "definition": " forall \u0393 A, \u0393 \u22a2 A <-> \u0393 \u22a2H A.", "proof": "\nsplit;[apply Nc_to_Hc|apply Hc_to_Nc]. \n", "def_ranges": [95, 0, 95, 51], "proof_ranges": [96, 0, 97, 4], "proof_steps": [{"text": "split;[apply Nc_to_Hc|apply Hc_to_Nc].", "goal_before": ["forall (\u0393 : list PropF) (A : PropF), \u0393 \u22a2 A <-> \u0393 \u22a2H A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) => conj (Nc_to_Hc (A:=A)) (Hc_to_Nc (A:=A)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) => conj (Nc_to_Hc (A:=A)) (Hc_to_Nc (A:=A)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/e_sequent_calculus.v", "name": "G_to_Nc", "text": "Theorem G_to_Nc : forall \u0393 \u0394, \u0393 \u2283 \u0394 -> \u0393 \u22a2 \u22c1\u0394.\nintros;apply ConjNeg_Disj;apply G_to_Nc_Neg;assumption.\nQed.\n", "definition": " forall \u0393 \u0394, \u0393 \u2283 \u0394 -> \u0393 \u22a2 \u22c1\u0394.", "proof": "\nintros;apply ConjNeg_Disj;apply G_to_Nc_Neg;assumption.\n", "def_ranges": [114, 0, 114, 46], "proof_ranges": [115, 0, 116, 4], "proof_steps": [{"text": "intros;apply ConjNeg_Disj;apply G_to_Nc_Neg;assumption.", "goal_before": ["forall \u0393 \u0394 : list PropF, \u0393 \u2283 \u0394 -> \u0393 \u22a2 \u22c1 \u0394"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => ConjNeg_Disj \u0394 \u0393 (G_to_Nc_Neg H))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 \u0394 : list PropF) (H : \u0393 \u2283 \u0394) => ConjNeg_Disj \u0394 \u0393 (G_to_Nc_Neg H))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/e_sequent_calculus.v", "name": "Nc_to_G", "text": "Theorem Nc_to_G : forall \u0393 A, \u0393 \u22a2 A -> \u0393 \u2283 [A].\ninduction 1.\n is_ass.\n apply ImpR with (\u03941:=[]);assumption.\n apply Cut with (A\u2192B).\n   apply WeakR with (\u03941:=[_]);assumption.\n   apply ImpL with (\u03931:=[]).\n     is_ass.\n     apply WeakR with (\u03941:=[_]);assumption.\n apply Cut with (\u00acA).\n   apply ImpR with (\u03941:=[]);is_ass.\n   eapply Cut.\n    apply WeakR with (\u03941:=[\u22a5]);assumption.\n    apply GBot;in_solve.\n apply AndR with (\u03941:=[]);assumption.\n apply Cut with (A \u2227 B).\n   apply WeakR with (\u03941:=[_]);assumption.\n   apply AndL with (\u03931:=[]);is_ass.\n apply Cut with (A \u2227 B).\n   apply WeakR with (\u03941:=[_]);assumption.\n   apply AndL with (\u03931:=[]);constructor 1 with B;in_solve.\n apply OrR with (\u03941:=[]);apply WeakR with (\u03941:=[_]);assumption.\n apply OrR with (\u03941:=[]);apply WeakR;assumption.\n apply Cut with (A \u2228 B).\n   apply WeakR with (\u03941:=[_]);assumption.\n   apply OrL with (\u03931:=[]);assumption.\nQed.\n", "definition": " forall \u0393 A, \u0393 \u22a2 A -> \u0393 \u2283 [A].", "proof": "\ninduction 1.\n is_ass.\n apply ImpR with (\u03941:=[]);assumption.\n apply Cut with (A\u2192B).\n   apply WeakR with (\u03941:=[_]);assumption.\n   apply ImpL with (\u03931:=[]).\n     is_ass.\n     apply WeakR with (\u03941:=[_]);assumption.\n apply Cut with (\u00acA).\n   apply ImpR with (\u03941:=[]);is_ass.\n   eapply Cut.\n    apply WeakR with (\u03941:=[\u22a5]);assumption.\n    apply GBot;in_solve.\n apply AndR with (\u03941:=[]);assumption.\n apply Cut with (A \u2227 B).\n   apply WeakR with (\u03941:=[_]);assumption.\n   apply AndL with (\u03931:=[]);is_ass.\n apply Cut with (A \u2227 B).\n   apply WeakR with (\u03941:=[_]);assumption.\n   apply AndL with (\u03931:=[]);constructor 1 with B;in_solve.\n apply OrR with (\u03941:=[]);apply WeakR with (\u03941:=[_]);assumption.\n apply OrR with (\u03941:=[]);apply WeakR;assumption.\n apply Cut with (A \u2228 B).\n   apply WeakR with (\u03941:=[_]);assumption.\n   apply OrL with (\u03931:=[]);assumption.\n", "def_ranges": [167, 0, 167, 47], "proof_ranges": [168, 0, 193, 4], "proof_steps": [{"text": "induction 1.", "goal_before": ["forall (\u0393 : list PropF) (A : PropF), \u0393 \u22a2 A -> \u0393 \u2283 [A]"], "goal_after": ["\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2192 B]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal7@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal8@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "is_ass.", "goal_before": ["\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2192 B]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A \u2192 B]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal7@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal8@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal7@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply ImpR with (\u03941:=[]);assumption.", "goal_before": ["\u0393 \u2283 [A \u2192 B]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal7@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply Cut with (A\u2192B).", "goal_before": ["\u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A \u2192 B; B]", "A \u2192 B :: \u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}\n      ?Goal7@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply WeakR with (\u03941:=[_]);assumption.", "goal_before": ["\u0393 \u2283 [A \u2192 B; B]", "A \u2192 B :: \u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["A \u2192 B :: \u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}\n      ?Goal7@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1) ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply ImpL with (\u03931:=[]).", "goal_before": ["A \u2192 B :: \u0393 \u2283 [B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["[] ++ B :: \u0393 \u2283 [B]", "[] ++ \u0393 \u2283 [A; B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1) ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930 ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}\n         ?Goal7@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "is_ass.", "goal_before": ["[] ++ B :: \u0393 \u2283 [B]", "[] ++ \u0393 \u2283 [A; B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["[] ++ \u0393 \u2283 [A; B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930 ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}\n         ?Goal7@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply WeakR with (\u03941:=[_]);assumption.", "goal_before": ["[] ++ \u0393 \u2283 [A; B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (H1 : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1}))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply Cut with (\u00acA).", "goal_before": ["\u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [\u00ac A; A]", "\u00ac A :: \u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0} ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply ImpR with (\u03941:=[]);is_ass.", "goal_before": ["\u0393 \u2283 [\u00ac A; A]", "\u00ac A :: \u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u00ac A :: \u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0} ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "eapply Cut.", "goal_before": ["\u00ac A :: \u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u00ac A :: \u0393 \u2283 [?A; A]", "?A :: \u00ac A :: \u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0} ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0}))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply WeakR with (\u03941:=[\u22a5]);assumption.", "goal_before": ["\u00ac A :: \u0393 \u2283 [?A; A]", "?A :: \u00ac A :: \u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u22a5 :: \u00ac A :: \u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0} ?Goal6@{\u0393:=\u03930; A:=A0; H:=H0}))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc) ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0}))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply GBot;in_solve.", "goal_before": ["\u22a5 :: \u00ac A :: \u0393 \u2283 [A]", "\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc) ?Goal5@{\u0393:=\u03930; A:=A0; H:=H0}))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply AndR with (\u03941:=[]);assumption.", "goal_before": ["\u0393 \u2283 [A \u2227 B]", "\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (H1 : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply Cut with (A \u2227 B).", "goal_before": ["\u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A \u2227 B; A]", "A \u2227 B :: \u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0} ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply WeakR with (\u03941:=[_]);assumption.", "goal_before": ["\u0393 \u2283 [A \u2227 B; A]", "A \u2227 B :: \u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["A \u2227 B :: \u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0} ?Goal4@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc) ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply AndL with (\u03931:=[]);is_ass.", "goal_before": ["A \u2227 B :: \u0393 \u2283 [A]", "\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc) ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply Cut with (A \u2227 B).", "goal_before": ["\u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A \u2227 B; B]", "A \u2227 B :: \u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0} ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply WeakR with (\u03941:=[_]);assumption.", "goal_before": ["\u0393 \u2283 [A \u2227 B; B]", "A \u2227 B :: \u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["A \u2227 B :: \u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0} ?Goal3@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc) ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply AndL with (\u03931:=[]);constructor 1 with B;in_solve.", "goal_before": ["A \u2227 B :: \u0393 \u2283 [B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc) ?Goal2@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply OrR with (\u03941:=[]);apply WeakR with (\u03941:=[_]);assumption.", "goal_before": ["\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal1@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply OrR with (\u03941:=[]);apply WeakR;assumption.", "goal_before": ["\u0393 \u2283 [A \u2228 B]", "\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (H0 : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    ?Goal@{\u0393:=\u03930; A:=A0; H:=H0})\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    OrR A0 B [] [] (WeakR [] [B] A0 IHNc))\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"]}, {"text": "apply Cut with (A \u2228 B).", "goal_before": ["\u0393 \u2283 [C]"], "goal_after": ["\u0393 \u2283 [A \u2228 B; C]", "A \u2228 B :: \u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    OrR A0 B [] [] (WeakR [] [B] A0 IHNc))\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) => ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2})\n   H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    OrR A0 B [] [] (WeakR [] [B] A0 IHNc))\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) =>\n    Cut ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}\n      ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "apply WeakR with (\u03941:=[_]);assumption.", "goal_before": ["\u0393 \u2283 [A \u2228 B; C]", "A \u2228 B :: \u0393 \u2283 [C]"], "goal_after": ["A \u2228 B :: \u0393 \u2283 [C]"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    OrR A0 B [] [] (WeakR [] [B] A0 IHNc))\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) =>\n    Cut ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}\n      ?Goal0@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    OrR A0 B [] [] (WeakR [] [B] A0 IHNc))\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) =>\n    Cut (WeakR [A0 \u2228 B] [] C IHNc1)\n      ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"]}, {"text": "apply OrL with (\u03931:=[]);assumption.", "goal_before": ["A \u2228 B :: \u0393 \u2283 [C]"], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    OrR A0 B [] [] (WeakR [] [B] A0 IHNc))\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (H0 : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (H1 : A0 :: \u03930 \u22a2 C) \n      (IHNc2 : A0 :: \u03930 \u2283 [C]) (H2 : B :: \u03930 \u22a2 C) \n      (IHNc3 : B :: \u03930 \u2283 [C]) =>\n    Cut (WeakR [A0 \u2228 B] [] C IHNc1)\n      ?Goal@{\u0393:=\u03930; A:=A0; H:=H0; H0:=H1; H1:=H2}) H)"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    OrR A0 B [] [] (WeakR [] [B] A0 IHNc))\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (_ : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (_ : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u2283 [C])\n      (_ : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u2283 [C]) =>\n    Cut (WeakR [A0 \u2228 B] [] C IHNc1) (OrL A0 B [] \u03930 IHNc2 IHNc3)) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) (H : \u0393 \u22a2 A) =>\n Nc_ind (fun (\u03930 : list PropF) (A0 : PropF) => \u03930 \u2283 [A0])\n   (fun (\u03930 : list PropF) (A0 : PropF) (H0 : In A0 \u03930) =>\n    Gax A0 \u03930 [A0] H0 (or_introl eq_refl))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : A0 :: \u03930 \u22a2 B)\n      (IHNc : A0 :: \u03930 \u2283 [B]) => ImpR B [] [] IHNc)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2192 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2192 B]) (_ : \u03930 \u22a2 A0) (IHNc2 : \u03930 \u2283 [A0]) =>\n    Cut (WeakR [A0 \u2192 B] [] B IHNc1)\n      (ImpL B [] \u03930\n         (Gax B ([] ++ B :: \u03930) [B]\n            (let H2 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H2 : In a l \\/ In a l' -> In a (l ++ l')) => H2) x x0\n               end in\n             H2 PropF [] (B :: \u03930) B (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl)) (WeakR [A0] [] B IHNc2)))\n   (fun (\u03930 : list PropF) (A0 : PropF) (_ : \u00ac A0 :: \u03930 \u22a2 \u22a5)\n      (IHNc : \u00ac A0 :: \u03930 \u2283 [\u22a5]) =>\n    Cut\n      (ImpR \u22a5 [] [A0]\n         (Gax A0 (A0 :: \u03930) ([] ++ [\u22a5; A0]) (or_introl eq_refl)\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] [\u22a5; A0] A0\n               (or_intror (or_intror (or_introl eq_refl))))))\n      (Cut (WeakR [\u22a5] [] A0 IHNc)\n         (GBot (\u22a5 :: \u00ac A0 :: \u03930) [A0] (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) \n      (IHNc1 : \u03930 \u2283 [A0]) (_ : \u03930 \u22a2 B) (IHNc2 : \u03930 \u2283 [B]) =>\n    AndR A0 B [] [] IHNc1 IHNc2)\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] A0 IHNc)\n      (AndL A0 B [] \u03930\n         (Gax A0 ([] ++ A0 :: B :: \u03930) [A0]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) A0 (or_intror (or_introl eq_refl)))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0 \u2227 B)\n      (IHNc : \u03930 \u2283 [A0 \u2227 B]) =>\n    Cut (WeakR [A0 \u2227 B] [] B IHNc)\n      (AndL A0 B [] \u03930\n         (Gax B ([] ++ A0 :: B :: \u03930) [B]\n            (let H1 :\n               forall (A1 : Type) (l l' : list A1) (a : A1),\n               In a l \\/ In a l' -> In a (l ++ l') :=\n               fun (A1 : Type) (l l' : list A1) (a : A1) =>\n               match in_app_iff l l' a with\n               | conj x x0 =>\n                   (fun (_ : In a (l ++ l') -> In a l \\/ In a l')\n                      (H1 : In a l \\/ In a l' -> In a (l ++ l')) => H1) x x0\n               end in\n             H1 PropF [] (A0 :: B :: \u03930) B\n               (or_intror (or_intror (or_introl eq_refl))))\n            (or_introl eq_refl))))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 A0) (IHNc : \u03930 \u2283 [A0]) =>\n    OrR A0 B [] [] (WeakR [A0] [] B IHNc))\n   (fun (\u03930 : list PropF) (A0 B : PropF) (_ : \u03930 \u22a2 B) (IHNc : \u03930 \u2283 [B]) =>\n    OrR A0 B [] [] (WeakR [] [B] A0 IHNc))\n   (fun (\u03930 : list PropF) (A0 B C : PropF) (_ : \u03930 \u22a2 A0 \u2228 B)\n      (IHNc1 : \u03930 \u2283 [A0 \u2228 B]) (_ : A0 :: \u03930 \u22a2 C) (IHNc2 : A0 :: \u03930 \u2283 [C])\n      (_ : B :: \u03930 \u22a2 C) (IHNc3 : B :: \u03930 \u2283 [C]) =>\n    Cut (WeakR [A0 \u2228 B] [] C IHNc1) (OrL A0 B [] \u03930 IHNc2 IHNc3)) H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/c_completeness.v", "name": "CNF_equiv_valid", "text": "Theorem CNF_equiv_valid : forall v A, TrueQ v (CNFtoPropF (MakeCNF A)) = TrueQ v (NNFtoPropF A).\nintros;induction A;simpl;try reflexivity;try (destruct (v p);simpl;reflexivity;fail);\n [rewrite CNF_and_valid|rewrite CNF_or_valid];rewrite IHA1;rewrite IHA2;reflexivity.\nQed.\n", "definition": " forall v A, TrueQ v (CNFtoPropF (MakeCNF A)) = TrueQ v (NNFtoPropF A).", "proof": "\nintros;induction A;simpl;try reflexivity;try (destruct (v p);simpl;reflexivity;fail);\n [rewrite CNF_and_valid|rewrite CNF_or_valid];rewrite IHA1;rewrite IHA2;reflexivity.\n", "def_ranges": [173, 0, 173, 96], "proof_ranges": [174, 0, 176, 4], "proof_steps": [{"text": "intros;induction A;simpl;try reflexivity;try (destruct (v p);simpl;reflexivity;fail);", "goal_before": ["forall (v : PropVars -> bool) (A : NNF),\nTrueQ v (CNFtoPropF (MakeCNF A)) = TrueQ v (NNFtoPropF A)"], "goal_after": ["forall (v : PropVars -> bool) (A : NNF),\nTrueQ v (CNFtoPropF (MakeCNF A)) = TrueQ v (NNFtoPropF A)"], "proof_term_before": [], "proof_term_after": []}, {"text": "[rewrite CNF_and_valid|rewrite CNF_or_valid];rewrite IHA1;rewrite IHA2;reflexivity.", "goal_before": ["forall (v : PropVars -> bool) (A : NNF),\nTrueQ v (CNFtoPropF (MakeCNF A)) = TrueQ v (NNFtoPropF A)"], "goal_after": ["forall (v : PropVars -> bool) (A : NNF),\nTrueQ v (CNFtoPropF (MakeCNF A)) = TrueQ v (NNFtoPropF A)"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/c_completeness.v", "name": "Clause_valid", "text": "Theorem Clause_valid : forall l, Valid (ClausetoPropF l) -> Valid_Clause l.\nintros;apply Validated_valid;apply TrueQ_impl_Validates;apply H;intros ? Q;destruct Q.\nQed.\n", "definition": " forall l, Valid (ClausetoPropF l) -> Valid_Clause l.", "proof": "\nintros;apply Validated_valid;apply TrueQ_impl_Validates;apply H;intros ? Q;destruct Q.\n", "def_ranges": [201, 0, 201, 75], "proof_ranges": [202, 0, 203, 4], "proof_steps": [{"text": "intros;apply Validated_valid;apply TrueQ_impl_Validates;apply H;intros ? Q;destruct Q.", "goal_before": ["forall l : list Literal, Valid (ClausetoPropF l) -> Valid_Clause l"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (l : list Literal) (H : Valid (ClausetoPropF l)) =>\n Validated_valid\n   (TrueQ_impl_Validates (Countervaluation l) l\n      (H (Countervaluation l)\n         ((fun (A : PropF) (Q : In A []) =>\n           match Q return (Is_true (TrueQ (Countervaluation l) A)) with\n           end)\n          :\n          Satisfies (Countervaluation l) []))))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : list Literal) (H : Valid (ClausetoPropF l)) =>\n Validated_valid\n   (TrueQ_impl_Validates (Countervaluation l) l\n      (H (Countervaluation l)\n         ((fun (A : PropF) (Q : In A []) =>\n           match Q return (Is_true (TrueQ (Countervaluation l) A)) with\n           end)\n          :\n          Satisfies (Countervaluation l) []))))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/c_completeness.v", "name": "CNF_valid", "text": "Theorem CNF_valid : forall ll, Valid (CNFtoPropF ll) -> Valid_CNF ll.\ninduction ll;intros ? ? H0;destruct H0;subst.\n  apply Clause_valid;intros v K;remember (H v K) as i eqn:x;clear x;\n   simpl in i;case_bool v (ClausetoPropF l).\n  apply IHll.\n    intros v K. remember (H v K). eapply proj2. apply andb_prop_elim. \n     rewrite <- CNF_and_valid. change (a::ll) with ([a]++ll) in H. eapply H;assumption.\n    assumption.\nQed.\n", "definition": " forall ll, Valid (CNFtoPropF ll) -> Valid_CNF ll.", "proof": "\ninduction ll;intros ? ? H0;destruct H0;subst.\n  apply Clause_valid;intros v K;remember (H v K) as i eqn:x;clear x;\n   simpl in i;case_bool v (ClausetoPropF l).\n  apply IHll.\n    intros v K. remember (H v K). eapply proj2. apply andb_prop_elim. \n     rewrite <- CNF_and_valid. change (a::ll) with ([a]++ll) in H. eapply H;assumption.\n    assumption.\n", "def_ranges": [205, 0, 205, 69], "proof_ranges": [206, 0, 213, 4], "proof_steps": [{"text": "induction ll;intros ? ? H0;destruct H0;subst.", "goal_before": ["forall ll : list (list Literal), Valid (CNFtoPropF ll) -> Valid_CNF ll"], "goal_after": ["Valid_Clause l", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": ["(fun ll : list (list Literal) =>\n list_ind\n   (fun ll0 : list (list Literal) => Valid (CNFtoPropF ll0) -> Valid_CNF ll0)\n   (fun _ : Valid (CNFtoPropF []) =>\n    (fun (l : Clause) (H0 : In l []) =>\n     match H0 return (Valid_Clause l) with\n     end)\n    :\n    Valid_CNF [])\n   (fun (a : list Literal) (ll0 : list (list Literal))\n      (IHll : Valid (CNFtoPropF ll0) -> Valid_CNF ll0)\n      (H : Valid (CNFtoPropF (a :: ll0))) =>\n    (fun (l : Clause) (H0 : In l (a :: ll0)) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : a = l =>\n          eq_ind_r\n            (fun a0 : Clause =>\n             Valid (CNFtoPropF (a0 :: ll0)) -> Valid_Clause l)\n            (fun H2 : Valid (CNFtoPropF (l :: ll0)) =>\n             ?Goal0@{ll:=ll0; H:=H2}) H1 H) x\n     | or_intror x => (fun H1 : In l ll0 => ?Goal@{ll:=ll0; H0:=H1}) x\n     end)\n    :\n    Valid_CNF (a :: ll0)) ll)"]}, {"text": "apply Clause_valid;intros v K;remember (H v K) as i eqn:x;clear x;", "goal_before": ["Valid_Clause l", "Valid_Clause l"], "goal_after": ["Valid_Clause l", "Valid_Clause l"], "proof_term_before": ["(fun ll : list (list Literal) =>\n list_ind\n   (fun ll0 : list (list Literal) => Valid (CNFtoPropF ll0) -> Valid_CNF ll0)\n   (fun _ : Valid (CNFtoPropF []) =>\n    (fun (l : Clause) (H0 : In l []) =>\n     match H0 return (Valid_Clause l) with\n     end)\n    :\n    Valid_CNF [])\n   (fun (a : list Literal) (ll0 : list (list Literal))\n      (IHll : Valid (CNFtoPropF ll0) -> Valid_CNF ll0)\n      (H : Valid (CNFtoPropF (a :: ll0))) =>\n    (fun (l : Clause) (H0 : In l (a :: ll0)) =>\n     match H0 with\n     | or_introl x =>\n         (fun H1 : a = l =>\n          eq_ind_r\n            (fun a0 : Clause =>\n             Valid (CNFtoPropF (a0 :: ll0)) -> Valid_Clause l)\n            (fun H2 : Valid (CNFtoPropF (l :: ll0)) =>\n             ?Goal0@{ll:=ll0; H:=H2}) H1 H) x\n     | or_intror x => (fun H1 : In l ll0 => ?Goal@{ll:=ll0; H0:=H1}) x\n     end)\n    :\n    Valid_CNF (a :: ll0)) ll)"], "proof_term_after": []}, {"text": "simpl in i;case_bool v (ClausetoPropF l).", "goal_before": ["Valid_Clause l", "Valid_Clause l"], "goal_after": ["Valid_Clause l", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply IHll.", "goal_before": ["Valid (CNFtoPropF ll)", "In l ll", "Valid_Clause l"], "goal_after": ["Valid (CNFtoPropF ll)", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros v K.", "goal_before": ["Is_true (TrueQ v (CNFtoPropF ll))", "In l ll", "Valid_Clause l"], "goal_after": ["Is_true (TrueQ v (CNFtoPropF ll))", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "remember (H v K).", "goal_before": ["Is_true (TrueQ v (CNFtoPropF ll))", "In l ll", "Valid_Clause l"], "goal_after": ["Is_true (TrueQ v (CNFtoPropF ll))", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply proj2.", "goal_before": ["?A /\\ Is_true (TrueQ v (CNFtoPropF ll))", "In l ll", "Valid_Clause l"], "goal_after": ["?A /\\ Is_true (TrueQ v (CNFtoPropF ll))", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply andb_prop_elim.", "goal_before": ["Is_true (?a && TrueQ v (CNFtoPropF ll))", "In l ll", "Valid_Clause l"], "goal_after": ["Is_true (?a && TrueQ v (CNFtoPropF ll))", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- CNF_and_valid.", "goal_before": ["Is_true (TrueQ v (CNFtoPropF (?ll1 ++ ll)))", "In l ll", "Valid_Clause l"], "goal_after": ["Is_true (TrueQ v (CNFtoPropF (?ll1 ++ ll)))", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "change (a::ll) with ([a]++ll) in H.", "goal_before": ["Is_true (TrueQ v (CNFtoPropF (?ll1 ++ ll)))", "In l ll", "Valid_Clause l"], "goal_after": ["Is_true (TrueQ v (CNFtoPropF (?ll1 ++ ll)))", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply H;assumption.", "goal_before": ["Is_true (TrueQ v (CNFtoPropF (?ll1 ++ ll)))", "In l ll", "Valid_Clause l"], "goal_after": ["Is_true (TrueQ v (CNFtoPropF (?ll1 ++ ll)))", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": ["Is_true (TrueQ v (CNFtoPropF (?ll1 ++ ll)))", "In l ll", "Valid_Clause l"], "goal_after": ["Is_true (TrueQ v (CNFtoPropF (?ll1 ++ ll)))", "In l ll", "Valid_Clause l"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/c_completeness.v", "name": "Clause_provable", "text": "Theorem Clause_provable : forall l, Valid_Clause l -> Provable (ClausetoPropF l).\nintros ? [?|(?&?&?)];apply in_split in H as (?&?&?);subst.\n induction x;simpl.\n   apply OrI1;simpl;apply ImpI;is_ass.\n   apply OrI2;apply IHx.\n apply in_app_or in H0 as [].\n   apply in_split in H as (?&?&?);subst.\n    rewrite app_ass;apply (Clause_provable_2 (LPos x)).\n   inversion H;[discriminate|].\n    apply in_split in H0 as (?&?&?);subst.\n     apply (Clause_provable_2 (LNeg x)).\nQed.\n", "definition": " forall l, Valid_Clause l -> Provable (ClausetoPropF l).", "proof": "\nintros ? [?|(?&?&?)];apply in_split in H as (?&?&?);subst.\n induction x;simpl.\n   apply OrI1;simpl;apply ImpI;is_ass.\n   apply OrI2;apply IHx.\n apply in_app_or in H0 as [].\n   apply in_split in H as (?&?&?);subst.\n    rewrite app_ass;apply (Clause_provable_2 (LPos x)).\n   inversion H;[discriminate|].\n    apply in_split in H0 as (?&?&?);subst.\n     apply (Clause_provable_2 (LNeg x)).\n", "def_ranges": [231, 0, 231, 81], "proof_ranges": [232, 0, 242, 4], "proof_steps": [{"text": "intros ? [?|(?&?&?)];apply in_split in H as (?&?&?);subst.", "goal_before": ["forall l : Clause, Valid_Clause l -> Provable (ClausetoPropF l)"], "goal_after": ["Provable (ClausetoPropF (x ++ LTop :: x0))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "proof_term_before": [], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  ?Goal@{x:=x2; x0:=x5} H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             ?Goal0@{x:=x2; x0:=x7; x1:=x10; H0:=H7}) H6 H3)\n                           x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "induction x;simpl.", "goal_before": ["Provable (ClausetoPropF (x ++ LTop :: x0))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "goal_after": ["Provable (ClausetoPropF (LTop :: x0))", "Provable (ClausetoPropF (a :: x ++ LTop :: x0))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  ?Goal@{x:=x2; x0:=x5} H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             ?Goal0@{x:=x2; x0:=x7; x1:=x10; H0:=H7}) H6 H3)\n                           x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (?Goal0@{x0:=x5}\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      ?Goal1@{x:=x6; x0:=x5}\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             ?Goal@{x:=x2; x0:=x7; x1:=x10; H0:=H7}) H6 H3)\n                           x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "apply OrI1;simpl;apply ImpI;is_ass.", "goal_before": ["Provable (ClausetoPropF (LTop :: x0))", "Provable (ClausetoPropF (a :: x ++ LTop :: x0))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "goal_after": ["Provable (ClausetoPropF (a :: x ++ LTop :: x0))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (?Goal0@{x0:=x5}\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      ?Goal1@{x:=x6; x0:=x5}\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             ?Goal@{x:=x2; x0:=x7; x1:=x10; H0:=H7}) H6 H3)\n                           x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      ?Goal0@{x:=x6; x0:=x5}\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             ?Goal@{x:=x2; x0:=x7; x1:=x10; H0:=H7}) H6 H3)\n                           x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "apply OrI2;apply IHx.", "goal_before": ["Provable (ClausetoPropF (a :: x ++ LTop :: x0))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "goal_after": ["Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      ?Goal0@{x:=x6; x0:=x5}\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             ?Goal@{x:=x2; x0:=x7; x1:=x10; H0:=H7}) H6 H3)\n                           x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             ?Goal@{x:=x2; x0:=x7; x1:=x10; H0:=H7}) H6 H3)\n                           x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "apply in_app_or in H0 as [].", "goal_before": ["Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "goal_after": ["Provable (ClausetoPropF (x0 ++ LPos x :: x1))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             ?Goal@{x:=x2; x0:=x7; x1:=x10; H0:=H7}) H6 H3)\n                           x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  ?Goal@{x:=x2; x0:=x7; x1:=x10; H:=H9}) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  ?Goal0@{x:=x2; x0:=x7; x1:=x10; H:=H9}) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "apply in_split in H as (?&?&?);subst.", "goal_before": ["Provable (ClausetoPropF (x0 ++ LPos x :: x1))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "goal_after": ["Provable (ClausetoPropF ((x2 ++ LNeg x :: x3) ++ LPos x :: x1))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  ?Goal@{x:=x2; x0:=x7; x1:=x10; H:=H9}) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  ?Goal0@{x:=x2; x0:=x7; x1:=x10; H:=H9}) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              ?Goal0@{\n                                              x:=x2; x1:=x10; x2:=x14;\n                                              x3:=x17} H12) x15 x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  ?Goal@{x:=x2; x0:=x7; x1:=x10; H:=H9}) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "rewrite app_ass;apply (Clause_provable_2 (LPos x)).", "goal_before": ["Provable (ClausetoPropF ((x2 ++ LNeg x :: x3) ++ LPos x :: x1))", "Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "goal_after": ["Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              ?Goal0@{\n                                              x:=x2; x1:=x10; x2:=x14;\n                                              x3:=x17} H12) x15 x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  ?Goal@{x:=x2; x0:=x7; x1:=x10; H:=H9}) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              (eq_ind_r\n                                                 (fun l0 : list Literal =>\n                                                 Provable (ClausetoPropF l0))\n                                                 (Clause_provable_2 \n                                                 (LPos x2) x14 x17 x10)\n                                                 (app_assoc_reverse x14\n                                                 (LNeg x2 :: x17)\n                                                 (LPos x2 :: x10))) H12) x15\n                                             x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  ?Goal@{x:=x2; x0:=x7; x1:=x10; H:=H9}) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "inversion H;[discriminate|].", "goal_before": ["Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "goal_after": ["Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              (eq_ind_r\n                                                 (fun l0 : list Literal =>\n                                                 Provable (ClausetoPropF l0))\n                                                 (Clause_provable_2 \n                                                 (LPos x2) x14 x17 x10)\n                                                 (app_assoc_reverse x14\n                                                 (LNeg x2 :: x17)\n                                                 (LPos x2 :: x10))) H12) x15\n                                             x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  ?Goal@{x:=x2; x0:=x7; x1:=x10; H:=H9}) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              (eq_ind_r\n                                                 (fun l0 : list Literal =>\n                                                 Provable (ClausetoPropF l0))\n                                                 (Clause_provable_2 \n                                                 (LPos x2) x14 x17 x10)\n                                                 (app_assoc_reverse x14\n                                                 (LNeg x2 :: x17)\n                                                 (LPos x2 :: x10))) H12) x15\n                                             x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  let H10 :\n                                    Provable\n                                      (ClausetoPropF (x7 ++ LPos x2 :: x10)) :=\n                                    match H9 with\n                                    | or_introl x12 =>\n                                        (fun H10 : LPos x2 = LNeg x2 =>\n                                         (fun H11 : LPos x2 = LNeg x2 =>\n                                          let H12 : False :=\n                                            eq_ind \n                                              (LPos x2)\n                                              (fun e : Literal =>\n                                               match e with\n                                               | LPos _ => True\n                                               | _ => False\n                                               end) I \n                                              (LNeg x2) H11 in\n                                          False_ind\n                                            (Provable\n                                               (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x10))) H12)\n                                           H10) x12\n                                    | or_intror x12 =>\n                                        (fun H10 : In (LNeg x2) x10 =>\n                                         (fun H11 : In (LNeg x2) x10 =>\n                                          ?Goal@{x:=x2; x0:=x7; x1:=x10;\n                                                 H:=H9; H0:=H11}) H10) x12\n                                    end in\n                                  H10) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "apply in_split in H0 as (?&?&?);subst.", "goal_before": ["Provable (ClausetoPropF (x0 ++ LPos x :: x1))"], "goal_after": ["Provable (ClausetoPropF (x0 ++ LPos x :: x2 ++ LNeg x :: x3))"], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              (eq_ind_r\n                                                 (fun l0 : list Literal =>\n                                                 Provable (ClausetoPropF l0))\n                                                 (Clause_provable_2 \n                                                 (LPos x2) x14 x17 x10)\n                                                 (app_assoc_reverse x14\n                                                 (LNeg x2 :: x17)\n                                                 (LPos x2 :: x10))) H12) x15\n                                             x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  let H10 :\n                                    Provable\n                                      (ClausetoPropF (x7 ++ LPos x2 :: x10)) :=\n                                    match H9 with\n                                    | or_introl x12 =>\n                                        (fun H10 : LPos x2 = LNeg x2 =>\n                                         (fun H11 : LPos x2 = LNeg x2 =>\n                                          let H12 : False :=\n                                            eq_ind \n                                              (LPos x2)\n                                              (fun e : Literal =>\n                                               match e with\n                                               | LPos _ => True\n                                               | _ => False\n                                               end) I \n                                              (LNeg x2) H11 in\n                                          False_ind\n                                            (Provable\n                                               (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x10))) H12)\n                                           H10) x12\n                                    | or_intror x12 =>\n                                        (fun H10 : In (LNeg x2) x10 =>\n                                         (fun H11 : In (LNeg x2) x10 =>\n                                          ?Goal@{x:=x2; x0:=x7; x1:=x10;\n                                                 H:=H9; H0:=H11}) H10) x12\n                                    end in\n                                  H10) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              (eq_ind_r\n                                                 (fun l0 : list Literal =>\n                                                 Provable (ClausetoPropF l0))\n                                                 (Clause_provable_2 \n                                                 (LPos x2) x14 x17 x10)\n                                                 (app_assoc_reverse x14\n                                                 (LNeg x2 :: x17)\n                                                 (LPos x2 :: x10))) H12) x15\n                                             x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  let H10 :\n                                    Provable\n                                      (ClausetoPropF (x7 ++ LPos x2 :: x10)) :=\n                                    match H9 with\n                                    | or_introl x12 =>\n                                        (fun H10 : LPos x2 = LNeg x2 =>\n                                         (fun H11 : LPos x2 = LNeg x2 =>\n                                          let H12 : False :=\n                                            eq_ind \n                                              (LPos x2)\n                                              (fun e : Literal =>\n                                               match e with\n                                               | LPos _ => True\n                                               | _ => False\n                                               end) I \n                                              (LNeg x2) H11 in\n                                          False_ind\n                                            (Provable\n                                               (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x10))) H12)\n                                           H10) x12\n                                    | or_intror x12 =>\n                                        (fun H10 : In (LNeg x2) x10 =>\n                                         (fun H11 : In (LNeg x2) x10 =>\n                                          let H12 :\n                                            exists \n                                            l1 l2 : list Literal,\n                                              x10 = l1 ++ LNeg x2 :: l2 :=\n                                            in_split (LNeg x2) x10 H11 in\n                                          match H12 with\n                                          | ex_intro _ x13 x14 =>\n                                              (fun \n                                                 (x15 : list Literal)\n                                                 (H13 : \n                                                 exists \n                                                 l2 : list Literal,\n                                                 x10 = x15 ++ LNeg x2 :: l2)\n                                               =>\n                                               match H13 with\n                                               | ex_intro _ x16 x17 =>\n                                                 (fun \n                                                 (x18 : list Literal)\n                                                 (H14 : \n                                                 x10 = \n                                                 x15 ++ LNeg x2 :: x18) =>\n                                                 eq_ind_r\n                                                 (fun x19 : list Literal =>\n                                                 In \n                                                 (LNeg x2) \n                                                 (LPos x2 :: x19) ->\n                                                 Provable\n                                                 (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x19)))\n                                                 (fun\n                                                 H15 : \n                                                 In \n                                                 (LNeg x2)\n                                                 (LPos x2\n                                                 :: \n                                                 x15 ++ LNeg x2 :: x18) =>\n                                                 ?Goal@{\n                                                 x:=x2; x0:=x7; x2:=x15;\n                                                 x3:=x18; H:=H15}) H14 H9)\n                                                 x16 x17\n                                               end) x13 x14\n                                          end) H10) x12\n                                    end in\n                                  H10) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "apply (Clause_provable_2 (LNeg x)).", "goal_before": ["Provable (ClausetoPropF (x0 ++ LPos x :: x2 ++ LNeg x :: x3))"], "goal_after": [], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              (eq_ind_r\n                                                 (fun l0 : list Literal =>\n                                                 Provable (ClausetoPropF l0))\n                                                 (Clause_provable_2 \n                                                 (LPos x2) x14 x17 x10)\n                                                 (app_assoc_reverse x14\n                                                 (LNeg x2 :: x17)\n                                                 (LPos x2 :: x10))) H12) x15\n                                             x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  let H10 :\n                                    Provable\n                                      (ClausetoPropF (x7 ++ LPos x2 :: x10)) :=\n                                    match H9 with\n                                    | or_introl x12 =>\n                                        (fun H10 : LPos x2 = LNeg x2 =>\n                                         (fun H11 : LPos x2 = LNeg x2 =>\n                                          let H12 : False :=\n                                            eq_ind \n                                              (LPos x2)\n                                              (fun e : Literal =>\n                                               match e with\n                                               | LPos _ => True\n                                               | _ => False\n                                               end) I \n                                              (LNeg x2) H11 in\n                                          False_ind\n                                            (Provable\n                                               (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x10))) H12)\n                                           H10) x12\n                                    | or_intror x12 =>\n                                        (fun H10 : In (LNeg x2) x10 =>\n                                         (fun H11 : In (LNeg x2) x10 =>\n                                          let H12 :\n                                            exists \n                                            l1 l2 : list Literal,\n                                              x10 = l1 ++ LNeg x2 :: l2 :=\n                                            in_split (LNeg x2) x10 H11 in\n                                          match H12 with\n                                          | ex_intro _ x13 x14 =>\n                                              (fun \n                                                 (x15 : list Literal)\n                                                 (H13 : \n                                                 exists \n                                                 l2 : list Literal,\n                                                 x10 = x15 ++ LNeg x2 :: l2)\n                                               =>\n                                               match H13 with\n                                               | ex_intro _ x16 x17 =>\n                                                 (fun \n                                                 (x18 : list Literal)\n                                                 (H14 : \n                                                 x10 = \n                                                 x15 ++ LNeg x2 :: x18) =>\n                                                 eq_ind_r\n                                                 (fun x19 : list Literal =>\n                                                 In \n                                                 (LNeg x2) \n                                                 (LPos x2 :: x19) ->\n                                                 Provable\n                                                 (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x19)))\n                                                 (fun\n                                                 H15 : \n                                                 In \n                                                 (LNeg x2)\n                                                 (LPos x2\n                                                 :: \n                                                 x15 ++ LNeg x2 :: x18) =>\n                                                 ?Goal@{\n                                                 x:=x2; x0:=x7; x2:=x15;\n                                                 x3:=x18; H:=H15}) H14 H9)\n                                                 x16 x17\n                                               end) x13 x14\n                                          end) H10) x12\n                                    end in\n                                  H10) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              (eq_ind_r\n                                                 (fun l0 : list Literal =>\n                                                 Provable (ClausetoPropF l0))\n                                                 (Clause_provable_2 \n                                                 (LPos x2) x14 x17 x10)\n                                                 (app_assoc_reverse x14\n                                                 (LNeg x2 :: x17)\n                                                 (LPos x2 :: x10))) H12) x15\n                                             x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  let H10 :\n                                    Provable\n                                      (ClausetoPropF (x7 ++ LPos x2 :: x10)) :=\n                                    match H9 with\n                                    | or_introl x12 =>\n                                        (fun H10 : LPos x2 = LNeg x2 =>\n                                         (fun H11 : LPos x2 = LNeg x2 =>\n                                          let H12 : False :=\n                                            eq_ind \n                                              (LPos x2)\n                                              (fun e : Literal =>\n                                               match e with\n                                               | LPos _ => True\n                                               | _ => False\n                                               end) I \n                                              (LNeg x2) H11 in\n                                          False_ind\n                                            (Provable\n                                               (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x10))) H12)\n                                           H10) x12\n                                    | or_intror x12 =>\n                                        (fun H10 : In (LNeg x2) x10 =>\n                                         (fun H11 : In (LNeg x2) x10 =>\n                                          let H12 :\n                                            exists \n                                            l1 l2 : list Literal,\n                                              x10 = l1 ++ LNeg x2 :: l2 :=\n                                            in_split (LNeg x2) x10 H11 in\n                                          match H12 with\n                                          | ex_intro _ x13 x14 =>\n                                              (fun \n                                                 (x15 : list Literal)\n                                                 (H13 : \n                                                 exists \n                                                 l2 : list Literal,\n                                                 x10 = x15 ++ LNeg x2 :: l2)\n                                               =>\n                                               match H13 with\n                                               | ex_intro _ x16 x17 =>\n                                                 (fun \n                                                 (x18 : list Literal)\n                                                 (H14 : \n                                                 x10 = \n                                                 x15 ++ LNeg x2 :: x18) =>\n                                                 eq_ind_r\n                                                 (fun x19 : list Literal =>\n                                                 In \n                                                 (LNeg x2) \n                                                 (LPos x2 :: x19) ->\n                                                 Provable\n                                                 (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x19)))\n                                                 (fun\n                                                 _ : \n                                                 In \n                                                 (LNeg x2)\n                                                 (LPos x2\n                                                 :: \n                                                 x15 ++ LNeg x2 :: x18) =>\n                                                 Clause_provable_2 \n                                                 (LNeg x2) x7 x15 x18) H14 H9)\n                                                 x16 x17\n                                               end) x13 x14\n                                          end) H10) x12\n                                    end in\n                                  H10) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Clause) (H : Valid_Clause l) =>\n match H with\n | or_introl x =>\n     (fun H0 : In LTop l =>\n      let H1 : exists l1 l2 : list Literal, l = l1 ++ LTop :: l2 :=\n        in_split LTop l H0 in\n      match H1 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : list Literal)\n             (H2 : exists l2 : list Literal, l = x2 ++ LTop :: l2) =>\n           match H2 with\n           | ex_intro _ x3 x4 =>\n               (fun (x5 : list Literal) (H3 : l = x2 ++ LTop :: x5) =>\n                eq_ind_r\n                  (fun l0 : list Literal => Provable (ClausetoPropF l0))\n                  (list_ind\n                     (fun x6 : list Literal =>\n                      Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                     (OrI1\n                        ((fix map_fold_right\n                            (A B : Type) (f : B -> A) \n                            (g : A -> A -> A) (a : A) \n                            (l0 : list B) {struct l0} : A :=\n                            match l0 with\n                            | [] => a\n                            | b :: l2 =>\n                                g (f b) (map_fold_right A B f g a l2)\n                            end) PropF Literal LiteraltoPropF Disj \u22a5 x5)\n                        (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n                         :\n                         [] \u22a2 LiteraltoPropF LTop)\n                      :\n                      Provable (ClausetoPropF ([] ++ LTop :: x5)))\n                     (fun (a : Literal) (x6 : list Literal)\n                        (IHx : Provable (ClausetoPropF (x6 ++ LTop :: x5)))\n                      =>\n                      OrI2 (LiteraltoPropF a) IHx\n                      :\n                      Provable (ClausetoPropF ((a :: x6) ++ LTop :: x5))) x2)\n                  H3) x3 x4\n           end) x0 x1\n      end) x\n | or_intror x =>\n     (fun H0 : exists A : PropVars, In (LPos A) l /\\ In (LNeg A) l =>\n      match H0 with\n      | ex_intro _ x0 x1 =>\n          (fun (x2 : PropVars) (H1 : In (LPos x2) l /\\ In (LNeg x2) l) =>\n           match H1 with\n           | conj x3 x4 =>\n               (fun (H2 : In (LPos x2) l) (H3 : In (LNeg x2) l) =>\n                let H4 :\n                  exists l1 l2 : list Literal, l = l1 ++ LPos x2 :: l2 :=\n                  in_split (LPos x2) l H2 in\n                match H4 with\n                | ex_intro _ x5 x6 =>\n                    (fun (x7 : list Literal)\n                       (H5 : exists l2 : list Literal,\n                               l = x7 ++ LPos x2 :: l2) =>\n                     match H5 with\n                     | ex_intro _ x8 x9 =>\n                         (fun (x10 : list Literal)\n                            (H6 : l = x7 ++ LPos x2 :: x10) =>\n                          eq_ind_r\n                            (fun l0 : list Literal =>\n                             In (LNeg x2) l0 -> Provable (ClausetoPropF l0))\n                            (fun H7 : In (LNeg x2) (x7 ++ LPos x2 :: x10) =>\n                             let H8 :\n                               In (LNeg x2) x7 \\/\n                               In (LNeg x2) (LPos x2 :: x10) :=\n                               in_app_or x7 (LPos x2 :: x10) (LNeg x2) H7 in\n                             match H8 with\n                             | or_introl x11 =>\n                                 (fun H9 : In (LNeg x2) x7 =>\n                                  let H10 :\n                                    exists l1 l2 : list Literal,\n                                      x7 = l1 ++ LNeg x2 :: l2 :=\n                                    in_split (LNeg x2) x7 H9 in\n                                  match H10 with\n                                  | ex_intro _ x12 x13 =>\n                                      (fun (x14 : list Literal)\n                                         (H11 : exists \n                                                l2 : list Literal,\n                                                 x7 = x14 ++ LNeg x2 :: l2)\n                                       =>\n                                       match H11 with\n                                       | ex_intro _ x15 x16 =>\n                                           (fun (x17 : list Literal)\n                                              (H12 : \n                                               x7 = \n                                               x14 ++ LNeg x2 :: x17) =>\n                                            eq_ind_r\n                                              (fun x18 : list Literal =>\n                                               Provable\n                                                 (ClausetoPropF\n                                                 (x18 ++ LPos x2 :: x10)))\n                                              (eq_ind_r\n                                                 (fun l0 : list Literal =>\n                                                 Provable (ClausetoPropF l0))\n                                                 (Clause_provable_2 \n                                                 (LPos x2) x14 x17 x10)\n                                                 (app_assoc_reverse x14\n                                                 (LNeg x2 :: x17)\n                                                 (LPos x2 :: x10))) H12) x15\n                                             x16\n                                       end) x12 x13\n                                  end) x11\n                             | or_intror x11 =>\n                                 (fun H9 : In (LNeg x2) (LPos x2 :: x10) =>\n                                  let H10 :\n                                    Provable\n                                      (ClausetoPropF (x7 ++ LPos x2 :: x10)) :=\n                                    match H9 with\n                                    | or_introl x12 =>\n                                        (fun H10 : LPos x2 = LNeg x2 =>\n                                         (fun H11 : LPos x2 = LNeg x2 =>\n                                          let H12 : False :=\n                                            eq_ind \n                                              (LPos x2)\n                                              (fun e : Literal =>\n                                               match e with\n                                               | LPos _ => True\n                                               | _ => False\n                                               end) I \n                                              (LNeg x2) H11 in\n                                          False_ind\n                                            (Provable\n                                               (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x10))) H12)\n                                           H10) x12\n                                    | or_intror x12 =>\n                                        (fun H10 : In (LNeg x2) x10 =>\n                                         (fun H11 : In (LNeg x2) x10 =>\n                                          let H12 :\n                                            exists \n                                            l1 l2 : list Literal,\n                                              x10 = l1 ++ LNeg x2 :: l2 :=\n                                            in_split (LNeg x2) x10 H11 in\n                                          match H12 with\n                                          | ex_intro _ x13 x14 =>\n                                              (fun \n                                                 (x15 : list Literal)\n                                                 (H13 : \n                                                 exists \n                                                 l2 : list Literal,\n                                                 x10 = x15 ++ LNeg x2 :: l2)\n                                               =>\n                                               match H13 with\n                                               | ex_intro _ x16 x17 =>\n                                                 (fun \n                                                 (x18 : list Literal)\n                                                 (H14 : \n                                                 x10 = \n                                                 x15 ++ LNeg x2 :: x18) =>\n                                                 eq_ind_r\n                                                 (fun x19 : list Literal =>\n                                                 In \n                                                 (LNeg x2) \n                                                 (LPos x2 :: x19) ->\n                                                 Provable\n                                                 (ClausetoPropF\n                                                 (x7 ++ LPos x2 :: x19)))\n                                                 (fun\n                                                 _ : \n                                                 In \n                                                 (LNeg x2)\n                                                 (LPos x2\n                                                 :: \n                                                 x15 ++ LNeg x2 :: x18) =>\n                                                 Clause_provable_2 \n                                                 (LNeg x2) x7 x15 x18) H14 H9)\n                                                 x16 x17\n                                               end) x13 x14\n                                          end) H10) x12\n                                    end in\n                                  H10) x11\n                             end) H6 H3) x8 x9\n                     end) x5 x6\n                end) x3 x4\n           end) x0 x1\n      end) x\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/c_completeness.v", "name": "CNF_provable", "text": "Theorem CNF_provable : forall ll, Valid_CNF ll -> Provable (CNFtoPropF ll).\nintros;induction ll;unfold CNFtoPropF;simpl.\n apply ImpI;is_ass.\n eapply AndI. \n   apply Clause_provable;apply H;constructor;reflexivity.\n   apply IHll;intro;intro;apply H;constructor 2;assumption.\nQed.\n", "definition": " forall ll, Valid_CNF ll -> Provable (CNFtoPropF ll).", "proof": "\nintros;induction ll;unfold CNFtoPropF;simpl.\n apply ImpI;is_ass.\n eapply AndI. \n   apply Clause_provable;apply H;constructor;reflexivity.\n   apply IHll;intro;intro;apply H;constructor 2;assumption.\n", "def_ranges": [244, 0, 244, 75], "proof_ranges": [245, 0, 250, 4], "proof_steps": [{"text": "intros;induction ll;unfold CNFtoPropF;simpl.", "goal_before": ["forall ll : list Clause, Valid_CNF ll -> Provable (CNFtoPropF ll)"], "goal_after": ["Provable \u22a4", "Provable (ClausetoPropF a \u2227 map_fold_right ClausetoPropF Conj \u22a4 ll)"], "proof_term_before": [], "proof_term_after": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun H0 : Valid_CNF [] =>\n    (?Goal@{H:=H0} : Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (?Goal0@{ll:=ll0; H:=H0}\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"]}, {"text": "apply ImpI;is_ass.", "goal_before": ["Provable \u22a4", "Provable (ClausetoPropF a \u2227 map_fold_right ClausetoPropF Conj \u22a4 ll)"], "goal_after": ["Provable (ClausetoPropF a \u2227 map_fold_right ClausetoPropF Conj \u22a4 ll)"], "proof_term_before": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun H0 : Valid_CNF [] =>\n    (?Goal@{H:=H0} : Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (?Goal0@{ll:=ll0; H:=H0}\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"], "proof_term_after": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun _ : Valid_CNF [] =>\n    (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (?Goal@{ll:=ll0; H:=H0}\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"]}, {"text": "eapply AndI.", "goal_before": ["Provable (ClausetoPropF a \u2227 map_fold_right ClausetoPropF Conj \u22a4 ll)"], "goal_after": ["[] \u22a2 ClausetoPropF a", "[] \u22a2 map_fold_right ClausetoPropF Conj \u22a4 ll"], "proof_term_before": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun _ : Valid_CNF [] =>\n    (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (?Goal@{ll:=ll0; H:=H0}\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"], "proof_term_after": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun _ : Valid_CNF [] =>\n    (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (AndI ?Goal@{ll:=ll0; H:=H0} ?Goal0@{ll:=ll0; H:=H0}\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"]}, {"text": "apply Clause_provable;apply H;constructor;reflexivity.", "goal_before": ["[] \u22a2 ClausetoPropF a", "[] \u22a2 map_fold_right ClausetoPropF Conj \u22a4 ll"], "goal_after": ["[] \u22a2 map_fold_right ClausetoPropF Conj \u22a4 ll"], "proof_term_before": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun _ : Valid_CNF [] =>\n    (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (AndI ?Goal@{ll:=ll0; H:=H0} ?Goal0@{ll:=ll0; H:=H0}\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"], "proof_term_after": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun _ : Valid_CNF [] =>\n    (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (AndI (Clause_provable (H0 a (or_introl eq_refl))) ?Goal@{ll:=ll0; H:=H0}\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"]}, {"text": "apply IHll;intro;intro;apply H;constructor 2;assumption.", "goal_before": ["[] \u22a2 map_fold_right ClausetoPropF Conj \u22a4 ll"], "goal_after": [], "proof_term_before": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun _ : Valid_CNF [] =>\n    (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (AndI (Clause_provable (H0 a (or_introl eq_refl))) ?Goal@{ll:=ll0; H:=H0}\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"], "proof_term_after": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun _ : Valid_CNF [] =>\n    (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (AndI (Clause_provable (H0 a (or_introl eq_refl)))\n       (IHll\n          ((fun (l : Clause) (H1 : In l ll0) => H0 l (or_intror H1))\n           :\n           Valid_CNF ll0))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (ll : list Clause) (H : Valid_CNF ll) =>\n list_ind\n   (fun ll0 : list Clause => Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n   (fun _ : Valid_CNF [] =>\n    (ImpI (Nax [\u22a5] \u22a5 (or_introl eq_refl))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 []))\n    :\n    Provable (CNFtoPropF []))\n   (fun (a : Clause) (ll0 : list Clause)\n      (IHll : Valid_CNF ll0 -> Provable (CNFtoPropF ll0))\n      (H0 : Valid_CNF (a :: ll0)) =>\n    (AndI (Clause_provable (H0 a (or_introl eq_refl)))\n       (IHll\n          ((fun (l : Clause) (H1 : In l ll0) => H0 l (or_intror H1))\n           :\n           Valid_CNF ll0))\n     :\n     Provable (map_fold_right ClausetoPropF Conj \u22a4 (a :: ll0)))\n    :\n    Provable (CNFtoPropF (a :: ll0))) ll H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/c_completeness.v", "name": "CNF_impl_prov", "text": "Theorem CNF_impl_prov : forall A, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A).\ninduction A;simpl;\n try (unfold CNFtoPropF; unfold ClausetoPropF;simpl;\n   apply ImpI;eapply OrE;\n     [eapply AndE1;is_ass|\n     is_ass|\n     apply BotC;is_ass];fail). \n apply ImpI;apply AndI;(eapply prov_impl;[eassumption|]);\n  [eapply AndE1|eapply AndE2];(eapply prov_impl;[apply CNF_and_prov|is_ass]).\n apply ImpI;eapply prov_impl.\n   apply ImpI;eapply prov_or;try eassumption;in_solve.\n   eapply prov_impl;[apply CNF_or_prov|is_ass].\nQed.\n", "definition": " forall A, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A).", "proof": "\ninduction A;simpl;\n try (unfold CNFtoPropF; unfold ClausetoPropF;simpl;\n   apply ImpI;eapply OrE;\n     [eapply AndE1;is_ass|\n     is_ass|\n     apply BotC;is_ass];fail). \n apply ImpI;apply AndI;(eapply prov_impl;[eassumption|]);\n  [eapply AndE1|eapply AndE2];(eapply prov_impl;[apply CNF_and_prov|is_ass]).\n apply ImpI;eapply prov_impl.\n   apply ImpI;eapply prov_or;try eassumption;in_solve.\n   eapply prov_impl;[apply CNF_or_prov|is_ass].\n", "def_ranges": [314, 0, 314, 83], "proof_ranges": [315, 0, 326, 4], "proof_steps": [{"text": "induction A;simpl;", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "proof_term_before": [], "proof_term_after": []}, {"text": "try (unfold CNFtoPropF; unfold ClausetoPropF;simpl;", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ImpI;eapply OrE;", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "proof_term_before": [], "proof_term_after": []}, {"text": "[eapply AndE1;is_ass|", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "proof_term_before": [], "proof_term_after": []}, {"text": "is_ass|", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "apply BotC;is_ass];fail).", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "proof_term_before": ["?Goal"], "proof_term_after": ["?Goal"]}, {"text": "apply ImpI;apply AndI;(eapply prov_impl;[eassumption|]);", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "proof_term_before": ["?Goal"], "proof_term_after": ["?Goal"]}, {"text": "[eapply AndE1|eapply AndE2];(eapply prov_impl;[apply CNF_and_prov|is_ass]).", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "proof_term_before": ["?Goal"], "proof_term_after": ["?Goal"]}, {"text": "apply ImpI;eapply prov_impl.", "goal_before": ["forall A : NNF, Provable (CNFtoPropF (MakeCNF A) \u2192 NNFtoPropF A)"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/c_completeness.v", "name": "Completeness", "text": "Theorem Completeness : Prop_Completeness.\ndo 2 intro.\nmp. apply NNF_impl_prov.\nmp. apply CNF_impl_prov.\napply CNF_provable.\napply CNF_valid.\nintros ? ?.\nrewrite CNF_equiv_valid.\nrewrite ((and_ind (fun A _ => A)) (NNF_equiv_valid v A)).\napply H;assumption.\nQed.\n", "definition": " Prop_Completeness.", "proof": "\ndo 2 intro.\nmp. apply NNF_impl_prov.\nmp. apply CNF_impl_prov.\napply CNF_provable.\napply CNF_valid.\nintros ? ?.\nrewrite CNF_equiv_valid.\nrewrite ((and_ind (fun A _ => A)) (NNF_equiv_valid v A)).\napply H;assumption.\n", "def_ranges": [360, 0, 360, 41], "proof_ranges": [361, 0, 370, 4], "proof_steps": [{"text": "do 2 intro.", "goal_before": ["Prop_Completeness"], "goal_after": ["Provable A"], "proof_term_before": [], "proof_term_after": ["((fun (A : PropF) (H : Valid A) => ?Goal) : Prop_Completeness)"]}, {"text": "mp.", "goal_before": ["Provable A"], "goal_after": ["[] \u22a2 ?A \u2192 A", "[] \u22a2 ?A"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) => ?Goal) : Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) => ImpE ?Goal ?Goal0) : Prop_Completeness)"]}, {"text": "apply NNF_impl_prov.", "goal_before": ["[] \u22a2 ?A \u2192 A", "[] \u22a2 ?A"], "goal_after": ["[] \u22a2 NNFtoPropF (MakeNNF A)"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) => ImpE ?Goal ?Goal0) : Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A) ?Goal)\n :\n Prop_Completeness)"]}, {"text": "mp.", "goal_before": ["[] \u22a2 NNFtoPropF (MakeNNF A)"], "goal_after": ["[] \u22a2 ?A \u2192 NNFtoPropF (MakeNNF A)", "[] \u22a2 ?A"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A) ?Goal)\n :\n Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A) (ImpE ?Goal ?Goal0))\n :\n Prop_Completeness)"]}, {"text": "apply CNF_impl_prov.", "goal_before": ["[] \u22a2 ?A \u2192 NNFtoPropF (MakeNNF A)", "[] \u22a2 ?A"], "goal_after": ["[] \u22a2 CNFtoPropF (MakeCNF (MakeNNF A))"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A) (ImpE ?Goal ?Goal0))\n :\n Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A) (ImpE (CNF_impl_prov (MakeNNF A)) ?Goal))\n :\n Prop_Completeness)"]}, {"text": "apply CNF_provable.", "goal_before": ["[] \u22a2 CNFtoPropF (MakeCNF (MakeNNF A))"], "goal_after": ["Valid_CNF (MakeCNF (MakeNNF A))"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A) (ImpE (CNF_impl_prov (MakeNNF A)) ?Goal))\n :\n Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A) (ImpE (CNF_impl_prov (MakeNNF A)) (CNF_provable ?Goal)))\n :\n Prop_Completeness)"]}, {"text": "apply CNF_valid.", "goal_before": ["Valid_CNF (MakeCNF (MakeNNF A))"], "goal_after": ["Valid (CNFtoPropF (MakeCNF (MakeNNF A)))"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A) (ImpE (CNF_impl_prov (MakeNNF A)) (CNF_provable ?Goal)))\n :\n Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable (CNF_valid (MakeCNF (MakeNNF A)) ?Goal))))\n :\n Prop_Completeness)"]}, {"text": "intros ? ?.", "goal_before": ["Valid (CNFtoPropF (MakeCNF (MakeNNF A)))"], "goal_after": ["Is_true (TrueQ v (CNFtoPropF (MakeCNF (MakeNNF A))))"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable (CNF_valid (MakeCNF (MakeNNF A)) ?Goal))))\n :\n Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable\n          (CNF_valid (MakeCNF (MakeNNF A))\n             ((fun (v : PropVars -> bool) (H0 : Satisfies v []) => ?Goal)\n              :\n              Valid (CNFtoPropF (MakeCNF (MakeNNF A))))))))\n :\n Prop_Completeness)"]}, {"text": "rewrite CNF_equiv_valid.", "goal_before": ["Is_true (TrueQ v (CNFtoPropF (MakeCNF (MakeNNF A))))"], "goal_after": ["Is_true (TrueQ v (NNFtoPropF (MakeNNF A)))"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable\n          (CNF_valid (MakeCNF (MakeNNF A))\n             ((fun (v : PropVars -> bool) (H0 : Satisfies v []) => ?Goal)\n              :\n              Valid (CNFtoPropF (MakeCNF (MakeNNF A))))))))\n :\n Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable\n          (CNF_valid (MakeCNF (MakeNNF A))\n             ((fun (v : PropVars -> bool) (H0 : Satisfies v []) =>\n               eq_ind_r (fun b : bool => Is_true b) \n                 ?Goal (CNF_equiv_valid v (MakeNNF A)))\n              :\n              Valid (CNFtoPropF (MakeCNF (MakeNNF A))))))))\n :\n Prop_Completeness)"]}, {"text": "rewrite ((and_ind (fun A _ => A)) (NNF_equiv_valid v A)).", "goal_before": ["Is_true (TrueQ v (NNFtoPropF (MakeNNF A)))"], "goal_after": ["Is_true (TrueQ v A)"], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable\n          (CNF_valid (MakeCNF (MakeNNF A))\n             ((fun (v : PropVars -> bool) (H0 : Satisfies v []) =>\n               eq_ind_r (fun b : bool => Is_true b) \n                 ?Goal (CNF_equiv_valid v (MakeNNF A)))\n              :\n              Valid (CNFtoPropF (MakeCNF (MakeNNF A))))))))\n :\n Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable\n          (CNF_valid (MakeCNF (MakeNNF A))\n             ((fun (v : PropVars -> bool) (H0 : Satisfies v []) =>\n               eq_ind_r (fun b : bool => Is_true b)\n                 (eq_ind_r (fun b : bool => Is_true b) \n                    ?Goal\n                    (and_ind\n                       (fun\n                          (A0 : TrueQ v (NNFtoPropF (MakeNNF A)) = TrueQ v A)\n                          (_ : TrueQ v (NNFtoPropF (MakeNNFN A)) =\n                               TrueQ v \u00ac A) => A0) \n                       (NNF_equiv_valid v A)))\n                 (CNF_equiv_valid v (MakeNNF A)))\n              :\n              Valid (CNFtoPropF (MakeCNF (MakeNNF A))))))))\n :\n Prop_Completeness)"]}, {"text": "apply H;assumption.", "goal_before": ["Is_true (TrueQ v A)"], "goal_after": [], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable\n          (CNF_valid (MakeCNF (MakeNNF A))\n             ((fun (v : PropVars -> bool) (H0 : Satisfies v []) =>\n               eq_ind_r (fun b : bool => Is_true b)\n                 (eq_ind_r (fun b : bool => Is_true b) \n                    ?Goal\n                    (and_ind\n                       (fun\n                          (A0 : TrueQ v (NNFtoPropF (MakeNNF A)) = TrueQ v A)\n                          (_ : TrueQ v (NNFtoPropF (MakeNNFN A)) =\n                               TrueQ v \u00ac A) => A0) \n                       (NNF_equiv_valid v A)))\n                 (CNF_equiv_valid v (MakeNNF A)))\n              :\n              Valid (CNFtoPropF (MakeCNF (MakeNNF A))))))))\n :\n Prop_Completeness)"], "proof_term_after": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable\n          (CNF_valid (MakeCNF (MakeNNF A))\n             ((fun (v : PropVars -> bool) (H0 : Satisfies v []) =>\n               eq_ind_r (fun b : bool => Is_true b)\n                 (eq_ind_r (fun b : bool => Is_true b) \n                    (H v H0)\n                    (and_ind\n                       (fun\n                          (A0 : TrueQ v (NNFtoPropF (MakeNNF A)) = TrueQ v A)\n                          (_ : TrueQ v (NNFtoPropF (MakeNNFN A)) =\n                               TrueQ v \u00ac A) => A0) \n                       (NNF_equiv_valid v A)))\n                 (CNF_equiv_valid v (MakeNNF A)))\n              :\n              Valid (CNFtoPropF (MakeCNF (MakeNNF A))))))))\n :\n Prop_Completeness)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (A : PropF) (H : Valid A) =>\n  ImpE\n    (let H0 : forall A0 : PropF, Provable (NNFtoPropF (MakeNNF A0) \u2192 A0) :=\n       fun A0 : PropF =>\n       match NNF_impl_prov A0 with\n       | conj x x0 =>\n           (fun (H0 : Provable (NNFtoPropF (MakeNNF A0) \u2192 A0))\n              (_ : Provable (NNFtoPropF (MakeNNFN A0) \u2192 \u00ac A0)) => H0) x x0\n       end in\n     H0 A)\n    (ImpE (CNF_impl_prov (MakeNNF A))\n       (CNF_provable\n          (CNF_valid (MakeCNF (MakeNNF A))\n             ((fun (v : PropVars -> bool) (H0 : Satisfies v []) =>\n               eq_ind_r (fun b : bool => Is_true b)\n                 (eq_ind_r (fun b : bool => Is_true b) \n                    (H v H0)\n                    (and_ind\n                       (fun\n                          (A0 : TrueQ v (NNFtoPropF (MakeNNF A)) = TrueQ v A)\n                          (_ : TrueQ v (NNFtoPropF (MakeNNFN A)) =\n                               TrueQ v \u00ac A) => A0) \n                       (NNF_equiv_valid v A)))\n                 (CNF_equiv_valid v (MakeNNF A)))\n              :\n              Valid (CNFtoPropF (MakeCNF (MakeNNF A))))))))\n :\n Prop_Completeness)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/c_completeness.v", "name": "prov_equiv_models", "text": "Theorem prov_equiv_models : forall \u0393 A, \u0393 \u22a2 A <-> \u0393 \u22a8 A.\nsplit;[apply Soundness_general|revert A;induction \u0393].\n apply Completeness.\n intros. apply deduction. apply IH\u0393. \n  intros ? ?. case_bool v a;rewrite H1;simpl.\n     apply H. intros ? ?. destruct H2;subst.\n      rewrite H1;exact I.\n      apply H0;in_solve.\n    exact I.\nQed.\n", "definition": " forall \u0393 A, \u0393 \u22a2 A <-> \u0393 \u22a8 A.", "proof": "\nsplit;[apply Soundness_general|revert A;induction \u0393].\n apply Completeness.\n intros. apply deduction. apply IH\u0393. \n  intros ? ?. case_bool v a;rewrite H1;simpl.\n     apply H. intros ? ?. destruct H2;subst.\n      rewrite H1;exact I.\n      apply H0;in_solve.\n    exact I.\n", "def_ranges": [372, 0, 372, 56], "proof_ranges": [373, 0, 381, 4], "proof_steps": [{"text": "split;[apply Soundness_general|revert A;induction \u0393].", "goal_before": ["forall (\u0393 : list PropF) (A : PropF), \u0393 \u22a2 A <-> \u0393 \u22a8 A"], "goal_after": ["forall A : PropF, [] \u22a8 A -> [] \u22a2 A", "forall A : PropF, a :: \u0393 \u22a8 A -> a :: \u0393 \u22a2 A"], "proof_term_before": [], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      ?Goal\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) => \n       ?Goal0@{\u0393:=\u03930}) \u0393 A))"]}, {"text": "apply Completeness.", "goal_before": ["forall A : PropF, [] \u22a8 A -> [] \u22a2 A", "forall A : PropF, a :: \u0393 \u22a8 A -> a :: \u0393 \u22a2 A"], "goal_after": ["forall A : PropF, a :: \u0393 \u22a8 A -> a :: \u0393 \u22a2 A"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      ?Goal\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) => \n       ?Goal0@{\u0393:=\u03930}) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) => \n       ?Goal@{\u0393:=\u03930}) \u0393 A))"]}, {"text": "intros.", "goal_before": ["forall A : PropF, a :: \u0393 \u22a8 A -> a :: \u0393 \u22a2 A"], "goal_after": ["a :: \u0393 \u22a2 A"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) => \n       ?Goal@{\u0393:=\u03930}) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) => ?Goal@{\u0393:=\u03930; A:=A0}) \u0393 A))"]}, {"text": "apply deduction.", "goal_before": ["a :: \u0393 \u22a2 A"], "goal_after": ["\u0393 \u22a2 a \u2192 A"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) => ?Goal@{\u0393:=\u03930; A:=A0}) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) => deduction ?Goal@{\u0393:=\u03930; A:=A0}) \u0393\n      A))"]}, {"text": "apply IH\u0393.", "goal_before": ["\u0393 \u22a2 a \u2192 A"], "goal_after": ["\u0393 \u22a8 a \u2192 A"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) => deduction ?Goal@{\u0393:=\u03930; A:=A0}) \u0393\n      A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction (IH\u0393 (a \u2192 A0) ?Goal@{\u0393:=\u03930; A:=A0})) \u0393 A))"]}, {"text": "intros ? ?.", "goal_before": ["\u0393 \u22a8 a \u2192 A"], "goal_after": ["Is_true (TrueQ v (a \u2192 A))"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction (IH\u0393 (a \u2192 A0) ?Goal@{\u0393:=\u03930; A:=A0})) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ?Goal@{\u0393:=\u03930; A:=A0})\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"]}, {"text": "case_bool v a;rewrite H1;simpl.", "goal_before": ["Is_true (TrueQ v (a \u2192 A))"], "goal_after": ["Is_true (TrueQ v A)", "True"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ?Goal@{\u0393:=\u03930; A:=A0})\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb true || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal0@{\u0393:=\u03930; A:=A0}\n                    :\n                    Is_true (negb false || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"]}, {"text": "apply H.", "goal_before": ["Is_true (TrueQ v A)", "True"], "goal_after": ["Satisfies v (a :: \u0393)", "True"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb true || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal0@{\u0393:=\u03930; A:=A0}\n                    :\n                    Is_true (negb false || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v ?Goal0@{\u0393:=\u03930; A:=A0}\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"]}, {"text": "intros ? ?.", "goal_before": ["Satisfies v (a :: \u0393)", "True"], "goal_after": ["Is_true (TrueQ v A0)", "True"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v ?Goal0@{\u0393:=\u03930; A:=A0}\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        ?Goal0@{\u0393:=\u03930; A:=A0; A0:=A1})\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"]}, {"text": "destruct H2;subst.", "goal_before": ["Is_true (TrueQ v A0)", "True"], "goal_after": ["Is_true (TrueQ v A0)", "Is_true (TrueQ v A0)", "True"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        ?Goal0@{\u0393:=\u03930; A:=A0; A0:=A1})\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        match H2 with\n                        | or_introl x =>\n                            (fun H3 : a = A1 =>\n                             eq_ind_r\n                               (fun a0 : PropF =>\n                                a0 :: \u03930 \u22a8 A0 ->\n                                TrueQ v a0 = true -> Is_true (TrueQ v A1))\n                               (fun (H4 : A1 :: \u03930 \u22a8 A0)\n                                  (H5 : TrueQ v A1 = true) =>\n                                ?Goal1@{\u0393:=\u03930; A:=A0; A0:=A1; H:=H4; H1:=H5})\n                               H3 H H1) x\n                        | or_intror x =>\n                            (fun H3 : In A1 \u03930 =>\n                             ?Goal0@{\u0393:=\u03930; A:=A0; A0:=A1; H2:=H3}) x\n                        end)\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"]}, {"text": "rewrite H1;exact I.", "goal_before": ["Is_true (TrueQ v A0)", "Is_true (TrueQ v A0)", "True"], "goal_after": ["Is_true (TrueQ v A0)", "True"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        match H2 with\n                        | or_introl x =>\n                            (fun H3 : a = A1 =>\n                             eq_ind_r\n                               (fun a0 : PropF =>\n                                a0 :: \u03930 \u22a8 A0 ->\n                                TrueQ v a0 = true -> Is_true (TrueQ v A1))\n                               (fun (H4 : A1 :: \u03930 \u22a8 A0)\n                                  (H5 : TrueQ v A1 = true) =>\n                                ?Goal1@{\u0393:=\u03930; A:=A0; A0:=A1; H:=H4; H1:=H5})\n                               H3 H H1) x\n                        | or_intror x =>\n                            (fun H3 : In A1 \u03930 =>\n                             ?Goal0@{\u0393:=\u03930; A:=A0; A0:=A1; H2:=H3}) x\n                        end)\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        match H2 with\n                        | or_introl x =>\n                            (fun H3 : a = A1 =>\n                             eq_ind_r\n                               (fun a0 : PropF =>\n                                a0 :: \u03930 \u22a8 A0 ->\n                                TrueQ v a0 = true -> Is_true (TrueQ v A1))\n                               (fun (_ : A1 :: \u03930 \u22a8 A0)\n                                  (H5 : TrueQ v A1 = true) =>\n                                eq_ind_r (fun b : bool => Is_true b) I H5) H3\n                               H H1) x\n                        | or_intror x =>\n                            (fun H3 : In A1 \u03930 =>\n                             ?Goal0@{\u0393:=\u03930; A:=A0; A0:=A1; H2:=H3}) x\n                        end)\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"]}, {"text": "apply H0;in_solve.", "goal_before": ["Is_true (TrueQ v A0)", "True"], "goal_after": ["True"], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        match H2 with\n                        | or_introl x =>\n                            (fun H3 : a = A1 =>\n                             eq_ind_r\n                               (fun a0 : PropF =>\n                                a0 :: \u03930 \u22a8 A0 ->\n                                TrueQ v a0 = true -> Is_true (TrueQ v A1))\n                               (fun (_ : A1 :: \u03930 \u22a8 A0)\n                                  (H5 : TrueQ v A1 = true) =>\n                                eq_ind_r (fun b : bool => Is_true b) I H5) H3\n                               H H1) x\n                        | or_intror x =>\n                            (fun H3 : In A1 \u03930 =>\n                             ?Goal0@{\u0393:=\u03930; A:=A0; A0:=A1; H2:=H3}) x\n                        end)\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        match H2 with\n                        | or_introl x =>\n                            (fun H3 : a = A1 =>\n                             eq_ind_r\n                               (fun a0 : PropF =>\n                                a0 :: \u03930 \u22a8 A0 ->\n                                TrueQ v a0 = true -> Is_true (TrueQ v A1))\n                               (fun (_ : A1 :: \u03930 \u22a8 A0)\n                                  (H5 : TrueQ v A1 = true) =>\n                                eq_ind_r (fun b : bool => Is_true b) I H5) H3\n                               H H1) x\n                        | or_intror x => (fun H3 : In A1 \u03930 => H0 A1 H3) x\n                        end)\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"]}, {"text": "exact I.", "goal_before": ["True"], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        match H2 with\n                        | or_introl x =>\n                            (fun H3 : a = A1 =>\n                             eq_ind_r\n                               (fun a0 : PropF =>\n                                a0 :: \u03930 \u22a8 A0 ->\n                                TrueQ v a0 = true -> Is_true (TrueQ v A1))\n                               (fun (_ : A1 :: \u03930 \u22a8 A0)\n                                  (H5 : TrueQ v A1 = true) =>\n                                eq_ind_r (fun b : bool => Is_true b) I H5) H3\n                               H H1) x\n                        | or_intror x => (fun H3 : In A1 \u03930 => H0 A1 H3) x\n                        end)\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (?Goal@{\u0393:=\u03930; A:=A0} : Is_true (negb false || TrueQ v A0))\n                   H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"], "proof_term_after": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        match H2 with\n                        | or_introl x =>\n                            (fun H3 : a = A1 =>\n                             eq_ind_r\n                               (fun a0 : PropF =>\n                                a0 :: \u03930 \u22a8 A0 ->\n                                TrueQ v a0 = true -> Is_true (TrueQ v A1))\n                               (fun (_ : A1 :: \u03930 \u22a8 A0)\n                                  (H5 : TrueQ v A1 = true) =>\n                                eq_ind_r (fun b : bool => Is_true b) I H5) H3\n                               H H1) x\n                        | or_intror x => (fun H3 : In A1 \u03930 => H0 A1 H3) x\n                        end)\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (I : Is_true (negb false || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (\u0393 : list PropF) (A : PropF) =>\n conj (Soundness_general (\u0393:=\u0393))\n   (list_ind (fun \u03930 : list PropF => forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0)\n      Completeness\n      (fun (a : PropF) (\u03930 : list PropF)\n         (IH\u0393 : forall A0 : PropF, \u03930 \u22a8 A0 -> \u03930 \u22a2 A0) \n         (A0 : PropF) (H : a :: \u03930 \u22a8 A0) =>\n       deduction\n         (IH\u0393 (a \u2192 A0)\n            ((fun (v : PropVars -> bool) (H0 : Satisfies v \u03930) =>\n              ((if TrueQ v a as b\n                 return (TrueQ v a = b -> Is_true (TrueQ v (a \u2192 A0)))\n                then\n                 fun H1 : TrueQ v a = true =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (H v\n                      ((fun (A1 : PropF) (H2 : In A1 (a :: \u03930)) =>\n                        match H2 with\n                        | or_introl x =>\n                            (fun H3 : a = A1 =>\n                             eq_ind_r\n                               (fun a0 : PropF =>\n                                a0 :: \u03930 \u22a8 A0 ->\n                                TrueQ v a0 = true -> Is_true (TrueQ v A1))\n                               (fun (_ : A1 :: \u03930 \u22a8 A0)\n                                  (H5 : TrueQ v A1 = true) =>\n                                eq_ind_r (fun b : bool => Is_true b) I H5) H3\n                               H H1) x\n                        | or_intror x => (fun H3 : In A1 \u03930 => H0 A1 H3) x\n                        end)\n                       :\n                       Satisfies v (a :: \u03930))\n                    :\n                    Is_true (negb true || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0))\n                else\n                 fun H1 : TrueQ v a = false =>\n                 eq_ind_r (fun b : bool => Is_true (negb b || TrueQ v A0))\n                   (I : Is_true (negb false || TrueQ v A0)) H1\n                 :\n                 Is_true (TrueQ v (a \u2192 A0)))\n               :\n               TrueQ v a = TrueQ v a -> Is_true (TrueQ v (a \u2192 A0))) eq_refl)\n             :\n             \u03930 \u22a8 a \u2192 A0))) \u0393 A))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/b_soundness.v", "name": "Soundness_general", "text": "Theorem Soundness_general : forall A \u0393, \u0393 \u22a2 A -> \u0393 \u22a8 A.\nintros A \u0393 H0 v;induction H0;simpl;intros;auto;\n try simpl in IHNc;try simpl in IHNc1;try simpl in IHNc2;\n  case_bool v A;try (case_bool v B;fail);\n   try (apply IHNc||apply IHNc2;prove_satisfaction);\n    case_bool v B;apply IHNc3;prove_satisfaction.\nQed.\n", "definition": " forall A \u0393, \u0393 \u22a2 A -> \u0393 \u22a8 A.", "proof": "\nintros A \u0393 H0 v;induction H0;simpl;intros;auto;\n try simpl in IHNc;try simpl in IHNc1;try simpl in IHNc2;\n  case_bool v A;try (case_bool v B;fail);\n   try (apply IHNc||apply IHNc2;prove_satisfaction);\n    case_bool v B;apply IHNc3;prove_satisfaction.\n", "def_ranges": [134, 0, 134, 55], "proof_ranges": [135, 0, 140, 4], "proof_steps": [{"text": "intros A \u0393 H0 v;induction H0;simpl;intros;auto;", "goal_before": ["forall (A : PropF) (\u0393 : list PropF), \u0393 \u22a2 A -> \u0393 \u22a8 A"], "goal_after": ["forall (A : PropF) (\u0393 : list PropF), \u0393 \u22a2 A -> \u0393 \u22a8 A"], "proof_term_before": [], "proof_term_after": []}, {"text": "try simpl in IHNc;try simpl in IHNc1;try simpl in IHNc2;", "goal_before": ["forall (A : PropF) (\u0393 : list PropF), \u0393 \u22a2 A -> \u0393 \u22a8 A"], "goal_after": ["forall (A : PropF) (\u0393 : list PropF), \u0393 \u22a2 A -> \u0393 \u22a8 A"], "proof_term_before": [], "proof_term_after": []}, {"text": "case_bool v A;try (case_bool v B;fail);", "goal_before": ["forall (A : PropF) (\u0393 : list PropF), \u0393 \u22a2 A -> \u0393 \u22a8 A"], "goal_after": ["forall (A : PropF) (\u0393 : list PropF), \u0393 \u22a2 A -> \u0393 \u22a8 A"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "try (apply IHNc||apply IHNc2;prove_satisfaction);", "goal_before": ["forall (A : PropF) (\u0393 : list PropF), \u0393 \u22a2 A -> \u0393 \u22a8 A"], "goal_after": [], "proof_term_before": ["?Goal"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/propcalc/b_soundness.v", "name": "Soundness", "text": "Theorem Soundness : Prop_Soundness.\nintros ? ? ? ?;eapply Soundness_general;eassumption.\nQed.\n", "definition": " Prop_Soundness.", "proof": "\nintros ? ? ? ?;eapply Soundness_general;eassumption.\n", "def_ranges": [142, 0, 142, 35], "proof_ranges": [143, 0, 144, 4], "proof_steps": [{"text": "intros ? ? ? ?;eapply Soundness_general;eassumption.", "goal_before": ["Prop_Soundness"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun (A : PropF) (H : Provable A) =>\n  (fun (v : PropVars -> bool) (H0 : Satisfies v []) => Soundness_general H H0)\n  :\n  Valid A)\n :\n Prop_Soundness)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (A : PropF) (H : Provable A) =>\n  (fun (v : PropVars -> bool) (H0 : Satisfies v []) => Soundness_general H H0)\n  :\n  Valid A)\n :\n Prop_Soundness)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_pair.v", "name": "pairing", "text": "Theorem pairing :\n forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)).\n\nProof.\nintros; unfold iff in |- *; apply and_intro.\n(* Forward implication *)\nintro; apply pairing_elim; assumption.\n(* Backward implication: case distinction *)\nintro H; apply H; clear H; intro H.\n(* First case *)\napply ELT_compat_l with X A a.\nassumption. apply pairing_intro1.\n(* Second case *)\napply ELT_compat_l with Y B b.\nassumption. apply pairing_intro2.\nQed.\n", "definition": "\n forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)).\n\n", "proof": "\nintros; unfold iff in |- *; apply and_intro.\n(* Forward implication *)\nintro; apply pairing_elim; assumption.\n(* Backward implication: case distinction *)\nintro H; apply H; clear H; intro H.\n(* First case *)\napply ELT_compat_l with X A a.\nassumption. apply pairing_intro1.\n(* Second case *)\napply ELT_compat_l with Y B b.\nassumption. apply pairing_intro2.\n", "def_ranges": [208, 0, 212, 44], "proof_ranges": [213, 0, 226, 4], "proof_steps": [{"text": "intros; unfold iff in |- *; apply and_intro.", "goal_before": ["forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n  (b : Y) (Z : Typ1) (C : Rel Z) (c : Z),\niff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n  (or (EQV Z C c X A a) (EQV Z C c Y B b))"], "goal_after": ["ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\nor (EQV Z C c X A a) (EQV Z C c Y B b)", "or (EQV Z C c X A a) (EQV Z C c Y B b) ->\nELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "proof_term_before": [], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)) \n   ?Goal ?Goal0\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "intro; apply pairing_elim; assumption.", "goal_before": ["ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\nor (EQV Z C c X A a) (EQV Z C c Y B b)", "or (EQV Z C c X A a) (EQV Z C c Y B b) ->\nELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "goal_after": ["or (EQV Z C c X A a) (EQV Z C c Y B b) ->\nELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)) \n   ?Goal ?Goal0\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H) ?Goal\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "intro H; apply H; clear H; intro H.", "goal_before": ["or (EQV Z C c X A a) (EQV Z C c Y B b) ->\nELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "goal_after": ["ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)", "ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H) ?Goal\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a => ?Goal@{H:=H0})\n      (fun H0 : EQV Z C c Y B b => ?Goal0@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "apply ELT_compat_l with X A a.", "goal_before": ["ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)", "ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "goal_after": ["EQV Z C c X A a", "ELT X A a (sum X Y) (PAIR X A a Y B b) (out X Y)", "ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a => ?Goal@{H:=H0})\n      (fun H0 : EQV Z C c Y B b => ?Goal0@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) ?Goal0@{H:=H0} ?Goal1@{H:=H0})\n      (fun H0 : EQV Z C c Y B b => ?Goal@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "assumption.", "goal_before": ["EQV Z C c X A a", "ELT X A a (sum X Y) (PAIR X A a Y B b) (out X Y)", "ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "goal_after": ["ELT X A a (sum X Y) (PAIR X A a Y B b) (out X Y)", "ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) ?Goal0@{H:=H0} ?Goal1@{H:=H0})\n      (fun H0 : EQV Z C c Y B b => ?Goal@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 ?Goal0@{H:=H0})\n      (fun H0 : EQV Z C c Y B b => ?Goal@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "apply pairing_intro1.", "goal_before": ["ELT X A a (sum X Y) (PAIR X A a Y B b) (out X Y)", "ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "goal_after": ["ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 ?Goal0@{H:=H0})\n      (fun H0 : EQV Z C c Y B b => ?Goal@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro1 X A a Y B b))\n      (fun H0 : EQV Z C c Y B b => ?Goal@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "apply ELT_compat_l with Y B b.", "goal_before": ["ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y)"], "goal_after": ["EQV Z C c Y B b", "ELT Y B b (sum X Y) (PAIR X A a Y B b) (out X Y)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro1 X A a Y B b))\n      (fun H0 : EQV Z C c Y B b => ?Goal@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro1 X A a Y B b))\n      (fun H0 : EQV Z C c Y B b =>\n       ELT_compat_l Z C c Y B b (sum X Y) (PAIR X A a Y B b) \n         (out X Y) ?Goal@{H:=H0} ?Goal0@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "assumption.", "goal_before": ["EQV Z C c Y B b", "ELT Y B b (sum X Y) (PAIR X A a Y B b) (out X Y)"], "goal_after": ["ELT Y B b (sum X Y) (PAIR X A a Y B b) (out X Y)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro1 X A a Y B b))\n      (fun H0 : EQV Z C c Y B b =>\n       ELT_compat_l Z C c Y B b (sum X Y) (PAIR X A a Y B b) \n         (out X Y) ?Goal@{H:=H0} ?Goal0@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro1 X A a Y B b))\n      (fun H0 : EQV Z C c Y B b =>\n       ELT_compat_l Z C c Y B b (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 ?Goal@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "apply pairing_intro2.", "goal_before": ["ELT Y B b (sum X Y) (PAIR X A a Y B b) (out X Y)"], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro1 X A a Y B b))\n      (fun H0 : EQV Z C c Y B b =>\n       ELT_compat_l Z C c Y B b (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 ?Goal@{H:=H0}))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro1 X A a Y B b))\n      (fun H0 : EQV Z C c Y B b =>\n       ELT_compat_l Z C c Y B b (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro2 X A a Y B b)))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (Z : Typ1) (C : Rel Z) (c : Z) =>\n and_intro\n   (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) ->\n    or (EQV Z C c X A a) (EQV Z C c Y B b))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b) ->\n    ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (fun H : ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y) =>\n    pairing_elim X A a Y B b Z C c H)\n   (fun H : or (EQV Z C c X A a) (EQV Z C c Y B b) =>\n    H (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n      (fun H0 : EQV Z C c X A a =>\n       ELT_compat_l Z C c X A a (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro1 X A a Y B b))\n      (fun H0 : EQV Z C c Y B b =>\n       ELT_compat_l Z C c Y B b (sum X Y) (PAIR X A a Y B b) \n         (out X Y) H0 (pairing_intro2 X A a Y B b)))\n :\n iff (ELT Z C c (sum X Y) (PAIR X A a Y B b) (out X Y))\n   (or (EQV Z C c X A a) (EQV Z C c Y B b)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_power.v", "name": "powerset", "text": "Theorem powerset :\n forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),\n iff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (SUB Y B b X A a).\n\nProof.\nintros X A a Y B b; unfold iff in |- *; apply and_intro.\nintro; apply powerset_elim; assumption.\nintro; apply powerset_intro; assumption.\nQed.\n", "definition": "\n forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),\n iff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (SUB Y B b X A a).\n\n", "proof": "\nintros X A a Y B b; unfold iff in |- *; apply and_intro.\nintro; apply powerset_elim; assumption.\nintro; apply powerset_intro; assumption.\n", "def_ranges": [202, 0, 205, 21], "proof_ranges": [206, 0, 211, 4], "proof_steps": [{"text": "intros X A a Y B b; unfold iff in |- *; apply and_intro.", "goal_before": ["forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),\niff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n  (SUB Y B b X A a)"], "goal_after": ["ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)) ->\nSUB Y B b X A a", "SUB Y B b X A a ->\nELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))"], "proof_term_before": [], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)) ->\n    SUB Y B b X A a)\n   (SUB Y B b X A a ->\n    ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))) \n   ?Goal ?Goal0\n :\n iff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (SUB Y B b X A a))"]}, {"text": "intro; apply powerset_elim; assumption.", "goal_before": ["ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)) ->\nSUB Y B b X A a", "SUB Y B b X A a ->\nELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))"], "goal_after": ["SUB Y B b X A a ->\nELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)) ->\n    SUB Y B b X A a)\n   (SUB Y B b X A a ->\n    ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))) \n   ?Goal ?Goal0\n :\n iff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (SUB Y B b X A a))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)) ->\n    SUB Y B b X A a)\n   (SUB Y B b X A a ->\n    ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (fun H : ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))\n    => powerset_elim X A a Y B b H) ?Goal\n :\n iff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (SUB Y B b X A a))"]}, {"text": "intro; apply powerset_intro; assumption.", "goal_before": ["SUB Y B b X A a ->\nELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))"], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)) ->\n    SUB Y B b X A a)\n   (SUB Y B b X A a ->\n    ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (fun H : ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))\n    => powerset_elim X A a Y B b H) ?Goal\n :\n iff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (SUB Y B b X A a))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)) ->\n    SUB Y B b X A a)\n   (SUB Y B b X A a ->\n    ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (fun H : ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))\n    => powerset_elim X A a Y B b H)\n   (fun H : SUB Y B b X A a => powerset_intro X A a Y B b H)\n :\n iff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (SUB Y B b X A a))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)) ->\n    SUB Y B b X A a)\n   (SUB Y B b X A a ->\n    ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (fun H : ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop))\n    => powerset_elim X A a Y B b H)\n   (fun H : SUB Y B b X A a => powerset_intro X A a Y B b H)\n :\n iff (ELT Y B b (sum X (X -> Prop)) (POWER X A a) (out X (X -> Prop)))\n   (SUB Y B b X A a))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_coll.v", "name": "collection", "text": "Theorem collection :\n forall (X : Typ1) (A : Rel X) (a : X) (R : REL),\n LCOMPAT R ->\n RCOMPAT R ->\n (forall (X' : Typ1) (A' : Rel X') (a' : X'),\n  ELT X' A' a' X A a -> exG (fun Y' B' b' => R X' A' a' Y' B' b')) ->\n forall (X' : Typ1) (A' : Rel X') (a' : X'),\n ELT X' A' a' X A a ->\n exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n   (fun Y' B' b' => R X' A' a' Y' B' b').\n\nProof.\nintros X A a R HL HR H0 X' A' a' H1.\napply H1; clear H1; intros x H1 H2.\n(* Perform a cut *)\ncut (exT (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b)))).\n(* Main premise *)\nintro H; apply (choice _ H); clear H; intros c H.\napply H; clear H; intros B H; change (Rel (coll_fam X A a R x c)) in B.\napply H; clear H; intros b H3; change (coll_fam X A a R x c) in b.\nchange (R X A x (coll_fam X A a R x c) B b) in H3.\napply exG_rel_intro with (coll_fam X A a R x c) B b.\napply ELT_intro with (foo_in X Code (coll_fam X A a R) x c B b).\nunfold COLL, coll_rt in |- *; apply FOO_rt.\nunfold coll, COLL in |- *; apply FOO_eqv.\napply HL with X A x; assumption.\n(* Argument *)\napply (H0 X A x (ELT_direct X A a x H1)); intros Y B b H3.\napply exT_intro with Y.\napply ex_intro with B.\napply ex_intro with b.\nassumption.\nQed.\n", "definition": "\n forall (X : Typ1) (A : Rel X) (a : X) (R : REL),\n LCOMPAT R ->\n RCOMPAT R ->\n (forall (X' : Typ1) (A' : Rel X') (a' : X'),\n  ELT X' A' a' X A a -> exG (fun Y' B' b' => R X' A' a' Y' B' b')) ->\n forall (X' : Typ1) (A' : Rel X') (a' : X'),\n ELT X' A' a' X A a ->\n exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n   (fun Y' B' b' => R X' A' a' Y' B' b').\n\n", "proof": "\nintros X A a R HL HR H0 X' A' a' H1.\napply H1; clear H1; intros x H1 H2.\n(* Perform a cut *)\ncut (exT (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b)))).\n(* Main premise *)\nintro H; apply (choice _ H); clear H; intros c H.\napply H; clear H; intros B H; change (Rel (coll_fam X A a R x c)) in B.\napply H; clear H; intros b H3; change (coll_fam X A a R x c) in b.\nchange (R X A x (coll_fam X A a R x c) B b) in H3.\napply exG_rel_intro with (coll_fam X A a R x c) B b.\napply ELT_intro with (foo_in X Code (coll_fam X A a R) x c B b).\nunfold COLL, coll_rt in |- *; apply FOO_rt.\nunfold coll, COLL in |- *; apply FOO_eqv.\napply HL with X A x; assumption.\n(* Argument *)\napply (H0 X A x (ELT_direct X A a x H1)); intros Y B b H3.\napply exT_intro with Y.\napply ex_intro with B.\napply ex_intro with b.\nassumption.\n", "def_ranges": [366, 0, 375, 41], "proof_ranges": [376, 0, 398, 4], "proof_steps": [{"text": "intros X A a R HL HR H0 X' A' a' H1.", "goal_before": ["forall (X : Typ1) (A : Rel X) (a : X) (R : REL),\nLCOMPAT R ->\nRCOMPAT R ->\n(forall (X' : Typ1) (A' : Rel X') (a' : X'),\n ELT X' A' a' X A a ->\n exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')) ->\nforall (X' : Typ1) (A' : Rel X') (a' : X'),\nELT X' A' a' X A a ->\nexG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "proof_term_before": [], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) => \n ?Goal)"]}, {"text": "apply H1; clear H1; intros x H1 H2.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) => \n ?Goal)"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    ?Goal@{H1:=H2; H2:=H3}))"]}, {"text": "cut (exT (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b)))).", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "goal_after": ["exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) ->\nexG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    ?Goal@{H1:=H2; H2:=H3}))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal0@{H1:=H2; H2:=H3} in\n    ?Goal@{H1:=H2; H2:=H3} H))"]}, {"text": "intro H; apply (choice _ H); clear H; intros c H.", "goal_before": ["exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) ->\nexG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal0@{H1:=H2; H2:=H3} in\n    ?Goal@{H1:=H2; H2:=H3} H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        => ?Goal0@{H1:=H2; H2:=H3; H:=H5})) H))"]}, {"text": "apply H; clear H; intros B H; change (Rel (coll_fam X A a R x c)) in B.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        => ?Goal0@{H1:=H2; H2:=H3; H:=H5})) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           => ?Goal0@{H1:=H2; H2:=H3; H:=H6}))) H))"]}, {"text": "apply H; clear H; intros b H3; change (coll_fam X A a R x c) in b.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           => ?Goal0@{H1:=H2; H2:=H3; H:=H6}))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              => ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"]}, {"text": "change (R X A x (coll_fam X A a R x c) B b) in H3.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              => ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              => ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"]}, {"text": "apply exG_rel_intro with (coll_fam X A a R x c) B b.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["ELT (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (coll_rt X A a R)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              => ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                ?Goal0@{H1:=H2; H2:=H3; H3:=H7}\n                ?Goal1@{H1:=H2; H2:=H3; H3:=H7})))) H))"]}, {"text": "apply ELT_intro with (foo_in X Code (coll_fam X A a R) x c B b).", "goal_before": ["ELT (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (coll_rt X A a R)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b) (coll_rt X A a R)", "EQV (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (foo_in X Code (coll_fam X A a R) x c B b)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                ?Goal0@{H1:=H2; H2:=H3; H3:=H7}\n                ?Goal1@{H1:=H2; H2:=H3; H3:=H7})))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   ?Goal1@{H1:=H2; H2:=H3; H3:=H7}\n                   ?Goal2@{H1:=H2; H2:=H3; H3:=H7})\n                ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"]}, {"text": "unfold COLL, coll_rt in |- *; apply FOO_rt.", "goal_before": ["COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b) (coll_rt X A a R)", "EQV (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (foo_in X Code (coll_fam X A a R) x c B b)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["EQV (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (foo_in X Code (coll_fam X A a R) x c B b)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   ?Goal1@{H1:=H2; H2:=H3; H3:=H7}\n                   ?Goal2@{H1:=H2; H2:=H3; H3:=H7})\n                ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R)) ?Goal1@{H1:=H2; H2:=H3; H3:=H7})\n                ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"]}, {"text": "unfold coll, COLL in |- *; apply FOO_eqv.", "goal_before": ["EQV (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (foo_in X Code (coll_fam X A a R) x c B b)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R)) ?Goal1@{H1:=H2; H2:=H3; H3:=H7})\n                ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"]}, {"text": "apply HL with X A x; assumption.", "goal_before": ["R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                ?Goal0@{H1:=H2; H2:=H3; H3:=H7})))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"]}, {"text": "apply (H0 X A x (ELT_direct X A a x H1)); intros Y B b H3.", "goal_before": ["exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exT\n  (fun Y0 : Typ1 =>\n   ex (Rel Y0) (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal@{H1:=H2; H2:=H3} in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         ?Goal@{H1:=H2; H2:=H3; H3:=H4}) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"]}, {"text": "apply exT_intro with Y.", "goal_before": ["exT\n  (fun Y0 : Typ1 =>\n   ex (Rel Y0) (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0)))"], "goal_after": ["ex (Rel Y) (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         ?Goal@{H1:=H2; H2:=H3; H3:=H4}) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           ?Goal@{H1:=H2; H2:=H3; H3:=H4}) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"]}, {"text": "apply ex_intro with B.", "goal_before": ["ex (Rel Y) (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0))"], "goal_after": ["ex Y (fun b0 : Y => R X A x Y B b0)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           ?Goal@{H1:=H2; H2:=H3; H3:=H4}) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              ?Goal@{H1:=H2; H2:=H3; H3:=H4})) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"]}, {"text": "apply ex_intro with b.", "goal_before": ["ex Y (fun b0 : Y => R X A x Y B b0)"], "goal_after": ["R X A x Y B b"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              ?Goal@{H1:=H2; H2:=H3; H3:=H4})) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b\n                 ?Goal@{H1:=H2; H2:=H3; H3:=H4}))) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"]}, {"text": "assumption.", "goal_before": ["R X A x Y B b"], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b\n                 ?Goal@{H1:=H2; H2:=H3; H3:=H4}))) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (_ : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b H4))) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (_ : RCOMPAT R)\n   (H0 : forall (X' : Typ1) (A' : Rel X') (a' : X'),\n         ELT X' A' a' X A a ->\n         exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (X' : Typ1) (A' : Rel X') (a' : X') (H1 : ELT X' A' a' X A a) =>\n H1\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H0 X A x (ELT_direct X A a x H2)\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X A x Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b H4))) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_coll.v", "name": "collection2", "text": "Theorem collection2 :\n forall (X : Typ1) (A : Rel X) (a : X) (R : REL),\n LCOMPAT R ->\n RCOMPAT R ->\n forall (X' : Typ1) (A' : Rel X') (a' : X'),\n ELT X' A' a' X A a ->\n exG (fun Y' B' b' => R X' A' a' Y' B' b') ->\n exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n   (fun Y' B' b' => R X' A' a' Y' B' b').\n\nProof.\nintros X A a R HL HR X' A' a' H H1.\napply H; clear H; intros x H2 H3.\n(* Perform a cut *)\ncut (exT (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b)))).\n(* Main premise *)\nintro H; apply (choice _ H); clear H; intros c H.\napply H; clear H; intros B H; change (Rel (coll_fam X A a R x c)) in B.\napply H; clear H; intros b H4; change (coll_fam X A a R x c) in b.\nchange (R X A x (coll_fam X A a R x c) B b) in H4.\napply exG_rel_intro with (coll_fam X A a R x c) B b.\napply ELT_intro with (foo_in X Code (coll_fam X A a R) x c B b).\nunfold COLL, coll_rt in |- *; apply FOO_rt.\nunfold coll, COLL in |- *; apply FOO_eqv.\napply HL with X A x; assumption.\n(* Argument *)\napply H1; clear H1; intros Y B b H1.\napply exT_intro with Y.\napply ex_intro with B.\napply ex_intro with b.\napply HL with X' A' a'.\napply EQV_sym; assumption. \nassumption.\nQed.\n", "definition": "\n forall (X : Typ1) (A : Rel X) (a : X) (R : REL),\n LCOMPAT R ->\n RCOMPAT R ->\n forall (X' : Typ1) (A' : Rel X') (a' : X'),\n ELT X' A' a' X A a ->\n exG (fun Y' B' b' => R X' A' a' Y' B' b') ->\n exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n   (fun Y' B' b' => R X' A' a' Y' B' b').\n\n", "proof": "\nintros X A a R HL HR X' A' a' H H1.\napply H; clear H; intros x H2 H3.\n(* Perform a cut *)\ncut (exT (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b)))).\n(* Main premise *)\nintro H; apply (choice _ H); clear H; intros c H.\napply H; clear H; intros B H; change (Rel (coll_fam X A a R x c)) in B.\napply H; clear H; intros b H4; change (coll_fam X A a R x c) in b.\nchange (R X A x (coll_fam X A a R x c) B b) in H4.\napply exG_rel_intro with (coll_fam X A a R x c) B b.\napply ELT_intro with (foo_in X Code (coll_fam X A a R) x c B b).\nunfold COLL, coll_rt in |- *; apply FOO_rt.\nunfold coll, COLL in |- *; apply FOO_eqv.\napply HL with X A x; assumption.\n(* Argument *)\napply H1; clear H1; intros Y B b H1.\napply exT_intro with Y.\napply ex_intro with B.\napply ex_intro with b.\napply HL with X' A' a'.\napply EQV_sym; assumption. \nassumption.\n", "def_ranges": [403, 0, 411, 41], "proof_ranges": [412, 0, 436, 4], "proof_steps": [{"text": "intros X A a R HL HR X' A' a' H H1.", "goal_before": ["forall (X : Typ1) (A : Rel X) (a : X) (R : REL),\nLCOMPAT R ->\nRCOMPAT R ->\nforall (X' : Typ1) (A' : Rel X') (a' : X'),\nELT X' A' a' X A a ->\nexG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b') ->\nexG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "proof_term_before": [], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n => ?Goal)"]}, {"text": "apply H; clear H; intros x H2 H3.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n => ?Goal)"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) => ?Goal))"]}, {"text": "cut (exT (fun Y => ex (Rel Y) (fun B => ex Y (fun b => R X A x Y B b)))).", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')"], "goal_after": ["exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) ->\nexG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) => ?Goal))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal0 in\n    ?Goal H0))"]}, {"text": "intro H; apply (choice _ H); clear H; intros c H.", "goal_before": ["exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) ->\nexG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal0 in\n    ?Goal H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        => ?Goal0@{H:=H5})) H0))"]}, {"text": "apply H; clear H; intros B H; change (Rel (coll_fam X A a R x c)) in B.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        => ?Goal0@{H:=H5})) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           => ?Goal0@{H:=H6}))) H0))"]}, {"text": "apply H; clear H; intros b H4; change (coll_fam X A a R x c) in b.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           => ?Goal0@{H:=H6}))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              => ?Goal0@{H4:=H7})))) H0))"]}, {"text": "change (R X A x (coll_fam X A a R x c) B b) in H4.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              => ?Goal0@{H4:=H7})))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              => ?Goal0@{H4:=H7})))) H0))"]}, {"text": "apply exG_rel_intro with (coll_fam X A a R x c) B b.", "goal_before": ["exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n  (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b')", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["ELT (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (coll_rt X A a R)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              => ?Goal0@{H4:=H7})))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                ?Goal0@{H4:=H7} ?Goal1@{H4:=H7})))) H0))"]}, {"text": "apply ELT_intro with (foo_in X Code (coll_fam X A a R) x c B b).", "goal_before": ["ELT (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (coll_rt X A a R)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b) (coll_rt X A a R)", "EQV (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (foo_in X Code (coll_fam X A a R) x c B b)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                ?Goal0@{H4:=H7} ?Goal1@{H4:=H7})))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b) \n                   ?Goal1@{H4:=H7} ?Goal2@{H4:=H7}) \n                ?Goal0@{H4:=H7})))) H0))"]}, {"text": "unfold COLL, coll_rt in |- *; apply FOO_rt.", "goal_before": ["COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b) (coll_rt X A a R)", "EQV (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (foo_in X Code (coll_fam X A a R) x c B b)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["EQV (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (foo_in X Code (coll_fam X A a R) x c B b)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b) \n                   ?Goal1@{H4:=H7} ?Goal2@{H4:=H7}) \n                ?Goal0@{H4:=H7})))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R)) ?Goal1@{H4:=H7}) \n                ?Goal0@{H4:=H7})))) H0))"]}, {"text": "unfold coll, COLL in |- *; apply FOO_eqv.", "goal_before": ["EQV (coll_fam X A a R x c) B b (coll X A a R) (COLL X A a R)\n  (foo_in X Code (coll_fam X A a R) x c B b)", "R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R)) ?Goal1@{H4:=H7}) \n                ?Goal0@{H4:=H7})))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                ?Goal0@{H4:=H7})))) H0))"]}, {"text": "apply HL with X A x; assumption.", "goal_before": ["R X' A' a' (coll_fam X A a R x c) B b", "exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                ?Goal0@{H4:=H7})))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"]}, {"text": "apply H1; clear H1; intros Y B b H1.", "goal_before": ["exT\n  (fun Y : Typ1 =>\n   ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))"], "goal_after": ["exT\n  (fun Y0 : Typ1 =>\n   ex (Rel Y0) (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0)))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      ?Goal in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         ?Goal@{H1:=H4}) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"]}, {"text": "apply exT_intro with Y.", "goal_before": ["exT\n  (fun Y0 : Typ1 =>\n   ex (Rel Y0) (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0)))"], "goal_after": ["ex (Rel Y) (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         ?Goal@{H1:=H4}) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           ?Goal@{H1:=H4}) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"]}, {"text": "apply ex_intro with B.", "goal_before": ["ex (Rel Y) (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0))"], "goal_after": ["ex Y (fun b0 : Y => R X A x Y B b0)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           ?Goal@{H1:=H4}) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              ?Goal@{H1:=H4})) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"]}, {"text": "apply ex_intro with b.", "goal_before": ["ex Y (fun b0 : Y => R X A x Y B b0)"], "goal_after": ["R X A x Y B b"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              ?Goal@{H1:=H4})) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b ?Goal@{H1:=H4})))\n      in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"]}, {"text": "apply HL with X' A' a'.", "goal_before": ["R X A x Y B b"], "goal_after": ["EQV X A x X' A' a'", "R X' A' a' Y B b"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b ?Goal@{H1:=H4})))\n      in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b\n                 (HL X A x X' A' a' Y B b ?Goal@{H1:=H4} ?Goal0@{H1:=H4}))))\n      in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"]}, {"text": "apply EQV_sym; assumption.", "goal_before": ["EQV X A x X' A' a'", "R X' A' a' Y B b"], "goal_after": ["R X' A' a' Y B b"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b\n                 (HL X A x X' A' a' Y B b ?Goal@{H1:=H4} ?Goal0@{H1:=H4}))))\n      in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b\n                 (HL X A x X' A' a' Y B b (EQV_sym X' A' a' X A x H3)\n                    ?Goal@{H1:=H4})))) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"]}, {"text": "assumption.", "goal_before": ["R X' A' a' Y B b"], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (HR : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (H2 : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b\n                 (HL X A x X' A' a' Y B b (EQV_sym X' A' a' X A x H3)\n                    ?Goal@{H1:=H4})))) in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (_ : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (_ : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b\n                 (HL X A x X' A' a' Y B b (EQV_sym X' A' a' X A x H3) H4))))\n      in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (R : REL) (HL : LCOMPAT R)\n   (_ : RCOMPAT R) (X' : Typ1) (A' : Rel X') (a' : X')\n   (H : ELT X' A' a' X A a)\n   (H1 : exG (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n =>\n H\n   (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n      (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n   (fun (x : X) (_ : A x a) (H3 : EQV X' A' a' X A x) =>\n    let H0 :\n      exT\n        (fun Y : Typ1 =>\n         ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) :=\n      H1\n        (exT\n           (fun Y : Typ1 =>\n            ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))))\n        (fun (Y : Typ1) (B : Rel Y) (b : Y) (H4 : R X' A' a' Y B b) =>\n         exT_intro\n           (fun Y0 : Typ1 =>\n            ex (Rel Y0)\n              (fun B0 : Rel Y0 => ex Y0 (fun b0 : Y0 => R X A x Y0 B0 b0))) Y\n           (ex_intro (Rel Y)\n              (fun B0 : Rel Y => ex Y (fun b0 : Y => R X A x Y B0 b0)) B\n              (ex_intro Y (fun b0 : Y => R X A x Y B b0) b\n                 (HL X A x X' A' a' Y B b (EQV_sym X' A' a' X A x H3) H4))))\n      in\n    (fun\n       H4 : exT\n              (fun Y : Typ1 =>\n               ex (Rel Y)\n                 (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) =>\n     choice\n       (fun Y : Typ1 =>\n        ex (Rel Y) (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b))) H4\n       (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n          (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n       (fun (c : Code)\n          (H5 : ex\n                  (Rel\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B b))) c))\n                  (fun\n                     B : Rel\n                           (eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B b))) c) =>\n                   ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)))\n        =>\n        H5\n          (exG_rel (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n             (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') => R X' A' a' Y' B' b'))\n          (fun\n             (B : Rel\n                    (eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B : Rel Y => ex Y (fun b : Y => R X A x Y B b)))\n                       c))\n             (H6 : ex\n                     (eps\n                        (fun Y : Typ1 =>\n                         ex (Rel Y)\n                           (fun B0 : Rel Y =>\n                            ex Y (fun b : Y => R X A x Y B0 b))) c)\n                     (fun\n                        b : eps\n                              (fun Y : Typ1 =>\n                               ex (Rel Y)\n                                 (fun B0 : Rel Y =>\n                                  ex Y (fun b : Y => R X A x Y B0 b))) c =>\n                      R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b))\n           =>\n           H6\n             (exG_rel (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b'))\n             (fun\n                (b : eps\n                       (fun Y : Typ1 =>\n                        ex (Rel Y)\n                          (fun B0 : Rel Y =>\n                           ex Y (fun b : Y => R X A x Y B0 b))) c)\n                (H7 : R X A x\n                        (eps\n                           (fun Y : Typ1 =>\n                            ex (Rel Y)\n                              (fun B0 : Rel Y =>\n                               ex Y (fun b0 : Y => R X A x Y B0 b0))) c) B b)\n              =>\n              exG_rel_intro (coll X A a R) (COLL X A a R) \n                (coll_rt X A a R)\n                (fun (Y' : Typ1) (B' : Rel Y') (b' : Y') =>\n                 R X' A' a' Y' B' b') (coll_fam X A a R x c) B b\n                (ELT_intro (coll_fam X A a R x c) B b \n                   (coll X A a R) (COLL X A a R) (coll_rt X A a R)\n                   (foo_in X Code (coll_fam X A a R) x c B b)\n                   (FOO_rt X Code (coll_fam X A a R) x c B b\n                    :\n                    COLL X A a R (foo_in X Code (coll_fam X A a R) x c B b)\n                      (coll_rt X A a R))\n                   (FOO_eqv X Code (coll_fam X A a R) x c B b\n                    :\n                    EQV (coll_fam X A a R x c) B b \n                      (coll X A a R) (COLL X A a R)\n                      (foo_in X Code (coll_fam X A a R) x c B b)))\n                (HL X' A' a' X A x (coll_fam X A a R x c) B b H3 H7))))) H0))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_base.v", "name": "extensionality", "text": "Theorem extensionality :\n forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),\n SUB X A a Y B b -> SUB Y B b X A a -> EQV X A a Y B b.\n\nProof.\nintros X A a Y B b H1 H2.\n(* Give the bisimulation: *)\napply\n EQV_intro with (fun x y => or (and (eq X x a) (eq Y y b)) (EQV X A x Y B y)).\n(* BIS1 *)\nintros x x' y H3 H4; apply H4; clear H4; intro H4.\n(* BIS1, first case: x = a and y = b *)\napply H4; clear H4; intros H4 H5.\ngeneralize (ELT_direct X A x x' H3); eapply (eq_sym _ _ _ H4).\nintro H6; apply (H1 _ _ _ H6); intros y' H7 H8.\napply ex2_intro with y'.\napply (eq_sym _ _ _ H5); assumption.\napply or_inr; assumption.\n(* BIS1, second case: (EQV X A x Y B y) *)\napply (EQV_shift _ _ _ _ _ _ H4 x' H3).\nintros y' H5 H6; apply ex2_intro with y'.\nassumption.  apply or_inr; assumption.\n(* BIS2 *)\nintros y y' x H3 H4; apply H4; clear H4; intro H4.\n(* BIS2, first case: x = a and y = b *)\napply H4; clear H4; intros H4 H5.\ngeneralize (ELT_direct Y B y y' H3); eapply (eq_sym _ _ _ H5).\nintro H6; apply (H2 _ _ _ H6); intros x' H7 H8.\napply ex2_intro with x'.\napply (eq_sym _ _ _ H4); assumption.\napply or_inr; apply EQV_sym; assumption.\n(* BIS2, second case: (EQV X A x Y B y) *)\napply (EQV_shift _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H4) y' H3).\nintros x' H5 H6; apply ex2_intro with x'.\nassumption.  apply or_inr; apply EQV_sym; assumption.\n(* BIS3 *)\napply or_inl; apply and_intro; apply eq_refl.\nQed.\n", "definition": "\n forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),\n SUB X A a Y B b -> SUB Y B b X A a -> EQV X A a Y B b.\n\n", "proof": "\nintros X A a Y B b H1 H2.\n(* Give the bisimulation: *)\napply\n EQV_intro with (fun x y => or (and (eq X x a) (eq Y y b)) (EQV X A x Y B y)).\n(* BIS1 *)\nintros x x' y H3 H4; apply H4; clear H4; intro H4.\n(* BIS1, first case: x = a and y = b *)\napply H4; clear H4; intros H4 H5.\ngeneralize (ELT_direct X A x x' H3); eapply (eq_sym _ _ _ H4).\nintro H6; apply (H1 _ _ _ H6); intros y' H7 H8.\napply ex2_intro with y'.\napply (eq_sym _ _ _ H5); assumption.\napply or_inr; assumption.\n(* BIS1, second case: (EQV X A x Y B y) *)\napply (EQV_shift _ _ _ _ _ _ H4 x' H3).\nintros y' H5 H6; apply ex2_intro with y'.\nassumption.  apply or_inr; assumption.\n(* BIS2 *)\nintros y y' x H3 H4; apply H4; clear H4; intro H4.\n(* BIS2, first case: x = a and y = b *)\napply H4; clear H4; intros H4 H5.\ngeneralize (ELT_direct Y B y y' H3); eapply (eq_sym _ _ _ H5).\nintro H6; apply (H2 _ _ _ H6); intros x' H7 H8.\napply ex2_intro with x'.\napply (eq_sym _ _ _ H4); assumption.\napply or_inr; apply EQV_sym; assumption.\n(* BIS2, second case: (EQV X A x Y B y) *)\napply (EQV_shift _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H4) y' H3).\nintros x' H5 H6; apply ex2_intro with x'.\nassumption.  apply or_inr; apply EQV_sym; assumption.\n(* BIS3 *)\napply or_inl; apply and_intro; apply eq_refl.\n", "def_ranges": [251, 0, 253, 55], "proof_ranges": [254, 0, 288, 4], "proof_steps": [{"text": "intros X A a Y B b H1 H2.", "goal_before": ["forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),\nSUB X A a Y B b -> SUB Y B b X A a -> EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (H1 : SUB X A a Y B b) (H2 : SUB Y B b X A a) => \n ?Goal)"]}, {"text": "apply", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) \n   (b : Y) (H1 : SUB X A a Y B b) (H2 : SUB Y B b X A a) => \n ?Goal)"], "proof_term_after": []}, {"text": "EQV_intro with (fun x y => or (and (eq X x a) (eq Y y b)) (EQV X A x Y B y)).", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x x' y H3 H4; apply H4; clear H4; intro H4.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H4; clear H4; intros H4 H5.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (ELT_direct X A x x' H3); eapply (eq_sym _ _ _ H4).", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H6; apply (H1 _ _ _ H6); intros y' H7 H8.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ex2_intro with y'.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (eq_sym _ _ _ H5); assumption.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply or_inr; assumption.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (EQV_shift _ _ _ _ _ _ H4 x' H3).", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y' H5 H6; apply ex2_intro with y'.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply or_inr; assumption.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y y' x H3 H4; apply H4; clear H4; intro H4.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H4; clear H4; intros H4 H5.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (ELT_direct Y B y y' H3); eapply (eq_sym _ _ _ H5).", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H6; apply (H2 _ _ _ H6); intros x' H7 H8.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ex2_intro with x'.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (eq_sym _ _ _ H4); assumption.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply or_inr; apply EQV_sym; assumption.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (EQV_shift _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H4) y' H3).", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x' H5 H6; apply ex2_intro with x'.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply or_inr; apply EQV_sym; assumption.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply or_inl; apply and_intro; apply eq_refl.", "goal_before": ["EQV X A a Y B b"], "goal_after": ["EQV X A a Y B b"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_select.v", "name": "selection", "text": "Theorem selection :\n forall (X : Typ1) (A : Rel X) (a : X) (P : PRED),\n Compat P ->\n forall (Y : Typ1) (B : Rel Y) (b : Y),\n iff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (and (ELT Y B b X A a) (P Y B b)).\n\nProof.\nintros X A a P H1 Y B b; unfold iff in |- *; apply and_intro.\nintro; apply selection_elim; assumption.\nintro H; apply H; intros; apply selection_intro; assumption.\nQed.", "definition": "\n forall (X : Typ1) (A : Rel X) (a : X) (P : PRED),\n Compat P ->\n forall (Y : Typ1) (B : Rel Y) (b : Y),\n iff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (and (ELT Y B b X A a) (P Y B b)).\n\n", "proof": "\nintros X A a P H1 Y B b; unfold iff in |- *; apply and_intro.\nintro; apply selection_elim; assumption.\nintro H; apply H; intros; apply selection_intro; assumption.\n", "def_ranges": [115, 0, 120, 37], "proof_ranges": [121, 0, 126, 4], "proof_steps": [{"text": "intros X A a P H1 Y B b; unfold iff in |- *; apply and_intro.", "goal_before": ["forall (X : Typ1) (A : Rel X) (a : X) (P : PRED),\nCompat P ->\nforall (Y : Typ1) (B : Rel Y) (b : Y),\niff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n  (and (ELT Y B b X A a) (P Y B b))"], "goal_after": ["ELT Y B b (opt X) (SELECT X A a P) (none X) ->\nand (ELT Y B b X A a) (P Y B b)", "and (ELT Y B b X A a) (P Y B b) ->\nELT Y B b (opt X) (SELECT X A a P) (none X)"], "proof_term_before": [], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (P : PRED) (H1 : Compat P) \n   (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (opt X) (SELECT X A a P) (none X) ->\n    and (ELT Y B b X A a) (P Y B b))\n   (and (ELT Y B b X A a) (P Y B b) ->\n    ELT Y B b (opt X) (SELECT X A a P) (none X)) ?Goal \n   ?Goal0\n :\n iff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (and (ELT Y B b X A a) (P Y B b)))"]}, {"text": "intro; apply selection_elim; assumption.", "goal_before": ["ELT Y B b (opt X) (SELECT X A a P) (none X) ->\nand (ELT Y B b X A a) (P Y B b)", "and (ELT Y B b X A a) (P Y B b) ->\nELT Y B b (opt X) (SELECT X A a P) (none X)"], "goal_after": ["and (ELT Y B b X A a) (P Y B b) ->\nELT Y B b (opt X) (SELECT X A a P) (none X)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (P : PRED) (H1 : Compat P) \n   (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (opt X) (SELECT X A a P) (none X) ->\n    and (ELT Y B b X A a) (P Y B b))\n   (and (ELT Y B b X A a) (P Y B b) ->\n    ELT Y B b (opt X) (SELECT X A a P) (none X)) ?Goal \n   ?Goal0\n :\n iff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (and (ELT Y B b X A a) (P Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (P : PRED) (H1 : Compat P) \n   (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (opt X) (SELECT X A a P) (none X) ->\n    and (ELT Y B b X A a) (P Y B b))\n   (and (ELT Y B b X A a) (P Y B b) ->\n    ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (fun H : ELT Y B b (opt X) (SELECT X A a P) (none X) =>\n    selection_elim X A a P H1 Y B b H) ?Goal\n :\n iff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (and (ELT Y B b X A a) (P Y B b)))"]}, {"text": "intro H; apply H; intros; apply selection_intro; assumption.", "goal_before": ["and (ELT Y B b X A a) (P Y B b) ->\nELT Y B b (opt X) (SELECT X A a P) (none X)"], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (P : PRED) (H1 : Compat P) \n   (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (opt X) (SELECT X A a P) (none X) ->\n    and (ELT Y B b X A a) (P Y B b))\n   (and (ELT Y B b X A a) (P Y B b) ->\n    ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (fun H : ELT Y B b (opt X) (SELECT X A a P) (none X) =>\n    selection_elim X A a P H1 Y B b H) ?Goal\n :\n iff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (and (ELT Y B b X A a) (P Y B b)))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X) (P : PRED) (H1 : Compat P) \n   (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (opt X) (SELECT X A a P) (none X) ->\n    and (ELT Y B b X A a) (P Y B b))\n   (and (ELT Y B b X A a) (P Y B b) ->\n    ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (fun H : ELT Y B b (opt X) (SELECT X A a P) (none X) =>\n    selection_elim X A a P H1 Y B b H)\n   (fun H : and (ELT Y B b X A a) (P Y B b) =>\n    H (ELT Y B b (opt X) (SELECT X A a P) (none X))\n      (fun (H0 : ELT Y B b X A a) (H2 : P Y B b) =>\n       selection_intro X A a P H1 Y B b H0 H2))\n :\n iff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (and (ELT Y B b X A a) (P Y B b)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X) (P : PRED) (H1 : Compat P) \n   (Y : Typ1) (B : Rel Y) (b : Y) =>\n and_intro\n   (ELT Y B b (opt X) (SELECT X A a P) (none X) ->\n    and (ELT Y B b X A a) (P Y B b))\n   (and (ELT Y B b X A a) (P Y B b) ->\n    ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (fun H : ELT Y B b (opt X) (SELECT X A a P) (none X) =>\n    selection_elim X A a P H1 Y B b H)\n   (fun H : and (ELT Y B b X A a) (P Y B b) =>\n    H (ELT Y B b (opt X) (SELECT X A a P) (none X))\n      (fun (H0 : ELT Y B b X A a) (H2 : P Y B b) =>\n       selection_intro X A a P H1 Y B b H0 H2))\n :\n iff (ELT Y B b (opt X) (SELECT X A a P) (none X))\n   (and (ELT Y B b X A a) (P Y B b)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_omega.v", "name": "omega_zero", "text": "Theorem omega_zero : ELT unit ZERO id (opt nat) OMEGA (none nat).\n\nProof.\napply ELT_intro with (some nat O).\nexact (OMEGA_rt O wf_nat_O).\napply EQV_sym; exact OMEGA_ZERO.\nQed.\n", "definition": " ELT unit ZERO id (opt nat) OMEGA (none nat).\n\n", "proof": "\napply ELT_intro with (some nat O).\nexact (OMEGA_rt O wf_nat_O).\napply EQV_sym; exact OMEGA_ZERO.\n", "def_ranges": [330, 0, 330, 65], "proof_ranges": [331, 0, 336, 4], "proof_steps": [{"text": "apply ELT_intro with (some nat O).", "goal_before": ["ELT unit ZERO id (opt nat) OMEGA (none nat)"], "goal_after": ["OMEGA (some nat O) (none nat)", "EQV unit ZERO id (opt nat) OMEGA (some nat O)"], "proof_term_before": [], "proof_term_after": ["(ELT_intro unit ZERO id (opt nat) OMEGA (none nat) (some nat O) ?Goal ?Goal0)"]}, {"text": "exact (OMEGA_rt O wf_nat_O).", "goal_before": ["OMEGA (some nat O) (none nat)", "EQV unit ZERO id (opt nat) OMEGA (some nat O)"], "goal_after": ["EQV unit ZERO id (opt nat) OMEGA (some nat O)"], "proof_term_before": ["(ELT_intro unit ZERO id (opt nat) OMEGA (none nat) (some nat O) ?Goal ?Goal0)"], "proof_term_after": ["(ELT_intro unit ZERO id (opt nat) OMEGA (none nat) \n   (some nat O) (OMEGA_rt O wf_nat_O) ?Goal)"]}, {"text": "apply EQV_sym; exact OMEGA_ZERO.", "goal_before": ["EQV unit ZERO id (opt nat) OMEGA (some nat O)"], "goal_after": [], "proof_term_before": ["(ELT_intro unit ZERO id (opt nat) OMEGA (none nat) \n   (some nat O) (OMEGA_rt O wf_nat_O) ?Goal)"], "proof_term_after": ["(ELT_intro unit ZERO id (opt nat) OMEGA (none nat) \n   (some nat O) (OMEGA_rt O wf_nat_O)\n   (EQV_sym (opt nat) OMEGA (some nat O) unit ZERO id OMEGA_ZERO))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(ELT_intro unit ZERO id (opt nat) OMEGA (none nat) \n   (some nat O) (OMEGA_rt O wf_nat_O)\n   (EQV_sym (opt nat) OMEGA (some nat O) unit ZERO id OMEGA_ZERO))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_omega.v", "name": "omega_succ", "text": "Theorem omega_succ :\n forall (X : Typ1) (A : Rel X) (a : X),\n ELT X A a (opt nat) OMEGA (none nat) ->\n ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat).\n\nProof.\nintros X A a H; apply H; clear H; intros z H H1; apply H; clear H.\n(* Case 1 (absurd) *)\nintros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).\n(* Case 2 *)\nintros n H0 H Hn; apply ELT_intro with (some nat (S n)).\nexact (OMEGA_rt (S n) (wf_nat_S n Hn)).\napply\n EQV_trans\n  with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).\napply SUCC_compat; apply H; assumption.\napply EQV_sym; apply OMEGA_SUCC; assumption.\nQed.\n", "definition": "\n forall (X : Typ1) (A : Rel X) (a : X),\n ELT X A a (opt nat) OMEGA (none nat) ->\n ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat).\n\n", "proof": "\nintros X A a H; apply H; clear H; intros z H H1; apply H; clear H.\n(* Case 1 (absurd) *)\nintros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).\n(* Case 2 *)\nintros n H0 H Hn; apply ELT_intro with (some nat (S n)).\nexact (OMEGA_rt (S n) (wf_nat_S n Hn)).\napply\n EQV_trans\n  with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).\napply SUCC_compat; apply H; assumption.\napply EQV_sym; apply OMEGA_SUCC; assumption.\n", "def_ranges": [340, 0, 343, 62], "proof_ranges": [344, 0, 357, 4], "proof_steps": [{"text": "intros X A a H; apply H; clear H; intros z H H1; apply H; clear H.", "goal_before": ["forall (X : Typ1) (A : Rel X) (a : X),\nELT X A a (opt nat) OMEGA (none nat) ->\nELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)"], "goal_after": ["forall n n' : nat,\neq (opt nat) (none nat) (some nat n) ->\neq (opt nat) z (some nat n') ->\nwf_nat n ->\nwf_nat n' ->\nlt n' n -> ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)", "forall n' : nat,\neq (opt nat) (none nat) (none nat) ->\neq (opt nat) z (some nat n') ->\nwf_nat n' -> ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)"], "proof_term_before": [], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)) \n      ?Goal ?Goal0))"]}, {"text": "intros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).", "goal_before": ["forall n n' : nat,\neq (opt nat) (none nat) (some nat n) ->\neq (opt nat) z (some nat n') ->\nwf_nat n ->\nwf_nat n' ->\nlt n' n -> ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)", "forall n' : nat,\neq (opt nat) (none nat) (none nat) ->\neq (opt nat) z (some nat n') ->\nwf_nat n' -> ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)"], "goal_after": ["forall n' : nat,\neq (opt nat) (none nat) (none nat) ->\neq (opt nat) z (some nat n') ->\nwf_nat n' -> ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)) \n      ?Goal ?Goal0))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      ?Goal))"]}, {"text": "intros n H0 H Hn; apply ELT_intro with (some nat (S n)).", "goal_before": ["forall n' : nat,\neq (opt nat) (none nat) (none nat) ->\neq (opt nat) z (some nat n') ->\nwf_nat n' -> ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)"], "goal_after": ["OMEGA (some nat (S n)) (none nat)", "EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      ?Goal))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) ?Goal@{H0:=H2; H:=H3}\n         ?Goal0@{H0:=H2; H:=H3})))"]}, {"text": "exact (OMEGA_rt (S n) (wf_nat_S n Hn)).", "goal_before": ["OMEGA (some nat (S n)) (none nat)", "EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "goal_after": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) ?Goal@{H0:=H2; H:=H3}\n         ?Goal0@{H0:=H2; H:=H3})))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) (OMEGA_rt (S n) (wf_nat_S n Hn))\n         ?Goal@{H0:=H2; H:=H3})))"]}, {"text": "apply", "goal_before": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "goal_after": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) (OMEGA_rt (S n) (wf_nat_S n Hn))\n         ?Goal@{H0:=H2; H:=H3})))"], "proof_term_after": []}, {"text": "EQV_trans", "goal_before": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "goal_after": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "proof_term_before": [], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) (OMEGA_rt (S n) (wf_nat_S n Hn))\n         ?Goal@{H0:=H2; H:=H3})))"]}, {"text": "with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).", "goal_before": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "goal_after": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) (OMEGA_rt (S n) (wf_nat_S n Hn))\n         ?Goal@{H0:=H2; H:=H3})))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) (OMEGA_rt (S n) (wf_nat_S n Hn))\n         ?Goal@{H0:=H2; H:=H3})))"]}, {"text": "apply SUCC_compat; apply H; assumption.", "goal_before": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "goal_after": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) (OMEGA_rt (S n) (wf_nat_S n Hn))\n         ?Goal@{H0:=H2; H:=H3})))"], "proof_term_after": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) (OMEGA_rt (S n) (wf_nat_S n Hn))\n         ?Goal@{H0:=H2; H:=H3})))"]}, {"text": "apply EQV_sym; apply OMEGA_SUCC; assumption.", "goal_before": ["EQV (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (some nat (S n))"], "goal_after": [], "proof_term_before": ["(fun (X : Typ1) (A : Rel X) (a : X)\n   (H : ELT X A a (opt nat) OMEGA (none nat)) =>\n H (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat))\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) =>\n       eq_none_some nat n H2\n         (ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat)))\n      (fun (n : nat) (H2 : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       ELT_intro (opt X) (SUCC X A a) (none X) (opt nat) OMEGA \n         (none nat) (some nat (S n)) (OMEGA_rt (S n) (wf_nat_S n Hn))\n         ?Goal@{H0:=H2; H:=H3})))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/izf/IZF_omega.v", "name": "omega_ind", "text": "Theorem omega_ind\n :\n (* If P is a compatible predicate such that: *)\n forall P : PRED,\n Compat P ->\n (* 1. P holds for zero *)\n P unit ZERO id ->\n (* 2. If P holds for an element of omega, then\n         P holds for the successor of this element *)\n (forall (X : Typ1) (A : Rel X) (a : X),\n  ELT X A a (opt nat) OMEGA (none nat) ->\n  P X A a -> P (opt X) (SUCC X A a) (none X)) ->\n (* Then: P holds for any element of omega *)\n forall (X : Typ1) (A : Rel X) (a : X),\n ELT X A a (opt nat) OMEGA (none nat) -> P X A a.\n\nProof.\nintros P HP HO HS X A a H; apply H; clear H.\nintros z H H1; apply H; clear H.\n(* Case 1 (absurd) *)\nintros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).\n(* Case 2 *)\nintros n H0 H Hn; clear H0.\napply (HP _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H1)).\napply (eq_sym _ _ _ H); clear H H1 a A X z.\n(* Perform induction on n:nat *)\napply (nat_ind' n Hn); clear Hn n.\n(* Basic case *)\napply HP with unit ZERO id.\napply EQV_sym; exact OMEGA_ZERO. assumption.\n(* Inductive case *)\nintros n Hn Hind.\napply\n HP with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).\napply EQV_sym; apply OMEGA_SUCC; assumption.\napply HS. apply ELT_direct; apply OMEGA_rt; assumption.\nassumption.\nQed.\n", "definition": "\n (* If P is a compatible predicate such that: *)\n forall P : PRED,\n Compat P ->\n (* 1. P holds for zero *)\n P unit ZERO id ->\n (* 2. If P holds for an element of omega, then\n         P holds for the successor of this element *)\n (forall (X : Typ1) (A : Rel X) (a : X),\n  ELT X A a (opt nat) OMEGA (none nat) ->\n  P X A a -> P (opt X) (SUCC X A a) (none X)) ->\n (* Then: P holds for any element of omega *)\n forall (X : Typ1) (A : Rel X) (a : X),\n ELT X A a (opt nat) OMEGA (none nat) -> P X A a.\n\n", "proof": "\nintros P HP HO HS X A a H; apply H; clear H.\nintros z H H1; apply H; clear H.\n(* Case 1 (absurd) *)\nintros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).\n(* Case 2 *)\nintros n H0 H Hn; clear H0.\napply (HP _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H1)).\napply (eq_sym _ _ _ H); clear H H1 a A X z.\n(* Perform induction on n:nat *)\napply (nat_ind' n Hn); clear Hn n.\n(* Basic case *)\napply HP with unit ZERO id.\napply EQV_sym; exact OMEGA_ZERO. assumption.\n(* Inductive case *)\nintros n Hn Hind.\napply\n HP with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).\napply EQV_sym; apply OMEGA_SUCC; assumption.\napply HS. apply ELT_direct; apply OMEGA_rt; assumption.\nassumption.\n", "def_ranges": [363, 0, 377, 49], "proof_ranges": [378, 0, 400, 4], "proof_steps": [{"text": "intros P HP HO HS X A a H; apply H; clear H.", "goal_before": [], "goal_after": ["forall P : PRED,\nCompat P ->\nP unit ZERO id ->\n(forall (X : Typ1) (A : Rel X) (a : X),\n ELT X A a (opt nat) OMEGA (none nat) ->\n P X A a -> P (opt X) (SUCC X A a) (none X)) ->\nforall (X : Typ1) (A : Rel X) (a : X),\nELT X A a (opt nat) OMEGA (none nat) -> P X A a"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros z H H1; apply H; clear H.", "goal_before": ["forall P : PRED,\nCompat P ->\nP unit ZERO id ->\n(forall (X : Typ1) (A : Rel X) (a : X),\n ELT X A a (opt nat) OMEGA (none nat) ->\n P X A a -> P (opt X) (SUCC X A a) (none X)) ->\nforall (X : Typ1) (A : Rel X) (a : X),\nELT X A a (opt nat) OMEGA (none nat) -> P X A a"], "goal_after": ["forall b' : opt nat,\nOMEGA b' (none nat) -> EQV X A a (opt nat) OMEGA b' -> P X A a"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n => H (P X A a) ?Goal)"]}, {"text": "intros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).", "goal_before": ["forall b' : opt nat,\nOMEGA b' (none nat) -> EQV X A a (opt nat) OMEGA b' -> P X A a"], "goal_after": ["forall n n' : nat,\neq (opt nat) (none nat) (some nat n) ->\neq (opt nat) z (some nat n') -> wf_nat n -> wf_nat n' -> lt n' n -> P X A a", "forall n' : nat,\neq (opt nat) (none nat) (none nat) ->\neq (opt nat) z (some nat n') -> wf_nat n' -> P X A a"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n => H (P X A a) ?Goal)"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) => H0 (P X A a) ?Goal ?Goal0))"]}, {"text": "intros n H0 H Hn; clear H0.", "goal_before": ["forall n n' : nat,\neq (opt nat) (none nat) (some nat n) ->\neq (opt nat) z (some nat n') -> wf_nat n -> wf_nat n' -> lt n' n -> P X A a", "forall n' : nat,\neq (opt nat) (none nat) (none nat) ->\neq (opt nat) z (some nat n') -> wf_nat n' -> P X A a"], "goal_after": ["forall n' : nat,\neq (opt nat) (none nat) (none nat) ->\neq (opt nat) z (some nat n') -> wf_nat n' -> P X A a"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) => H0 (P X A a) ?Goal ?Goal0))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      ?Goal))"]}, {"text": "apply (HP _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H1)).", "goal_before": ["forall n' : nat,\neq (opt nat) (none nat) (none nat) ->\neq (opt nat) z (some nat n') -> wf_nat n' -> P X A a"], "goal_after": ["P X A a"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      ?Goal))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) => \n       ?Goal@{H:=H3})))"]}, {"text": "apply (eq_sym _ _ _ H); clear H H1 a A X z.", "goal_before": ["P X A a"], "goal_after": ["P (opt nat) OMEGA z"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) => \n       ?Goal@{H:=H3})))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         ?Goal@{H:=H3})))"]}, {"text": "apply (nat_ind' n Hn); clear Hn n.", "goal_before": ["P (opt nat) OMEGA z"], "goal_after": ["P (opt nat) OMEGA (some nat n)"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         ?Goal@{H:=H3})))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0) \n            ?Goal))))"]}, {"text": "apply HP with unit ZERO id.", "goal_before": ["P (opt nat) OMEGA (some nat n)"], "goal_after": ["P (opt nat) OMEGA (some nat O)", "forall p : nat,\nwf_nat p ->\nP (opt nat) OMEGA (some nat p) -> P (opt nat) OMEGA (some nat (S p))"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0) \n            ?Goal))))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               ?Goal ?Goal0)))))"]}, {"text": "apply EQV_sym; exact OMEGA_ZERO.", "goal_before": ["P (opt nat) OMEGA (some nat O)", "forall p : nat,\nwf_nat p ->\nP (opt nat) OMEGA (some nat p) -> P (opt nat) OMEGA (some nat (S p))"], "goal_after": ["EQV unit ZERO id (opt nat) OMEGA (some nat O)", "P unit ZERO id", "forall p : nat,\nwf_nat p ->\nP (opt nat) OMEGA (some nat p) -> P (opt nat) OMEGA (some nat (S p))"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               ?Goal ?Goal0)))))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               (HP unit ZERO id (opt nat) OMEGA (some nat O) ?Goal0 ?Goal1)\n               ?Goal)))))"]}, {"text": "assumption.", "goal_before": ["EQV unit ZERO id (opt nat) OMEGA (some nat O)", "P unit ZERO id", "forall p : nat,\nwf_nat p ->\nP (opt nat) OMEGA (some nat p) -> P (opt nat) OMEGA (some nat (S p))"], "goal_after": ["P unit ZERO id", "forall p : nat,\nwf_nat p ->\nP (opt nat) OMEGA (some nat p) -> P (opt nat) OMEGA (some nat (S p))"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               (HP unit ZERO id (opt nat) OMEGA (some nat O) ?Goal0 ?Goal1)\n               ?Goal)))))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               (HP unit ZERO id (opt nat) OMEGA (some nat O)\n                  (EQV_sym (opt nat) OMEGA (some nat O) unit ZERO id\n                     OMEGA_ZERO) ?Goal0) ?Goal)))))"]}, {"text": "intros n Hn Hind.", "goal_before": ["P unit ZERO id", "forall p : nat,\nwf_nat p ->\nP (opt nat) OMEGA (some nat p) -> P (opt nat) OMEGA (some nat (S p))"], "goal_after": ["forall p : nat,\nwf_nat p ->\nP (opt nat) OMEGA (some nat p) -> P (opt nat) OMEGA (some nat (S p))"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               (HP unit ZERO id (opt nat) OMEGA (some nat O)\n                  (EQV_sym (opt nat) OMEGA (some nat O) unit ZERO id\n                     OMEGA_ZERO) ?Goal0) ?Goal)))))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               (HP unit ZERO id (opt nat) OMEGA (some nat O)\n                  (EQV_sym (opt nat) OMEGA (some nat O) unit ZERO id\n                     OMEGA_ZERO) HO) ?Goal)))))"]}, {"text": "apply", "goal_before": ["forall p : nat,\nwf_nat p ->\nP (opt nat) OMEGA (some nat p) -> P (opt nat) OMEGA (some nat (S p))"], "goal_after": ["P (opt nat) OMEGA (some nat (S n))"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               (HP unit ZERO id (opt nat) OMEGA (some nat O)\n                  (EQV_sym (opt nat) OMEGA (some nat O) unit ZERO id\n                     OMEGA_ZERO) HO) ?Goal)))))"], "proof_term_after": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               (HP unit ZERO id (opt nat) OMEGA (some nat O)\n                  (EQV_sym (opt nat) OMEGA (some nat O) unit ZERO id\n                     OMEGA_ZERO) HO)\n               (fun (n0 : nat) (Hn0 : wf_nat n0)\n                  (Hind : P (opt nat) OMEGA (some nat n0)) =>\n                ?Goal@{n:=n0; Hn:=Hn0}))))))"]}, {"text": "HP with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).", "goal_before": ["P (opt nat) OMEGA (some nat (S n))"], "goal_after": ["P (opt nat) OMEGA (some nat (S n))"], "proof_term_before": ["(fun (P : PRED) (HP : Compat P) (HO : P unit ZERO id)\n   (HS : forall (X : Typ1) (A : Rel X) (a : X),\n         ELT X A a (opt nat) OMEGA (none nat) ->\n         P X A a -> P (opt X) (SUCC X A a) (none X)) \n   (X : Typ1) (A : Rel X) (a : X) (H : ELT X A a (opt nat) OMEGA (none nat))\n =>\n H (P X A a)\n   (fun (z : opt nat) (H0 : OMEGA z (none nat))\n      (H1 : EQV X A a (opt nat) OMEGA z) =>\n    H0 (P X A a)\n      (fun (n m : nat) (H2 : eq (opt nat) (none nat) (some nat n))\n         (_ : eq (opt nat) z (some nat m)) (_ : wf_nat n) \n         (_ : wf_nat m) (_ : lt m n) => eq_none_some nat n H2 (P X A a))\n      (fun (n : nat) (_ : eq (opt nat) (none nat) (none nat))\n         (H3 : eq (opt nat) z (some nat n)) (Hn : wf_nat n) =>\n       HP (opt nat) OMEGA z X A a (EQV_sym X A a (opt nat) OMEGA z H1)\n         (eq_sym (opt nat) z (some nat n) H3\n            (fun z0 : opt nat => P (opt nat) OMEGA z0)\n            (nat_ind' n Hn (fun n0 : nat => P (opt nat) OMEGA (some nat n0))\n               (HP unit ZERO id (opt nat) OMEGA (some nat O)\n                  (EQV_sym (opt nat) OMEGA (some nat O) unit ZERO id\n                     OMEGA_ZERO) HO)\n               (fun (n0 : nat) (Hn0 : wf_nat n0)\n                  (Hind : P (opt nat) OMEGA (some nat n0)) =>\n                ?Goal@{n:=n0; Hn:=Hn0}))))))"], "proof_term_after": []}, {"text": "apply EQV_sym; apply OMEGA_SUCC; assumption.", "goal_before": ["P (opt nat) OMEGA (some nat (S n))"], "goal_after": ["P (opt nat) OMEGA (some nat (S n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply HS.", "goal_before": ["P (opt nat) OMEGA (some nat (S n))"], "goal_after": ["P (opt nat) OMEGA (some nat (S n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ELT_direct; apply OMEGA_rt; assumption.", "goal_before": ["P (opt nat) OMEGA (some nat (S n))"], "goal_after": ["P (opt nat) OMEGA (some nat (S n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": ["P (opt nat) OMEGA (some nat (S n))"], "goal_after": ["P (opt nat) OMEGA (some nat (S n))"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": ["P (opt nat) OMEGA (some nat (S n))"], "goal_after": ["P (opt nat) OMEGA (some nat (S n))"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "Ex_Wallen", "text": "Theorem Ex_Wallen : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n", "definition": " (A -> B /\\ C) -> (A -> B) \\/ (A -> C).", "proof": "\ntauto.\n", "def_ranges": [33, 0, 33, 58], "proof_ranges": [34, 0, 35, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(A -> B /\\ C) -> (A -> B) \\/ (A -> C)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun H : A -> B /\\ C =>\n or_introl\n   (fun H0 : A =>\n    let H1 : B /\\ C := H H0 in and_ind (fun (H2 : B) (_ : C) => H2) H1))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun H : A -> B /\\ C =>\n or_introl\n   (fun H0 : A =>\n    let H1 : B /\\ C := H H0 in and_ind (fun (H2 : B) (_ : C) => H2) H1))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "Ex_Klenne", "text": "Theorem Ex_Klenne : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n", "definition": " ~ ~ (A \\/ ~ A).", "proof": "\ntauto.\n", "def_ranges": [37, 0, 37, 35], "proof_ranges": [38, 0, 39, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["~ ~ (A \\/ ~ A)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun H : ~ (A \\/ ~ A) =>\n  let H0 : A -> False := fun H0 : A => H (or_introl H0) in\n  let H1 : ~ A -> False := fun H1 : ~ A => H (or_intror H1) in\n  let H2 : False := H1 H0 in False_ind False H2)\n :\n ~ ~ (A \\/ ~ A))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun H : ~ (A \\/ ~ A) =>\n  let H0 : A -> False := fun H0 : A => H (or_introl H0) in\n  let H1 : ~ A -> False := fun H1 : ~ A => H (or_intror H1) in\n  let H2 : False := H1 H0 in False_ind False H2)\n :\n ~ ~ (A \\/ ~ A))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "Ex_Klenne'", "text": "Theorem Ex_Klenne' : forall n : nat, ~ ~ (even n \\/ ~ even n).\nintro.\ntauto.\nQed.\n", "definition": " forall n : nat, ~ ~ (even n \\/ ~ even n).", "proof": "\nintro.\ntauto.\n", "def_ranges": [42, 0, 42, 62], "proof_ranges": [43, 0, 45, 4], "proof_steps": [{"text": "intro.", "goal_before": ["forall n : nat, ~ ~ (even n \\/ ~ even n)"], "goal_after": ["~ ~ (even n \\/ ~ even n)"], "proof_term_before": [], "proof_term_after": ["(fun n : nat => ?Goal)"]}, {"text": "tauto.", "goal_before": ["~ ~ (even n \\/ ~ even n)"], "goal_after": [], "proof_term_before": ["(fun n : nat => ?Goal)"], "proof_term_after": ["(fun n : nat =>\n (fun H : ~ (even n \\/ ~ even n) =>\n  let H0 : even n -> False := fun H0 : even n => H (or_introl H0) in\n  let H1 : ~ even n -> False := fun H1 : ~ even n => H (or_intror H1) in\n  let H2 : False := H1 H0 in False_ind False H2)\n :\n ~ ~ (even n \\/ ~ even n))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n (fun H : ~ (even n \\/ ~ even n) =>\n  let H0 : even n -> False := fun H0 : even n => H (or_introl H0) in\n  let H1 : ~ even n -> False := fun H1 : ~ even n => H (or_intror H1) in\n  let H2 : False := H1 H0 in False_ind False H2)\n :\n ~ ~ (even n \\/ ~ even n))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "Ex_Klenne''", "text": "Theorem Ex_Klenne'' :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).\ntauto.\nQed.\n", "definition": "\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)).", "proof": "\ntauto.\n", "def_ranges": [48, 0, 49, 62], "proof_ranges": [50, 0, 51, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m))"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun H : ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)) =>\n  let H0 : (forall n : nat, even n) -> False :=\n    fun H0 : forall n : nat, even n => H (or_introl H0) in\n  let H1 : ~ (forall m : nat, even m) -> False :=\n    fun H1 : ~ (forall m : nat, even m) => H (or_intror H1) in\n  let H2 : False := H1 H0 in False_ind False H2)\n :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun H : ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)) =>\n  let H0 : (forall n : nat, even n) -> False :=\n    fun H0 : forall n : nat, even n => H (or_introl H0) in\n  let H1 : ~ (forall m : nat, even m) -> False :=\n    fun H1 : ~ (forall m : nat, even m) => H (or_intror H1) in\n  let H2 : False := H1 H0 in False_ind False H2)\n :\n ~ ~ ((forall n : nat, even n) \\/ ~ (forall m : nat, even m)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "Intu", "text": "Theorem Intu :\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.\nintuition.\nQed.\n", "definition": "\n (forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0.", "proof": "\nintuition.\n", "def_ranges": [56, 0, 57, 72], "proof_ranges": [58, 0, 59, 4], "proof_steps": [{"text": "intuition.", "goal_before": ["(forall x : nat, P x) /\\ B -> (forall y : nat, P y) /\\ P 0 \\/ B /\\ P 0"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun H : (forall x : nat, P x) /\\ B =>\n and_ind\n   (fun (H0 : forall x : nat, P x) (_ : B) =>\n    or_introl (conj H0 (H0 0 : P 0))) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun H : (forall x : nat, P x) /\\ B =>\n and_ind\n   (fun (H0 : forall x : nat, P x) (_ : B) =>\n    or_introl (conj H0 (H0 0 : P 0))) H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "tauto", "text": "Theorem tauto : (forall x : nat, P x) -> forall y : nat, P y.\ntauto.\nQed.\n", "definition": " (forall x : nat, P x) -> forall y : nat, P y.", "proof": "\ntauto.\n", "def_ranges": [90, 0, 90, 61], "proof_ranges": [91, 0, 92, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(forall x : nat, P x) -> forall y : nat, P y"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun H : forall x : nat, P x => H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun H : forall x : nat, P x => H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "tauto1", "text": "Theorem tauto1 : A -> A.\ntauto.\nQed.\n", "definition": " A -> A.", "proof": "\ntauto.\n", "def_ranges": [94, 0, 94, 24], "proof_ranges": [95, 0, 96, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["A -> A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun H : A => H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun H : A => H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "tauto2", "text": "Theorem tauto2 : (A -> B -> C) -> (A -> B) -> A -> C.\ntauto.\nQed.\n", "definition": " (A -> B -> C) -> (A -> B) -> A -> C.", "proof": "\ntauto.\n", "def_ranges": [98, 0, 98, 53], "proof_ranges": [99, 0, 100, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(A -> B -> C) -> (A -> B) -> A -> C"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (H : A -> B -> C) (H0 : A -> B) (H1 : A) =>\n let H2 : B -> C := H H1 in let H3 : B := H0 H1 in let H4 : C := H2 H3 in H4)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (H : A -> B -> C) (H0 : A -> B) (H1 : A) =>\n let H2 : B -> C := H H1 in let H3 : B := H0 H1 in let H4 : C := H2 H3 in H4)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "a", "text": "Theorem a : forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.\ntauto.\nQed.\n", "definition": " forall (x0 : A \\/ B) (x1 : B /\\ C), A -> B.", "proof": "\ntauto.\n", "def_ranges": [102, 0, 102, 55], "proof_ranges": [103, 0, 104, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["A \\/ B -> B /\\ C -> A -> B"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x0 : A \\/ B) (x1 : B /\\ C) (_ : A) =>\n and_ind\n   (fun (H0 : B) (_ : C) => or_ind (fun _ : A => H0) (fun H2 : B => H2) x0)\n   x1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x0 : A \\/ B) (x1 : B /\\ C) (_ : A) =>\n and_ind\n   (fun (H0 : B) (_ : C) => or_ind (fun _ : A => H0) (fun H2 : B => H2) x0)\n   x1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "a2", "text": "Theorem a2 : (A -> B /\\ C) -> (A -> B) \\/ (A -> C).\ntauto.\nQed.\n", "definition": " (A -> B /\\ C) -> (A -> B) \\/ (A -> C).", "proof": "\ntauto.\n", "def_ranges": [106, 0, 106, 51], "proof_ranges": [107, 0, 108, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(A -> B /\\ C) -> (A -> B) \\/ (A -> C)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun H : A -> B /\\ C =>\n or_introl\n   (fun H0 : A =>\n    let H1 : B /\\ C := H H0 in and_ind (fun (H2 : B) (_ : C) => H2) H1))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun H : A -> B /\\ C =>\n or_introl\n   (fun H0 : A =>\n    let H1 : B /\\ C := H H0 in and_ind (fun (H2 : B) (_ : C) => H2) H1))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "a4", "text": "Theorem a4 : ~ A -> ~ A.\ntauto.\nQed.\n", "definition": " ~ A -> ~ A.", "proof": "\ntauto.\n", "def_ranges": [110, 0, 110, 24], "proof_ranges": [111, 0, 112, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["~ A -> ~ A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun H : ~ A =>\n (fun H0 : A => let H1 : False := H H0 in False_ind False H1) : ~ A)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun H : ~ A =>\n (fun H0 : A => let H1 : False := H H0 in False_ind False H1) : ~ A)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "e2", "text": "Theorem e2 : ~ ~ (A \\/ ~ A).\ntauto.\nQed.\n", "definition": " ~ ~ (A \\/ ~ A).", "proof": "\ntauto.\n", "def_ranges": [114, 0, 114, 28], "proof_ranges": [115, 0, 116, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["~ ~ (A \\/ ~ A)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun H : ~ (A \\/ ~ A) =>\n  let H0 : A -> False := fun H0 : A => H (or_introl H0) in\n  let H1 : ~ A -> False := fun H1 : ~ A => H (or_intror H1) in\n  let H2 : False := H1 H0 in False_ind False H2)\n :\n ~ ~ (A \\/ ~ A))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun H : ~ (A \\/ ~ A) =>\n  let H0 : A -> False := fun H0 : A => H (or_introl H0) in\n  let H1 : ~ A -> False := fun H1 : ~ A => H (or_intror H1) in\n  let H2 : False := H1 H0 in False_ind False H2)\n :\n ~ ~ (A \\/ ~ A))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "e4", "text": "Theorem e4 : ~ ~ (A \\/ B -> A \\/ B).\ntauto.\nQed.\n", "definition": " ~ ~ (A \\/ B -> A \\/ B).", "proof": "\ntauto.\n", "def_ranges": [118, 0, 118, 36], "proof_ranges": [119, 0, 120, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["~ ~ (A \\/ B -> A \\/ B)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun H : ~ (A \\/ B -> A \\/ B) =>\n  let H0 : False :=\n    let H0 : A \\/ B -> A \\/ B :=\n      (fun (H0 : A \\/ B -> False) (H1 : A \\/ B) =>\n       or_ind\n         (fun H2 : A =>\n          let H3 : A -> False := fun H3 : A => H0 (or_introl H3) in\n          let H4 : B -> False := fun H4 : B => H0 (or_intror H4) in\n          let H5 : False := H3 H2 in False_ind (A \\/ B) H5)\n         (fun H2 : B =>\n          let H3 : A -> False := fun H3 : A => H0 (or_introl H3) in\n          let H4 : B -> False := fun H4 : B => H0 (or_intror H4) in\n          let H5 : False := H4 H2 in False_ind (A \\/ B) H5) H1)\n        (fun y : A \\/ B => H (fun _ : A \\/ B => y)) in\n    H H0 in\n  (fun H1 : False => False_ind False H1) H0)\n :\n ~ ~ (A \\/ B -> A \\/ B))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun H : ~ (A \\/ B -> A \\/ B) =>\n  let H0 : False :=\n    let H0 : A \\/ B -> A \\/ B :=\n      (fun (H0 : A \\/ B -> False) (H1 : A \\/ B) =>\n       or_ind\n         (fun H2 : A =>\n          let H3 : A -> False := fun H3 : A => H0 (or_introl H3) in\n          let H4 : B -> False := fun H4 : B => H0 (or_intror H4) in\n          let H5 : False := H3 H2 in False_ind (A \\/ B) H5)\n         (fun H2 : B =>\n          let H3 : A -> False := fun H3 : A => H0 (or_introl H3) in\n          let H4 : B -> False := fun H4 : B => H0 (or_intror H4) in\n          let H5 : False := H4 H2 in False_ind (A \\/ B) H5) H1)\n        (fun y : A \\/ B => H (fun _ : A \\/ B => y)) in\n    H H0 in\n  (fun H1 : False => False_ind False H1) H0)\n :\n ~ ~ (A \\/ B -> A \\/ B))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y0", "text": "Theorem y0 :\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.\ntauto.\nQed.\n", "definition": "\n forall (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B),\n A -> False.", "proof": "\ntauto.\n", "def_ranges": [122, 0, 124, 12], "proof_ranges": [125, 0, 126, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["A -> ~ A -> (A -> B) -> A \\/ B -> A /\\ B -> A -> False"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B) (_ : A) =>\n and_ind\n   (fun (_ : A) (_ : B) =>\n    or_ind\n      (fun _ : A =>\n       let H3 : False := x1 x0 in let H4 : B := x2 x0 in False_ind False H3)\n      (fun _ : B =>\n       let H3 : False := x1 x0 in let H4 : B := x2 x0 in False_ind False H3)\n      x3) x4)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x0 : A) (x1 : ~ A) (x2 : A -> B) (x3 : A \\/ B) (x4 : A /\\ B) (_ : A) =>\n and_ind\n   (fun (_ : A) (_ : B) =>\n    or_ind\n      (fun _ : A =>\n       let H3 : False := x1 x0 in let H4 : B := x2 x0 in False_ind False H3)\n      (fun _ : B =>\n       let H3 : False := x1 x0 in let H4 : B := x2 x0 in False_ind False H3)\n      x3) x4)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y1", "text": "Theorem y1 : forall x0 : (A /\\ B) /\\ C, B.\ntauto.\nQed.\n", "definition": " forall x0 : (A /\\ B) /\\ C, B.", "proof": "\ntauto.\n", "def_ranges": [128, 0, 128, 42], "proof_ranges": [129, 0, 130, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(A /\\ B) /\\ C -> B"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun x0 : (A /\\ B) /\\ C =>\n and_ind (fun (H : A /\\ B) (_ : C) => and_ind (fun (_ : A) (H2 : B) => H2) H)\n   x0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x0 : (A /\\ B) /\\ C =>\n and_ind (fun (H : A /\\ B) (_ : C) => and_ind (fun (_ : A) (H2 : B) => H2) H)\n   x0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y2", "text": "Theorem y2 : forall (x0 : A) (x1 : B), C \\/ B.\ntauto.\nQed.\n", "definition": " forall (x0 : A) (x1 : B), C \\/ B.", "proof": "\ntauto.\n", "def_ranges": [132, 0, 132, 46], "proof_ranges": [133, 0, 134, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["A -> B -> C \\/ B"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (_ : A) (x1 : B) => or_intror x1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (_ : A) (x1 : B) => or_intror x1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y3", "text": "Theorem y3 : forall x0 : A /\\ B, B /\\ A.\ntauto.\nQed.\n", "definition": " forall x0 : A /\\ B, B /\\ A.", "proof": "\ntauto.\n", "def_ranges": [136, 0, 136, 40], "proof_ranges": [137, 0, 138, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["A /\\ B -> B /\\ A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun x0 : A /\\ B => and_ind (fun (H : A) (H0 : B) => conj H0 H) x0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x0 : A /\\ B => and_ind (fun (H : A) (H0 : B) => conj H0 H) x0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y5", "text": "Theorem y5 : forall x0 : A \\/ B, B \\/ A.\ntauto.\nQed.\n", "definition": " forall x0 : A \\/ B, B \\/ A.", "proof": "\ntauto.\n", "def_ranges": [140, 0, 140, 40], "proof_ranges": [141, 0, 142, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["A \\/ B -> B \\/ A"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun x0 : A \\/ B =>\n or_ind (fun H : A => or_intror H) (fun H : B => or_introl H) x0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x0 : A \\/ B =>\n or_ind (fun H : A => or_intror H) (fun H : B => or_introl H) x0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y6", "text": "Theorem y6 : forall (x0 : A -> B) (x1 : A), B.\ntauto.\nQed.\n", "definition": " forall (x0 : A -> B) (x1 : A), B.", "proof": "\ntauto.\n", "def_ranges": [144, 0, 144, 46], "proof_ranges": [145, 0, 146, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(A -> B) -> A -> B"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x0 : A -> B) (x1 : A) => let H : B := x0 x1 in H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x0 : A -> B) (x1 : A) => let H : B := x0 x1 in H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y7", "text": "Theorem y7 : forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.\ntauto.\nQed.\n", "definition": " forall (x0 : A /\\ B -> C) (x1 : B) (x2 : A), C.", "proof": "\ntauto.\n", "def_ranges": [148, 0, 148, 60], "proof_ranges": [149, 0, 150, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(A /\\ B -> C) -> B -> A -> C"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x0 : A /\\ B -> C) (x1 : B) (x2 : A) =>\n let H : A -> B -> C := fun (H : A) (H0 : B) => x0 (conj H H0) in\n let H0 : B -> C := H x2 in let H1 : C := H0 x1 in H1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x0 : A /\\ B -> C) (x1 : B) (x2 : A) =>\n let H : A -> B -> C := fun (H : A) (H0 : B) => x0 (conj H H0) in\n let H0 : B -> C := H x2 in let H1 : C := H0 x1 in H1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y8", "text": "Theorem y8 : forall (x0 : A \\/ B -> C) (x1 : A), C.\ntauto.\nQed.\n", "definition": " forall (x0 : A \\/ B -> C) (x1 : A), C.", "proof": "\ntauto.\n", "def_ranges": [152, 0, 152, 51], "proof_ranges": [153, 0, 154, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(A \\/ B -> C) -> A -> C"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x0 : A \\/ B -> C) (x1 : A) =>\n let H : A -> C := fun H : A => x0 (or_introl H) in\n let H0 : B -> C := fun H0 : B => x0 (or_intror H0) in\n let H1 : C := H x1 in H1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x0 : A \\/ B -> C) (x1 : A) =>\n let H : A -> C := fun H : A => x0 (or_introl H) in\n let H0 : B -> C := fun H0 : B => x0 (or_intror H0) in\n let H1 : C := H x1 in H1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y9", "text": "Theorem y9 : forall (x0 : A \\/ B -> C) (x1 : B), C.\ntauto.\nQed.\n", "definition": " forall (x0 : A \\/ B -> C) (x1 : B), C.", "proof": "\ntauto.\n", "def_ranges": [156, 0, 156, 51], "proof_ranges": [157, 0, 158, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["(A \\/ B -> C) -> B -> C"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x0 : A \\/ B -> C) (x1 : B) =>\n let H : A -> C := fun H : A => x0 (or_introl H) in\n let H0 : B -> C := fun H0 : B => x0 (or_intror H0) in\n let H1 : C := H0 x1 in H1)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x0 : A \\/ B -> C) (x1 : B) =>\n let H : A -> C := fun H : A => x0 (or_introl H) in\n let H0 : B -> C := fun H0 : B => x0 (or_intror H0) in\n let H1 : C := H0 x1 in H1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Demo_tauto.v", "name": "y10", "text": "Theorem y10 : forall (x0 : (A -> B) -> C) (x1 : B), C.\ntauto.\nQed.\n", "definition": " forall (x0 : (A -> B) -> C) (x1 : B), C.", "proof": "\ntauto.\n", "def_ranges": [160, 0, 160, 54], "proof_ranges": [161, 0, 162, 4], "proof_steps": [{"text": "tauto.", "goal_before": ["((A -> B) -> C) -> B -> C"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x0 : (A -> B) -> C) (x1 : B) =>\n let H : C :=\n   let H : A -> B :=\n     (fun (H : B -> C) (_ : A) => let H1 : C := H x1 in x1)\n       (fun y : B => x0 (fun _ : A => y)) in\n   x0 H in\n (fun H0 : C => H0) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x0 : (A -> B) -> C) (x1 : B) =>\n let H : C :=\n   let H : A -> B :=\n     (fun (H : B -> C) (_ : A) => let H1 : C := H x1 in x1)\n       (fun y : B => x0 (fun _ : A => y)) in\n   x0 H in\n (fun H0 : C => H0) H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "diff_true_false", "text": "Theorem diff_true_false : true <> false.\nProof.\ndiscriminate.\nQed.\n", "definition": " true <> false.\n", "proof": "\ndiscriminate.\n", "def_ranges": [164, 0, 164, 40], "proof_ranges": [165, 0, 167, 4], "proof_steps": [{"text": "discriminate.", "goal_before": ["true <> false"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun H : true = false =>\n  let H0 : False :=\n    eq_ind true (fun e : bool => if e then True else False) I false H in\n  False_ind False H0)\n :\n true <> false)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun H : true = false =>\n  let H0 : False :=\n    eq_ind true (fun e : bool => if e then True else False) I false H in\n  False_ind False H0)\n :\n true <> false)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "si_intro", "text": "Theorem si_intro :\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\nProof.\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\nQed.\n", "definition": "\n forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n (b = true :>bool -> P x) -> (b = false :>bool -> P y) -> P (si X b x y).\n", "proof": "\nsimple induction b.\n\n intros.\n rewrite si_eq1.\n apply H.\n trivial.\n\n intros.\n rewrite si_eq2.\n apply H0.\n trivial.\n\n", "def_ranges": [170, 0, 172, 73], "proof_ranges": [173, 0, 186, 4], "proof_steps": [{"text": "simple induction b.", "goal_before": ["forall (X : Set) (P : X -> Prop) (x y : X) (b : bool),\n(b = true -> P x) -> (b = false -> P y) -> P (si X b x y)"], "goal_after": ["(true = true -> P x) -> (true = false -> P y) -> P (si X true x y)", "(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "proof_term_before": [], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y)) \n   ?Goal ?Goal0 b)"]}, {"text": "intros.", "goal_before": ["(true = true -> P x) -> (true = false -> P y) -> P (si X true x y)", "(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "goal_after": ["P (si X true x y)", "(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y)) \n   ?Goal ?Goal0 b)"], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (H0 : true = false -> P y) => ?Goal0) \n   ?Goal b)"]}, {"text": "rewrite si_eq1.", "goal_before": ["P (si X true x y)", "(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "goal_after": ["P x", "(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (H0 : true = false -> P y) => ?Goal0) \n   ?Goal b)"], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (H0 : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) ?Goal0 (si_eq1 X x y)) \n   ?Goal b)"]}, {"text": "apply H.", "goal_before": ["P x", "(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "goal_after": ["true = true", "(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (H0 : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) ?Goal0 (si_eq1 X x y)) \n   ?Goal b)"], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (H0 : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H ?Goal0) (si_eq1 X x y)) \n   ?Goal b)"]}, {"text": "trivial.", "goal_before": ["true = true", "(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "goal_after": ["(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (H0 : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H ?Goal0) (si_eq1 X x y)) \n   ?Goal b)"], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y)) \n   ?Goal b)"]}, {"text": "intros.", "goal_before": ["(false = true -> P x) -> (false = false -> P y) -> P (si X false x y)"], "goal_after": ["P (si X false x y)"], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y)) \n   ?Goal b)"], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y))\n   (fun (H : false = true -> P x) (H0 : false = false -> P y) => ?Goal) b)"]}, {"text": "rewrite si_eq2.", "goal_before": ["P (si X false x y)"], "goal_after": ["P y"], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y))\n   (fun (H : false = true -> P x) (H0 : false = false -> P y) => ?Goal) b)"], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y))\n   (fun (H : false = true -> P x) (H0 : false = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) ?Goal (si_eq2 X x y)) b)"]}, {"text": "apply H0.", "goal_before": ["P y"], "goal_after": ["false = false"], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y))\n   (fun (H : false = true -> P x) (H0 : false = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) ?Goal (si_eq2 X x y)) b)"], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y))\n   (fun (H : false = true -> P x) (H0 : false = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H0 ?Goal) (si_eq2 X x y)) b)"]}, {"text": "trivial.", "goal_before": ["false = false"], "goal_after": [], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y))\n   (fun (H : false = true -> P x) (H0 : false = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H0 ?Goal) (si_eq2 X x y)) b)"], "proof_term_after": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y))\n   (fun (_ : false = true -> P x) (H : false = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq2 X x y)) b)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (X : Set) (P : X -> Prop) (x y : X) (b : bool) =>\n bool_ind\n   (fun b0 : bool =>\n    (b0 = true -> P x) -> (b0 = false -> P y) -> P (si X b0 x y))\n   (fun (H : true = true -> P x) (_ : true = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq1 X x y))\n   (fun (_ : false = true -> P x) (H : false = false -> P y) =>\n    eq_ind_r (fun x0 : X => P x0) (H eq_refl) (si_eq2 X x y)) b)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "inf_false_true", "text": "Theorem inf_false_true :\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\nProof.\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\nQed.\n", "definition": "\n forall n m : nat, inf_egal n m = false -> inf_egal m n = true.\n", "proof": "\nsimple induction n.\n intros.\n apply False_ind.\n apply diff_true_false.\n assumption.\n simple induction m.\n  intro.\n  trivial.\n  intros.\n  rewrite inf_egal_eq3.\n  apply H.\n  assumption.\n", "def_ranges": [189, 0, 190, 63], "proof_ranges": [191, 0, 204, 4], "proof_steps": [{"text": "simple induction n.", "goal_before": ["forall n m : nat, inf_egal n m = false -> inf_egal m n = true"], "goal_after": ["forall m : nat, inf_egal 0 m = false -> inf_egal m 0 = true", "forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "proof_term_before": [], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) \n   ?Goal ?Goal0 n)"]}, {"text": "intros.", "goal_before": ["forall m : nat, inf_egal 0 m = false -> inf_egal m 0 = true", "forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "goal_after": ["inf_egal m 0 = true", "forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) \n   ?Goal ?Goal0 n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) => ?Goal0) \n   ?Goal n)"]}, {"text": "apply False_ind.", "goal_before": ["inf_egal m 0 = true", "forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "goal_after": ["False", "forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) => ?Goal0) \n   ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) ?Goal0) ?Goal n)"]}, {"text": "apply diff_true_false.", "goal_before": ["False", "forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "goal_after": ["true = false", "forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) ?Goal0) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false ?Goal0)) \n   ?Goal n)"]}, {"text": "assumption.", "goal_before": ["true = false", "forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "goal_after": ["forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false ?Goal0)) \n   ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H)) \n   ?Goal n)"]}, {"text": "simple induction m.", "goal_before": ["forall n0 : nat,\n(forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true) ->\nforall m : nat, inf_egal (S n0) m = false -> inf_egal m (S n0) = true"], "goal_after": ["inf_egal (S n0) 0 = false -> inf_egal 0 (S n0) = true", "forall n1 : nat,\n(inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true) ->\ninf_egal (S n0) (S n1) = false -> inf_egal (S n1) (S n0) = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H)) \n   ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true) \n      ?Goal ?Goal0 m) n)"]}, {"text": "intro.", "goal_before": ["inf_egal (S n0) 0 = false -> inf_egal 0 (S n0) = true", "forall n1 : nat,\n(inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true) ->\ninf_egal (S n0) (S n1) = false -> inf_egal (S n1) (S n0) = true"], "goal_after": ["inf_egal 0 (S n0) = true", "forall n1 : nat,\n(inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true) ->\ninf_egal (S n0) (S n1) = false -> inf_egal (S n1) (S n0) = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true) \n      ?Goal ?Goal0 m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun H0 : inf_egal (S n0) 0 = false => ?Goal0) \n      ?Goal m) n)"]}, {"text": "trivial.", "goal_before": ["inf_egal 0 (S n0) = true", "forall n1 : nat,\n(inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true) ->\ninf_egal (S n0) (S n1) = false -> inf_egal (S n1) (S n0) = true"], "goal_after": ["forall n1 : nat,\n(inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true) ->\ninf_egal (S n0) (S n1) = false -> inf_egal (S n1) (S n0) = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun H0 : inf_egal (S n0) 0 = false => ?Goal0) \n      ?Goal m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl) \n      ?Goal m) n)"]}, {"text": "intros.", "goal_before": ["forall n1 : nat,\n(inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true) ->\ninf_egal (S n0) (S n1) = false -> inf_egal (S n1) (S n0) = true"], "goal_after": ["inf_egal (S n1) (S n0) = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl) \n      ?Goal m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl)\n      (fun (n1 : nat)\n         (H0 : inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true)\n         (H1 : inf_egal (S n0) (S n1) = false) => \n       ?Goal) m) n)"]}, {"text": "rewrite inf_egal_eq3.", "goal_before": ["inf_egal (S n1) (S n0) = true"], "goal_after": ["inf_egal n1 n0 = true"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl)\n      (fun (n1 : nat)\n         (H0 : inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true)\n         (H1 : inf_egal (S n0) (S n1) = false) => \n       ?Goal) m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl)\n      (fun (n1 : nat)\n         (H0 : inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true)\n         (H1 : inf_egal (S n0) (S n1) = false) =>\n       eq_ind_r (fun b : bool => b = true) ?Goal (inf_egal_eq3 n1 n0)) m) n)"]}, {"text": "apply H.", "goal_before": ["inf_egal n1 n0 = true"], "goal_after": ["inf_egal n0 n1 = false"], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl)\n      (fun (n1 : nat)\n         (H0 : inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true)\n         (H1 : inf_egal (S n0) (S n1) = false) =>\n       eq_ind_r (fun b : bool => b = true) ?Goal (inf_egal_eq3 n1 n0)) m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl)\n      (fun (n1 : nat)\n         (H0 : inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true)\n         (H1 : inf_egal (S n0) (S n1) = false) =>\n       eq_ind_r (fun b : bool => b = true) (H n1 ?Goal) (inf_egal_eq3 n1 n0))\n      m) n)"]}, {"text": "assumption.", "goal_before": ["inf_egal n0 n1 = false"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl)\n      (fun (n1 : nat)\n         (H0 : inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true)\n         (H1 : inf_egal (S n0) (S n1) = false) =>\n       eq_ind_r (fun b : bool => b = true) (H n1 ?Goal) (inf_egal_eq3 n1 n0))\n      m) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl)\n      (fun (n1 : nat)\n         (_ : inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true)\n         (H0 : inf_egal (S n0) (S n1) = false) =>\n       eq_ind_r (fun b : bool => b = true) (H n1 H0) (inf_egal_eq3 n1 n0)) m)\n   n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind\n   (fun n0 : nat =>\n    forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n   (fun (m : nat) (H : inf_egal 0 m = false) =>\n    False_ind (inf_egal m 0 = true) (diff_true_false H))\n   (fun (n0 : nat)\n      (H : forall m : nat, inf_egal n0 m = false -> inf_egal m n0 = true)\n      (m : nat) =>\n    nat_ind\n      (fun m0 : nat =>\n       inf_egal (S n0) m0 = false -> inf_egal m0 (S n0) = true)\n      (fun _ : inf_egal (S n0) 0 = false => eq_refl)\n      (fun (n1 : nat)\n         (_ : inf_egal (S n0) n1 = false -> inf_egal n1 (S n0) = true)\n         (H0 : inf_egal (S n0) (S n1) = false) =>\n       eq_ind_r (fun b : bool => b = true) (H n1 H0) (inf_egal_eq3 n1 n0)) m)\n   n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "sorted_cdr", "text": "Theorem sorted_cdr :\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\nProof.\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\nQed.\n", "definition": "\n forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x.\n", "proof": "\nsimple induction x.\n intro. unfold sorted in |- *. trivial.\n intro. intro. intro. \n rewrite sorted_eq3.\n tauto.\n", "def_ranges": [208, 0, 209, 68], "proof_ranges": [210, 0, 216, 4], "proof_steps": [{"text": "simple induction x.", "goal_before": ["forall (n : nat) (x : list nat), sorted (Cons nat n x) -> sorted x"], "goal_after": ["sorted (Cons nat n (Nil nat)) -> sorted (Nil nat)", "forall (x0 : nat) (l : list nat),\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "proof_term_before": [], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   ?Goal ?Goal0 x)"]}, {"text": "intro.", "goal_before": ["sorted (Cons nat n (Nil nat)) -> sorted (Nil nat)", "forall (x0 : nat) (l : list nat),\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "goal_after": ["sorted (Nil nat)", "forall (x0 : nat) (l : list nat),\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   ?Goal ?Goal0 x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => ?Goal0) \n   ?Goal x)"]}, {"text": "unfold sorted in |- *.", "goal_before": ["sorted (Nil nat)", "forall (x0 : nat) (l : list nat),\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "goal_after": ["True", "forall (x0 : nat) (l : list nat),\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => ?Goal0) \n   ?Goal x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => ?Goal0 : sorted (Nil nat)) \n   ?Goal x)"]}, {"text": "trivial.", "goal_before": ["True", "forall (x0 : nat) (l : list nat),\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "goal_after": ["forall (x0 : nat) (l : list nat),\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => ?Goal0 : sorted (Nil nat)) \n   ?Goal x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat)) \n   ?Goal x)"]}, {"text": "intro.", "goal_before": ["forall (x0 : nat) (l : list nat),\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "goal_after": ["forall l : list nat,\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat)) \n   ?Goal x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun x0 : nat => ?Goal) x)"]}, {"text": "intro.", "goal_before": ["forall l : list nat,\n(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "goal_after": ["(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun x0 : nat => ?Goal) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun (x0 : nat) (l : list nat) => ?Goal) x)"]}, {"text": "intro.", "goal_before": ["(sorted (Cons nat n l) -> sorted l) ->\nsorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "goal_after": ["sorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun (x0 : nat) (l : list nat) => ?Goal) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun (x0 : nat) (l : list nat) (H : sorted (Cons nat n l) -> sorted l) =>\n    ?Goal) x)"]}, {"text": "rewrite sorted_eq3.", "goal_before": ["sorted (Cons nat n (Cons nat x0 l)) -> sorted (Cons nat x0 l)"], "goal_after": ["inf_egal n x0 = true /\\ sorted (Cons nat x0 l) -> sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun (x0 : nat) (l : list nat) (H : sorted (Cons nat n l) -> sorted l) =>\n    ?Goal) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun (x0 : nat) (l : list nat) (H : sorted (Cons nat n l) -> sorted l) =>\n    eq_ind_r (fun P : Prop => P -> sorted (Cons nat x0 l)) \n      ?Goal (sorted_eq3 n x0 l)) x)"]}, {"text": "tauto.", "goal_before": ["inf_egal n x0 = true /\\ sorted (Cons nat x0 l) -> sorted (Cons nat x0 l)"], "goal_after": [], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun (x0 : nat) (l : list nat) (H : sorted (Cons nat n l) -> sorted l) =>\n    eq_ind_r (fun P : Prop => P -> sorted (Cons nat x0 l)) \n      ?Goal (sorted_eq3 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun (x0 : nat) (l : list nat) (_ : sorted (Cons nat n l) -> sorted l) =>\n    eq_ind_r (fun P : Prop => P -> sorted (Cons nat x0 l))\n      (fun H0 : inf_egal n x0 = true /\\ sorted (Cons nat x0 l) =>\n       and_ind\n         (fun (_ : inf_egal n x0 = true) (H2 : sorted (Cons nat x0 l)) => H2)\n         H0) (sorted_eq3 n x0 l)) x)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted (Cons nat n x0) -> sorted x0)\n   (fun H : sorted (Cons nat n (Nil nat)) => H : sorted (Nil nat))\n   (fun (x0 : nat) (l : list nat) (_ : sorted (Cons nat n l) -> sorted l) =>\n    eq_ind_r (fun P : Prop => P -> sorted (Cons nat x0 l))\n      (fun H0 : inf_egal n x0 = true /\\ sorted (Cons nat x0 l) =>\n       and_ind\n         (fun (_ : inf_egal n x0 = true) (H2 : sorted (Cons nat x0 l)) => H2)\n         H0) (sorted_eq3 n x0 l)) x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "sorted_inf", "text": "Theorem sorted_inf :\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\nProof.\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\nQed.\n", "definition": "\n forall (n m : nat) (x : list nat),\n sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true.\n", "proof": "\nintro. intro. intro.\nrewrite sorted_eq3.\ntauto.\n", "def_ranges": [218, 0, 220, 59], "proof_ranges": [221, 0, 225, 4], "proof_steps": [{"text": "intro.", "goal_before": ["forall (n m : nat) (x : list nat),\nsorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true"], "goal_after": ["forall (m : nat) (x : list nat),\nsorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true"], "proof_term_before": [], "proof_term_after": ["(fun n : nat => ?Goal)"]}, {"text": "intro.", "goal_before": ["forall (m : nat) (x : list nat),\nsorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true"], "goal_after": ["forall x : list nat,\nsorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true"], "proof_term_before": ["(fun n : nat => ?Goal)"], "proof_term_after": ["(fun n m : nat => ?Goal)"]}, {"text": "intro.", "goal_before": ["forall x : list nat,\nsorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true"], "goal_after": ["sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true"], "proof_term_before": ["(fun n m : nat => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (x : list nat) => ?Goal)"]}, {"text": "rewrite sorted_eq3.", "goal_before": ["sorted (Cons nat n (Cons nat m x)) -> inf_egal n m = true"], "goal_after": ["inf_egal n m = true /\\ sorted (Cons nat m x) -> inf_egal n m = true"], "proof_term_before": ["(fun (n m : nat) (x : list nat) => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (x : list nat) =>\n eq_ind_r (fun P : Prop => P -> inf_egal n m = true) ?Goal (sorted_eq3 n m x))"]}, {"text": "tauto.", "goal_before": ["inf_egal n m = true /\\ sorted (Cons nat m x) -> inf_egal n m = true"], "goal_after": [], "proof_term_before": ["(fun (n m : nat) (x : list nat) =>\n eq_ind_r (fun P : Prop => P -> inf_egal n m = true) ?Goal (sorted_eq3 n m x))"], "proof_term_after": ["(fun (n m : nat) (x : list nat) =>\n eq_ind_r (fun P : Prop => P -> inf_egal n m = true)\n   (fun H : inf_egal n m = true /\\ sorted (Cons nat m x) =>\n    and_ind\n      (fun (H0 : inf_egal n m = true) (_ : sorted (Cons nat m x)) => H0) H)\n   (sorted_eq3 n m x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n m : nat) (x : list nat) =>\n eq_ind_r (fun P : Prop => P -> inf_egal n m = true)\n   (fun H : inf_egal n m = true /\\ sorted (Cons nat m x) =>\n    and_ind\n      (fun (H0 : inf_egal n m = true) (_ : sorted (Cons nat m x)) => H0) H)\n   (sorted_eq3 n m x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "sorted_ins_Cons", "text": "Theorem sorted_ins_Cons :\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\nProof.\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\nQed.\n", "definition": "\n forall (x : list nat) (n m : nat),\n inf_egal n m = false ->\n sorted (Cons nat m x) -> sorted (Cons nat m (ins n x)).\n", "proof": "\nsimple induction x.\n intros.\n rewrite ins_eq1.\n rewrite sorted_eq3.\n split.\n  apply inf_false_true. assumption.\n  trivial.\n intros.\n rewrite ins_eq2.\n apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).\n  intro. \n  rewrite sorted_eq3.\n  split.\n   apply inf_false_true. assumption.\n   rewrite sorted_eq3.\n   split.\n    apply H2.\n    apply (sorted_cdr m). assumption.\n  intro.\n  rewrite sorted_eq3.\n  split.\n   apply (sorted_inf m x0 l). assumption.\n   apply H.\n    assumption.\n    apply (sorted_cdr m). assumption.\n", "def_ranges": [275, 0, 278, 56], "proof_ranges": [279, 0, 305, 4], "proof_steps": [{"text": "simple induction x.", "goal_before": ["forall (x : list nat) (n m : nat),\ninf_egal n m = false ->\nsorted (Cons nat m x) -> sorted (Cons nat m (ins n x))"], "goal_after": ["forall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Nil nat)) -> sorted (Cons nat m (ins n (Nil nat)))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": [], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0))) \n   ?Goal ?Goal0 x)"]}, {"text": "intros.", "goal_before": ["forall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Nil nat)) -> sorted (Cons nat m (ins n (Nil nat)))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["sorted (Cons nat m (ins n (Nil nat)))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0))) \n   ?Goal ?Goal0 x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) => ?Goal0) \n   ?Goal x)"]}, {"text": "rewrite ins_eq1.", "goal_before": ["sorted (Cons nat m (ins n (Nil nat)))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["sorted (Cons nat m (Cons nat n (Nil nat)))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) => ?Goal0) \n   ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l)) ?Goal0 (ins_eq1 n))\n   ?Goal x)"]}, {"text": "rewrite sorted_eq3.", "goal_before": ["sorted (Cons nat m (Cons nat n (Nil nat)))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["inf_egal m n = true /\\ sorted (Cons nat n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l)) ?Goal0 (ins_eq1 n))\n   ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) ?Goal0 (sorted_eq3 m n (Nil nat)))\n      (ins_eq1 n)) ?Goal x)"]}, {"text": "split.", "goal_before": ["inf_egal m n = true /\\ sorted (Cons nat n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["inf_egal m n = true", "sorted (Cons nat n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) ?Goal0 (sorted_eq3 m n (Nil nat)))\n      (ins_eq1 n)) ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj ?Goal0 ?Goal1)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n)) \n   ?Goal x)"]}, {"text": "apply inf_false_true.", "goal_before": ["inf_egal m n = true", "sorted (Cons nat n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["inf_egal n m = false", "sorted (Cons nat n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj ?Goal0 ?Goal1)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n)) \n   ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m ?Goal1) ?Goal0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n)) \n   ?Goal x)"]}, {"text": "assumption.", "goal_before": ["inf_egal n m = false", "sorted (Cons nat n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["sorted (Cons nat n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m ?Goal1) ?Goal0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n)) \n   ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) ?Goal0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n)) \n   ?Goal x)"]}, {"text": "trivial.", "goal_before": ["sorted (Cons nat n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) ?Goal0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n)) \n   ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n)) \n   ?Goal x)"]}, {"text": "intros.", "goal_before": ["forall (x0 : nat) (l : list nat),\n(forall n m : nat,\n inf_egal n m = false ->\n sorted (Cons nat m l) -> sorted (Cons nat m (ins n l))) ->\nforall n m : nat,\ninf_egal n m = false ->\nsorted (Cons nat m (Cons nat x0 l)) ->\nsorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["sorted (Cons nat m (ins n (Cons nat x0 l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n)) \n   ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) => \n    ?Goal) x)"]}, {"text": "rewrite ins_eq2.", "goal_before": ["sorted (Cons nat m (ins n (Cons nat x0 l)))"], "goal_after": ["sorted\n  (Cons nat m\n     (si (list nat) (inf_egal n x0) (Cons nat n (Cons nat x0 l))\n        (Cons nat x0 (ins n l))))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) => \n    ?Goal) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0)) \n      ?Goal (ins_eq2 n x0 l)) x)"]}, {"text": "apply (si_intro (list nat) (fun x : list nat => sorted (Cons nat m x))).", "goal_before": ["sorted\n  (Cons nat m\n     (si (list nat) (inf_egal n x0) (Cons nat n (Cons nat x0 l))\n        (Cons nat x0 (ins n l))))"], "goal_after": ["inf_egal n x0 = true -> sorted (Cons nat m (Cons nat n (Cons nat x0 l)))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0)) \n      ?Goal (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0) ?Goal ?Goal0) (ins_eq2 n x0 l)) x)"]}, {"text": "intro.", "goal_before": ["inf_egal n x0 = true -> sorted (Cons nat m (Cons nat n (Cons nat x0 l)))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["sorted (Cons nat m (Cons nat n (Cons nat x0 l)))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0) ?Goal ?Goal0) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0) (fun H2 : inf_egal n x0 = true => ?Goal0) \n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "rewrite sorted_eq3.", "goal_before": ["sorted (Cons nat m (Cons nat n (Cons nat x0 l)))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["inf_egal m n = true /\\ sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0) (fun H2 : inf_egal n x0 = true => ?Goal0) \n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) ?Goal0\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"]}, {"text": "split.", "goal_before": ["inf_egal m n = true /\\ sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["inf_egal m n = true", "sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) ?Goal0\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj ?Goal0 ?Goal1)\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"]}, {"text": "apply inf_false_true.", "goal_before": ["inf_egal m n = true", "sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["inf_egal n m = false", "sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj ?Goal0 ?Goal1)\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m ?Goal1) ?Goal0)\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["inf_egal n m = false", "sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m ?Goal1) ?Goal0)\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H0) ?Goal0)\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"]}, {"text": "rewrite sorted_eq3.", "goal_before": ["sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["inf_egal n x0 = true /\\ sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H0) ?Goal0)\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P) ?Goal0 (sorted_eq3 n x0 l)))\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"]}, {"text": "split.", "goal_before": ["inf_egal n x0 = true /\\ sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["inf_egal n x0 = true", "sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P) ?Goal0 (sorted_eq3 n x0 l)))\n            (sorted_eq3 m n (Cons nat x0 l))) ?Goal) \n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P) (conj ?Goal0 ?Goal1)\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "apply H2.", "goal_before": ["inf_egal n x0 = true", "sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P) (conj ?Goal0 ?Goal1)\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P) (conj H2 ?Goal0)\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "apply (sorted_cdr m).", "goal_before": ["sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["sorted (Cons nat m (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P) (conj H2 ?Goal0)\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) ?Goal0))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["sorted (Cons nat m (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) ?Goal0))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "intro.", "goal_before": ["inf_egal n x0 = false -> sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["sorted (Cons nat m (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false => ?Goal)) \n      (ins_eq2 n x0 l)) x)"]}, {"text": "rewrite sorted_eq3.", "goal_before": ["sorted (Cons nat m (Cons nat x0 (ins n l)))"], "goal_after": ["inf_egal m x0 = true /\\ sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false => ?Goal)) \n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P) ?Goal (sorted_eq3 m x0 (ins n l))))\n      (ins_eq2 n x0 l)) x)"]}, {"text": "split.", "goal_before": ["inf_egal m x0 = true /\\ sorted (Cons nat x0 (ins n l))"], "goal_after": ["inf_egal m x0 = true", "sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P) ?Goal (sorted_eq3 m x0 (ins n l))))\n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P) (conj ?Goal ?Goal0)\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"]}, {"text": "apply (sorted_inf m x0 l).", "goal_before": ["inf_egal m x0 = true", "sorted (Cons nat x0 (ins n l))"], "goal_after": ["sorted (Cons nat m (Cons nat x0 l))", "sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P) (conj ?Goal ?Goal0)\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l ?Goal0) ?Goal)\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["sorted (Cons nat m (Cons nat x0 l))", "sorted (Cons nat x0 (ins n l))"], "goal_after": ["sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l ?Goal0) ?Goal)\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P) (conj (sorted_inf m x0 l H1) ?Goal)\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"]}, {"text": "apply H.", "goal_before": ["sorted (Cons nat x0 (ins n l))"], "goal_after": ["inf_egal n x0 = false", "sorted (Cons nat x0 l)"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P) (conj (sorted_inf m x0 l H1) ?Goal)\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l H1) (H n x0 ?Goal ?Goal0))\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["inf_egal n x0 = false", "sorted (Cons nat x0 l)"], "goal_after": ["sorted (Cons nat x0 l)"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l H1) (H n x0 ?Goal ?Goal0))\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l H1) (H n x0 H2 ?Goal))\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"]}, {"text": "apply (sorted_cdr m).", "goal_before": ["sorted (Cons nat x0 l)"], "goal_after": ["sorted (Cons nat m (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l H1) (H n x0 H2 ?Goal))\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l H1)\n               (H n x0 H2 (sorted_cdr m (Cons nat x0 l) ?Goal)))\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["sorted (Cons nat m (Cons nat x0 l))"], "goal_after": [], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l H1)\n               (H n x0 H2 (sorted_cdr m (Cons nat x0 l) ?Goal)))\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l H1)\n               (H n x0 H2 (sorted_cdr m (Cons nat x0 l) H1)))\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat,\n    inf_egal n m = false ->\n    sorted (Cons nat m x0) -> sorted (Cons nat m (ins n x0)))\n   (fun (n m : nat) (H : inf_egal n m = false)\n      (H0 : sorted (Cons nat m (Nil nat))) =>\n    eq_ind_r (fun l : list nat => sorted (Cons nat m l))\n      (eq_ind_r (fun P : Prop => P) (conj (inf_false_true n m H) H0)\n         (sorted_eq3 m n (Nil nat))) (ins_eq1 n))\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat,\n           inf_egal n m = false ->\n           sorted (Cons nat m l) -> sorted (Cons nat m (ins n l)))\n      (n m : nat) (H0 : inf_egal n m = false)\n      (H1 : sorted (Cons nat m (Cons nat x0 l))) =>\n    eq_ind_r (fun l0 : list nat => sorted (Cons nat m l0))\n      (si_intro (list nat) (fun x1 : list nat => sorted (Cons nat m x1))\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H2 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (inf_false_true n m H0)\n               (eq_ind_r (fun P : Prop => P)\n                  (conj H2 (sorted_cdr m (Cons nat x0 l) H1))\n                  (sorted_eq3 n x0 l))) (sorted_eq3 m n (Cons nat x0 l)))\n         (fun H2 : inf_egal n x0 = false =>\n          eq_ind_r (fun P : Prop => P)\n            (conj (sorted_inf m x0 l H1)\n               (H n x0 H2 (sorted_cdr m (Cons nat x0 l) H1)))\n            (sorted_eq3 m x0 (ins n l)))) (ins_eq2 n x0 l)) x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "sorted_ins", "text": "Theorem sorted_ins :\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\nQed.\n", "definition": "\n forall (n : nat) (x : list nat), sorted x -> sorted (ins n x).\n", "proof": "\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply si_intro.\n  intros.\n  rewrite sorted_eq3.\n  split. assumption. assumption.\n  intro.\n  apply sorted_ins_Cons. assumption. assumption.\n", "def_ranges": [307, 0, 308, 63], "proof_ranges": [309, 0, 320, 4], "proof_steps": [{"text": "simple induction x.", "goal_before": ["forall (n : nat) (x : list nat), sorted x -> sorted (ins n x)"], "goal_after": ["sorted (Nil nat) -> sorted (ins n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(sorted l -> sorted (ins n l)) ->\nsorted (Cons nat x0 l) -> sorted (ins n (Cons nat x0 l))"], "proof_term_before": [], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0)) \n   ?Goal ?Goal0 x)"]}, {"text": "trivial.", "goal_before": ["sorted (Nil nat) -> sorted (ins n (Nil nat))", "forall (x0 : nat) (l : list nat),\n(sorted l -> sorted (ins n l)) ->\nsorted (Cons nat x0 l) -> sorted (ins n (Cons nat x0 l))"], "goal_after": ["forall (x0 : nat) (l : list nat),\n(sorted l -> sorted (ins n l)) ->\nsorted (Cons nat x0 l) -> sorted (ins n (Cons nat x0 l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0)) \n   ?Goal ?Goal0 x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H) ?Goal x)"]}, {"text": "intros.", "goal_before": ["forall (x0 : nat) (l : list nat),\n(sorted l -> sorted (ins n l)) ->\nsorted (Cons nat x0 l) -> sorted (ins n (Cons nat x0 l))"], "goal_after": ["sorted (ins n (Cons nat x0 l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H) ?Goal x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) => ?Goal) x)"]}, {"text": "rewrite ins_eq2.", "goal_before": ["sorted (ins n (Cons nat x0 l))"], "goal_after": ["sorted\n  (si (list nat) (inf_egal n x0) (Cons nat n (Cons nat x0 l))\n     (Cons nat x0 (ins n l)))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) => ?Goal) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0) ?Goal (ins_eq2 n x0 l)) x)"]}, {"text": "apply si_intro.", "goal_before": ["sorted\n  (si (list nat) (inf_egal n x0) (Cons nat n (Cons nat x0 l))\n     (Cons nat x0 (ins n l)))"], "goal_after": ["inf_egal n x0 = true -> sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0) ?Goal (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0) ?Goal ?Goal0) (ins_eq2 n x0 l)) x)"]}, {"text": "intros.", "goal_before": ["inf_egal n x0 = true -> sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "goal_after": ["sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0) ?Goal ?Goal0) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0) (fun H1 : inf_egal n x0 = true => ?Goal0) \n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "rewrite sorted_eq3.", "goal_before": ["sorted (Cons nat n (Cons nat x0 l))", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "goal_after": ["inf_egal n x0 = true /\\ sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0) (fun H1 : inf_egal n x0 = true => ?Goal0) \n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) ?Goal0 (sorted_eq3 n x0 l)) \n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "split.", "goal_before": ["inf_egal n x0 = true /\\ sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "goal_after": ["inf_egal n x0 = true", "sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) ?Goal0 (sorted_eq3 n x0 l)) \n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj ?Goal0 ?Goal1)\n            (sorted_eq3 n x0 l)) ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["inf_egal n x0 = true", "sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "goal_after": ["sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj ?Goal0 ?Goal1)\n            (sorted_eq3 n x0 l)) ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 ?Goal0) (sorted_eq3 n x0 l))\n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["sorted (Cons nat x0 l)", "inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "goal_after": ["inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 ?Goal0) (sorted_eq3 n x0 l))\n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 H0) (sorted_eq3 n x0 l))\n         ?Goal) (ins_eq2 n x0 l)) x)"]}, {"text": "intro.", "goal_before": ["inf_egal n x0 = false -> sorted (Cons nat x0 (ins n l))"], "goal_after": ["sorted (Cons nat x0 (ins n l))"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 H0) (sorted_eq3 n x0 l))\n         ?Goal) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 H0) (sorted_eq3 n x0 l))\n         (fun H1 : inf_egal n x0 = false => ?Goal)) \n      (ins_eq2 n x0 l)) x)"]}, {"text": "apply sorted_ins_Cons.", "goal_before": ["sorted (Cons nat x0 (ins n l))"], "goal_after": ["inf_egal n x0 = false", "sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 H0) (sorted_eq3 n x0 l))\n         (fun H1 : inf_egal n x0 = false => ?Goal)) \n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 H0) (sorted_eq3 n x0 l))\n         (fun H1 : inf_egal n x0 = false =>\n          sorted_ins_Cons l n x0 ?Goal ?Goal0)) (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["inf_egal n x0 = false", "sorted (Cons nat x0 l)"], "goal_after": ["sorted (Cons nat x0 l)"], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 H0) (sorted_eq3 n x0 l))\n         (fun H1 : inf_egal n x0 = false =>\n          sorted_ins_Cons l n x0 ?Goal ?Goal0)) (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 H0) (sorted_eq3 n x0 l))\n         (fun H1 : inf_egal n x0 = false => sorted_ins_Cons l n x0 H1 ?Goal))\n      (ins_eq2 n x0 l)) x)"]}, {"text": "assumption.", "goal_before": ["sorted (Cons nat x0 l)"], "goal_after": [], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (H : sorted l -> sorted (ins n l))\n      (H0 : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H1 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H1 H0) (sorted_eq3 n x0 l))\n         (fun H1 : inf_egal n x0 = false => sorted_ins_Cons l n x0 H1 ?Goal))\n      (ins_eq2 n x0 l)) x)"], "proof_term_after": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (_ : sorted l -> sorted (ins n l))\n      (H : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H0 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H0 H) (sorted_eq3 n x0 l))\n         (fun H1 : inf_egal n x0 = false => sorted_ins_Cons l n x0 H1 H))\n      (ins_eq2 n x0 l)) x)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n : nat) (x : list nat) =>\n list_ind nat (fun x0 : list nat => sorted x0 -> sorted (ins n x0))\n   (fun H : sorted (Nil nat) => H)\n   (fun (x0 : nat) (l : list nat) (_ : sorted l -> sorted (ins n l))\n      (H : sorted (Cons nat x0 l)) =>\n    eq_ind_r (fun l0 : list nat => sorted l0)\n      (si_intro (list nat) (fun l0 : list nat => sorted l0)\n         (Cons nat n (Cons nat x0 l)) (Cons nat x0 (ins n l)) \n         (inf_egal n x0)\n         (fun H0 : inf_egal n x0 = true =>\n          eq_ind_r (fun P : Prop => P) (conj H0 H) (sorted_eq3 n x0 l))\n         (fun H1 : inf_egal n x0 = false => sorted_ins_Cons l n x0 H1 H))\n      (ins_eq2 n x0 l)) x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "nocc_Cons_Cons", "text": "Theorem nocc_Cons_Cons :\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\nProof.\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\nQed.\n", "definition": "\n forall (n m p : nat) (x : list nat),\n nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x)).\n", "proof": "\nintros.\nrewrite (nocc_eq2 n p (Cons nat m x)).\napply si_intro.\n intro.\n rewrite nocc_eq2.\n apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  apply refl_equal.\n intro.\n rewrite (nocc_eq2 n m x).\n apply si_intro.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq1.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n  intro.\n  rewrite nocc_eq2.\n  rewrite H0.\n  rewrite si_eq2.\n  rewrite nocc_eq2.\n  rewrite H.\n  rewrite si_eq2.\n  apply refl_equal.\n", "def_ranges": [325, 0, 327, 73], "proof_ranges": [328, 0, 370, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall (n m p : nat) (x : list nat),\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x))"], "goal_after": ["nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x))"], "proof_term_before": [], "proof_term_after": ["(fun (n m p : nat) (x : list nat) => ?Goal)"]}, {"text": "rewrite (nocc_eq2 n p (Cons nat m x)).", "goal_before": ["nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat p (Cons nat m x))"], "goal_after": ["nocc n (Cons nat m (Cons nat p x)) =\nsi nat (egal_nat n p) (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x))"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) => ?Goal)"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0) \n   ?Goal (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "apply si_intro.", "goal_before": ["nocc n (Cons nat m (Cons nat p x)) =\nsi nat (egal_nat n p) (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x))"], "goal_after": ["egal_nat n p = true ->\nnocc n (Cons nat m (Cons nat p x)) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0) \n   ?Goal (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p) ?Goal ?Goal0) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "intro.", "goal_before": ["egal_nat n p = true ->\nnocc n (Cons nat m (Cons nat p x)) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["nocc n (Cons nat m (Cons nat p x)) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p) ?Goal ?Goal0) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p) (fun H : egal_nat n p = true => ?Goal0) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["nocc n (Cons nat m (Cons nat p x)) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["si nat (egal_nat n m) (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) =\nS (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p) (fun H : egal_nat n p = true => ?Goal0) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x))) \n         ?Goal0 (nocc_eq2 n m (Cons nat p x))) ?Goal)\n   (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "apply (si_intro nat (fun p : nat => p = S (nocc n (Cons nat m x)))).", "goal_before": ["si nat (egal_nat n m) (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) =\nS (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["egal_nat n m = true -> S (nocc n (Cons nat p x)) = S (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x))) \n         ?Goal0 (nocc_eq2 n m (Cons nat p x))) ?Goal)\n   (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m) ?Goal0 ?Goal1) (nocc_eq2 n m (Cons nat p x)))\n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "intro.", "goal_before": ["egal_nat n m = true -> S (nocc n (Cons nat p x)) = S (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (nocc n (Cons nat p x)) = S (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m) ?Goal0 ?Goal1) (nocc_eq2 n m (Cons nat p x)))\n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m) (fun H0 : egal_nat n m = true => ?Goal1) \n            ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["S (nocc n (Cons nat p x)) = S (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (si nat (egal_nat n p) (S (nocc n x)) (nocc n x)) =\nS (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m) (fun H0 : egal_nat n m = true => ?Goal1) \n            ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               ?Goal1 (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x)))\n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite H.", "goal_before": ["S (si nat (egal_nat n p) (S (nocc n x)) (nocc n x)) =\nS (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (si nat true (S (nocc n x)) (nocc n x)) = S (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               ?Goal1 (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x)))\n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x))) ?Goal1 H) \n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite si_eq1.", "goal_before": ["S (si nat true (S (nocc n x)) (nocc n x)) = S (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (S (nocc n x)) = S (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x))) ?Goal1 H) \n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     ?Goal1 (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["S (S (nocc n x)) = S (nocc n (Cons nat m x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (S (nocc n x)) = S (si nat (egal_nat n m) (S (nocc n x)) (nocc n x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     ?Goal1 (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        ?Goal1 (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite H0.", "goal_before": ["S (S (nocc n x)) = S (si nat (egal_nat n m) (S (nocc n x)) (nocc n x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (S (nocc n x)) = S (si nat true (S (nocc n x)) (nocc n x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        ?Goal1 (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x))) \n                           ?Goal1 H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite si_eq1.", "goal_before": ["S (S (nocc n x)) = S (si nat true (S (nocc n x)) (nocc n x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (S (nocc n x)) = S (S (nocc n x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x))) \n                           ?Goal1 H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              ?Goal1 (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "apply refl_equal.", "goal_before": ["S (S (nocc n x)) = S (S (nocc n x))", "egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              ?Goal1 (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "intro.", "goal_before": ["egal_nat n m = false -> nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) ?Goal0) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) (fun H0 : egal_nat n m = false => ?Goal0))\n         (nocc_eq2 n m (Cons nat p x))) ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["nocc n (Cons nat p x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["si nat (egal_nat n p) (S (nocc n x)) (nocc n x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x)) (fun H0 : egal_nat n m = false => ?Goal0))\n         (nocc_eq2 n m (Cons nat p x))) ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x))) \n               ?Goal0 (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite H.", "goal_before": ["si nat (egal_nat n p) (S (nocc n x)) (nocc n x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["si nat true (S (nocc n x)) (nocc n x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x))) \n               ?Goal0 (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x))) ?Goal0 H) \n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite si_eq1.", "goal_before": ["si nat true (S (nocc n x)) (nocc n x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (nocc n x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x))) ?Goal0 H) \n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     ?Goal0 (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["S (nocc n x) = S (nocc n (Cons nat m x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (nocc n x) = S (si nat (egal_nat n m) (S (nocc n x)) (nocc n x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     ?Goal0 (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0) \n                        ?Goal0 (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite H0.", "goal_before": ["S (nocc n x) = S (si nat (egal_nat n m) (S (nocc n x)) (nocc n x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (nocc n x) = S (si nat false (S (nocc n x)) (nocc n x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0) \n                        ?Goal0 (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x))) \n                           ?Goal0 H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite si_eq2.", "goal_before": ["S (nocc n x) = S (si nat false (S (nocc n x)) (nocc n x))", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["S (nocc n x) = S (nocc n x)", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x))) \n                           ?Goal0 H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              ?Goal0 (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "apply refl_equal.", "goal_before": ["S (nocc n x) = S (nocc n x)", "egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              ?Goal0 (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "intro.", "goal_before": ["egal_nat n p = false ->\nnocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x))) \n      ?Goal) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false => ?Goal)) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite (nocc_eq2 n m x).", "goal_before": ["nocc n (Cons nat m (Cons nat p x)) = nocc n (Cons nat m x)"], "goal_after": ["nocc n (Cons nat m (Cons nat p x)) =\nsi nat (egal_nat n m) (S (nocc n x)) (nocc n x)"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false => ?Goal)) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         ?Goal (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "apply si_intro.", "goal_before": ["nocc n (Cons nat m (Cons nat p x)) =\nsi nat (egal_nat n m) (S (nocc n x)) (nocc n x)"], "goal_after": ["egal_nat n m = true -> nocc n (Cons nat m (Cons nat p x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         ?Goal (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m) \n            ?Goal ?Goal0) (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "intro.", "goal_before": ["egal_nat n m = true -> nocc n (Cons nat m (Cons nat p x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["nocc n (Cons nat m (Cons nat p x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m) \n            ?Goal ?Goal0) (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true => ?Goal0) \n            ?Goal) (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["nocc n (Cons nat m (Cons nat p x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["si nat (egal_nat n m) (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) =\nS (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true => ?Goal0) \n            ?Goal) (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x)) \n               ?Goal0 (nocc_eq2 n m (Cons nat p x))) \n            ?Goal) (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite H0.", "goal_before": ["si nat (egal_nat n m) (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) =\nS (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["si nat true (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) =\nS (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x)) \n               ?Goal0 (nocc_eq2 n m (Cons nat p x))) \n            ?Goal) (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x)) \n                  ?Goal0 H0) (nocc_eq2 n m (Cons nat p x))) \n            ?Goal) (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite si_eq1.", "goal_before": ["si nat true (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) =\nS (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["S (nocc n (Cons nat p x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x)) \n                  ?Goal0 H0) (nocc_eq2 n m (Cons nat p x))) \n            ?Goal) (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x)) \n                     ?Goal0\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["S (nocc n (Cons nat p x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["S (si nat (egal_nat n p) (S (nocc n x)) (nocc n x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x)) \n                     ?Goal0\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x)) \n                        ?Goal0 (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite H.", "goal_before": ["S (si nat (egal_nat n p) (S (nocc n x)) (nocc n x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["S (si nat false (S (nocc n x)) (nocc n x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x)) \n                        ?Goal0 (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x)) ?Goal0 H) \n                        (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite si_eq2.", "goal_before": ["S (si nat false (S (nocc n x)) (nocc n x)) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["S (nocc n x) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x)) ?Goal0 H) \n                        (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              ?Goal0 (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "apply refl_equal.", "goal_before": ["S (nocc n x) = S (nocc n x)", "egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              ?Goal0 (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "intro.", "goal_before": ["egal_nat n m = false -> nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x))) ?Goal) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false => ?Goal)) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["nocc n (Cons nat m (Cons nat p x)) = nocc n x"], "goal_after": ["si nat (egal_nat n m) (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) =\nnocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false => ?Goal)) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x) \n               ?Goal (nocc_eq2 n m (Cons nat p x)))) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite H0.", "goal_before": ["si nat (egal_nat n m) (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) =\nnocc n x"], "goal_after": ["si nat false (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x) \n               ?Goal (nocc_eq2 n m (Cons nat p x)))) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x) \n                  ?Goal H0) (nocc_eq2 n m (Cons nat p x)))) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite si_eq2.", "goal_before": ["si nat false (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x)) = nocc n x"], "goal_after": ["nocc n (Cons nat p x) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x) \n                  ?Goal H0) (nocc_eq2 n m (Cons nat p x)))) \n         (nocc_eq2 n m x))) (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x) \n                     ?Goal\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite nocc_eq2.", "goal_before": ["nocc n (Cons nat p x) = nocc n x"], "goal_after": ["si nat (egal_nat n p) (S (nocc n x)) (nocc n x) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x) \n                     ?Goal\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                     (eq_ind_r (fun n0 : nat => n0 = nocc n x) \n                        ?Goal (nocc_eq2 n p x))\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite H.", "goal_before": ["si nat (egal_nat n p) (S (nocc n x)) (nocc n x) = nocc n x"], "goal_after": ["si nat false (S (nocc n x)) (nocc n x) = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                     (eq_ind_r (fun n0 : nat => n0 = nocc n x) \n                        ?Goal (nocc_eq2 n p x))\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                     (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            si nat b (S (nocc n x)) (nocc n x) = nocc n x)\n                           ?Goal H) (nocc_eq2 n p x))\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "rewrite si_eq2.", "goal_before": ["si nat false (S (nocc n x)) (nocc n x) = nocc n x"], "goal_after": ["nocc n x = nocc n x"], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                     (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            si nat b (S (nocc n x)) (nocc n x) = nocc n x)\n                           ?Goal H) (nocc_eq2 n p x))\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                     (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            si nat b (S (nocc n x)) (nocc n x) = nocc n x)\n                           (eq_ind_r (fun n0 : nat => n0 = nocc n x) \n                              ?Goal (si_eq2 nat (S (nocc n x)) (nocc n x))) H)\n                        (nocc_eq2 n p x))\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "apply refl_equal.", "goal_before": ["nocc n x = nocc n x"], "goal_after": [], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                     (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            si nat b (S (nocc n x)) (nocc n x) = nocc n x)\n                           (eq_ind_r (fun n0 : nat => n0 = nocc n x) \n                              ?Goal (si_eq2 nat (S (nocc n x)) (nocc n x))) H)\n                        (nocc_eq2 n p x))\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                     (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            si nat b (S (nocc n x)) (nocc n x) = nocc n x)\n                           (eq_ind_r (fun n0 : nat => n0 = nocc n x) eq_refl\n                              (si_eq2 nat (S (nocc n x)) (nocc n x))) H)\n                        (nocc_eq2 n p x))\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n m p : nat) (x : list nat) =>\n eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n   (si_intro nat (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n      (S (nocc n (Cons nat m x))) (nocc n (Cons nat m x)) \n      (egal_nat n p)\n      (fun H : egal_nat n p = true =>\n       eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n         (si_intro nat (fun p0 : nat => p0 = S (nocc n (Cons nat m x)))\n            (S (nocc n (Cons nat p x))) (nocc n (Cons nat p x))\n            (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   S (si nat b (S (nocc n x)) (nocc n x)) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r\n                     (fun n0 : nat => S n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (S (nocc n x)) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (S (nocc n x)) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r\n                              (fun n0 : nat => S (S (nocc n x)) = S n0)\n                              eq_refl (si_eq1 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n x)) (nocc n x) =\n                   S (nocc n (Cons nat m x)))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n (Cons nat m x)))\n                     (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (nocc n x) =\n                            S (si nat b (S (nocc n x)) (nocc n x)))\n                           (eq_ind_r (fun n0 : nat => S (nocc n x) = S n0)\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H0) (nocc_eq2 n m x))\n                     (si_eq1 nat (S (nocc n x)) (nocc n x))) H)\n               (nocc_eq2 n p x))) (nocc_eq2 n m (Cons nat p x)))\n      (fun H : egal_nat n p = false =>\n       eq_ind_r (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n         (si_intro nat\n            (fun n0 : nat => nocc n (Cons nat m (Cons nat p x)) = n0)\n            (S (nocc n x)) (nocc n x) (egal_nat n m)\n            (fun H0 : egal_nat n m = true =>\n             eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = S (nocc n x))\n                  (eq_ind_r (fun n0 : nat => n0 = S (nocc n x))\n                     (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                        (eq_ind_r\n                           (fun b : bool =>\n                            S (si nat b (S (nocc n x)) (nocc n x)) =\n                            S (nocc n x))\n                           (eq_ind_r (fun n0 : nat => S n0 = S (nocc n x))\n                              eq_refl (si_eq2 nat (S (nocc n x)) (nocc n x)))\n                           H) (nocc_eq2 n p x))\n                     (si_eq1 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))\n            (fun H0 : egal_nat n m = false =>\n             eq_ind_r (fun n0 : nat => n0 = nocc n x)\n               (eq_ind_r\n                  (fun b : bool =>\n                   si nat b (S (nocc n (Cons nat p x)))\n                     (nocc n (Cons nat p x)) = nocc n x)\n                  (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                     (eq_ind_r (fun n0 : nat => n0 = nocc n x)\n                        (eq_ind_r\n                           (fun b : bool =>\n                            si nat b (S (nocc n x)) (nocc n x) = nocc n x)\n                           (eq_ind_r (fun n0 : nat => n0 = nocc n x) eq_refl\n                              (si_eq2 nat (S (nocc n x)) (nocc n x))) H)\n                        (nocc_eq2 n p x))\n                     (si_eq2 nat (S (nocc n (Cons nat p x)))\n                        (nocc n (Cons nat p x)))) H0)\n               (nocc_eq2 n m (Cons nat p x)))) (nocc_eq2 n m x)))\n   (nocc_eq2 n p (Cons nat m x)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "nocc_Cons", "text": "Theorem nocc_Cons :\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\nProof.\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\nQed.\n", "definition": "\n forall (n m : nat) (x y : list nat),\n nocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y).\n", "proof": "\nintros.\nunfold nocc in |- *.\napply si_intro.\n intro.\n rewrite H0.\n simpl in |- *.\n apply eq_S.\n assumption.\n intro.\n rewrite H0.\n simpl in |- *.\n assumption.\n", "def_ranges": [372, 0, 374, 70], "proof_ranges": [375, 0, 388, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall (n m : nat) (x y : list nat),\nnocc n x = nocc n y -> nocc n (Cons nat m x) = nocc n (Cons nat m y)"], "goal_after": ["nocc n (Cons nat m x) = nocc n (Cons nat m y)"], "proof_term_before": [], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) => ?Goal)"]}, {"text": "unfold nocc in |- *.", "goal_before": ["nocc n (Cons nat m x) = nocc n (Cons nat m y)"], "goal_after": ["si nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n x))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n ?Goal : nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "apply si_intro.", "goal_before": ["si nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n x))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["egal_nat n m = true ->\nS\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n ?Goal : nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m) ?Goal ?Goal0\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "intro.", "goal_before": ["egal_nat n m = true ->\nS\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["S\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m) ?Goal ?Goal0\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m) (fun H0 : egal_nat n m = true => ?Goal0)\n   ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "rewrite H0.", "goal_before": ["S\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["S\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nsi nat true\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m) (fun H0 : egal_nat n m = true => ?Goal0)\n   ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) ?Goal0 H0) ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "simpl in |- *.", "goal_before": ["S\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nsi nat true\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["S\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nS\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) ?Goal0 H0) ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (?Goal0\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0) ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "apply eq_S.", "goal_before": ["S\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n x) =\nS\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n y", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (?Goal0\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0) ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) ?Goal0\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0) ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "assumption.", "goal_before": ["(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n y", "egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) ?Goal0\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0) ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0) ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "intro.", "goal_before": ["egal_nat n m = false ->\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0) ?Goal\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0) (fun H0 : egal_nat n m = false => ?Goal)\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "rewrite H0.", "goal_before": ["(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat (egal_nat n m)\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat false\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0) (fun H0 : egal_nat n m = false => ?Goal)\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n   (fun H0 : egal_nat n m = false =>\n    eq_ind_r\n      (fun b : bool =>\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) ?Goal H0)\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "simpl in |- *.", "goal_before": ["(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\nsi nat false\n  (S\n     ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n         match l with\n         | @Nil _ => 0\n         | @Cons _ m0 x0 =>\n             si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n         end) n y))\n  ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n      match l with\n      | @Nil _ => 0\n      | @Cons _ m0 x0 =>\n          si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n      end) n y)"], "goal_after": ["(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n y"], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n   (fun H0 : egal_nat n m = false =>\n    eq_ind_r\n      (fun b : bool =>\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) ?Goal H0)\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n   (fun H0 : egal_nat n m = false =>\n    eq_ind_r\n      (fun b : bool =>\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (?Goal\n       :\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat false\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "assumption.", "goal_before": ["(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n x =\n(fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n   match l with\n   | @Nil _ => 0\n   | @Cons _ m0 x0 => si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n   end) n y"], "goal_after": [], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n   (fun H0 : egal_nat n m = false =>\n    eq_ind_r\n      (fun b : bool =>\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (?Goal\n       :\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat false\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n   (fun H0 : egal_nat n m = false =>\n    eq_ind_r\n      (fun b : bool =>\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (H\n       :\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat false\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (n m : nat) (x y : list nat) (H : nocc n x = nocc n y) =>\n si_intro nat\n   (fun n0 : nat =>\n    n0 =\n    si nat (egal_nat n m)\n      (S\n         ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n             end) n y))\n      ((fix nocc (n1 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n1 m0) (S (nocc n1 x0)) (nocc n1 x0)\n          end) n y))\n   (S\n      ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x))\n   ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n       match l with\n       | @Nil _ => 0\n       | @Cons _ m0 x0 =>\n           si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n       end) n x) (egal_nat n m)\n   (fun H0 : egal_nat n m = true =>\n    eq_ind_r\n      (fun b : bool =>\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (eq_S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x)\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y) H\n       :\n       S\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n x) =\n       si nat true\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n   (fun H0 : egal_nat n m = false =>\n    eq_ind_r\n      (fun b : bool =>\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat b\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y))\n      (H\n       :\n       (fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n          match l with\n          | @Nil _ => 0\n          | @Cons _ m0 x0 =>\n              si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n          end) n x =\n       si nat false\n         (S\n            ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n                match l with\n                | @Nil _ => 0\n                | @Cons _ m0 x0 =>\n                    si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n                end) n y))\n         ((fix nocc (n0 : nat) (l : list nat) {struct l} : nat :=\n             match l with\n             | @Nil _ => 0\n             | @Cons _ m0 x0 =>\n                 si nat (egal_nat n0 m0) (S (nocc n0 x0)) (nocc n0 x0)\n             end) n y)) H0)\n :\n nocc n (Cons nat m x) = nocc n (Cons nat m y))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "nocc_ins", "text": "Theorem nocc_ins :\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\nQed.\n", "definition": "\n forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x).\n", "proof": "\nsimple induction x.\n trivial.\n intros.\n rewrite ins_eq2.\n apply\n  (si_intro (list nat)\n     (fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).\n  trivial.\n  intro.\n  rewrite nocc_Cons_Cons.\n  apply nocc_Cons.\n  apply H.\n", "def_ranges": [390, 0, 391, 77], "proof_ranges": [392, 0, 405, 4], "proof_steps": [{"text": "simple induction x.", "goal_before": ["forall (x : list nat) (n m : nat), nocc n (ins m x) = nocc n (Cons nat m x)"], "goal_after": ["forall n m : nat, nocc n (ins m (Nil nat)) = nocc n (Cons nat m (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l)) ->\nforall n m : nat,\nnocc n (ins m (Cons nat x0 l)) = nocc n (Cons nat m (Cons nat x0 l))"], "proof_term_before": [], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0)) \n   ?Goal ?Goal0 x)"]}, {"text": "trivial.", "goal_before": ["forall n m : nat, nocc n (ins m (Nil nat)) = nocc n (Cons nat m (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l)) ->\nforall n m : nat,\nnocc n (ins m (Cons nat x0 l)) = nocc n (Cons nat m (Cons nat x0 l))"], "goal_after": ["forall (x0 : nat) (l : list nat),\n(forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l)) ->\nforall n m : nat,\nnocc n (ins m (Cons nat x0 l)) = nocc n (Cons nat m (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0)) \n   ?Goal ?Goal0 x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl) ?Goal x)"]}, {"text": "intros.", "goal_before": ["forall (x0 : nat) (l : list nat),\n(forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l)) ->\nforall n m : nat,\nnocc n (ins m (Cons nat x0 l)) = nocc n (Cons nat m (Cons nat x0 l))"], "goal_after": ["nocc n (ins m (Cons nat x0 l)) = nocc n (Cons nat m (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl) ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) => ?Goal) x)"]}, {"text": "rewrite ins_eq2.", "goal_before": ["nocc n (ins m (Cons nat x0 l)) = nocc n (Cons nat m (Cons nat x0 l))"], "goal_after": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) => ?Goal) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      ?Goal (ins_eq2 m x0 l)) x)"]}, {"text": "apply", "goal_before": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "goal_after": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      ?Goal (ins_eq2 m x0 l)) x)"], "proof_term_after": []}, {"text": "(si_intro (list nat)", "goal_before": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "goal_after": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "proof_term_before": [], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      ?Goal (ins_eq2 m x0 l)) x)"]}, {"text": "(fun t : list nat => nocc n t = nocc n (Cons nat m (Cons nat x0 l)))).", "goal_before": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "goal_after": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      ?Goal (ins_eq2 m x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      ?Goal (ins_eq2 m x0 l)) x)"]}, {"text": "trivial.", "goal_before": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "goal_after": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      ?Goal (ins_eq2 m x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      ?Goal (ins_eq2 m x0 l)) x)"]}, {"text": "intro.", "goal_before": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat m (Cons nat x0 l))"], "goal_after": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat x0 (Cons nat m l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      ?Goal (ins_eq2 m x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      (eq_ind_r\n         (fun n0 : nat =>\n          nocc n\n            (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n               (Cons nat x0 (ins m l))) = n0) ?Goal \n         (nocc_Cons_Cons n m x0 l)) (ins_eq2 m x0 l)) x)"]}, {"text": "rewrite nocc_Cons_Cons.", "goal_before": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat x0 (Cons nat m l))"], "goal_after": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat x0 (Cons nat m l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      (eq_ind_r\n         (fun n0 : nat =>\n          nocc n\n            (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n               (Cons nat x0 (ins m l))) = n0) ?Goal \n         (nocc_Cons_Cons n m x0 l)) (ins_eq2 m x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      (eq_ind_r\n         (fun n0 : nat =>\n          nocc n\n            (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n               (Cons nat x0 (ins m l))) = n0) ?Goal \n         (nocc_Cons_Cons n m x0 l)) (ins_eq2 m x0 l)) x)"]}, {"text": "apply nocc_Cons.", "goal_before": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat x0 (Cons nat m l))"], "goal_after": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat x0 (Cons nat m l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      (eq_ind_r\n         (fun n0 : nat =>\n          nocc n\n            (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n               (Cons nat x0 (ins m l))) = n0) ?Goal \n         (nocc_Cons_Cons n m x0 l)) (ins_eq2 m x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      (eq_ind_r\n         (fun n0 : nat =>\n          nocc n\n            (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n               (Cons nat x0 (ins m l))) = n0) ?Goal \n         (nocc_Cons_Cons n m x0 l)) (ins_eq2 m x0 l)) x)"]}, {"text": "apply H.", "goal_before": ["nocc n\n  (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n     (Cons nat x0 (ins m l))) = nocc n (Cons nat x0 (Cons nat m l))"], "goal_after": [], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat =>\n    forall n m : nat, nocc n (ins m x0) = nocc n (Cons nat m x0))\n   (fun n m : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n m : nat, nocc n (ins m l) = nocc n (Cons nat m l))\n      (n m : nat) =>\n    eq_ind_r\n      (fun l0 : list nat => nocc n l0 = nocc n (Cons nat m (Cons nat x0 l)))\n      (eq_ind_r\n         (fun n0 : nat =>\n          nocc n\n            (si (list nat) (inf_egal m x0) (Cons nat m (Cons nat x0 l))\n               (Cons nat x0 (ins m l))) = n0) ?Goal \n         (nocc_Cons_Cons n m x0 l)) (ins_eq2 m x0 l)) x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/demos/Sorting.v", "name": "nocc_tri_ins", "text": "Theorem nocc_tri_ins :\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\nProof.\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\nQed.\n", "definition": "\n forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x).\n", "proof": "\nsimple induction x.\n trivial.\n intros.\n rewrite tri_ins_eq2.\n rewrite nocc_ins.\n apply nocc_Cons.\n apply H.\n", "def_ranges": [407, 0, 408, 64], "proof_ranges": [409, 0, 417, 4], "proof_steps": [{"text": "simple induction x.", "goal_before": ["forall (x : list nat) (n : nat), nocc n x = nocc n (tri_ins x)"], "goal_after": ["forall n : nat, nocc n (Nil nat) = nocc n (tri_ins (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n : nat, nocc n l = nocc n (tri_ins l)) ->\nforall n : nat, nocc n (Cons nat x0 l) = nocc n (tri_ins (Cons nat x0 l))"], "proof_term_before": [], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   ?Goal ?Goal0 x)"]}, {"text": "trivial.", "goal_before": ["forall n : nat, nocc n (Nil nat) = nocc n (tri_ins (Nil nat))", "forall (x0 : nat) (l : list nat),\n(forall n : nat, nocc n l = nocc n (tri_ins l)) ->\nforall n : nat, nocc n (Cons nat x0 l) = nocc n (tri_ins (Cons nat x0 l))"], "goal_after": ["forall (x0 : nat) (l : list nat),\n(forall n : nat, nocc n l = nocc n (tri_ins l)) ->\nforall n : nat, nocc n (Cons nat x0 l) = nocc n (tri_ins (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   ?Goal ?Goal0 x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl) ?Goal x)"]}, {"text": "intros.", "goal_before": ["forall (x0 : nat) (l : list nat),\n(forall n : nat, nocc n l = nocc n (tri_ins l)) ->\nforall n : nat, nocc n (Cons nat x0 l) = nocc n (tri_ins (Cons nat x0 l))"], "goal_after": ["nocc n (Cons nat x0 l) = nocc n (tri_ins (Cons nat x0 l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl) ?Goal x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) => ?Goal) x)"]}, {"text": "rewrite tri_ins_eq2.", "goal_before": ["nocc n (Cons nat x0 l) = nocc n (tri_ins (Cons nat x0 l))"], "goal_after": ["nocc n (Cons nat x0 l) = nocc n (ins x0 (tri_ins l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) => ?Goal) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) =>\n    eq_ind_r (fun l0 : list nat => nocc n (Cons nat x0 l) = nocc n l0) \n      ?Goal (tri_ins_eq2 x0 l)) x)"]}, {"text": "rewrite nocc_ins.", "goal_before": ["nocc n (Cons nat x0 l) = nocc n (ins x0 (tri_ins l))"], "goal_after": ["nocc n (Cons nat x0 l) = nocc n (Cons nat x0 (tri_ins l))"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) =>\n    eq_ind_r (fun l0 : list nat => nocc n (Cons nat x0 l) = nocc n l0) \n      ?Goal (tri_ins_eq2 x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) =>\n    eq_ind_r (fun l0 : list nat => nocc n (Cons nat x0 l) = nocc n l0)\n      (eq_ind_r (fun n0 : nat => nocc n (Cons nat x0 l) = n0) \n         ?Goal (nocc_ins (tri_ins l) n x0)) (tri_ins_eq2 x0 l)) x)"]}, {"text": "apply nocc_Cons.", "goal_before": ["nocc n (Cons nat x0 l) = nocc n (Cons nat x0 (tri_ins l))"], "goal_after": ["nocc n l = nocc n (tri_ins l)"], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) =>\n    eq_ind_r (fun l0 : list nat => nocc n (Cons nat x0 l) = nocc n l0)\n      (eq_ind_r (fun n0 : nat => nocc n (Cons nat x0 l) = n0) \n         ?Goal (nocc_ins (tri_ins l) n x0)) (tri_ins_eq2 x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) =>\n    eq_ind_r (fun l0 : list nat => nocc n (Cons nat x0 l) = nocc n l0)\n      (eq_ind_r (fun n0 : nat => nocc n (Cons nat x0 l) = n0)\n         (nocc_Cons n x0 l (tri_ins l) ?Goal) (nocc_ins (tri_ins l) n x0))\n      (tri_ins_eq2 x0 l)) x)"]}, {"text": "apply H.", "goal_before": ["nocc n l = nocc n (tri_ins l)"], "goal_after": [], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) =>\n    eq_ind_r (fun l0 : list nat => nocc n (Cons nat x0 l) = nocc n l0)\n      (eq_ind_r (fun n0 : nat => nocc n (Cons nat x0 l) = n0)\n         (nocc_Cons n x0 l (tri_ins l) ?Goal) (nocc_ins (tri_ins l) n x0))\n      (tri_ins_eq2 x0 l)) x)"], "proof_term_after": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) =>\n    eq_ind_r (fun l0 : list nat => nocc n (Cons nat x0 l) = nocc n l0)\n      (eq_ind_r (fun n0 : nat => nocc n (Cons nat x0 l) = n0)\n         (nocc_Cons n x0 l (tri_ins l) (H n)) (nocc_ins (tri_ins l) n x0))\n      (tri_ins_eq2 x0 l)) x)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : list nat =>\n list_ind nat\n   (fun x0 : list nat => forall n : nat, nocc n x0 = nocc n (tri_ins x0))\n   (fun n : nat => eq_refl)\n   (fun (x0 : nat) (l : list nat)\n      (H : forall n : nat, nocc n l = nocc n (tri_ins l)) \n      (n : nat) =>\n    eq_ind_r (fun l0 : list nat => nocc n (Cons nat x0 l) = nocc n l0)\n      (eq_ind_r (fun n0 : nat => nocc n (Cons nat x0 l) = n0)\n         (nocc_Cons n x0 l (tri_ins l) (H n)) (nocc_ins (tri_ins l) n x0))\n      (tri_ins_eq2 x0 l)) x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/mini-compiler/compiler.v", "name": "correctness", "text": "Theorem correctness :\n forall (e : expr) (m : symt) (s : state) (s' : store) (r : nat),\n (forall v : string, m v < r) ->\n (forall v : string, s v = s' (Reg (m v))) ->\n Sl s' (C m r e) Acc = E s e /\\\n (forall x : nat, x < r -> Sl s' (C m r e) (Reg x) = s' (Reg x)).\nProof.\nsimple induction e; simpl in |- *; intros.\nintuition.\nintuition.\nunfold update in |- *; simpl in |- *; intuition.\nrepeat rewrite Sl_append.\ngeneralize (H m s s' r H1 H2).\nintros (H3, H4).\nset (s'' := Sl (Sl s' (C m r e0)) (list1 (STO r))) in *.\nassert (H01 : forall v : string, m v < S r).\nintuition.\nassert (H02 : forall v : string, s v = s'' (Reg (m v))).\nintro; unfold s'' in |- *; simpl in |- *; unfold update in |- *.\ncase (cell_eq_dec (Reg (m v)) (Reg r)); intro.\ninjection e2; generalize (H1 v); omega.\nrewrite H2. rewrite H4. trivial.\nintuition.\ngeneralize (H0 m s s'' (S r) H01 H02); intuition.\nsimpl in |- *.\nrewrite H6.\nunfold s'' in |- *; simpl in |- *.\nrewrite H3.\nunfold update in |- *; simpl in |- *.\napply (f_equal2 plus); trivial.\nrewrite Sl_invariant. \ncase (cell_eq_dec (Reg r) (Reg r)); intro.\ntrivial.\nelim n; trivial. omega.\nsimpl in |- *.\nrewrite H7.\nunfold s'' in |- *; simpl in |- *.\nrewrite H3.\nunfold update in |- *; simpl in |- *.\nrewrite Sl_invariant. \ncase (cell_eq_dec (Reg x) (Reg r)); intro.\ninjection e2; omega.\nrewrite H4; trivial.\nomega.\nomega.\nQed.\n", "definition": "\n forall (e : expr) (m : symt) (s : state) (s' : store) (r : nat),\n (forall v : string, m v < r) ->\n (forall v : string, s v = s' (Reg (m v))) ->\n Sl s' (C m r e) Acc = E s e /\\\n (forall x : nat, x < r -> Sl s' (C m r e) (Reg x) = s' (Reg x)).\n", "proof": "\nsimple induction e; simpl in |- *; intros.\nintuition.\nintuition.\nunfold update in |- *; simpl in |- *; intuition.\nrepeat rewrite Sl_append.\ngeneralize (H m s s' r H1 H2).\nintros (H3, H4).\nset (s'' := Sl (Sl s' (C m r e0)) (list1 (STO r))) in *.\nassert (H01 : forall v : string, m v < S r).\nintuition.\nassert (H02 : forall v : string, s v = s'' (Reg (m v))).\nintro; unfold s'' in |- *; simpl in |- *; unfold update in |- *.\ncase (cell_eq_dec (Reg (m v)) (Reg r)); intro.\ninjection e2; generalize (H1 v); omega.\nrewrite H2. rewrite H4. trivial.\nintuition.\ngeneralize (H0 m s s'' (S r) H01 H02); intuition.\nsimpl in |- *.\nrewrite H6.\nunfold s'' in |- *; simpl in |- *.\nrewrite H3.\nunfold update in |- *; simpl in |- *.\napply (f_equal2 plus); trivial.\nrewrite Sl_invariant. \ncase (cell_eq_dec (Reg r) (Reg r)); intro.\ntrivial.\nelim n; trivial. omega.\nsimpl in |- *.\nrewrite H7.\nunfold s'' in |- *; simpl in |- *.\nrewrite H3.\nunfold update in |- *; simpl in |- *.\nrewrite Sl_invariant. \ncase (cell_eq_dec (Reg x) (Reg r)); intro.\ninjection e2; omega.\nrewrite H4; trivial.\nomega.\nomega.\n", "def_ranges": [133, 0, 138, 65], "proof_ranges": [139, 0, 178, 4], "proof_steps": [{"text": "simple induction e; simpl in |- *; intros.", "goal_before": ["forall (e : expr) (m : symt) (s : state) (s' : store) (r : nat),\n(forall v : string, m v < r) ->\n(forall v : string, s v = s' (Reg (m v))) ->\nSl s' (C m r e) Acc = E s e /\\\n(forall x : nat, x < r -> Sl s' (C m r e) (Reg x) = s' (Reg x))"], "goal_after": ["update s' Acc n Acc = n /\\\n(forall x : nat, x < r -> update s' Acc n (Reg x) = s' (Reg x))", "update s' Acc (s' (Reg (m s))) Acc = s0 s /\\\n(forall x : nat, x < r -> update s' Acc (s' (Reg (m s))) (Reg x) = s' (Reg x))", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\nE s e0 + E s e1 /\\\n(forall x : nat,\n x < r ->\n Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\n s' (Reg x))"], "proof_term_before": [], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (H : forall v : string, m v < r)\n       (H0 : forall v : string, s v = s' (Reg (m v))) => \n     ?Goal)\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (H : forall v : string, m v < r)\n       (H0 : forall v : string, s0 v = s' (Reg (m v))) => \n     ?Goal0)\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) => \n     ?Goal1)\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "intuition.", "goal_before": ["update s' Acc n Acc = n /\\\n(forall x : nat, x < r -> update s' Acc n (Reg x) = s' (Reg x))", "update s' Acc (s' (Reg (m s))) Acc = s0 s /\\\n(forall x : nat, x < r -> update s' Acc (s' (Reg (m s))) (Reg x) = s' (Reg x))", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\nE s e0 + E s e1 /\\\n(forall x : nat,\n x < r ->\n Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\n s' (Reg x))"], "goal_after": ["update s' Acc (s' (Reg (m s))) Acc = s0 s /\\\n(forall x : nat, x < r -> update s' Acc (s' (Reg (m s))) (Reg x) = s' (Reg x))", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\nE s e0 + E s e1 /\\\n(forall x : nat,\n x < r ->\n Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\n s' (Reg x))"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (H : forall v : string, m v < r)\n       (H0 : forall v : string, s v = s' (Reg (m v))) => \n     ?Goal)\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (H : forall v : string, m v < r)\n       (H0 : forall v : string, s0 v = s' (Reg (m v))) => \n     ?Goal0)\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) => \n     ?Goal1)\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (H : forall v : string, m v < r)\n       (H0 : forall v : string, s0 v = s' (Reg (m v))) => \n     ?Goal)\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) => \n     ?Goal0)\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "intuition.", "goal_before": ["update s' Acc (s' (Reg (m s))) Acc = s0 s /\\\n(forall x : nat, x < r -> update s' Acc (s' (Reg (m s))) (Reg x) = s' (Reg x))", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\nE s e0 + E s e1 /\\\n(forall x : nat,\n x < r ->\n Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\n s' (Reg x))"], "goal_after": ["Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\nE s e0 + E s e1 /\\\n(forall x : nat,\n x < r ->\n Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\n s' (Reg x))"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (H : forall v : string, m v < r)\n       (H0 : forall v : string, s0 v = s' (Reg (m v))) => \n     ?Goal)\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) => \n     ?Goal0)\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) => \n     ?Goal)\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "unfold update in |- *; simpl in |- *; intuition.", "goal_before": ["Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\nE s e0 + E s e1 /\\\n(forall x : nat,\n x < r ->\n Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\n s' (Reg x))"], "goal_after": ["Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\nE s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) => \n     ?Goal)\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj ?Goal (fun (x : nat) (H3 : x < r) => ?Goal0)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "repeat rewrite Sl_append.", "goal_before": ["Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\nE s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["Sl (Sl (Sl (Sl s' (C m r e0)) (list1 (STO r))) (C m (S r) e1))\n  (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj ?Goal (fun (x : nat) (H3 : x < r) => ?Goal0)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1) ?Goal0\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "generalize (H m s s' r H1 H2).", "goal_before": ["Sl (Sl (Sl (Sl s' (C m r e0)) (list1 (STO r))) (C m (S r) e1))\n  (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["Sl s' (C m r e0) Acc = E s e0 /\\\n(forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) ->\nSl (Sl (Sl (Sl s' (C m r e0)) (list1 (STO r))) (C m (S r) e1))\n  (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1) ?Goal0\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1) (?Goal0 (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "intros (H3, H4).", "goal_before": ["Sl s' (C m r e0) Acc = E s e0 /\\\n(forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) ->\nSl (Sl (Sl (Sl s' (C m r e0)) (list1 (STO r))) (C m (S r) e1))\n  (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["Sl (Sl (Sl (Sl s' (C m r e0)) (list1 (STO r))) (C m (S r) e1))\n  (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1) (?Goal0 (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "set (s'' := Sl (Sl s' (C m r e0)) (list1 (STO r))) in *.", "goal_before": ["Sl (Sl (Sl (Sl s' (C m r e0)) (list1 (STO r))) (C m (S r) e1))\n  (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "assert (H01 : forall v : string, m v < S r).", "goal_before": ["Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["forall v : string, m v < S r", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r := ?Goal0 in\n                        ?Goal1) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "intuition.", "goal_before": ["forall v : string, m v < S r", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r := ?Goal0 in\n                        ?Goal1) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "assert (H02 : forall v : string, s v = s'' (Reg (m v))).", "goal_before": ["Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["forall v : string, s v = s'' (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          ?Goal0 in\n                        ?Goal1) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "intro; unfold s'' in |- *; simpl in |- *; unfold update in |- *.", "goal_before": ["forall v : string, s v = s'' (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s v =\n(if cell_eq_dec (Reg (m v)) (Reg r)\n then Sl s' (C m r e0) Acc\n else Sl s' (C m r e0) (Reg (m v)))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          ?Goal0 in\n                        ?Goal1) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((?Goal1\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "case (cell_eq_dec (Reg (m v)) (Reg r)); intro.", "goal_before": ["s v =\n(if cell_eq_dec (Reg (m v)) (Reg r)\n then Sl s' (C m r e0) Acc\n else Sl s' (C m r e0) (Reg (m v)))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s v = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((?Goal1\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r => ?Goal1) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal2) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "injection e2; generalize (H1 v); omega.", "goal_before": ["s v = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s v = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r => ?Goal1) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal2) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r => ?Goal1) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal2) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite H2.", "goal_before": ["s v = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r => ?Goal1) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal2) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite H4.", "goal_before": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "trivial.", "goal_before": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "intuition.", "goal_before": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "generalize (H0 m s s'' (S r) H01 H02); intuition.", "goal_before": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "simpl in |- *.", "goal_before": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   ?Goal2 (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (?Goal2\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite H6.", "goal_before": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (?Goal2\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (?Goal2\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "unfold s'' in |- *; simpl in |- *.", "goal_before": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (?Goal2\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((?Goal2\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite H3.", "goal_before": ["s' (Reg (m v)) = Sl s' (C m r e0) Acc", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((?Goal2\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ?Goal2 H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "unfold update in |- *; simpl in |- *.", "goal_before": ["s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ?Goal2 H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((?Goal2 : s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "apply (f_equal2 plus); trivial.", "goal_before": ["s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((?Goal2 : s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((?Goal2 : s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite Sl_invariant.", "goal_before": ["s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((?Goal2 : s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((?Goal2 : s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "case (cell_eq_dec (Reg r) (Reg r)); intro.", "goal_before": ["s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((?Goal2 : s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal2) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal3) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "trivial.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal2) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal3) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal2) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal3) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "elim n; trivial.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal2) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal3) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal2) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal3) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "omega.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal2) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal3) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal2) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal3) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "simpl in |- *.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal2) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal3) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal3\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite H7.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal3\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal3\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "unfold s'' in |- *; simpl in |- *.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ?Goal3\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite H3.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "unfold update in |- *; simpl in |- *.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite Sl_invariant.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "case (cell_eq_dec (Reg x) (Reg r)); intro.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "injection e2; omega.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "rewrite H4; trivial.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "omega.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "omega.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"]}, {"text": "Qed.", "goal_before": ["s' (Reg (m v)) = E s e0", "s' (Reg (m v)) = E s e0", "s v = Sl s' (C m r e0) (Reg (m v))", "Sl (Sl s'' (C m (S r) e1)) (list1 (ADD r)) Acc = E s e0 + E s e1", "Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) (Reg x) =\ns' (Reg x)"], "goal_after": [], "proof_term_before": ["(fun e : expr =>\n expr_ind\n   (fun e0 : expr =>\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r e0) Acc = E s e0 /\\\n    (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n   ((fun (n : nat) (m : symt) (s : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (_ : forall v : string, s v = s' (Reg (m v))) =>\n     conj eq_refl (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (n : nat) (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Lit n)) Acc = E s (Lit n) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Lit n)) (Reg x) = s' (Reg x)))\n   ((fun (s : string) (m : symt) (s0 : state) (s' : store) \n       (r : nat) (_ : forall v : string, m v < r)\n       (H : forall v : string, s0 v = s' (Reg (m v))) =>\n     conj (eq_sym (H s) : update s' Acc (s' (Reg (m s))) Acc = s0 s)\n       (fun (x : nat) (_ : x < r) => eq_refl))\n    :\n    forall (s : string) (m : symt) (s0 : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s0 v = s' (Reg (m v))) ->\n    Sl s' (C m r (Var s)) Acc = E s0 (Var s) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Var s)) (Reg x) = s' (Reg x)))\n   ((fun (e0 : expr)\n       (H : forall (m : symt) (s : state) (s' : store) (r : nat),\n            (forall v : string, m v < r) ->\n            (forall v : string, s v = s' (Reg (m v))) ->\n            Sl s' (C m r e0) Acc = E s e0 /\\\n            (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)))\n       (e1 : expr)\n       (H0 : forall (m : symt) (s : state) (s' : store) (r : nat),\n             (forall v : string, m v < r) ->\n             (forall v : string, s v = s' (Reg (m v))) ->\n             Sl s' (C m r e1) Acc = E s e1 /\\\n             (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x)))\n       (m : symt) (s : state) (s' : store) (r : nat)\n       (H1 : forall v : string, m v < r)\n       (H2 : forall v : string, s v = s' (Reg (m v))) =>\n     (conj\n        (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n           (eq_ind_r (fun s0 : store => s0 Acc = E s e0 + E s e1)\n              (eq_ind_r\n                 (fun s0 : store =>\n                  Sl (Sl s0 (C m (S r) e1)) (list1 (ADD r)) Acc =\n                  E s e0 + E s e1)\n                 ((fun\n                     H5 : Sl s' (C m r e0) Acc = E s e0 /\\\n                          (forall x : nat,\n                           x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x)) =>\n                   match H5 with\n                   | conj x x0 =>\n                       (fun (H3 : Sl s' (C m r e0) Acc = E s e0)\n                          (H4 : forall x1 : nat,\n                                x1 < r ->\n                                Sl s' (C m r e0) (Reg x1) = s' (Reg x1)) =>\n                        let s'' := Sl (Sl s' (C m r e0)) (list1 (STO r)) in\n                        let H01 : forall v : string, m v < S r :=\n                          fun v : string =>\n                          Nat.lt_lt_succ_r (m v) r (H1 v) : m v < S r in\n                        let H02 : forall v : string, s v = s'' (Reg (m v)) :=\n                          fun v : string =>\n                          ((match\n                              cell_eq_dec (Reg (m v)) (Reg r) as s0\n                              return\n                                (s v =\n                                 (if s0\n                                  then Sl s' (C m r e0) Acc\n                                  else Sl s' (C m r e0) (Reg (m v))))\n                            with\n                            | left a =>\n                                (fun e2 : Reg (m v) = Reg r =>\n                                 eq_ind_r\n                                   (fun n : nat => n = Sl s' (C m r e0) Acc)\n                                   (((eq_ind_r\n                                        (fun n : nat => s' (Reg (m v)) = n)\n                                        ((match\n                                            cell_eq_dec (Reg r) (Reg r)\n                                          with\n                                          | left a0 =>\n                                              (fun e3 : Reg r = Reg r =>\n                                               ((((?Goal3\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                 :\n                                                 s' (Reg (m v)) = E s e0)\n                                                :\n                                                s' (Reg (m v)) = E s e0)\n                                               :\n                                               s' (Reg (m v)) = E s e0) a0\n                                          | right b =>\n                                              (fun n : Reg r <> Reg r =>\n                                               ?Goal2) b\n                                          end\n                                          :\n                                          s' (Reg (m v)) = E s e0)\n                                         :\n                                         s' (Reg (m v)) = E s e0) H3\n                                      :\n                                      s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                     :\n                                     s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                    :\n                                    s' (Reg (m v)) = Sl s' (C m r e0) Acc)\n                                   (H2 v)) a\n                            | right b =>\n                                (fun n : Reg (m v) <> Reg r => ?Goal1) b\n                            end\n                            :\n                            s v =\n                            update (Sl s' (C m r e0)) \n                              (Reg r) (Sl s' (C m r e0) Acc) \n                              (Reg (m v)))\n                           :\n                           s v =\n                           Sl (Sl s' (C m r e0)) (list1 (STO r)) (Reg (m v)))\n                          :\n                          s v = s'' (Reg (m v)) in\n                        ?Goal0) x x0\n                   end) (H m s s' r H1 H2))\n                 (Sl_append (C m r e0) (list1 (STO r)) s'))\n              (Sl_append (C m (S r) e1) (list1 (ADD r))\n                 (Sl s' (C m r e0 ++ list1 (STO r)))))\n           (Sl_append (C m r e0 ++ list1 (STO r))\n              (C m (S r) e1 ++ list1 (ADD r)) s'))\n        (fun (x : nat) (H3 : x < r) => ?Goal)\n      :\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        Acc = E s e0 + E s e1 /\\\n      (forall x : nat,\n       x < r ->\n       Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n         (Reg x) = s' (Reg x)))\n     :\n     Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r)) Acc =\n     E s e0 + E s e1 /\\\n     (forall x : nat,\n      x < r ->\n      Sl s' ((C m r e0 ++ list1 (STO r)) ++ C m (S r) e1 ++ list1 (ADD r))\n        (Reg x) = s' (Reg x)))\n    :\n    forall e0 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e0) Acc = E s e0 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e0) (Reg x) = s' (Reg x))) ->\n    forall e1 : expr,\n    (forall (m : symt) (s : state) (s' : store) (r : nat),\n     (forall v : string, m v < r) ->\n     (forall v : string, s v = s' (Reg (m v))) ->\n     Sl s' (C m r e1) Acc = E s e1 /\\\n     (forall x : nat, x < r -> Sl s' (C m r e1) (Reg x) = s' (Reg x))) ->\n    forall (m : symt) (s : state) (s' : store) (r : nat),\n    (forall v : string, m v < r) ->\n    (forall v : string, s v = s' (Reg (m v))) ->\n    Sl s' (C m r (Plus e0 e1)) Acc = E s (Plus e0 e1) /\\\n    (forall x : nat, x < r -> Sl s' (C m r (Plus e0 e1)) (Reg x) = s' (Reg x)))\n   e)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/fundamental-arithmetics/nthroot.v", "name": "sqrt_prime_irrat", "text": "Theorem sqrt_prime_irrat : forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n", "definition": " forall (p k a b:nat),(is_prime p)->(rel_prime p k)->(b<>O)->(p*k*(square b) <> (square a)).", "proof": "\n  intros.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.\n  intro.\n  rewrite H3 in H5.\n  replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.\n  rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.\n  assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).\n  apply mult_lemma6 with (square (gcd a b)).\n  unfold square.\n  generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.\n  intro;apply H6.\n  case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.\n  rewrite <- H5;ring.\n  apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\n", "def_ranges": [61, 0, 61, 118], "proof_ranges": [62, 0, 79, 4], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (gcd_is_gcd a b);intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H2));intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H2));intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H3 in H5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (square b) with (square (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H2))) in H5;auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite square_mult_lemma in H5;rewrite square_mult_lemma in H5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (p*k*(square (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)))=(square (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply mult_lemma6 with (square (gcd a b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold square.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (gcd_non_zero (gcd a b) a b H1 H2);intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro;apply H6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (mult_lemma2 (gcd a b) (gcd a b) H7);trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H5;ring.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (sqrt_prime_irrat_aux p k (quo a (gcd a b) (gcd_div_l (gcd a b) a b H2)) (quo b (gcd a b) (gcd_div_r (gcd a b) a b H2)));auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/fundamental-arithmetics/nthroot.v", "name": "nth_root_irrat", "text": "Theorem nth_root_irrat : forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\n  assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\n  assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\nQed.\n", "definition": " forall (p k a b n r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p r)*k*(power b n) <> (power a n)).", "proof": "\n  intros.\n  intro.\n  generalize (gcd_is_gcd a b);intro.\n  generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.\n  generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.\n  assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).\n  assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).\n  rewrite power_mult_lemma1 in H8;rewrite H8 in H4.\n  rewrite power_mult_lemma1 in H9;rewrite H9 in H4.\n  rewrite mult_lemma7 in H4.\n  assert ((power (gcd a b) n)<>O).\n  intro.\n  generalize (power_zero n (gcd a b) H10);intro.\n  apply (gcd_non_zero (gcd a b) a b);trivial.\n  generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).\n  fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).\n  apply nth_root_irrat_aux;trivial.\n  apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.\n", "def_ranges": [132, 0, 132, 146], "proof_ranges": [133, 0, 151, 4], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (gcd_is_gcd a b);intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (quo_is_quo a (gcd a b) (gcd_div_l (gcd a b) a b H5));intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (quo_is_quo b (gcd a b) (gcd_div_r (gcd a b) a b H5));intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert ((power a n)=(power (gcd a b * quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n));try (rewrite <- H6;trivial).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert ((power b n)=(power (gcd a b * quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n));try (rewrite <- H7;trivial).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite power_mult_lemma1 in H8;rewrite H8 in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite power_mult_lemma1 in H9;rewrite H9 in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite mult_lemma7 in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert ((power (gcd a b) n)<>O).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (power_zero n (gcd a b) H10);intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (gcd_non_zero (gcd a b) a b);trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (mult_lemma6 (power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n) (power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n) (power (gcd a b) n) H10 H4).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fold ((power p r * k * power (quo b (gcd a b) (gcd_div_r (gcd a b) a b H5)) n)<>(power (quo a (gcd a b) (gcd_div_l (gcd a b) a b H5)) n)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply nth_root_irrat_aux;trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply gcd_rel_prime;apply (gcd_non_zero (gcd a b) a b);trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/fundamental-arithmetics/nthroot.v", "name": "nth_root_irrational", "text": "Theorem nth_root_irrational : forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).\n  intros.\n  intro.\n  rewrite power_plus_lemma1 in H4.\n  assert (divides a (power p q)).\n  apply prime_power_qn with n;try (auto with arith);try omega.\n  exists ((power p r)*k*(power b n)).\n  rewrite <- H4;ring.\n  assert (0<n);try omega.\n  elim H5;intro a';intro.\n  rewrite H7 in H4.\n  rewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\n  assert ((power p (q*n))<>0).\n  intro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\n  rewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\n  generalize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\n  fold (power p r * k * power b n <> power a' n).\n  apply nth_root_irrat;trivial.\nQed.\n", "definition": " forall (p k a b n q r:nat),(is_prime p)->(rel_prime p k)->(0<r)->(r<n)->(b<>0)->((power p (q*n+r))*k*(power b n) <> (power a n)).", "proof": "\n  intros.\n  intro.\n  rewrite power_plus_lemma1 in H4.\n  assert (divides a (power p q)).\n  apply prime_power_qn with n;try (auto with arith);try omega.\n  exists ((power p r)*k*(power b n)).\n  rewrite <- H4;ring.\n  assert (0<n);try omega.\n  elim H5;intro a';intro.\n  rewrite H7 in H4.\n  rewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.\n  assert ((power p (q*n))<>0).\n  intro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.\n  rewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.\n  generalize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).\n  fold (power p r * k * power b n <> power a' n).\n  apply nth_root_irrat;trivial.\n", "def_ranges": [154, 0, 154, 159], "proof_ranges": [155, 0, 172, 4], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite power_plus_lemma1 in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (divides a (power p q)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply prime_power_qn with n;try (auto with arith);try omega.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists ((power p r)*k*(power b n)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H4;ring.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (0<n);try omega.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H5;intro a';intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H7 in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite power_mult_lemma1 in H4;rewrite power_power_lemma1 in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert ((power p (q*n))<>0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro;apply not_prime_zero;generalize (power_zero (q*n) p H8);intro;rewrite H9 in H;trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (mult_assoc (power p (q*n))) in H4;rewrite <- (mult_assoc (power p (q*n))) in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (mult_lemma6 (power p r*k*power b n) (power a' n) (power p (q*n)) H8 H4).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fold (power p r * k * power b n <> power a' n).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply nth_root_irrat;trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/fundamental-arithmetics/nthroot.v", "name": "nth_root", "text": "Theorem nth_root : forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.\n  intros.\n  case (is_power_m_dec x n H);intro;try tauto.\n  elim s;intro p;intro.\n  elim p0;intro q;intro.\n  elim p1;intro r;intro.\n  elim p2;intro k;intro.\n  right;intros.\n  assert (x=(power p (q*n+r))*k);try tauto.\n  rewrite H1;apply nth_root_irrational;tauto.\nQed.\n", "definition": " forall (x n:nat),(n>0)->{y:nat | x=(power y n)}+{forall (a b:nat),(b<>0)->x*(power b n)<>(power a n)}.", "proof": "\n  intros.\n  case (is_power_m_dec x n H);intro;try tauto.\n  elim s;intro p;intro.\n  elim p0;intro q;intro.\n  elim p1;intro r;intro.\n  elim p2;intro k;intro.\n  right;intros.\n  assert (x=(power p (q*n+r))*k);try tauto.\n  rewrite H1;apply nth_root_irrational;tauto.\n", "def_ranges": [175, 0, 175, 121], "proof_ranges": [176, 0, 185, 4], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case (is_power_m_dec x n H);intro;try tauto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim s;intro p;intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim p0;intro q;intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim p1;intro r;intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim p2;intro k;intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "right;intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (x=(power p (q*n+r))*k);try tauto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H1;apply nth_root_irrational;tauto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/fundamental-arithmetics/euclide.v", "name": "euclide", "text": "Theorem euclide : forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\nQed.\n", "definition": " forall (a b:nat),(b<>O)->{q:nat & { r:nat | (a=b*q+r) /\\ (r < b)}}.", "proof": "\n  intros.\n  apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b}})).\n  intros.\n  case (le_lt_dec b n);intro.\n  elim (H0 (n-b)).\n  intro q;intro.\n  elim p;intro r;intro.\n  exists (q+1);exists r.\n  split;try tauto.\n  rewrite (le_plus_minus b n);trivial.\n  elim p0;intros.\n  rewrite H1;ring.\n  omega.\n  exists 0;exists n.\n  split;try tauto.\n  ring.\n", "def_ranges": [35, 0, 35, 85], "proof_ranges": [36, 0, 52, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall a b : nat, b <> 0 -> {q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": [], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "apply (lt_wf_rec a (fun a:nat =>{q : nat &  {r : nat | a = b * q + r /\\ r < b)).", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "intros.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "case (le_lt_dec b n);intro.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "elim (H0 (n-b)).", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "intro q;intro.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "elim p;intro r;intro.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "exists (q+1);exists r.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "split;try tauto.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "rewrite (le_plus_minus b n);trivial.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "elim p0;intros.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "rewrite H1;ring.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "omega.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "exists 0;exists n.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "split;try tauto.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "ring.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"]}, {"text": "Qed.", "goal_before": ["{q : nat & {r : nat | a = b * q + r /\\ r < b}}"], "goal_after": [], "proof_term_before": ["(fun (a b : nat) (H : b <> 0) => ?Goal)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "thm4_1a", "text": "Theorem thm4_1a :\n forall (x : Segment) (l : Line),\n DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l.\nProof.\nintros x l.\ngeneralize (inc_ln2 x); generalize (inc_ln1 x).\nunfold Incident in |- *.\ngeneralize (el_ax x l (ln x)).\ntauto.\nQed.\n", "definition": "\n forall (x : Segment) (l : Line),\n DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l.\n", "proof": "\nintros x l.\ngeneralize (inc_ln2 x); generalize (inc_ln1 x).\nunfold Incident in |- *.\ngeneralize (el_ax x l (ln x)).\ntauto.\n", "def_ranges": [26, 0, 28, 62], "proof_ranges": [29, 0, 35, 4], "proof_steps": [{"text": "intros x l.", "goal_before": ["forall (x : Segment) (l : Line),\nDiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "goal_after": ["DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "proof_term_before": [], "proof_term_after": ["(fun (x : Segment) (l : Line) => ?Goal)"]}, {"text": "generalize (inc_ln2 x); generalize (inc_ln1 x).", "goal_before": ["DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "goal_after": ["Incident (origin x) (ln x) ->\nIncident (extremity x) (ln x) ->\nDiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "proof_term_before": ["(fun (x : Segment) (l : Line) => ?Goal)"], "proof_term_after": ["(fun (x : Segment) (l : Line) => ?Goal (inc_ln1 x) (inc_ln2 x))"]}, {"text": "unfold Incident in |- *.", "goal_before": ["Incident (origin x) (ln x) ->\nIncident (extremity x) (ln x) ->\nDiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "goal_after": ["~ Apart (origin x) (ln x) ->\n~ Apart (extremity x) (ln x) ->\nDiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "proof_term_before": ["(fun (x : Segment) (l : Line) => ?Goal (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n (?Goal\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l) \n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "generalize (el_ax x l (ln x)).", "goal_before": ["~ Apart (origin x) (ln x) ->\n~ Apart (extremity x) (ln x) ->\nDiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "goal_after": ["(DiLn l (ln x) ->\n (Apart (origin x) l \\/ Apart (extremity x) l) \\/\n Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x)) ->\n~ Apart (origin x) (ln x) ->\n~ Apart (extremity x) (ln x) ->\nDiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n (?Goal\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l) \n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n (?Goal (el_ax x l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l) \n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "tauto.", "goal_before": ["(DiLn l (ln x) ->\n (Apart (origin x) l \\/ Apart (extremity x) l) \\/\n Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x)) ->\n~ Apart (origin x) (ln x) ->\n~ Apart (extremity x) (ln x) ->\nDiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l"], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n (?Goal (el_ax x l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l) \n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n ((fun\n     (H : DiLn l (ln x) ->\n          (Apart (origin x) l \\/ Apart (extremity x) l) \\/\n          Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x))\n     (H0 : ~ Apart (origin x) (ln x)) (H1 : ~ Apart (extremity x) (ln x))\n     (H2 : DiLn l (ln x)) =>\n   let H3 :\n     (Apart (origin x) l \\/ Apart (extremity x) l) \\/\n     Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x) := \n     H H2 in\n   or_ind\n     (fun H4 : Apart (origin x) l \\/ Apart (extremity x) l =>\n      or_ind (fun H5 : Apart (origin x) l => or_introl H5)\n        (fun H5 : Apart (extremity x) l => or_intror H5) H4)\n     (fun H4 : Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x) =>\n      or_ind\n        (fun H5 : Apart (origin x) (ln x) =>\n         let H6 : False := H0 H5 in\n         False_ind (Apart (origin x) l \\/ Apart (extremity x) l) H6)\n        (fun H5 : Apart (extremity x) (ln x) =>\n         let H6 : False := H1 H5 in\n         False_ind (Apart (origin x) l \\/ Apart (extremity x) l) H6) H4) H3)\n    (el_ax x l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l) \n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n ((fun\n     (H : DiLn l (ln x) ->\n          (Apart (origin x) l \\/ Apart (extremity x) l) \\/\n          Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x))\n     (H0 : ~ Apart (origin x) (ln x)) (H1 : ~ Apart (extremity x) (ln x))\n     (H2 : DiLn l (ln x)) =>\n   let H3 :\n     (Apart (origin x) l \\/ Apart (extremity x) l) \\/\n     Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x) := \n     H H2 in\n   or_ind\n     (fun H4 : Apart (origin x) l \\/ Apart (extremity x) l =>\n      or_ind (fun H5 : Apart (origin x) l => or_introl H5)\n        (fun H5 : Apart (extremity x) l => or_intror H5) H4)\n     (fun H4 : Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x) =>\n      or_ind\n        (fun H5 : Apart (origin x) (ln x) =>\n         let H6 : False := H0 H5 in\n         False_ind (Apart (origin x) l \\/ Apart (extremity x) l) H6)\n        (fun H5 : Apart (extremity x) (ln x) =>\n         let H6 : False := H1 H5 in\n         False_ind (Apart (origin x) l \\/ Apart (extremity x) l) H6) H4) H3)\n    (el_ax x l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  DiLn l (ln x) -> Apart (origin x) l \\/ Apart (extremity x) l) \n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "thm4_1b", "text": "Theorem thm4_1b :\n forall (x : Segment) (l : Line),\n Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x).\nProof.\nintros x l.\ngeneralize (inc_ln2 x); generalize (inc_ln1 x).\nunfold Incident in |- *.\nintros H' H'0 H'1; elim H'1; intro H'2; clear H'1.\nelim (cmp_apt_diln (origin x) l (ln x)); tauto.\nelim (cmp_apt_diln (extremity x) l (ln x)); tauto.\nQed.\n", "definition": "\n forall (x : Segment) (l : Line),\n Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x).\n", "proof": "\nintros x l.\ngeneralize (inc_ln2 x); generalize (inc_ln1 x).\nunfold Incident in |- *.\nintros H' H'0 H'1; elim H'1; intro H'2; clear H'1.\nelim (cmp_apt_diln (origin x) l (ln x)); tauto.\nelim (cmp_apt_diln (extremity x) l (ln x)); tauto.\n", "def_ranges": [37, 0, 39, 62], "proof_ranges": [40, 0, 47, 4], "proof_steps": [{"text": "intros x l.", "goal_before": ["forall (x : Segment) (l : Line),\nApart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)"], "goal_after": ["Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Segment) (l : Line) => ?Goal)"]}, {"text": "generalize (inc_ln2 x); generalize (inc_ln1 x).", "goal_before": ["Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)"], "goal_after": ["Incident (origin x) (ln x) ->\nIncident (extremity x) (ln x) ->\nApart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)"], "proof_term_before": ["(fun (x : Segment) (l : Line) => ?Goal)"], "proof_term_after": ["(fun (x : Segment) (l : Line) => ?Goal (inc_ln1 x) (inc_ln2 x))"]}, {"text": "unfold Incident in |- *.", "goal_before": ["Incident (origin x) (ln x) ->\nIncident (extremity x) (ln x) ->\nApart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)"], "goal_after": ["~ Apart (origin x) (ln x) ->\n~ Apart (extremity x) (ln x) ->\nApart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)"], "proof_term_before": ["(fun (x : Segment) (l : Line) => ?Goal (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n (?Goal\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)) \n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "intros H' H'0 H'1; elim H'1; intro H'2; clear H'1.", "goal_before": ["~ Apart (origin x) (ln x) ->\n~ Apart (extremity x) (ln x) ->\nApart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)"], "goal_after": ["DiLn l (ln x)", "DiLn l (ln x)"], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n (?Goal\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)) \n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : Apart (origin x) l \\/ Apart (extremity x) l) =>\n   or_ind (fun H'2 : Apart (origin x) l => ?Goal)\n     (fun H'2 : Apart (extremity x) l => ?Goal0) H'1)\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)) \n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "elim (cmp_apt_diln (origin x) l (ln x)); tauto.", "goal_before": ["DiLn l (ln x)", "DiLn l (ln x)"], "goal_after": ["DiLn l (ln x)"], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : Apart (origin x) l \\/ Apart (extremity x) l) =>\n   or_ind (fun H'2 : Apart (origin x) l => ?Goal)\n     (fun H'2 : Apart (extremity x) l => ?Goal0) H'1)\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)) \n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : Apart (origin x) l \\/ Apart (extremity x) l) =>\n   or_ind\n     (fun H'2 : Apart (origin x) l =>\n      or_ind (fun H : DiLn l (ln x) => H)\n        (fun H : Apart (origin x) (ln x) =>\n         let H0 : False := H' H in False_ind (DiLn l (ln x)) H0)\n        (cmp_apt_diln (origin x) l (ln x) H'2))\n     (fun H'2 : Apart (extremity x) l => ?Goal) H'1)\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)) \n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "elim (cmp_apt_diln (extremity x) l (ln x)); tauto.", "goal_before": ["DiLn l (ln x)"], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : Apart (origin x) l \\/ Apart (extremity x) l) =>\n   or_ind\n     (fun H'2 : Apart (origin x) l =>\n      or_ind (fun H : DiLn l (ln x) => H)\n        (fun H : Apart (origin x) (ln x) =>\n         let H0 : False := H' H in False_ind (DiLn l (ln x)) H0)\n        (cmp_apt_diln (origin x) l (ln x) H'2))\n     (fun H'2 : Apart (extremity x) l => ?Goal) H'1)\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)) \n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : Apart (origin x) l \\/ Apart (extremity x) l) =>\n   or_ind\n     (fun H'2 : Apart (origin x) l =>\n      or_ind (fun H : DiLn l (ln x) => H)\n        (fun H : Apart (origin x) (ln x) =>\n         let H0 : False := H' H in False_ind (DiLn l (ln x)) H0)\n        (cmp_apt_diln (origin x) l (ln x) H'2))\n     (fun H'2 : Apart (extremity x) l =>\n      or_ind (fun H : DiLn l (ln x) => H)\n        (fun H : Apart (extremity x) (ln x) =>\n         let H0 : False := H'0 H in False_ind (DiLn l (ln x)) H0)\n        (cmp_apt_diln (extremity x) l (ln x) H'2)) H'1)\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)) \n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : Apart (origin x) l \\/ Apart (extremity x) l) =>\n   or_ind\n     (fun H'2 : Apart (origin x) l =>\n      or_ind (fun H : DiLn l (ln x) => H)\n        (fun H : Apart (origin x) (ln x) =>\n         let H0 : False := H' H in False_ind (DiLn l (ln x)) H0)\n        (cmp_apt_diln (origin x) l (ln x) H'2))\n     (fun H'2 : Apart (extremity x) l =>\n      or_ind (fun H : DiLn l (ln x) => H)\n        (fun H : Apart (extremity x) (ln x) =>\n         let H0 : False := H'0 H in False_ind (DiLn l (ln x)) H0)\n        (cmp_apt_diln (extremity x) l (ln x) H'2)) H'1)\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Apart (origin x) l \\/ Apart (extremity x) l -> DiLn l (ln x)) \n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "thm4_1c", "text": "Theorem thm4_1c :\n forall (x : Twolines) (a : Point),\n DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x).\nProof.\nintros x a.\ngeneralize (inc_pt2 x); generalize (inc_pt1 x).\nunfold Incident in |- *.\nintros H' H'0 H'1.\ngeneralize (el_ax (Seg a (pt x) H'1) (line1 x) (line2 x)); simpl in |- *.\ncut (DiLn (line1 x) (line2 x)).\ntauto.\nelim x; auto.\nQed.\n", "definition": "\n forall (x : Twolines) (a : Point),\n DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x).\n", "proof": "\nintros x a.\ngeneralize (inc_pt2 x); generalize (inc_pt1 x).\nunfold Incident in |- *.\nintros H' H'0 H'1.\ngeneralize (el_ax (Seg a (pt x) H'1) (line1 x) (line2 x)); simpl in |- *.\ncut (DiLn (line1 x) (line2 x)).\ntauto.\nelim x; auto.\n", "def_ranges": [50, 0, 52, 57], "proof_ranges": [53, 0, 62, 4], "proof_steps": [{"text": "intros x a.", "goal_before": ["forall (x : Twolines) (a : Point),\nDiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)"], "goal_after": ["DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Twolines) (a : Point) => ?Goal)"]}, {"text": "generalize (inc_pt2 x); generalize (inc_pt1 x).", "goal_before": ["DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)"], "goal_after": ["Incident (pt x) (line1 x) ->\nIncident (pt x) (line2 x) ->\nDiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) => ?Goal)"], "proof_term_after": ["(fun (x : Twolines) (a : Point) => ?Goal (inc_pt1 x) (inc_pt2 x))"]}, {"text": "unfold Incident in |- *.", "goal_before": ["Incident (pt x) (line1 x) ->\nIncident (pt x) (line2 x) ->\nDiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)"], "goal_after": ["~ Apart (pt x) (line1 x) ->\n~ Apart (pt x) (line2 x) ->\nDiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) => ?Goal (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n (?Goal\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "intros H' H'0 H'1.", "goal_before": ["~ Apart (pt x) (line1 x) ->\n~ Apart (pt x) (line2 x) ->\nDiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)"], "goal_after": ["Apart a (line1 x) \\/ Apart a (line2 x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n (?Goal\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) => ?Goal)\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "generalize (el_ax (Seg a (pt x) H'1) (line1 x) (line2 x)); simpl in |- *.", "goal_before": ["Apart a (line1 x) \\/ Apart a (line2 x)"], "goal_after": ["(DiLn (line1 x) (line2 x) ->\n (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n Apart a (line2 x) \\/ Apart (pt x) (line2 x)) ->\nApart a (line1 x) \\/ Apart a (line2 x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) => ?Goal)\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) =>\n   (?Goal\n    :\n    (DiLn (line1 x) (line2 x) ->\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x)) -> Apart a (line1 x) \\/ Apart a (line2 x))\n     (el_ax {| origin := a; extremity := pt x; Seg_cond := H'1 |} \n        (line1 x) (line2 x)))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "cut (DiLn (line1 x) (line2 x)).", "goal_before": ["(DiLn (line1 x) (line2 x) ->\n (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n Apart a (line2 x) \\/ Apart (pt x) (line2 x)) ->\nApart a (line1 x) \\/ Apart a (line2 x)"], "goal_after": ["DiLn (line1 x) (line2 x) ->\n(DiLn (line1 x) (line2 x) ->\n (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n Apart a (line2 x) \\/ Apart (pt x) (line2 x)) ->\nApart a (line1 x) \\/ Apart a (line2 x)", "DiLn (line1 x) (line2 x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) =>\n   (?Goal\n    :\n    (DiLn (line1 x) (line2 x) ->\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x)) -> Apart a (line1 x) \\/ Apart a (line2 x))\n     (el_ax {| origin := a; extremity := pt x; Seg_cond := H'1 |} \n        (line1 x) (line2 x)))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) =>\n   ((let H : DiLn (line1 x) (line2 x) := ?Goal0 in ?Goal H)\n    :\n    (DiLn (line1 x) (line2 x) ->\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x)) -> Apart a (line1 x) \\/ Apart a (line2 x))\n     (el_ax {| origin := a; extremity := pt x; Seg_cond := H'1 |} \n        (line1 x) (line2 x)))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "tauto.", "goal_before": ["DiLn (line1 x) (line2 x) ->\n(DiLn (line1 x) (line2 x) ->\n (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n Apart a (line2 x) \\/ Apart (pt x) (line2 x)) ->\nApart a (line1 x) \\/ Apart a (line2 x)", "DiLn (line1 x) (line2 x)"], "goal_after": ["DiLn (line1 x) (line2 x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) =>\n   ((let H : DiLn (line1 x) (line2 x) := ?Goal0 in ?Goal H)\n    :\n    (DiLn (line1 x) (line2 x) ->\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x)) -> Apart a (line1 x) \\/ Apart a (line2 x))\n     (el_ax {| origin := a; extremity := pt x; Seg_cond := H'1 |} \n        (line1 x) (line2 x)))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) =>\n   ((let H : DiLn (line1 x) (line2 x) := ?Goal in\n     (fun (H0 : DiLn (line1 x) (line2 x))\n        (H1 : DiLn (line1 x) (line2 x) ->\n              (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n              Apart a (line2 x) \\/ Apart (pt x) (line2 x)) =>\n      let H2 :\n        (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n        Apart a (line2 x) \\/ Apart (pt x) (line2 x) := \n        H1 H0 in\n      or_ind\n        (fun H3 : Apart a (line1 x) \\/ Apart (pt x) (line1 x) =>\n         or_ind (fun H4 : Apart a (line1 x) => or_introl H4)\n           (fun H4 : Apart (pt x) (line1 x) =>\n            let H5 : False := H' H4 in\n            False_ind (Apart a (line1 x) \\/ Apart a (line2 x)) H5) H3)\n        (fun H3 : Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n         or_ind (fun H4 : Apart a (line2 x) => or_intror H4)\n           (fun H4 : Apart (pt x) (line2 x) =>\n            let H5 : False := H'0 H4 in\n            False_ind (Apart a (line1 x) \\/ Apart a (line2 x)) H5) H3) H2) H)\n    :\n    (DiLn (line1 x) (line2 x) ->\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x)) -> Apart a (line1 x) \\/ Apart a (line2 x))\n     (el_ax {| origin := a; extremity := pt x; Seg_cond := H'1 |} \n        (line1 x) (line2 x)))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "elim x; auto.", "goal_before": ["DiLn (line1 x) (line2 x)"], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) =>\n   ((let H : DiLn (line1 x) (line2 x) := ?Goal in\n     (fun (H0 : DiLn (line1 x) (line2 x))\n        (H1 : DiLn (line1 x) (line2 x) ->\n              (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n              Apart a (line2 x) \\/ Apart (pt x) (line2 x)) =>\n      let H2 :\n        (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n        Apart a (line2 x) \\/ Apart (pt x) (line2 x) := \n        H1 H0 in\n      or_ind\n        (fun H3 : Apart a (line1 x) \\/ Apart (pt x) (line1 x) =>\n         or_ind (fun H4 : Apart a (line1 x) => or_introl H4)\n           (fun H4 : Apart (pt x) (line1 x) =>\n            let H5 : False := H' H4 in\n            False_ind (Apart a (line1 x) \\/ Apart a (line2 x)) H5) H3)\n        (fun H3 : Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n         or_ind (fun H4 : Apart a (line2 x) => or_intror H4)\n           (fun H4 : Apart (pt x) (line2 x) =>\n            let H5 : False := H'0 H4 in\n            False_ind (Apart a (line1 x) \\/ Apart a (line2 x)) H5) H3) H2) H)\n    :\n    (DiLn (line1 x) (line2 x) ->\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x)) -> Apart a (line1 x) \\/ Apart a (line2 x))\n     (el_ax {| origin := a; extremity := pt x; Seg_cond := H'1 |} \n        (line1 x) (line2 x)))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) =>\n   ((let H : DiLn (line1 x) (line2 x) :=\n       match x as t return (DiLn (line1 t) (line2 t)) with\n       | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n           (fun (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6) =>\n            Convergent_imp_distinct\n              (line1\n                 {|\n                   line1 := line5; line2 := line6; Twol_cond := Twol_cond0\n                 |})\n              (line2\n                 {|\n                   line1 := line5; line2 := line6; Twol_cond := Twol_cond0\n                 |}) Twol_cond0) line3 line4 Twol_cond\n       end in\n     (fun (H0 : DiLn (line1 x) (line2 x))\n        (H1 : DiLn (line1 x) (line2 x) ->\n              (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n              Apart a (line2 x) \\/ Apart (pt x) (line2 x)) =>\n      let H2 :\n        (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n        Apart a (line2 x) \\/ Apart (pt x) (line2 x) := \n        H1 H0 in\n      or_ind\n        (fun H3 : Apart a (line1 x) \\/ Apart (pt x) (line1 x) =>\n         or_ind (fun H4 : Apart a (line1 x) => or_introl H4)\n           (fun H4 : Apart (pt x) (line1 x) =>\n            let H5 : False := H' H4 in\n            False_ind (Apart a (line1 x) \\/ Apart a (line2 x)) H5) H3)\n        (fun H3 : Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n         or_ind (fun H4 : Apart a (line2 x) => or_intror H4)\n           (fun H4 : Apart (pt x) (line2 x) =>\n            let H5 : False := H'0 H4 in\n            False_ind (Apart a (line1 x) \\/ Apart a (line2 x)) H5) H3) H2) H)\n    :\n    (DiLn (line1 x) (line2 x) ->\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x)) -> Apart a (line1 x) \\/ Apart a (line2 x))\n     (el_ax {| origin := a; extremity := pt x; Seg_cond := H'1 |} \n        (line1 x) (line2 x)))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : DiPt a (pt x)) =>\n   ((let H : DiLn (line1 x) (line2 x) :=\n       match x as t return (DiLn (line1 t) (line2 t)) with\n       | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n           (fun (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6) =>\n            Convergent_imp_distinct\n              (line1\n                 {|\n                   line1 := line5; line2 := line6; Twol_cond := Twol_cond0\n                 |})\n              (line2\n                 {|\n                   line1 := line5; line2 := line6; Twol_cond := Twol_cond0\n                 |}) Twol_cond0) line3 line4 Twol_cond\n       end in\n     (fun (H0 : DiLn (line1 x) (line2 x))\n        (H1 : DiLn (line1 x) (line2 x) ->\n              (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n              Apart a (line2 x) \\/ Apart (pt x) (line2 x)) =>\n      let H2 :\n        (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n        Apart a (line2 x) \\/ Apart (pt x) (line2 x) := \n        H1 H0 in\n      or_ind\n        (fun H3 : Apart a (line1 x) \\/ Apart (pt x) (line1 x) =>\n         or_ind (fun H4 : Apart a (line1 x) => or_introl H4)\n           (fun H4 : Apart (pt x) (line1 x) =>\n            let H5 : False := H' H4 in\n            False_ind (Apart a (line1 x) \\/ Apart a (line2 x)) H5) H3)\n        (fun H3 : Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n         or_ind (fun H4 : Apart a (line2 x) => or_intror H4)\n           (fun H4 : Apart (pt x) (line2 x) =>\n            let H5 : False := H'0 H4 in\n            False_ind (Apart a (line1 x) \\/ Apart a (line2 x)) H5) H3) H2) H)\n    :\n    (DiLn (line1 x) (line2 x) ->\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'1 |})\n       (line2 x)) -> Apart a (line1 x) \\/ Apart a (line2 x))\n     (el_ax {| origin := a; extremity := pt x; Seg_cond := H'1 |} \n        (line1 x) (line2 x)))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  DiPt a (pt x) -> Apart a (line1 x) \\/ Apart a (line2 x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "thm4_1d", "text": "Theorem thm4_1d :\n forall (x : Twolines) (a : Point),\n Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x).\nProof.\nintros x a.\ngeneralize (inc_pt2 x); generalize (inc_pt1 x).\nunfold Incident in |- *.\nintros H' H'0 H'1; elim H'1; intro H'2; clear H'1.\ngeneralize (cmp_apt_dipt a (pt x) (line1 x)); tauto.\ngeneralize (cmp_apt_dipt a (pt x) (line2 x)); tauto.\nQed.\n", "definition": "\n forall (x : Twolines) (a : Point),\n Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x).\n", "proof": "\nintros x a.\ngeneralize (inc_pt2 x); generalize (inc_pt1 x).\nunfold Incident in |- *.\nintros H' H'0 H'1; elim H'1; intro H'2; clear H'1.\ngeneralize (cmp_apt_dipt a (pt x) (line1 x)); tauto.\ngeneralize (cmp_apt_dipt a (pt x) (line2 x)); tauto.\n", "def_ranges": [64, 0, 66, 57], "proof_ranges": [67, 0, 74, 4], "proof_steps": [{"text": "intros x a.", "goal_before": ["forall (x : Twolines) (a : Point),\nApart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)"], "goal_after": ["Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Twolines) (a : Point) => ?Goal)"]}, {"text": "generalize (inc_pt2 x); generalize (inc_pt1 x).", "goal_before": ["Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)"], "goal_after": ["Incident (pt x) (line1 x) ->\nIncident (pt x) (line2 x) ->\nApart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) => ?Goal)"], "proof_term_after": ["(fun (x : Twolines) (a : Point) => ?Goal (inc_pt1 x) (inc_pt2 x))"]}, {"text": "unfold Incident in |- *.", "goal_before": ["Incident (pt x) (line1 x) ->\nIncident (pt x) (line2 x) ->\nApart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)"], "goal_after": ["~ Apart (pt x) (line1 x) ->\n~ Apart (pt x) (line2 x) ->\nApart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) => ?Goal (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n (?Goal\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "intros H' H'0 H'1; elim H'1; intro H'2; clear H'1.", "goal_before": ["~ Apart (pt x) (line1 x) ->\n~ Apart (pt x) (line2 x) ->\nApart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)"], "goal_after": ["DiPt a (pt x)", "DiPt a (pt x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n (?Goal\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : Apart a (line1 x) \\/ Apart a (line2 x)) =>\n   or_ind (fun H'2 : Apart a (line1 x) => ?Goal)\n     (fun H'2 : Apart a (line2 x) => ?Goal0) H'1)\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "generalize (cmp_apt_dipt a (pt x) (line1 x)); tauto.", "goal_before": ["DiPt a (pt x)", "DiPt a (pt x)"], "goal_after": ["DiPt a (pt x)"], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : Apart a (line1 x) \\/ Apart a (line2 x)) =>\n   or_ind (fun H'2 : Apart a (line1 x) => ?Goal)\n     (fun H'2 : Apart a (line2 x) => ?Goal0) H'1)\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : Apart a (line1 x) \\/ Apart a (line2 x)) =>\n   or_ind\n     (fun H'2 : Apart a (line1 x) =>\n      (fun H : Apart a (line1 x) -> DiPt a (pt x) \\/ Apart (pt x) (line1 x)\n       =>\n       let H0 : DiPt a (pt x) \\/ Apart (pt x) (line1 x) := H H'2 in\n       or_ind (fun H1 : DiPt a (pt x) => H1)\n         (fun H1 : Apart (pt x) (line1 x) =>\n          let H2 : False := H' H1 in False_ind (DiPt a (pt x)) H2) H0)\n        (cmp_apt_dipt a (pt x) (line1 x)))\n     (fun H'2 : Apart a (line2 x) => ?Goal) H'1)\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "generalize (cmp_apt_dipt a (pt x) (line2 x)); tauto.", "goal_before": ["DiPt a (pt x)"], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : Apart a (line1 x) \\/ Apart a (line2 x)) =>\n   or_ind\n     (fun H'2 : Apart a (line1 x) =>\n      (fun H : Apart a (line1 x) -> DiPt a (pt x) \\/ Apart (pt x) (line1 x)\n       =>\n       let H0 : DiPt a (pt x) \\/ Apart (pt x) (line1 x) := H H'2 in\n       or_ind (fun H1 : DiPt a (pt x) => H1)\n         (fun H1 : Apart (pt x) (line1 x) =>\n          let H2 : False := H' H1 in False_ind (DiPt a (pt x)) H2) H0)\n        (cmp_apt_dipt a (pt x) (line1 x)))\n     (fun H'2 : Apart a (line2 x) => ?Goal) H'1)\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : Apart a (line1 x) \\/ Apart a (line2 x)) =>\n   or_ind\n     (fun H'2 : Apart a (line1 x) =>\n      (fun H : Apart a (line1 x) -> DiPt a (pt x) \\/ Apart (pt x) (line1 x)\n       =>\n       let H0 : DiPt a (pt x) \\/ Apart (pt x) (line1 x) := H H'2 in\n       or_ind (fun H1 : DiPt a (pt x) => H1)\n         (fun H1 : Apart (pt x) (line1 x) =>\n          let H2 : False := H' H1 in False_ind (DiPt a (pt x)) H2) H0)\n        (cmp_apt_dipt a (pt x) (line1 x)))\n     (fun H'2 : Apart a (line2 x) =>\n      (fun H : Apart a (line2 x) -> DiPt a (pt x) \\/ Apart (pt x) (line2 x)\n       =>\n       let H0 : DiPt a (pt x) \\/ Apart (pt x) (line2 x) := H H'2 in\n       or_ind (fun H1 : DiPt a (pt x) => H1)\n         (fun H1 : Apart (pt x) (line2 x) =>\n          let H2 : False := H'0 H1 in False_ind (DiPt a (pt x)) H2) H0)\n        (cmp_apt_dipt a (pt x) (line2 x))) H'1)\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (a : Point) =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (H'1 : Apart a (line1 x) \\/ Apart a (line2 x)) =>\n   or_ind\n     (fun H'2 : Apart a (line1 x) =>\n      (fun H : Apart a (line1 x) -> DiPt a (pt x) \\/ Apart (pt x) (line1 x)\n       =>\n       let H0 : DiPt a (pt x) \\/ Apart (pt x) (line1 x) := H H'2 in\n       or_ind (fun H1 : DiPt a (pt x) => H1)\n         (fun H1 : Apart (pt x) (line1 x) =>\n          let H2 : False := H' H1 in False_ind (DiPt a (pt x)) H2) H0)\n        (cmp_apt_dipt a (pt x) (line1 x)))\n     (fun H'2 : Apart a (line2 x) =>\n      (fun H : Apart a (line2 x) -> DiPt a (pt x) \\/ Apart (pt x) (line2 x)\n       =>\n       let H0 : DiPt a (pt x) \\/ Apart (pt x) (line2 x) := H H'2 in\n       or_ind (fun H1 : DiPt a (pt x) => H1)\n         (fun H1 : Apart (pt x) (line2 x) =>\n          let H2 : False := H'0 H1 in False_ind (DiPt a (pt x)) H2) H0)\n        (cmp_apt_dipt a (pt x) (line2 x))) H'1)\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  Apart a (line1 x) \\/ Apart a (line2 x) -> DiPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "Symmetry_of_Apart", "text": "Theorem Symmetry_of_Apart :\n forall x y : Segment,\n Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) ->\n Apart (origin y) (ln x) \\/ Apart (extremity y) (ln x).\nintros x y H'.\napply thm4_1a.\napply sym_DiLn; auto.\nQed.\n", "definition": "\n forall x y : Segment,\n Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) ->\n Apart (origin y) (ln x) \\/ Apart (extremity y) (ln x).", "proof": "\nintros x y H'.\napply thm4_1a.\napply sym_DiLn; auto.\n", "def_ranges": [76, 0, 79, 55], "proof_ranges": [80, 0, 83, 4], "proof_steps": [{"text": "intros x y H'.", "goal_before": ["forall x y : Segment,\nApart (origin x) (ln y) \\/ Apart (extremity x) (ln y) ->\nApart (origin y) (ln x) \\/ Apart (extremity y) (ln x)"], "goal_after": ["Apart (origin y) (ln x) \\/ Apart (extremity y) (ln x)"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Segment)\n   (H' : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y)) => \n ?Goal)"]}, {"text": "apply thm4_1a.", "goal_before": ["Apart (origin y) (ln x) \\/ Apart (extremity y) (ln x)"], "goal_after": ["DiLn (ln x) (ln y)"], "proof_term_before": ["(fun (x y : Segment)\n   (H' : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y)) => \n ?Goal)"], "proof_term_after": ["(fun (x y : Segment)\n   (H' : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y)) =>\n thm4_1a y (ln x) ?Goal)"]}, {"text": "apply sym_DiLn; auto.", "goal_before": ["DiLn (ln x) (ln y)"], "goal_after": [], "proof_term_before": ["(fun (x y : Segment)\n   (H' : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y)) =>\n thm4_1a y (ln x) ?Goal)"], "proof_term_after": ["(fun (x y : Segment)\n   (H' : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y)) =>\n thm4_1a y (ln x) (sym_DiLn (ln y) (ln x) (thm4_1b x (ln y) H')))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : Segment)\n   (H' : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y)) =>\n thm4_1a y (ln x) (sym_DiLn (ln y) (ln x) (thm4_1b x (ln y) H')))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "thm4_3a", "text": "Theorem thm4_3a :\n forall (x : Segment) (c : Point), Apart c (ln x) -> DiPt c (origin x).\nProof.\nintros x c H'.\nelim (cmp_apt_dipt c (origin x) (ln x)); trivial.\nintro H0; elim (inc_ln1 x); trivial.\nQed.\n", "definition": "\n forall (x : Segment) (c : Point), Apart c (ln x) -> DiPt c (origin x).\n", "proof": "\nintros x c H'.\nelim (cmp_apt_dipt c (origin x) (ln x)); trivial.\nintro H0; elim (inc_ln1 x); trivial.\n", "def_ranges": [85, 0, 86, 71], "proof_ranges": [87, 0, 91, 4], "proof_steps": [{"text": "intros x c H'.", "goal_before": ["forall (x : Segment) (c : Point), Apart c (ln x) -> DiPt c (origin x)"], "goal_after": ["DiPt c (origin x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) => ?Goal)"]}, {"text": "elim (cmp_apt_dipt c (origin x) (ln x)); trivial.", "goal_before": ["DiPt c (origin x)"], "goal_after": ["Apart (origin x) (ln x) -> DiPt c (origin x)"], "proof_term_before": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) => ?Goal)"], "proof_term_after": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) =>\n or_ind (fun H : DiPt c (origin x) => H) ?Goal\n   (cmp_apt_dipt c (origin x) (ln x) H'))"]}, {"text": "intro H0; elim (inc_ln1 x); trivial.", "goal_before": ["Apart (origin x) (ln x) -> DiPt c (origin x)"], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) =>\n or_ind (fun H : DiPt c (origin x) => H) ?Goal\n   (cmp_apt_dipt c (origin x) (ln x) H'))"], "proof_term_after": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) =>\n or_ind (fun H : DiPt c (origin x) => H)\n   (fun H0 : Apart (origin x) (ln x) =>\n    False_ind (DiPt c (origin x)) (inc_ln1 x H0))\n   (cmp_apt_dipt c (origin x) (ln x) H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) =>\n or_ind (fun H : DiPt c (origin x) => H)\n   (fun H0 : Apart (origin x) (ln x) =>\n    False_ind (DiPt c (origin x)) (inc_ln1 x H0))\n   (cmp_apt_dipt c (origin x) (ln x) H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "thm4_3b", "text": "Theorem thm4_3b :\n forall (x : Segment) (c : Point), Apart c (ln x) -> DiPt c (extremity x).\nProof.\nintros x c H'.\nelim (cmp_apt_dipt c (extremity x) (ln x)); trivial.\nintro H0; elim (inc_ln2 x); trivial.\nQed.\n", "definition": "\n forall (x : Segment) (c : Point), Apart c (ln x) -> DiPt c (extremity x).\n", "proof": "\nintros x c H'.\nelim (cmp_apt_dipt c (extremity x) (ln x)); trivial.\nintro H0; elim (inc_ln2 x); trivial.\n", "def_ranges": [93, 0, 94, 74], "proof_ranges": [95, 0, 99, 4], "proof_steps": [{"text": "intros x c H'.", "goal_before": ["forall (x : Segment) (c : Point), Apart c (ln x) -> DiPt c (extremity x)"], "goal_after": ["DiPt c (extremity x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) => ?Goal)"]}, {"text": "elim (cmp_apt_dipt c (extremity x) (ln x)); trivial.", "goal_before": ["DiPt c (extremity x)"], "goal_after": ["Apart (extremity x) (ln x) -> DiPt c (extremity x)"], "proof_term_before": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) => ?Goal)"], "proof_term_after": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) =>\n or_ind (fun H : DiPt c (extremity x) => H) ?Goal\n   (cmp_apt_dipt c (extremity x) (ln x) H'))"]}, {"text": "intro H0; elim (inc_ln2 x); trivial.", "goal_before": ["Apart (extremity x) (ln x) -> DiPt c (extremity x)"], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) =>\n or_ind (fun H : DiPt c (extremity x) => H) ?Goal\n   (cmp_apt_dipt c (extremity x) (ln x) H'))"], "proof_term_after": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) =>\n or_ind (fun H : DiPt c (extremity x) => H)\n   (fun H0 : Apart (extremity x) (ln x) =>\n    False_ind (DiPt c (extremity x)) (inc_ln2 x H0))\n   (cmp_apt_dipt c (extremity x) (ln x) H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (c : Point) (H' : Apart c (ln x)) =>\n or_ind (fun H : DiPt c (extremity x) => H)\n   (fun H0 : Apart (extremity x) (ln x) =>\n    False_ind (DiPt c (extremity x)) (inc_ln2 x H0))\n   (cmp_apt_dipt c (extremity x) (ln x) H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "auxs1", "text": "Theorem auxs1 : forall t : Triangle, origin (base t) = extremity (Side1 t).\nProof.\nintro t; elim t; auto.\nQed.\n", "definition": " forall t : Triangle, origin (base t) = extremity (Side1 t).\n", "proof": "\nintro t; elim t; auto.\n", "def_ranges": [117, 0, 117, 75], "proof_ranges": [118, 0, 120, 4], "proof_steps": [{"text": "intro t; elim t; auto.", "goal_before": ["forall t : Triangle, origin (base t) = extremity (Side1 t)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (origin (base t0) = extremity (Side1 t0)) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) => eq_refl) summit base\n       Tri_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (origin (base t0) = extremity (Side1 t0)) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) => eq_refl) summit base\n       Tri_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "auxs2", "text": "Theorem auxs2 : forall t : Triangle, extremity (base t) = extremity (Side2 t).\nProof.\nintro t; elim t; auto.\nQed.\n", "definition": " forall t : Triangle, extremity (base t) = extremity (Side2 t).\n", "proof": "\nintro t; elim t; auto.\n", "def_ranges": [122, 0, 122, 78], "proof_ranges": [123, 0, 125, 4], "proof_steps": [{"text": "intro t; elim t; auto.", "goal_before": ["forall t : Triangle, extremity (base t) = extremity (Side2 t)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (extremity (base t0) = extremity (Side2 t0)) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) => eq_refl) summit base\n       Tri_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (extremity (base t0) = extremity (Side2 t0)) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) => eq_refl) summit base\n       Tri_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "auxs3", "text": "Theorem auxs3 : forall t : Triangle, summit t = origin (Side1 t).\nProof.\nintro t; elim t; auto.\nQed.\n", "definition": " forall t : Triangle, summit t = origin (Side1 t).\n", "proof": "\nintro t; elim t; auto.\n", "def_ranges": [127, 0, 127, 65], "proof_ranges": [128, 0, 130, 4], "proof_steps": [{"text": "intro t; elim t; auto.", "goal_before": ["forall t : Triangle, summit t = origin (Side1 t)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (summit t0 = origin (Side1 t0)) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) => eq_refl) summit base\n       Tri_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (summit t0 = origin (Side1 t0)) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) => eq_refl) summit base\n       Tri_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "auxs4", "text": "Theorem auxs4 : forall t : Triangle, summit t = origin (Side2 t).\nProof.\nintro t; elim t; auto.\nQed.\n", "definition": " forall t : Triangle, summit t = origin (Side2 t).\n", "proof": "\nintro t; elim t; auto.\n", "def_ranges": [132, 0, 132, 65], "proof_ranges": [133, 0, 135, 4], "proof_steps": [{"text": "intro t; elim t; auto.", "goal_before": ["forall t : Triangle, summit t = origin (Side2 t)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (summit t0 = origin (Side2 t0)) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) => eq_refl) summit base\n       Tri_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (summit t0 = origin (Side2 t0)) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) => eq_refl) summit base\n       Tri_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "thm4_3c", "text": "Theorem thm4_3c : forall t : Triangle, DiLn (ln (base t)) (ln (Side1 t)).\nProof.\nintro H'; elim H'; clear H'.\nintros summit base Tri_cond.\nelim (cmp_apt_diln summit (ln base) (ln (Side1 (Tri summit base Tri_cond))));\n auto.\nQed.\n", "definition": " forall t : Triangle, DiLn (ln (base t)) (ln (Side1 t)).\n", "proof": "\nintro H'; elim H'; clear H'.\nintros summit base Tri_cond.\nelim (cmp_apt_diln summit (ln base) (ln (Side1 (Tri summit base Tri_cond))));\n auto.\n", "def_ranges": [137, 0, 137, 73], "proof_ranges": [138, 0, 143, 4], "proof_steps": [{"text": "intro H'; elim H'; clear H'.", "goal_before": ["forall t : Triangle, DiLn (ln (base t)) (ln (Side1 t))"], "goal_after": ["forall (summit : Point) (base : Segment) (Tri_cond : Apart summit (ln base)),\nDiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side1 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "proof_term_before": [], "proof_term_after": ["(fun H' : Triangle =>\n match H' as t return (DiLn (ln (base t)) (ln (Side1 t))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     ?Goal summit base Tri_cond\n end)"]}, {"text": "intros summit base Tri_cond.", "goal_before": ["forall (summit : Point) (base : Segment) (Tri_cond : Apart summit (ln base)),\nDiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side1 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "goal_after": ["DiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side1 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "proof_term_before": ["(fun H' : Triangle =>\n match H' as t return (DiLn (ln (base t)) (ln (Side1 t))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     ?Goal summit base Tri_cond\n end)"], "proof_term_after": ["(fun H' : Triangle =>\n match H' as t return (DiLn (ln (base t)) (ln (Side1 t))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) =>\n      ?Goal@{summit:=summit0; base:=base0; Tri_cond:=Tri_cond0}) summit base\n       Tri_cond\n end)"]}, {"text": "elim (cmp_apt_diln summit (ln base) (ln (Side1 (Tri summit base Tri_cond))));", "goal_before": ["DiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side1 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "goal_after": ["DiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side1 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "proof_term_before": ["(fun H' : Triangle =>\n match H' as t return (DiLn (ln (base t)) (ln (Side1 t))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) =>\n      ?Goal@{summit:=summit0; base:=base0; Tri_cond:=Tri_cond0}) summit base\n       Tri_cond\n end)"], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": ["thm4_3c is defined"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part2.v", "name": "thm4_3d", "text": "Theorem thm4_3d : forall t : Triangle, DiLn (ln (base t)) (ln (Side2 t)).\nProof.\nintro H'; elim H'; clear H'.\nintros summit base Tri_cond.\nelim (cmp_apt_diln summit (ln base) (ln (Side2 (Tri summit base Tri_cond))));\n auto.\nQed.\n", "definition": " forall t : Triangle, DiLn (ln (base t)) (ln (Side2 t)).\n", "proof": "\nintro H'; elim H'; clear H'.\nintros summit base Tri_cond.\nelim (cmp_apt_diln summit (ln base) (ln (Side2 (Tri summit base Tri_cond))));\n auto.\n", "def_ranges": [145, 0, 145, 73], "proof_ranges": [146, 0, 151, 4], "proof_steps": [{"text": "intro H'; elim H'; clear H'.", "goal_before": ["forall t : Triangle, DiLn (ln (base t)) (ln (Side2 t))"], "goal_after": ["forall (summit : Point) (base : Segment) (Tri_cond : Apart summit (ln base)),\nDiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side2 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "proof_term_before": [], "proof_term_after": ["(fun H' : Triangle =>\n match H' as t return (DiLn (ln (base t)) (ln (Side2 t))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     ?Goal summit base Tri_cond\n end)"]}, {"text": "intros summit base Tri_cond.", "goal_before": ["forall (summit : Point) (base : Segment) (Tri_cond : Apart summit (ln base)),\nDiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side2 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "goal_after": ["DiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side2 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "proof_term_before": ["(fun H' : Triangle =>\n match H' as t return (DiLn (ln (base t)) (ln (Side2 t))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     ?Goal summit base Tri_cond\n end)"], "proof_term_after": ["(fun H' : Triangle =>\n match H' as t return (DiLn (ln (base t)) (ln (Side2 t))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) =>\n      ?Goal@{summit:=summit0; base:=base0; Tri_cond:=Tri_cond0}) summit base\n       Tri_cond\n end)"]}, {"text": "elim (cmp_apt_diln summit (ln base) (ln (Side2 (Tri summit base Tri_cond))));", "goal_before": ["DiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side2 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "goal_after": ["DiLn\n  (ln (basis.base {| summit := summit; base := base; Tri_cond := Tri_cond |}))\n  (ln (Side2 {| summit := summit; base := base; Tri_cond := Tri_cond |}))"], "proof_term_before": ["(fun H' : Triangle =>\n match H' as t return (DiLn (ln (base t)) (ln (Side2 t))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) =>\n      ?Goal@{summit:=summit0; base:=base0; Tri_cond:=Tri_cond0}) summit base\n       Tri_cond\n end)"], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": ["thm4_3d is defined"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "Uniqueness_of_constructed_lines", "text": "Theorem Uniqueness_of_constructed_lines :\n forall (x : Segment) (l : Line),\n Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).\nProof.\nintros x l.\ngeneralize (inc_ln2 x); generalize (inc_ln1 x).\nunfold Incident, EqLn, Negation in |- *.\nintros H' H'0 H'1 H'2; red in |- *; intro H'3.\nlapply (el_ax x l (ln x)); trivial.\ntauto.\nQed.\n", "definition": "\n forall (x : Segment) (l : Line),\n Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x).\n", "proof": "\nintros x l.\ngeneralize (inc_ln2 x); generalize (inc_ln1 x).\nunfold Incident, EqLn, Negation in |- *.\nintros H' H'0 H'1 H'2; red in |- *; intro H'3.\nlapply (el_ax x l (ln x)); trivial.\ntauto.\n", "def_ranges": [28, 0, 30, 68], "proof_ranges": [31, 0, 38, 4], "proof_steps": [{"text": "intros x l.", "goal_before": ["forall (x : Segment) (l : Line),\nIncident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x)"], "goal_after": ["Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Segment) (l : Line) => ?Goal)"]}, {"text": "generalize (inc_ln2 x); generalize (inc_ln1 x).", "goal_before": ["Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x)"], "goal_after": ["Incident (origin x) (ln x) ->\nIncident (extremity x) (ln x) ->\nIncident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x)"], "proof_term_before": ["(fun (x : Segment) (l : Line) => ?Goal)"], "proof_term_after": ["(fun (x : Segment) (l : Line) => ?Goal (inc_ln1 x) (inc_ln2 x))"]}, {"text": "unfold Incident, EqLn, Negation in |- *.", "goal_before": ["Incident (origin x) (ln x) ->\nIncident (extremity x) (ln x) ->\nIncident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x)"], "goal_after": ["~ Apart (origin x) (ln x) ->\n~ Apart (extremity x) (ln x) ->\n~ Apart (origin x) l -> ~ Apart (extremity x) l -> ~ DiLn l (ln x)"], "proof_term_before": ["(fun (x : Segment) (l : Line) => ?Goal (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n (?Goal\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "intros H' H'0 H'1 H'2; red in |- *; intro H'3.", "goal_before": ["~ Apart (origin x) (ln x) ->\n~ Apart (extremity x) (ln x) ->\n~ Apart (origin x) l -> ~ Apart (extremity x) l -> ~ DiLn l (ln x)"], "goal_after": ["False"], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n (?Goal\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : ~ Apart (origin x) l) (H'2 : ~ Apart (extremity x) l) =>\n   (fun H'3 : DiLn l (ln x) => ?Goal) : ~ DiLn l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "lapply (el_ax x l (ln x)); trivial.", "goal_before": ["False"], "goal_after": ["(Apart (origin x) l \\/ Apart (extremity x) l) \\/\nApart (origin x) (ln x) \\/ Apart (extremity x) (ln x) -> False"], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : ~ Apart (origin x) l) (H'2 : ~ Apart (extremity x) l) =>\n   (fun H'3 : DiLn l (ln x) => ?Goal) : ~ DiLn l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : ~ Apart (origin x) l) (H'2 : ~ Apart (extremity x) l) =>\n   (fun H'3 : DiLn l (ln x) => ?Goal (el_ax x l (ln x) H'3))\n   :\n   ~ DiLn l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "tauto.", "goal_before": ["(Apart (origin x) l \\/ Apart (extremity x) l) \\/\nApart (origin x) (ln x) \\/ Apart (extremity x) (ln x) -> False"], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : ~ Apart (origin x) l) (H'2 : ~ Apart (extremity x) l) =>\n   (fun H'3 : DiLn l (ln x) => ?Goal (el_ax x l (ln x) H'3))\n   :\n   ~ DiLn l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : ~ Apart (origin x) l) (H'2 : ~ Apart (extremity x) l) =>\n   (fun H'3 : DiLn l (ln x) =>\n    (fun\n       H : (Apart (origin x) l \\/ Apart (extremity x) l) \\/\n           Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x) =>\n     or_ind\n       (fun H0 : Apart (origin x) l \\/ Apart (extremity x) l =>\n        or_ind\n          (fun H1 : Apart (origin x) l =>\n           let H2 : False := H'1 H1 in False_ind False H2)\n          (fun H1 : Apart (extremity x) l =>\n           let H2 : False := H'2 H1 in False_ind False H2) H0)\n       (fun H0 : Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x) =>\n        or_ind\n          (fun H1 : Apart (origin x) (ln x) =>\n           let H2 : False := H' H1 in False_ind False H2)\n          (fun H1 : Apart (extremity x) (ln x) =>\n           let H2 : False := H'0 H1 in False_ind False H2) H0) H)\n      (el_ax x l (ln x) H'3))\n   :\n   ~ DiLn l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n   (inc_ln1 x) (inc_ln2 x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (l : Line) =>\n ((fun (H' : ~ Apart (origin x) (ln x)) (H'0 : ~ Apart (extremity x) (ln x))\n     (H'1 : ~ Apart (origin x) l) (H'2 : ~ Apart (extremity x) l) =>\n   (fun H'3 : DiLn l (ln x) =>\n    (fun\n       H : (Apart (origin x) l \\/ Apart (extremity x) l) \\/\n           Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x) =>\n     or_ind\n       (fun H0 : Apart (origin x) l \\/ Apart (extremity x) l =>\n        or_ind\n          (fun H1 : Apart (origin x) l =>\n           let H2 : False := H'1 H1 in False_ind False H2)\n          (fun H1 : Apart (extremity x) l =>\n           let H2 : False := H'2 H1 in False_ind False H2) H0)\n       (fun H0 : Apart (origin x) (ln x) \\/ Apart (extremity x) (ln x) =>\n        or_ind\n          (fun H1 : Apart (origin x) (ln x) =>\n           let H2 : False := H' H1 in False_ind False H2)\n          (fun H1 : Apart (extremity x) (ln x) =>\n           let H2 : False := H'0 H1 in False_ind False H2) H0) H)\n      (el_ax x l (ln x) H'3))\n   :\n   ~ DiLn l (ln x))\n  :\n  Incident (origin x) (ln x) ->\n  Incident (extremity x) (ln x) ->\n  Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n   (inc_ln1 x) (inc_ln2 x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "Convergent_imp_distinct", "text": "Theorem Convergent_imp_distinct : forall l m : Line, ConLn l m -> DiLn l m.\nProof.\nintros l m H'.\nlapply (cmp_con_diln l m l); trivial.\nintro H'0; elim H'0; auto.\nintro H'1; elim apart_con.\nintro H'2; elim (H'2 l); trivial.\nQed.\n", "definition": " forall l m : Line, ConLn l m -> DiLn l m.\n", "proof": "\nintros l m H'.\nlapply (cmp_con_diln l m l); trivial.\nintro H'0; elim H'0; auto.\nintro H'1; elim apart_con.\nintro H'2; elim (H'2 l); trivial.\n", "def_ranges": [40, 0, 40, 75], "proof_ranges": [41, 0, 47, 4], "proof_steps": [{"text": "intros l m H'.", "goal_before": ["forall l m : Line, ConLn l m -> DiLn l m"], "goal_after": ["DiLn l m"], "proof_term_before": [], "proof_term_after": ["(fun (l m : Line) (H' : ConLn l m) => ?Goal)"]}, {"text": "lapply (cmp_con_diln l m l); trivial.", "goal_before": ["DiLn l m"], "goal_after": ["DiLn m l \\/ ConLn l l -> DiLn l m"], "proof_term_before": ["(fun (l m : Line) (H' : ConLn l m) => ?Goal)"], "proof_term_after": ["(fun (l m : Line) (H' : ConLn l m) => ?Goal (cmp_con_diln l m l H'))"]}, {"text": "intro H'0; elim H'0; auto.", "goal_before": ["DiLn m l \\/ ConLn l l -> DiLn l m"], "goal_after": ["ConLn l l -> DiLn l m"], "proof_term_before": ["(fun (l m : Line) (H' : ConLn l m) => ?Goal (cmp_con_diln l m l H'))"], "proof_term_after": ["(fun (l m : Line) (H' : ConLn l m) =>\n (fun H'0 : DiLn m l \\/ ConLn l l =>\n  or_ind (fun H : DiLn m l => sym_DiLn m l H) ?Goal H'0)\n   (cmp_con_diln l m l H'))"]}, {"text": "intro H'1; elim apart_con.", "goal_before": ["ConLn l l -> DiLn l m"], "goal_after": ["Irreflexive Line ConLn -> Separating Line ConLn -> DiLn l m"], "proof_term_before": ["(fun (l m : Line) (H' : ConLn l m) =>\n (fun H'0 : DiLn m l \\/ ConLn l l =>\n  or_ind (fun H : DiLn m l => sym_DiLn m l H) ?Goal H'0)\n   (cmp_con_diln l m l H'))"], "proof_term_after": ["(fun (l m : Line) (H' : ConLn l m) =>\n (fun H'0 : DiLn m l \\/ ConLn l l =>\n  or_ind (fun H : DiLn m l => sym_DiLn m l H)\n    (fun H'1 : ConLn l l =>\n     Apartness_ind Line ConLn (DiLn l m) ?Goal apart_con) H'0)\n   (cmp_con_diln l m l H'))"]}, {"text": "intro H'2; elim (H'2 l); trivial.", "goal_before": ["Irreflexive Line ConLn -> Separating Line ConLn -> DiLn l m"], "goal_after": [], "proof_term_before": ["(fun (l m : Line) (H' : ConLn l m) =>\n (fun H'0 : DiLn m l \\/ ConLn l l =>\n  or_ind (fun H : DiLn m l => sym_DiLn m l H)\n    (fun H'1 : ConLn l l =>\n     Apartness_ind Line ConLn (DiLn l m) ?Goal apart_con) H'0)\n   (cmp_con_diln l m l H'))"], "proof_term_after": ["(fun (l m : Line) (H' : ConLn l m) =>\n (fun H'0 : DiLn m l \\/ ConLn l l =>\n  or_ind (fun H : DiLn m l => sym_DiLn m l H)\n    (fun H'1 : ConLn l l =>\n     Apartness_ind Line ConLn (DiLn l m)\n       (fun H'2 : Irreflexive Line ConLn =>\n        False_ind (Separating Line ConLn -> DiLn l m) (H'2 l H'1)) apart_con)\n    H'0) (cmp_con_diln l m l H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m : Line) (H' : ConLn l m) =>\n (fun H'0 : DiLn m l \\/ ConLn l l =>\n  or_ind (fun H : DiLn m l => sym_DiLn m l H)\n    (fun H'1 : ConLn l l =>\n     Apartness_ind Line ConLn (DiLn l m)\n       (fun H'2 : Irreflexive Line ConLn =>\n        False_ind (Separating Line ConLn -> DiLn l m) (H'2 l H'1)) apart_con)\n    H'0) (cmp_con_diln l m l H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "Uniqueness_of_constructed_points", "text": "Theorem Uniqueness_of_constructed_points :\n forall (x : Twolines) (a : Point),\n Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).\nProof.\nintro x.\ngeneralize (inc_pt2 x); generalize (inc_pt1 x).\nunfold Incident, EqPt, Negation in |- *.\nintros H' H'0 a H'1 H'2; red in |- *; intro H'3.\nlapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)); simpl in |- *.\ntauto.\nelim x; auto.\nQed.\n", "definition": "\n forall (x : Twolines) (a : Point),\n Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x).\n", "proof": "\nintro x.\ngeneralize (inc_pt2 x); generalize (inc_pt1 x).\nunfold Incident, EqPt, Negation in |- *.\nintros H' H'0 a H'1 H'2; red in |- *; intro H'3.\nlapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)); simpl in |- *.\ntauto.\nelim x; auto.\n", "def_ranges": [50, 0, 52, 63], "proof_ranges": [53, 0, 61, 4], "proof_steps": [{"text": "intro x.", "goal_before": ["forall (x : Twolines) (a : Point),\nIncident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)"], "goal_after": ["forall a : Point,\nIncident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)"], "proof_term_before": [], "proof_term_after": ["(fun x : Twolines => ?Goal)"]}, {"text": "generalize (inc_pt2 x); generalize (inc_pt1 x).", "goal_before": ["forall a : Point,\nIncident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)"], "goal_after": ["Incident (pt x) (line1 x) ->\nIncident (pt x) (line2 x) ->\nforall a : Point,\nIncident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)"], "proof_term_before": ["(fun x : Twolines => ?Goal)"], "proof_term_after": ["(fun x : Twolines => ?Goal (inc_pt1 x) (inc_pt2 x))"]}, {"text": "unfold Incident, EqPt, Negation in |- *.", "goal_before": ["Incident (pt x) (line1 x) ->\nIncident (pt x) (line2 x) ->\nforall a : Point,\nIncident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)"], "goal_after": ["~ Apart (pt x) (line1 x) ->\n~ Apart (pt x) (line2 x) ->\nforall a : Point,\n~ Apart a (line1 x) -> ~ Apart a (line2 x) -> ~ DiPt a (pt x)"], "proof_term_before": ["(fun x : Twolines => ?Goal (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun x : Twolines =>\n (?Goal\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "intros H' H'0 a H'1 H'2; red in |- *; intro H'3.", "goal_before": ["~ Apart (pt x) (line1 x) ->\n~ Apart (pt x) (line2 x) ->\nforall a : Point,\n~ Apart a (line1 x) -> ~ Apart a (line2 x) -> ~ DiPt a (pt x)"], "goal_after": ["False"], "proof_term_before": ["(fun x : Twolines =>\n (?Goal\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun x : Twolines =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (a : Point) (H'1 : ~ Apart a (line1 x)) (H'2 : ~ Apart a (line2 x)) =>\n   (fun H'3 : DiPt a (pt x) => ?Goal) : ~ DiPt a (pt x))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "lapply (el_ax (Seg a (pt x) H'3) (line1 x) (line2 x)); simpl in |- *.", "goal_before": ["False"], "goal_after": ["(Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\nApart a (line2 x) \\/ Apart (pt x) (line2 x) -> False", "DiLn (line1 x) (line2 x)"], "proof_term_before": ["(fun x : Twolines =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (a : Point) (H'1 : ~ Apart a (line1 x)) (H'2 : ~ Apart a (line2 x)) =>\n   (fun H'3 : DiPt a (pt x) => ?Goal) : ~ DiPt a (pt x))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun x : Twolines =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (a : Point) (H'1 : ~ Apart a (line1 x)) (H'2 : ~ Apart a (line2 x)) =>\n   (fun H'3 : DiPt a (pt x) =>\n    (?Goal\n     :\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) -> False)\n      (el_ax {| origin := a; extremity := pt x; Seg_cond := H'3 |} \n         (line1 x) (line2 x) (?Goal0 : DiLn (line1 x) (line2 x))))\n   :\n   ~ DiPt a (pt x))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "tauto.", "goal_before": ["(Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\nApart a (line2 x) \\/ Apart (pt x) (line2 x) -> False", "DiLn (line1 x) (line2 x)"], "goal_after": ["DiLn (line1 x) (line2 x)"], "proof_term_before": ["(fun x : Twolines =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (a : Point) (H'1 : ~ Apart a (line1 x)) (H'2 : ~ Apart a (line2 x)) =>\n   (fun H'3 : DiPt a (pt x) =>\n    (?Goal\n     :\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) -> False)\n      (el_ax {| origin := a; extremity := pt x; Seg_cond := H'3 |} \n         (line1 x) (line2 x) (?Goal0 : DiLn (line1 x) (line2 x))))\n   :\n   ~ DiPt a (pt x))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun x : Twolines =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (a : Point) (H'1 : ~ Apart a (line1 x)) (H'2 : ~ Apart a (line2 x)) =>\n   (fun H'3 : DiPt a (pt x) =>\n    ((fun\n        H : (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n            Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n      or_ind\n        (fun H0 : Apart a (line1 x) \\/ Apart (pt x) (line1 x) =>\n         or_ind\n           (fun H1 : Apart a (line1 x) =>\n            let H2 : False := H'1 H1 in False_ind False H2)\n           (fun H1 : Apart (pt x) (line1 x) =>\n            let H2 : False := H' H1 in False_ind False H2) H0)\n        (fun H0 : Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n         or_ind\n           (fun H1 : Apart a (line2 x) =>\n            let H2 : False := H'2 H1 in False_ind False H2)\n           (fun H1 : Apart (pt x) (line2 x) =>\n            let H2 : False := H'0 H1 in False_ind False H2) H0) H)\n     :\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) -> False)\n      (el_ax {| origin := a; extremity := pt x; Seg_cond := H'3 |} \n         (line1 x) (line2 x) (?Goal : DiLn (line1 x) (line2 x))))\n   :\n   ~ DiPt a (pt x))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "elim x; auto.", "goal_before": ["DiLn (line1 x) (line2 x)"], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (a : Point) (H'1 : ~ Apart a (line1 x)) (H'2 : ~ Apart a (line2 x)) =>\n   (fun H'3 : DiPt a (pt x) =>\n    ((fun\n        H : (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n            Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n      or_ind\n        (fun H0 : Apart a (line1 x) \\/ Apart (pt x) (line1 x) =>\n         or_ind\n           (fun H1 : Apart a (line1 x) =>\n            let H2 : False := H'1 H1 in False_ind False H2)\n           (fun H1 : Apart (pt x) (line1 x) =>\n            let H2 : False := H' H1 in False_ind False H2) H0)\n        (fun H0 : Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n         or_ind\n           (fun H1 : Apart a (line2 x) =>\n            let H2 : False := H'2 H1 in False_ind False H2)\n           (fun H1 : Apart (pt x) (line2 x) =>\n            let H2 : False := H'0 H1 in False_ind False H2) H0) H)\n     :\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) -> False)\n      (el_ax {| origin := a; extremity := pt x; Seg_cond := H'3 |} \n         (line1 x) (line2 x) (?Goal : DiLn (line1 x) (line2 x))))\n   :\n   ~ DiPt a (pt x))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": ["(fun x : Twolines =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (a : Point) (H'1 : ~ Apart a (line1 x)) (H'2 : ~ Apart a (line2 x)) =>\n   (fun H'3 : DiPt a (pt x) =>\n    ((fun\n        H : (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n            Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n      or_ind\n        (fun H0 : Apart a (line1 x) \\/ Apart (pt x) (line1 x) =>\n         or_ind\n           (fun H1 : Apart a (line1 x) =>\n            let H2 : False := H'1 H1 in False_ind False H2)\n           (fun H1 : Apart (pt x) (line1 x) =>\n            let H2 : False := H' H1 in False_ind False H2) H0)\n        (fun H0 : Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n         or_ind\n           (fun H1 : Apart a (line2 x) =>\n            let H2 : False := H'2 H1 in False_ind False H2)\n           (fun H1 : Apart (pt x) (line2 x) =>\n            let H2 : False := H'0 H1 in False_ind False H2) H0) H)\n     :\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) -> False)\n      (el_ax {| origin := a; extremity := pt x; Seg_cond := H'3 |} \n         (line1 x) (line2 x)\n         (match x as t return (DiLn (line1 t) (line2 t)) with\n          | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n              (fun (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6) =>\n               Convergent_imp_distinct\n                 (line1\n                    {|\n                      line1 := line5; line2 := line6; Twol_cond := Twol_cond0\n                    |})\n                 (line2\n                    {|\n                      line1 := line5; line2 := line6; Twol_cond := Twol_cond0\n                    |}) Twol_cond0) line3 line4 Twol_cond\n          end\n          :\n          DiLn (line1 x) (line2 x))))\n   :\n   ~ DiPt a (pt x))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n ((fun (H' : ~ Apart (pt x) (line1 x)) (H'0 : ~ Apart (pt x) (line2 x))\n     (a : Point) (H'1 : ~ Apart a (line1 x)) (H'2 : ~ Apart a (line2 x)) =>\n   (fun H'3 : DiPt a (pt x) =>\n    ((fun\n        H : (Apart a (line1 x) \\/ Apart (pt x) (line1 x)) \\/\n            Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n      or_ind\n        (fun H0 : Apart a (line1 x) \\/ Apart (pt x) (line1 x) =>\n         or_ind\n           (fun H1 : Apart a (line1 x) =>\n            let H2 : False := H'1 H1 in False_ind False H2)\n           (fun H1 : Apart (pt x) (line1 x) =>\n            let H2 : False := H' H1 in False_ind False H2) H0)\n        (fun H0 : Apart a (line2 x) \\/ Apart (pt x) (line2 x) =>\n         or_ind\n           (fun H1 : Apart a (line2 x) =>\n            let H2 : False := H'2 H1 in False_ind False H2)\n           (fun H1 : Apart (pt x) (line2 x) =>\n            let H2 : False := H'0 H1 in False_ind False H2) H0) H)\n     :\n     (Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x) \\/\n      Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n        (line1 x)) \\/\n     Apart (origin {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) \\/\n     Apart (extremity {| origin := a; extremity := pt x; Seg_cond := H'3 |})\n       (line2 x) -> False)\n      (el_ax {| origin := a; extremity := pt x; Seg_cond := H'3 |} \n         (line1 x) (line2 x)\n         (match x as t return (DiLn (line1 t) (line2 t)) with\n          | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n              (fun (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6) =>\n               Convergent_imp_distinct\n                 (line1\n                    {|\n                      line1 := line5; line2 := line6; Twol_cond := Twol_cond0\n                    |})\n                 (line2\n                    {|\n                      line1 := line5; line2 := line6; Twol_cond := Twol_cond0\n                    |}) Twol_cond0) line3 line4 Twol_cond\n          end\n          :\n          DiLn (line1 x) (line2 x))))\n   :\n   ~ DiPt a (pt x))\n  :\n  Incident (pt x) (line1 x) ->\n  Incident (pt x) (line2 x) ->\n  forall a : Point,\n  Incident a (line1 x) -> Incident a (line2 x) -> EqPt a (pt x)) \n   (inc_pt1 x) (inc_pt2 x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqpt_apt", "text": "Theorem cong_eqpt_apt :\n forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.\nProof.\nintros a b l H' H'0.\nelim (cmp_apt_dipt a b l); auto.\nintro H'1; elim H'0; trivial.\nQed.\n", "definition": "\n forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l.\n", "proof": "\nintros a b l H' H'0.\nelim (cmp_apt_dipt a b l); auto.\nintro H'1; elim H'0; trivial.\n", "def_ranges": [63, 0, 64, 69], "proof_ranges": [65, 0, 69, 4], "proof_steps": [{"text": "intros a b l H' H'0.", "goal_before": ["forall (a b : Point) (l : Line), Apart a l -> EqPt a b -> Apart b l"], "goal_after": ["Apart b l"], "proof_term_before": [], "proof_term_after": ["(fun (a b : Point) (l : Line) (H' : Apart a l) (H'0 : EqPt a b) => ?Goal)"]}, {"text": "elim (cmp_apt_dipt a b l); auto.", "goal_before": ["Apart b l"], "goal_after": ["DiPt a b -> Apart b l"], "proof_term_before": ["(fun (a b : Point) (l : Line) (H' : Apart a l) (H'0 : EqPt a b) => ?Goal)"], "proof_term_after": ["(fun (a b : Point) (l : Line) (H' : Apart a l) (H'0 : EqPt a b) =>\n or_ind ?Goal (fun H : Apart b l => H) (cmp_apt_dipt a b l H'))"]}, {"text": "intro H'1; elim H'0; trivial.", "goal_before": ["DiPt a b -> Apart b l"], "goal_after": [], "proof_term_before": ["(fun (a b : Point) (l : Line) (H' : Apart a l) (H'0 : EqPt a b) =>\n or_ind ?Goal (fun H : Apart b l => H) (cmp_apt_dipt a b l H'))"], "proof_term_after": ["(fun (a b : Point) (l : Line) (H' : Apart a l) (H'0 : EqPt a b) =>\n or_ind (fun H'1 : DiPt a b => False_ind (Apart b l) (H'0 H'1))\n   (fun H : Apart b l => H) (cmp_apt_dipt a b l H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : Point) (l : Line) (H' : Apart a l) (H'0 : EqPt a b) =>\n or_ind (fun H'1 : DiPt a b => False_ind (Apart b l) (H'0 H'1))\n   (fun H : Apart b l => H) (cmp_apt_dipt a b l H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqln_apt", "text": "Theorem cong_eqln_apt :\n forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.\nProof.\nintros a l m H' H'0.\nelim (cmp_apt_diln a l m); auto.\nintro H'1; elim H'0; trivial.\nQed.\n", "definition": "\n forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m.\n", "proof": "\nintros a l m H' H'0.\nelim (cmp_apt_diln a l m); auto.\nintro H'1; elim H'0; trivial.\n", "def_ranges": [71, 0, 72, 69], "proof_ranges": [73, 0, 77, 4], "proof_steps": [{"text": "intros a l m H' H'0.", "goal_before": ["forall (a : Point) (l m : Line), Apart a l -> EqLn l m -> Apart a m"], "goal_after": ["Apart a m"], "proof_term_before": [], "proof_term_after": ["(fun (a : Point) (l m : Line) (H' : Apart a l) (H'0 : EqLn l m) => ?Goal)"]}, {"text": "elim (cmp_apt_diln a l m); auto.", "goal_before": ["Apart a m"], "goal_after": ["DiLn l m -> Apart a m"], "proof_term_before": ["(fun (a : Point) (l m : Line) (H' : Apart a l) (H'0 : EqLn l m) => ?Goal)"], "proof_term_after": ["(fun (a : Point) (l m : Line) (H' : Apart a l) (H'0 : EqLn l m) =>\n or_ind ?Goal (fun H : Apart a m => H) (cmp_apt_diln a l m H'))"]}, {"text": "intro H'1; elim H'0; trivial.", "goal_before": ["DiLn l m -> Apart a m"], "goal_after": [], "proof_term_before": ["(fun (a : Point) (l m : Line) (H' : Apart a l) (H'0 : EqLn l m) =>\n or_ind ?Goal (fun H : Apart a m => H) (cmp_apt_diln a l m H'))"], "proof_term_after": ["(fun (a : Point) (l m : Line) (H' : Apart a l) (H'0 : EqLn l m) =>\n or_ind (fun H'1 : DiLn l m => False_ind (Apart a m) (H'0 H'1))\n   (fun H : Apart a m => H) (cmp_apt_diln a l m H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : Point) (l m : Line) (H' : Apart a l) (H'0 : EqLn l m) =>\n or_ind (fun H'1 : DiLn l m => False_ind (Apart a m) (H'0 H'1))\n   (fun H : Apart a m => H) (cmp_apt_diln a l m H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqpt_inc", "text": "Theorem cong_eqpt_inc :\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.\nProof.\nunfold Incident in |- *.\nintros a b l H' H'0; red in |- *; intro H'1; apply H'.\napply cong_eqpt_apt with (a := b); auto.\nQed.\n", "definition": "\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l.\n", "proof": "\nunfold Incident in |- *.\nintros a b l H' H'0; red in |- *; intro H'1; apply H'.\napply cong_eqpt_apt with (a := b); auto.\n", "def_ranges": [79, 0, 80, 75], "proof_ranges": [81, 0, 85, 4], "proof_steps": [{"text": "unfold Incident in |- *.", "goal_before": ["forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l"], "goal_after": ["forall (a b : Point) (l : Line), ~ Apart a l -> EqPt a b -> ~ Apart b l"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l)"]}, {"text": "intros a b l H' H'0; red in |- *; intro H'1; apply H'.", "goal_before": ["forall (a b : Point) (l : Line), ~ Apart a l -> EqPt a b -> ~ Apart b l"], "goal_after": ["Apart a l"], "proof_term_before": ["(?Goal\n :\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l)"], "proof_term_after": ["((fun (a b : Point) (l : Line) (H' : ~ Apart a l) (H'0 : EqPt a b) =>\n  (fun H'1 : Apart b l => H' ?Goal) : ~ Apart b l)\n :\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l)"]}, {"text": "apply cong_eqpt_apt with (a := b); auto.", "goal_before": ["Apart a l"], "goal_after": [], "proof_term_before": ["((fun (a b : Point) (l : Line) (H' : ~ Apart a l) (H'0 : EqPt a b) =>\n  (fun H'1 : Apart b l => H' ?Goal) : ~ Apart b l)\n :\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l)"], "proof_term_after": ["((fun (a b : Point) (l : Line) (H' : ~ Apart a l) (H'0 : EqPt a b) =>\n  (fun H'1 : Apart b l => H' (cong_eqpt_apt b a l H'1 (sym_EqPt a b H'0)))\n  :\n  ~ Apart b l)\n :\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (a b : Point) (l : Line) (H' : ~ Apart a l) (H'0 : EqPt a b) =>\n  (fun H'1 : Apart b l => H' (cong_eqpt_apt b a l H'1 (sym_EqPt a b H'0)))\n  :\n  ~ Apart b l)\n :\n forall (a b : Point) (l : Line), Incident a l -> EqPt a b -> Incident b l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqln_inc", "text": "Theorem cong_eqln_inc :\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.\nProof.\nunfold Incident in |- *.\nintros a l m H' H'0; red in |- *; intro H'1; apply H'.\napply cong_eqln_apt with (l := m); auto.\nQed.\n", "definition": "\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m.\n", "proof": "\nunfold Incident in |- *.\nintros a l m H' H'0; red in |- *; intro H'1; apply H'.\napply cong_eqln_apt with (l := m); auto.\n", "def_ranges": [87, 0, 88, 75], "proof_ranges": [89, 0, 93, 4], "proof_steps": [{"text": "unfold Incident in |- *.", "goal_before": ["forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m"], "goal_after": ["forall (a : Point) (l m : Line), ~ Apart a l -> EqLn l m -> ~ Apart a m"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m)"]}, {"text": "intros a l m H' H'0; red in |- *; intro H'1; apply H'.", "goal_before": ["forall (a : Point) (l m : Line), ~ Apart a l -> EqLn l m -> ~ Apart a m"], "goal_after": ["Apart a l"], "proof_term_before": ["(?Goal\n :\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m)"], "proof_term_after": ["((fun (a : Point) (l m : Line) (H' : ~ Apart a l) (H'0 : EqLn l m) =>\n  (fun H'1 : Apart a m => H' ?Goal) : ~ Apart a m)\n :\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m)"]}, {"text": "apply cong_eqln_apt with (l := m); auto.", "goal_before": ["Apart a l"], "goal_after": [], "proof_term_before": ["((fun (a : Point) (l m : Line) (H' : ~ Apart a l) (H'0 : EqLn l m) =>\n  (fun H'1 : Apart a m => H' ?Goal) : ~ Apart a m)\n :\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m)"], "proof_term_after": ["((fun (a : Point) (l m : Line) (H' : ~ Apart a l) (H'0 : EqLn l m) =>\n  (fun H'1 : Apart a m => H' (cong_eqln_apt a m l H'1 (sym_EqLn l m H'0)))\n  :\n  ~ Apart a m)\n :\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (a : Point) (l m : Line) (H' : ~ Apart a l) (H'0 : EqLn l m) =>\n  (fun H'1 : Apart a m => H' (cong_eqln_apt a m l H'1 (sym_EqLn l m H'0)))\n  :\n  ~ Apart a m)\n :\n forall (a : Point) (l m : Line), Incident a l -> EqLn l m -> Incident a m)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqln_con", "text": "Theorem cong_eqln_con :\n forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.\nProof.\nintros l m n H' H'0.\nelim (cmp_con_diln l m n); auto.\nintro H'1; elim H'0; trivial.\nQed.\n", "definition": "\n forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n.\n", "proof": "\nintros l m n H' H'0.\nelim (cmp_con_diln l m n); auto.\nintro H'1; elim H'0; trivial.\n", "def_ranges": [95, 0, 96, 57], "proof_ranges": [97, 0, 101, 4], "proof_steps": [{"text": "intros l m n H' H'0.", "goal_before": ["forall l m n : Line, ConLn l m -> EqLn m n -> ConLn l n"], "goal_after": ["ConLn l n"], "proof_term_before": [], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : EqLn m n) => ?Goal)"]}, {"text": "elim (cmp_con_diln l m n); auto.", "goal_before": ["ConLn l n"], "goal_after": ["DiLn m n -> ConLn l n"], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : EqLn m n) => ?Goal)"], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : EqLn m n) =>\n or_ind ?Goal (fun H : ConLn l n => H) (cmp_con_diln l m n H'))"]}, {"text": "intro H'1; elim H'0; trivial.", "goal_before": ["DiLn m n -> ConLn l n"], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : EqLn m n) =>\n or_ind ?Goal (fun H : ConLn l n => H) (cmp_con_diln l m n H'))"], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : EqLn m n) =>\n or_ind (fun H'1 : DiLn m n => False_ind (ConLn l n) (H'0 H'1))\n   (fun H : ConLn l n => H) (cmp_con_diln l m n H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : EqLn m n) =>\n or_ind (fun H'1 : DiLn m n => False_ind (ConLn l n) (H'0 H'1))\n   (fun H : ConLn l n => H) (cmp_con_diln l m n H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqln_par", "text": "Theorem cong_eqln_par : forall l m n : Line, Par l m -> EqLn m n -> Par l n.\nProof.\nunfold Par, Negation in |- *.\nintros l m n H' H'0; red in |- *; intro H'1; apply H'.\napply cong_eqln_con with (m := n); auto.\nQed.\n", "definition": " forall l m n : Line, Par l m -> EqLn m n -> Par l n.\n", "proof": "\nunfold Par, Negation in |- *.\nintros l m n H' H'0; red in |- *; intro H'1; apply H'.\napply cong_eqln_con with (m := n); auto.\n", "def_ranges": [103, 0, 103, 76], "proof_ranges": [104, 0, 108, 4], "proof_steps": [{"text": "unfold Par, Negation in |- *.", "goal_before": ["forall l m n : Line, Par l m -> EqLn m n -> Par l n"], "goal_after": ["forall l m n : Line, ~ ConLn l m -> EqLn m n -> ~ ConLn l n"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall l m n : Line, Par l m -> EqLn m n -> Par l n)"]}, {"text": "intros l m n H' H'0; red in |- *; intro H'1; apply H'.", "goal_before": ["forall l m n : Line, ~ ConLn l m -> EqLn m n -> ~ ConLn l n"], "goal_after": ["ConLn l m"], "proof_term_before": ["(?Goal : forall l m n : Line, Par l m -> EqLn m n -> Par l n)"], "proof_term_after": ["((fun (l m n : Line) (H' : ~ ConLn l m) (H'0 : EqLn m n) =>\n  (fun H'1 : ConLn l n => H' ?Goal) : ~ ConLn l n)\n :\n forall l m n : Line, Par l m -> EqLn m n -> Par l n)"]}, {"text": "apply cong_eqln_con with (m := n); auto.", "goal_before": ["ConLn l m"], "goal_after": [], "proof_term_before": ["((fun (l m n : Line) (H' : ~ ConLn l m) (H'0 : EqLn m n) =>\n  (fun H'1 : ConLn l n => H' ?Goal) : ~ ConLn l n)\n :\n forall l m n : Line, Par l m -> EqLn m n -> Par l n)"], "proof_term_after": ["((fun (l m n : Line) (H' : ~ ConLn l m) (H'0 : EqLn m n) =>\n  (fun H'1 : ConLn l n => H' (cong_eqln_con l n m H'1 (sym_EqLn m n H'0)))\n  :\n  ~ ConLn l n)\n :\n forall l m n : Line, Par l m -> EqLn m n -> Par l n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (l m n : Line) (H' : ~ ConLn l m) (H'0 : EqLn m n) =>\n  (fun H'1 : ConLn l n => H' (cong_eqln_con l n m H'1 (sym_EqLn m n H'0)))\n  :\n  ~ ConLn l n)\n :\n forall l m n : Line, Par l m -> EqLn m n -> Par l n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqpt_dipt", "text": "Theorem cong_eqpt_dipt :\n forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.\nProof.\nintros a b c H' H'0; elim apart_dipt.\nunfold Separating at 1 in |- *.\nintros H'1 H'2; elim (H'2 a b c); trivial.\nintro H'3; elim H'0; trivial.\nQed.\n", "definition": "\n forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c.\n", "proof": "\nintros a b c H' H'0; elim apart_dipt.\nunfold Separating at 1 in |- *.\nintros H'1 H'2; elim (H'2 a b c); trivial.\nintro H'3; elim H'0; trivial.\n", "def_ranges": [110, 0, 111, 56], "proof_ranges": [112, 0, 117, 4], "proof_steps": [{"text": "intros a b c H' H'0; elim apart_dipt.", "goal_before": ["forall a b c : Point, DiPt a b -> EqPt b c -> DiPt a c"], "goal_after": ["Irreflexive Point DiPt -> Separating Point DiPt -> DiPt a c"], "proof_term_before": [], "proof_term_after": ["(fun (a b c : Point) (H' : DiPt a b) (H'0 : EqPt b c) =>\n Apartness_ind Point DiPt (DiPt a c) ?Goal apart_dipt)"]}, {"text": "unfold Separating at 1 in |- *.", "goal_before": ["Irreflexive Point DiPt -> Separating Point DiPt -> DiPt a c"], "goal_after": ["Irreflexive Point DiPt ->\n(forall x y z : Point, DiPt x y -> DiPt x z \\/ DiPt y z) -> DiPt a c"], "proof_term_before": ["(fun (a b c : Point) (H' : DiPt a b) (H'0 : EqPt b c) =>\n Apartness_ind Point DiPt (DiPt a c) ?Goal apart_dipt)"], "proof_term_after": ["(fun (a b c : Point) (H' : DiPt a b) (H'0 : EqPt b c) =>\n Apartness_ind Point DiPt (DiPt a c)\n   (?Goal : Irreflexive Point DiPt -> Separating Point DiPt -> DiPt a c)\n   apart_dipt)"]}, {"text": "intros H'1 H'2; elim (H'2 a b c); trivial.", "goal_before": ["Irreflexive Point DiPt ->\n(forall x y z : Point, DiPt x y -> DiPt x z \\/ DiPt y z) -> DiPt a c"], "goal_after": ["DiPt b c -> DiPt a c"], "proof_term_before": ["(fun (a b c : Point) (H' : DiPt a b) (H'0 : EqPt b c) =>\n Apartness_ind Point DiPt (DiPt a c)\n   (?Goal : Irreflexive Point DiPt -> Separating Point DiPt -> DiPt a c)\n   apart_dipt)"], "proof_term_after": ["(fun (a b c : Point) (H' : DiPt a b) (H'0 : EqPt b c) =>\n Apartness_ind Point DiPt (DiPt a c)\n   ((fun (H'1 : Irreflexive Point DiPt)\n       (H'2 : forall x y z : Point, DiPt x y -> DiPt x z \\/ DiPt y z) =>\n     or_ind (fun H : DiPt a c => H) ?Goal (H'2 a b c H'))\n    :\n    Irreflexive Point DiPt -> Separating Point DiPt -> DiPt a c) apart_dipt)"]}, {"text": "intro H'3; elim H'0; trivial.", "goal_before": ["DiPt b c -> DiPt a c"], "goal_after": [], "proof_term_before": ["(fun (a b c : Point) (H' : DiPt a b) (H'0 : EqPt b c) =>\n Apartness_ind Point DiPt (DiPt a c)\n   ((fun (H'1 : Irreflexive Point DiPt)\n       (H'2 : forall x y z : Point, DiPt x y -> DiPt x z \\/ DiPt y z) =>\n     or_ind (fun H : DiPt a c => H) ?Goal (H'2 a b c H'))\n    :\n    Irreflexive Point DiPt -> Separating Point DiPt -> DiPt a c) apart_dipt)"], "proof_term_after": ["(fun (a b c : Point) (H' : DiPt a b) (H'0 : EqPt b c) =>\n Apartness_ind Point DiPt (DiPt a c)\n   ((fun (_ : Irreflexive Point DiPt)\n       (H'2 : forall x y z : Point, DiPt x y -> DiPt x z \\/ DiPt y z) =>\n     or_ind (fun H : DiPt a c => H)\n       (fun H'3 : DiPt b c => False_ind (DiPt a c) (H'0 H'3)) \n       (H'2 a b c H'))\n    :\n    Irreflexive Point DiPt -> Separating Point DiPt -> DiPt a c) apart_dipt)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b c : Point) (H' : DiPt a b) (H'0 : EqPt b c) =>\n Apartness_ind Point DiPt (DiPt a c)\n   ((fun (_ : Irreflexive Point DiPt)\n       (H'2 : forall x y z : Point, DiPt x y -> DiPt x z \\/ DiPt y z) =>\n     or_ind (fun H : DiPt a c => H)\n       (fun H'3 : DiPt b c => False_ind (DiPt a c) (H'0 H'3)) \n       (H'2 a b c H'))\n    :\n    Irreflexive Point DiPt -> Separating Point DiPt -> DiPt a c) apart_dipt)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqln_diln", "text": "Theorem cong_eqln_diln :\n forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.\nProof.\nintros l m n H' H'0; elim apart_diln.\nunfold Separating at 1 in |- *.\nintros H'1 H'2; elim (H'2 l m n); trivial.\nintro H'3; elim H'0; trivial.\nQed.\n", "definition": "\n forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n.\n", "proof": "\nintros l m n H' H'0; elim apart_diln.\nunfold Separating at 1 in |- *.\nintros H'1 H'2; elim (H'2 l m n); trivial.\nintro H'3; elim H'0; trivial.\n", "def_ranges": [119, 0, 120, 55], "proof_ranges": [121, 0, 126, 4], "proof_steps": [{"text": "intros l m n H' H'0; elim apart_diln.", "goal_before": ["forall l m n : Line, DiLn l m -> EqLn m n -> DiLn l n"], "goal_after": ["Irreflexive Line DiLn -> Separating Line DiLn -> DiLn l n"], "proof_term_before": [], "proof_term_after": ["(fun (l m n : Line) (H' : DiLn l m) (H'0 : EqLn m n) =>\n Apartness_ind Line DiLn (DiLn l n) ?Goal apart_diln)"]}, {"text": "unfold Separating at 1 in |- *.", "goal_before": ["Irreflexive Line DiLn -> Separating Line DiLn -> DiLn l n"], "goal_after": ["Irreflexive Line DiLn ->\n(forall x y z : Line, DiLn x y -> DiLn x z \\/ DiLn y z) -> DiLn l n"], "proof_term_before": ["(fun (l m n : Line) (H' : DiLn l m) (H'0 : EqLn m n) =>\n Apartness_ind Line DiLn (DiLn l n) ?Goal apart_diln)"], "proof_term_after": ["(fun (l m n : Line) (H' : DiLn l m) (H'0 : EqLn m n) =>\n Apartness_ind Line DiLn (DiLn l n)\n   (?Goal : Irreflexive Line DiLn -> Separating Line DiLn -> DiLn l n)\n   apart_diln)"]}, {"text": "intros H'1 H'2; elim (H'2 l m n); trivial.", "goal_before": ["Irreflexive Line DiLn ->\n(forall x y z : Line, DiLn x y -> DiLn x z \\/ DiLn y z) -> DiLn l n"], "goal_after": ["DiLn m n -> DiLn l n"], "proof_term_before": ["(fun (l m n : Line) (H' : DiLn l m) (H'0 : EqLn m n) =>\n Apartness_ind Line DiLn (DiLn l n)\n   (?Goal : Irreflexive Line DiLn -> Separating Line DiLn -> DiLn l n)\n   apart_diln)"], "proof_term_after": ["(fun (l m n : Line) (H' : DiLn l m) (H'0 : EqLn m n) =>\n Apartness_ind Line DiLn (DiLn l n)\n   ((fun (H'1 : Irreflexive Line DiLn)\n       (H'2 : forall x y z : Line, DiLn x y -> DiLn x z \\/ DiLn y z) =>\n     or_ind (fun H : DiLn l n => H) ?Goal (H'2 l m n H'))\n    :\n    Irreflexive Line DiLn -> Separating Line DiLn -> DiLn l n) apart_diln)"]}, {"text": "intro H'3; elim H'0; trivial.", "goal_before": ["DiLn m n -> DiLn l n"], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : DiLn l m) (H'0 : EqLn m n) =>\n Apartness_ind Line DiLn (DiLn l n)\n   ((fun (H'1 : Irreflexive Line DiLn)\n       (H'2 : forall x y z : Line, DiLn x y -> DiLn x z \\/ DiLn y z) =>\n     or_ind (fun H : DiLn l n => H) ?Goal (H'2 l m n H'))\n    :\n    Irreflexive Line DiLn -> Separating Line DiLn -> DiLn l n) apart_diln)"], "proof_term_after": ["(fun (l m n : Line) (H' : DiLn l m) (H'0 : EqLn m n) =>\n Apartness_ind Line DiLn (DiLn l n)\n   ((fun (_ : Irreflexive Line DiLn)\n       (H'2 : forall x y z : Line, DiLn x y -> DiLn x z \\/ DiLn y z) =>\n     or_ind (fun H : DiLn l n => H)\n       (fun H'3 : DiLn m n => False_ind (DiLn l n) (H'0 H'3)) \n       (H'2 l m n H'))\n    :\n    Irreflexive Line DiLn -> Separating Line DiLn -> DiLn l n) apart_diln)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : DiLn l m) (H'0 : EqLn m n) =>\n Apartness_ind Line DiLn (DiLn l n)\n   ((fun (_ : Irreflexive Line DiLn)\n       (H'2 : forall x y z : Line, DiLn x y -> DiLn x z \\/ DiLn y z) =>\n     or_ind (fun H : DiLn l n => H)\n       (fun H'3 : DiLn m n => False_ind (DiLn l n) (H'0 H'3)) \n       (H'2 l m n H'))\n    :\n    Irreflexive Line DiLn -> Separating Line DiLn -> DiLn l n) apart_diln)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "eqln_imp_par", "text": "Theorem eqln_imp_par : forall l m : Line, EqLn l m -> Par l m.\nProof.\nunfold Par, EqLn, Negation in |- *; red in |- *; auto.\nQed.\n", "definition": " forall l m : Line, EqLn l m -> Par l m.\n", "proof": "\nunfold Par, EqLn, Negation in |- *; red in |- *; auto.\n", "def_ranges": [128, 0, 128, 62], "proof_ranges": [129, 0, 131, 4], "proof_steps": [{"text": "unfold Par, EqLn, Negation in |- *; red in |- *; auto.", "goal_before": ["forall l m : Line, EqLn l m -> Par l m"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(((fun (l m : Line) (H : ~ DiLn l m) (H0 : ConLn l m) =>\n   H (Convergent_imp_distinct l m H0))\n  :\n  forall l m : Line, ~ DiLn l m -> ~ ConLn l m)\n :\n forall l m : Line, EqLn l m -> Par l m)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(((fun (l m : Line) (H : ~ DiLn l m) (H0 : ConLn l m) =>\n   H (Convergent_imp_distinct l m H0))\n  :\n  forall l m : Line, ~ DiLn l m -> ~ ConLn l m)\n :\n forall l m : Line, EqLn l m -> Par l m)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_par_con", "text": "Theorem cong_par_con : forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.\nProof.\nintros l m n H' H'0.\nelim apart_con.\nunfold Separating at 1 in |- *.\nintros H'1 H'2; elim (H'2 l m n); trivial.\nintro H'3; elim H'0; trivial.\nQed.\n", "definition": " forall l m n : Line, ConLn l m -> Par m n -> ConLn l n.\n", "proof": "\nintros l m n H' H'0.\nelim apart_con.\nunfold Separating at 1 in |- *.\nintros H'1 H'2; elim (H'2 l m n); trivial.\nintro H'3; elim H'0; trivial.\n", "def_ranges": [133, 0, 133, 78], "proof_ranges": [134, 0, 140, 4], "proof_steps": [{"text": "intros l m n H' H'0.", "goal_before": ["forall l m n : Line, ConLn l m -> Par m n -> ConLn l n"], "goal_after": ["ConLn l n"], "proof_term_before": [], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) => ?Goal)"]}, {"text": "elim apart_con.", "goal_before": ["ConLn l n"], "goal_after": ["Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n"], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) => ?Goal)"], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) =>\n Apartness_ind Line ConLn (ConLn l n) ?Goal apart_con)"]}, {"text": "unfold Separating at 1 in |- *.", "goal_before": ["Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n"], "goal_after": ["Irreflexive Line ConLn ->\n(forall x y z : Line, ConLn x y -> ConLn x z \\/ ConLn y z) -> ConLn l n"], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) =>\n Apartness_ind Line ConLn (ConLn l n) ?Goal apart_con)"], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) =>\n Apartness_ind Line ConLn (ConLn l n)\n   (?Goal : Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n)\n   apart_con)"]}, {"text": "intros H'1 H'2; elim (H'2 l m n); trivial.", "goal_before": ["Irreflexive Line ConLn ->\n(forall x y z : Line, ConLn x y -> ConLn x z \\/ ConLn y z) -> ConLn l n"], "goal_after": ["ConLn m n -> ConLn l n"], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) =>\n Apartness_ind Line ConLn (ConLn l n)\n   (?Goal : Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n)\n   apart_con)"], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) =>\n Apartness_ind Line ConLn (ConLn l n)\n   ((fun (H'1 : Irreflexive Line ConLn)\n       (H'2 : forall x y z : Line, ConLn x y -> ConLn x z \\/ ConLn y z) =>\n     or_ind (fun H : ConLn l n => H) ?Goal (H'2 l m n H'))\n    :\n    Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n) apart_con)"]}, {"text": "intro H'3; elim H'0; trivial.", "goal_before": ["ConLn m n -> ConLn l n"], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) =>\n Apartness_ind Line ConLn (ConLn l n)\n   ((fun (H'1 : Irreflexive Line ConLn)\n       (H'2 : forall x y z : Line, ConLn x y -> ConLn x z \\/ ConLn y z) =>\n     or_ind (fun H : ConLn l n => H) ?Goal (H'2 l m n H'))\n    :\n    Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n) apart_con)"], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) =>\n Apartness_ind Line ConLn (ConLn l n)\n   ((fun (_ : Irreflexive Line ConLn)\n       (H'2 : forall x y z : Line, ConLn x y -> ConLn x z \\/ ConLn y z) =>\n     or_ind (fun H : ConLn l n => H)\n       (fun H'3 : ConLn m n => False_ind (ConLn l n) (H'0 H'3))\n       (H'2 l m n H'))\n    :\n    Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n) apart_con)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) (H'0 : Par m n) =>\n Apartness_ind Line ConLn (ConLn l n)\n   ((fun (_ : Irreflexive Line ConLn)\n       (H'2 : forall x y z : Line, ConLn x y -> ConLn x z \\/ ConLn y z) =>\n     or_ind (fun H : ConLn l n => H)\n       (fun H'3 : ConLn m n => False_ind (ConLn l n) (H'0 H'3))\n       (H'2 l m n H'))\n    :\n    Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n) apart_con)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "sym_SPar", "text": "Theorem sym_SPar : forall x y : Line, SPar x y -> SPar y x.\nProof.\nunfold SPar in |- *.\nintuition.\nQed.\n", "definition": " forall x y : Line, SPar x y -> SPar y x.\n", "proof": "\nunfold SPar in |- *.\nintuition.\n", "def_ranges": [142, 0, 142, 59], "proof_ranges": [143, 0, 146, 4], "proof_steps": [{"text": "unfold SPar in |- *.", "goal_before": ["forall x y : Line, SPar x y -> SPar y x"], "goal_after": ["forall x y : Line, Par x y /\\ DiLn x y -> Par y x /\\ DiLn y x"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall x y : Line, SPar x y -> SPar y x)"]}, {"text": "intuition.", "goal_before": ["forall x y : Line, Par x y /\\ DiLn x y -> Par y x /\\ DiLn y x"], "goal_after": [], "proof_term_before": ["(?Goal : forall x y : Line, SPar x y -> SPar y x)"], "proof_term_after": ["((fun (x y : Line) (H : Par x y /\\ DiLn x y) =>\n  and_ind\n    (fun (H0 : Par x y) (H1 : DiLn x y) =>\n     conj (sym_Par x y H0 : Par y x) (sym_DiLn x y H1 : DiLn y x)) H)\n :\n forall x y : Line, SPar x y -> SPar y x)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (x y : Line) (H : Par x y /\\ DiLn x y) =>\n  and_ind\n    (fun (H0 : Par x y) (H1 : DiLn x y) =>\n     conj (sym_Par x y H0 : Par y x) (sym_DiLn x y H1 : DiLn y x)) H)\n :\n forall x y : Line, SPar x y -> SPar y x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "cong_eqln_spar", "text": "Theorem cong_eqln_spar :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.\nProof.\nunfold SPar in |- *.\nintros l m n H'; elim H'; intros H'0 H'1; try exact H'0; clear H'.\nintro H'; split.\napply cong_eqln_par with (m := m); trivial.\napply cong_eqln_diln with (m := m); trivial.\nQed.\n", "definition": "\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n.\n", "proof": "\nunfold SPar in |- *.\nintros l m n H'; elim H'; intros H'0 H'1; try exact H'0; clear H'.\nintro H'; split.\napply cong_eqln_par with (m := m); trivial.\napply cong_eqln_diln with (m := m); trivial.\n", "def_ranges": [149, 0, 150, 55], "proof_ranges": [151, 0, 157, 4], "proof_steps": [{"text": "unfold SPar in |- *.", "goal_before": ["forall l m n : Line, SPar l m -> EqLn m n -> SPar l n"], "goal_after": ["forall l m n : Line, Par l m /\\ DiLn l m -> EqLn m n -> Par l n /\\ DiLn l n"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"]}, {"text": "intros l m n H'; elim H'; intros H'0 H'1; try exact H'0; clear H'.", "goal_before": ["forall l m n : Line, Par l m /\\ DiLn l m -> EqLn m n -> Par l n /\\ DiLn l n"], "goal_after": ["EqLn m n -> Par l n /\\ DiLn l n"], "proof_term_before": ["(?Goal : forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"], "proof_term_after": ["((fun (l m n : Line) (H' : Par l m /\\ DiLn l m) =>\n  and_ind (fun (H'0 : Par l m) (H'1 : DiLn l m) => ?Goal) H')\n :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"]}, {"text": "intro H'; split.", "goal_before": ["EqLn m n -> Par l n /\\ DiLn l n"], "goal_after": ["Par l n", "DiLn l n"], "proof_term_before": ["((fun (l m n : Line) (H' : Par l m /\\ DiLn l m) =>\n  and_ind (fun (H'0 : Par l m) (H'1 : DiLn l m) => ?Goal) H')\n :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"], "proof_term_after": ["((fun (l m n : Line) (H' : Par l m /\\ DiLn l m) =>\n  and_ind\n    (fun (H'0 : Par l m) (H'1 : DiLn l m) (H'2 : EqLn m n) =>\n     conj ?Goal@{H':=H'2} ?Goal0@{H':=H'2}) H')\n :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"]}, {"text": "apply cong_eqln_par with (m := m); trivial.", "goal_before": ["Par l n", "DiLn l n"], "goal_after": ["DiLn l n"], "proof_term_before": ["((fun (l m n : Line) (H' : Par l m /\\ DiLn l m) =>\n  and_ind\n    (fun (H'0 : Par l m) (H'1 : DiLn l m) (H'2 : EqLn m n) =>\n     conj ?Goal@{H':=H'2} ?Goal0@{H':=H'2}) H')\n :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"], "proof_term_after": ["((fun (l m n : Line) (H' : Par l m /\\ DiLn l m) =>\n  and_ind\n    (fun (H'0 : Par l m) (H'1 : DiLn l m) (H'2 : EqLn m n) =>\n     conj (cong_eqln_par l m n H'0 H'2) ?Goal@{H':=H'2}) H')\n :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"]}, {"text": "apply cong_eqln_diln with (m := m); trivial.", "goal_before": ["DiLn l n"], "goal_after": [], "proof_term_before": ["((fun (l m n : Line) (H' : Par l m /\\ DiLn l m) =>\n  and_ind\n    (fun (H'0 : Par l m) (H'1 : DiLn l m) (H'2 : EqLn m n) =>\n     conj (cong_eqln_par l m n H'0 H'2) ?Goal@{H':=H'2}) H')\n :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"], "proof_term_after": ["((fun (l m n : Line) (H' : Par l m /\\ DiLn l m) =>\n  and_ind\n    (fun (H'0 : Par l m) (H'1 : DiLn l m) (H'2 : EqLn m n) =>\n     conj (cong_eqln_par l m n H'0 H'2) (cong_eqln_diln l m n H'1 H'2)) H')\n :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (l m n : Line) (H' : Par l m /\\ DiLn l m) =>\n  and_ind\n    (fun (H'0 : Par l m) (H'1 : DiLn l m) (H'2 : EqLn m n) =>\n     conj (cong_eqln_par l m n H'0 H'2) (cong_eqln_diln l m n H'1 H'2)) H')\n :\n forall l m n : Line, SPar l m -> EqLn m n -> SPar l n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "orig_rev", "text": "Theorem orig_rev : forall x : Segment, origin x = extremity (reverse x).\nProof.\nintro x; elim x; simpl in |- *; auto.\nQed.\n", "definition": " forall x : Segment, origin x = extremity (reverse x).\n", "proof": "\nintro x; elim x; simpl in |- *; auto.\n", "def_ranges": [166, 0, 166, 72], "proof_ranges": [167, 0, 169, 4], "proof_steps": [{"text": "intro x; elim x; simpl in |- *; auto.", "goal_before": ["forall x : Segment, origin x = extremity (reverse x)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun x : Segment =>\n match x as s return (origin s = extremity (reverse s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (_ : DiPt origin extremity) => eq_refl)\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} =\n      extremity\n        (reverse\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |})) origin0 extremity0 Seg_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Segment =>\n match x as s return (origin s = extremity (reverse s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (_ : DiPt origin extremity) => eq_refl)\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} =\n      extremity\n        (reverse\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |})) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "ext_rev", "text": "Theorem ext_rev : forall x : Segment, extremity x = origin (reverse x).\nProof.\nintro x; elim x; simpl in |- *; auto.\nQed.\n", "definition": " forall x : Segment, extremity x = origin (reverse x).\n", "proof": "\nintro x; elim x; simpl in |- *; auto.\n", "def_ranges": [171, 0, 171, 71], "proof_ranges": [172, 0, 174, 4], "proof_steps": [{"text": "intro x; elim x; simpl in |- *; auto.", "goal_before": ["forall x : Segment, extremity x = origin (reverse x)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun x : Segment =>\n match x as s return (extremity s = origin (reverse s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (_ : DiPt origin extremity) => eq_refl)\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} =\n      origin\n        (reverse\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |})) origin0 extremity0 Seg_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Segment =>\n match x as s return (extremity s = origin (reverse s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (_ : DiPt origin extremity) => eq_refl)\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} =\n      origin\n        (reverse\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |})) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "rev_defines_sameln", "text": "Theorem rev_defines_sameln : forall x : Segment, EqLn (ln x) (ln (reverse x)).\nProof.\nintro x; apply Uniqueness_of_constructed_lines.\nrewrite <- (ext_rev x); auto.\nrewrite <- (orig_rev x); auto.\nQed.\n", "definition": " forall x : Segment, EqLn (ln x) (ln (reverse x)).\n", "proof": "\nintro x; apply Uniqueness_of_constructed_lines.\nrewrite <- (ext_rev x); auto.\nrewrite <- (orig_rev x); auto.\n", "def_ranges": [176, 0, 176, 78], "proof_ranges": [177, 0, 181, 4], "proof_steps": [{"text": "intro x; apply Uniqueness_of_constructed_lines.", "goal_before": ["forall x : Segment, EqLn (ln x) (ln (reverse x))"], "goal_after": ["Incident (origin (reverse x)) (ln x)", "Incident (extremity (reverse x)) (ln x)"], "proof_term_before": [], "proof_term_after": ["(fun x : Segment =>\n Uniqueness_of_constructed_lines (reverse x) (ln x) ?Goal ?Goal0)"]}, {"text": "rewrite <- (ext_rev x); auto.", "goal_before": ["Incident (origin (reverse x)) (ln x)", "Incident (extremity (reverse x)) (ln x)"], "goal_after": ["Incident (extremity (reverse x)) (ln x)"], "proof_term_before": ["(fun x : Segment =>\n Uniqueness_of_constructed_lines (reverse x) (ln x) ?Goal ?Goal0)"], "proof_term_after": ["(fun x : Segment =>\n Uniqueness_of_constructed_lines (reverse x) (ln x)\n   (eq_ind (extremity x) (fun p : Point => Incident p (ln x)) \n      (inc_ln2 x) (origin (reverse x)) (ext_rev x)) \n   ?Goal)"]}, {"text": "rewrite <- (orig_rev x); auto.", "goal_before": ["Incident (extremity (reverse x)) (ln x)"], "goal_after": [], "proof_term_before": ["(fun x : Segment =>\n Uniqueness_of_constructed_lines (reverse x) (ln x)\n   (eq_ind (extremity x) (fun p : Point => Incident p (ln x)) \n      (inc_ln2 x) (origin (reverse x)) (ext_rev x)) \n   ?Goal)"], "proof_term_after": ["(fun x : Segment =>\n Uniqueness_of_constructed_lines (reverse x) (ln x)\n   (eq_ind (extremity x) (fun p : Point => Incident p (ln x)) \n      (inc_ln2 x) (origin (reverse x)) (ext_rev x))\n   (eq_ind (origin x) (fun p : Point => Incident p (ln x)) \n      (inc_ln1 x) (extremity (reverse x)) (orig_rev x)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Segment =>\n Uniqueness_of_constructed_lines (reverse x) (ln x)\n   (eq_ind (extremity x) (fun p : Point => Incident p (ln x)) \n      (inc_ln2 x) (origin (reverse x)) (ext_rev x))\n   (eq_ind (origin x) (fun p : Point => Incident p (ln x)) \n      (inc_ln1 x) (extremity (reverse x)) (orig_rev x)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "line1_flip", "text": "Theorem line1_flip : forall x : Twolines, line1 x = line2 (flip x).\nProof.\nintro x; elim x; simpl in |- *; auto.\nQed.\n", "definition": " forall x : Twolines, line1 x = line2 (flip x).\n", "proof": "\nintro x; elim x; simpl in |- *; auto.\n", "def_ranges": [191, 0, 191, 67], "proof_ranges": [192, 0, 194, 4], "proof_steps": [{"text": "intro x; elim x; simpl in |- *; auto.", "goal_before": ["forall x : Twolines, line1 x = line2 (flip x)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (line1 t = line2 (flip t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (_ : ConLn line1 line2) => eq_refl)\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      line2\n        (flip {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |}))\n       line3 line4 Twol_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (line1 t = line2 (flip t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (_ : ConLn line1 line2) => eq_refl)\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      line2\n        (flip {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |}))\n       line3 line4 Twol_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "line2_flip", "text": "Theorem line2_flip : forall x : Twolines, line2 x = line1 (flip x).\nProof.\nintro x; elim x; simpl in |- *; auto.\nQed.\n", "definition": " forall x : Twolines, line2 x = line1 (flip x).\n", "proof": "\nintro x; elim x; simpl in |- *; auto.\n", "def_ranges": [196, 0, 196, 67], "proof_ranges": [197, 0, 199, 4], "proof_steps": [{"text": "intro x; elim x; simpl in |- *; auto.", "goal_before": ["forall x : Twolines, line2 x = line1 (flip x)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (line2 t = line1 (flip t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (_ : ConLn line1 line2) => eq_refl)\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      line1\n        (flip {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |}))\n       line3 line4 Twol_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (line2 t = line1 (flip t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (_ : ConLn line1 line2) => eq_refl)\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      line1\n        (flip {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |}))\n       line3 line4 Twol_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "flip_defines_samept", "text": "Theorem flip_defines_samept : forall x : Twolines, EqPt (pt x) (pt (flip x)).\nProof.\nintro x; apply Uniqueness_of_constructed_points.\nrewrite <- (line2_flip x); auto.\nrewrite <- (line1_flip x); auto.\nQed.\n", "definition": " forall x : Twolines, EqPt (pt x) (pt (flip x)).\n", "proof": "\nintro x; apply Uniqueness_of_constructed_points.\nrewrite <- (line2_flip x); auto.\nrewrite <- (line1_flip x); auto.\n", "def_ranges": [201, 0, 201, 77], "proof_ranges": [202, 0, 206, 4], "proof_steps": [{"text": "intro x; apply Uniqueness_of_constructed_points.", "goal_before": ["forall x : Twolines, EqPt (pt x) (pt (flip x))"], "goal_after": ["Incident (pt x) (line1 (flip x))", "Incident (pt x) (line2 (flip x))"], "proof_term_before": [], "proof_term_after": ["(fun x : Twolines =>\n Uniqueness_of_constructed_points (flip x) (pt x) ?Goal ?Goal0)"]}, {"text": "rewrite <- (line2_flip x); auto.", "goal_before": ["Incident (pt x) (line1 (flip x))", "Incident (pt x) (line2 (flip x))"], "goal_after": ["Incident (pt x) (line2 (flip x))"], "proof_term_before": ["(fun x : Twolines =>\n Uniqueness_of_constructed_points (flip x) (pt x) ?Goal ?Goal0)"], "proof_term_after": ["(fun x : Twolines =>\n Uniqueness_of_constructed_points (flip x) (pt x)\n   (eq_ind (line2 x) (fun l : Line => Incident (pt x) l) \n      (inc_pt2 x) (line1 (flip x)) (line2_flip x)) \n   ?Goal)"]}, {"text": "rewrite <- (line1_flip x); auto.", "goal_before": ["Incident (pt x) (line2 (flip x))"], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n Uniqueness_of_constructed_points (flip x) (pt x)\n   (eq_ind (line2 x) (fun l : Line => Incident (pt x) l) \n      (inc_pt2 x) (line1 (flip x)) (line2_flip x)) \n   ?Goal)"], "proof_term_after": ["(fun x : Twolines =>\n Uniqueness_of_constructed_points (flip x) (pt x)\n   (eq_ind (line2 x) (fun l : Line => Incident (pt x) l) \n      (inc_pt2 x) (line1 (flip x)) (line2_flip x))\n   (eq_ind (line1 x) (fun l : Line => Incident (pt x) l) \n      (inc_pt1 x) (line2 (flip x)) (line1_flip x)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n Uniqueness_of_constructed_points (flip x) (pt x)\n   (eq_ind (line2 x) (fun l : Line => Incident (pt x) l) \n      (inc_pt2 x) (line1 (flip x)) (line2_flip x))\n   (eq_ind (line1 x) (fun l : Line => Incident (pt x) l) \n      (inc_pt1 x) (line2 (flip x)) (line1_flip x)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part1.v", "name": "Colinearity_is_equivalence", "text": "Theorem Colinearity_is_equivalence : Equivalence Segment colinear.\nProof.\ncut (Equivalence Line EqLn); auto.\nintro H'; elim H'.\nintros H'0 H'1 H'2; apply Definition_of_equivalence; unfold colinear in |- *;\n auto.\nred in |- *.\nintros x y z H'3 H'4.\nred in H'2.\napply H'2 with (y := ln y); auto.\nQed.\n", "definition": " Equivalence Segment colinear.\n", "proof": "\ncut (Equivalence Line EqLn); auto.\nintro H'; elim H'.\nintros H'0 H'1 H'2; apply Definition_of_equivalence; unfold colinear in |- *;\n auto.\nred in |- *.\nintros x y z H'3 H'4.\nred in H'2.\napply H'2 with (y := ln y); auto.\n", "def_ranges": [211, 0, 211, 66], "proof_ranges": [212, 0, 221, 4], "proof_steps": [{"text": "cut (Equivalence Line EqLn); auto.", "goal_before": ["Equivalence Segment colinear"], "goal_after": ["Equivalence Line EqLn -> Equivalence Segment colinear"], "proof_term_before": [], "proof_term_after": ["(let H : Equivalence Line EqLn := equiv_EqLn in ?Goal H)"]}, {"text": "intro H'; elim H'.", "goal_before": ["Equivalence Line EqLn -> Equivalence Segment colinear"], "goal_after": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "proof_term_before": ["(let H : Equivalence Line EqLn := equiv_EqLn in ?Goal H)"], "proof_term_after": ["(let H : Equivalence Line EqLn := equiv_EqLn in\n (fun H' : Equivalence Line EqLn =>\n  Equivalence_ind Line EqLn (Equivalence Segment colinear) ?Goal H') H)"]}, {"text": "intros H'0 H'1 H'2; apply Definition_of_equivalence; unfold colinear in |- *;", "goal_before": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "goal_after": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "proof_term_before": ["(let H : Equivalence Line EqLn := equiv_EqLn in\n (fun H' : Equivalence Line EqLn =>\n  Equivalence_ind Line EqLn (Equivalence Segment colinear) ?Goal H') H)"], "proof_term_after": []}, {"text": "auto.", "goal_before": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "goal_after": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *.", "goal_before": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "goal_after": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x y z H'3 H'4.", "goal_before": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "goal_after": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "proof_term_before": [], "proof_term_after": []}, {"text": "red in H'2.", "goal_before": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "goal_after": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H'2 with (y := ln y); auto.", "goal_before": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "goal_after": ["Reflexive Line EqLn ->\nSymmetric Line EqLn -> Transitive Line EqLn -> Equivalence Segment colinear"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "Triangle_axioms_i", "text": "Theorem Triangle_axioms_i :\n forall t : Triangle, Apart (origin (base t)) (ln (Side2 t)).\nProof.\nintro t.\ngeneralize (thm4_3d t); intro H'.\nlapply (el_ax (base t) (ln (base t)) (ln (Side2 t))); trivial.\nintro H.\nelim H; intro H'0; clear H.\ngeneralize (inc_ln2 (base t)); generalize (inc_ln1 (base t)).\nunfold Incident in |- *; tauto.\ngeneralize H'0; clear H'0.\nrewrite (auxs2 t).\nintro H'2.\nelim H'2; [ trivial | intro H'0; clear H'2 ].\nelim (inc_ln2 (Side2 t)); trivial.\nQed.\n", "definition": "\n forall t : Triangle, Apart (origin (base t)) (ln (Side2 t)).\n", "proof": "\nintro t.\ngeneralize (thm4_3d t); intro H'.\nlapply (el_ax (base t) (ln (base t)) (ln (Side2 t))); trivial.\nintro H.\nelim H; intro H'0; clear H.\ngeneralize (inc_ln2 (base t)); generalize (inc_ln1 (base t)).\nunfold Incident in |- *; tauto.\ngeneralize H'0; clear H'0.\nrewrite (auxs2 t).\nintro H'2.\nelim H'2; [ trivial | intro H'0; clear H'2 ].\nelim (inc_ln2 (Side2 t)); trivial.\n", "def_ranges": [28, 0, 29, 61], "proof_ranges": [30, 0, 43, 4], "proof_steps": [{"text": "intro t.", "goal_before": ["forall t : Triangle, Apart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t))"], "proof_term_before": [], "proof_term_after": ["(fun t : Triangle => ?Goal)"]}, {"text": "generalize (thm4_3d t); intro H'.", "goal_before": ["Apart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle => ?Goal)"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) => ?Goal) (thm4_3d t))"]}, {"text": "lapply (el_ax (base t) (ln (base t)) (ln (Side2 t))); trivial.", "goal_before": ["Apart (origin (base t)) (ln (Side2 t))"], "goal_after": ["(Apart (origin (base t)) (ln (base t)) \\/\n Apart (extremity (base t)) (ln (base t))) \\/\nApart (origin (base t)) (ln (Side2 t)) \\/\nApart (extremity (base t)) (ln (Side2 t)) ->\nApart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) => ?Goal) (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  ?Goal (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"]}, {"text": "intro H.", "goal_before": ["(Apart (origin (base t)) (ln (base t)) \\/\n Apart (extremity (base t)) (ln (base t))) \\/\nApart (origin (base t)) (ln (Side2 t)) \\/\nApart (extremity (base t)) (ln (Side2 t)) ->\nApart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  ?Goal (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) => \n   ?Goal) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"]}, {"text": "elim H; intro H'0; clear H.", "goal_before": ["Apart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t))", "Apart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) => \n   ?Goal) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) => \n      ?Goal)\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) => \n      ?Goal0) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H'))\n   (thm4_3d t))"]}, {"text": "generalize (inc_ln2 (base t)); generalize (inc_ln1 (base t)).", "goal_before": ["Apart (origin (base t)) (ln (Side2 t))", "Apart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Incident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (origin (base t)) (ln (Side2 t))", "Apart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) => \n      ?Goal)\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) => \n      ?Goal0) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H'))\n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ?Goal0 (inc_ln1 (base t)) (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) => \n      ?Goal) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"]}, {"text": "unfold Incident in |- *; tauto.", "goal_before": ["Incident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (origin (base t)) (ln (Side2 t))", "Apart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ?Goal0 (inc_ln1 (base t)) (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) => \n      ?Goal) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) => \n      ?Goal) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"]}, {"text": "generalize H'0; clear H'0.", "goal_before": ["Apart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t)) \\/\nApart (extremity (base t)) (ln (Side2 t)) ->\nApart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) => \n      ?Goal) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) => \n      ?Goal H'0) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H'))\n   (thm4_3d t))"]}, {"text": "rewrite (auxs2 t).", "goal_before": ["Apart (origin (base t)) (ln (Side2 t)) \\/\nApart (extremity (base t)) (ln (Side2 t)) ->\nApart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t)) \\/\nApart (extremity (Side2 t)) (ln (Side2 t)) ->\nApart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) => \n      ?Goal H'0) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H'))\n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) =>\n      eq_ind_r\n        (fun p : Point =>\n         Apart (origin (base t)) (ln (Side2 t)) \\/ Apart p (ln (Side2 t)) ->\n         Apart (origin (base t)) (ln (Side2 t))) ?Goal \n        (auxs2 t) H'0) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H'))\n   (thm4_3d t))"]}, {"text": "intro H'2.", "goal_before": ["Apart (origin (base t)) (ln (Side2 t)) \\/\nApart (extremity (Side2 t)) (ln (Side2 t)) ->\nApart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) =>\n      eq_ind_r\n        (fun p : Point =>\n         Apart (origin (base t)) (ln (Side2 t)) \\/ Apart p (ln (Side2 t)) ->\n         Apart (origin (base t)) (ln (Side2 t))) ?Goal \n        (auxs2 t) H'0) H) (el_ax (base t) (ln (base t)) (ln (Side2 t)) H'))\n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) =>\n      eq_ind_r\n        (fun p : Point =>\n         Apart (origin (base t)) (ln (Side2 t)) \\/ Apart p (ln (Side2 t)) ->\n         Apart (origin (base t)) (ln (Side2 t)))\n        (fun\n           H'2 : Apart (origin (base t)) (ln (Side2 t)) \\/\n                 Apart (extremity (Side2 t)) (ln (Side2 t)) => \n         ?Goal) (auxs2 t) H'0) H)\n    (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"]}, {"text": "elim H'2; [ trivial | intro H'0; clear H'2 ].", "goal_before": ["Apart (origin (base t)) (ln (Side2 t))"], "goal_after": ["Apart (origin (base t)) (ln (Side2 t))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) =>\n      eq_ind_r\n        (fun p : Point =>\n         Apart (origin (base t)) (ln (Side2 t)) \\/ Apart p (ln (Side2 t)) ->\n         Apart (origin (base t)) (ln (Side2 t)))\n        (fun\n           H'2 : Apart (origin (base t)) (ln (Side2 t)) \\/\n                 Apart (extremity (Side2 t)) (ln (Side2 t)) => \n         ?Goal) (auxs2 t) H'0) H)\n    (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) =>\n      eq_ind_r\n        (fun p : Point =>\n         Apart (origin (base t)) (ln (Side2 t)) \\/ Apart p (ln (Side2 t)) ->\n         Apart (origin (base t)) (ln (Side2 t)))\n        (fun\n           H'2 : Apart (origin (base t)) (ln (Side2 t)) \\/\n                 Apart (extremity (Side2 t)) (ln (Side2 t)) =>\n         or_ind (fun H0 : Apart (origin (base t)) (ln (Side2 t)) => H0)\n           (fun H'1 : Apart (extremity (Side2 t)) (ln (Side2 t)) =>\n            ?Goal@{H'0:=H'1}) H'2) (auxs2 t) H'0) H)\n    (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"]}, {"text": "elim (inc_ln2 (Side2 t)); trivial.", "goal_before": ["Apart (origin (base t)) (ln (Side2 t))"], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) =>\n      eq_ind_r\n        (fun p : Point =>\n         Apart (origin (base t)) (ln (Side2 t)) \\/ Apart p (ln (Side2 t)) ->\n         Apart (origin (base t)) (ln (Side2 t)))\n        (fun\n           H'2 : Apart (origin (base t)) (ln (Side2 t)) \\/\n                 Apart (extremity (Side2 t)) (ln (Side2 t)) =>\n         or_ind (fun H0 : Apart (origin (base t)) (ln (Side2 t)) => H0)\n           (fun H'1 : Apart (extremity (Side2 t)) (ln (Side2 t)) =>\n            ?Goal@{H'0:=H'1}) H'2) (auxs2 t) H'0) H)\n    (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) =>\n      eq_ind_r\n        (fun p : Point =>\n         Apart (origin (base t)) (ln (Side2 t)) \\/ Apart p (ln (Side2 t)) ->\n         Apart (origin (base t)) (ln (Side2 t)))\n        (fun\n           H'2 : Apart (origin (base t)) (ln (Side2 t)) \\/\n                 Apart (extremity (Side2 t)) (ln (Side2 t)) =>\n         or_ind (fun H0 : Apart (origin (base t)) (ln (Side2 t)) => H0)\n           (fun H'1 : Apart (extremity (Side2 t)) (ln (Side2 t)) =>\n            False_ind (Apart (origin (base t)) (ln (Side2 t)))\n              (inc_ln2 (Side2 t) H'1)) H'2) (auxs2 t) H'0) H)\n    (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side2 t)) =>\n  (fun\n     H : (Apart (origin (base t)) (ln (base t)) \\/\n          Apart (extremity (base t)) (ln (base t))) \\/\n         Apart (origin (base t)) (ln (Side2 t)) \\/\n         Apart (extremity (base t)) (ln (Side2 t)) =>\n   or_ind\n     (fun\n        H'0 : Apart (origin (base t)) (ln (base t)) \\/\n              Apart (extremity (base t)) (ln (base t)) =>\n      ((fun (H0 : ~ Apart (origin (base t)) (ln (base t)))\n          (H1 : ~ Apart (extremity (base t)) (ln (base t))) =>\n        or_ind\n          (fun H2 : Apart (origin (base t)) (ln (base t)) =>\n           let H3 : False := H0 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3)\n          (fun H2 : Apart (extremity (base t)) (ln (base t)) =>\n           let H3 : False := H1 H2 in\n           False_ind (Apart (origin (base t)) (ln (Side2 t))) H3) H'0)\n       :\n       Incident (origin (base t)) (ln (base t)) ->\n       Incident (extremity (base t)) (ln (base t)) ->\n       Apart (origin (base t)) (ln (Side2 t))) (inc_ln1 (base t))\n        (inc_ln2 (base t)))\n     (fun\n        H'0 : Apart (origin (base t)) (ln (Side2 t)) \\/\n              Apart (extremity (base t)) (ln (Side2 t)) =>\n      eq_ind_r\n        (fun p : Point =>\n         Apart (origin (base t)) (ln (Side2 t)) \\/ Apart p (ln (Side2 t)) ->\n         Apart (origin (base t)) (ln (Side2 t)))\n        (fun\n           H'2 : Apart (origin (base t)) (ln (Side2 t)) \\/\n                 Apart (extremity (Side2 t)) (ln (Side2 t)) =>\n         or_ind (fun H0 : Apart (origin (base t)) (ln (Side2 t)) => H0)\n           (fun H'1 : Apart (extremity (Side2 t)) (ln (Side2 t)) =>\n            False_ind (Apart (origin (base t)) (ln (Side2 t)))\n              (inc_ln2 (Side2 t) H'1)) H'2) (auxs2 t) H'0) H)\n    (el_ax (base t) (ln (base t)) (ln (Side2 t)) H')) \n   (thm4_3d t))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "Triangle_axioms_ii", "text": "Theorem Triangle_axioms_ii :\n forall t : Triangle, Apart (extremity (base t)) (ln (reverse (Side1 t))).\nProof.\nintro t.\ngeneralize (thm4_3c t); intro H'.\nlapply (el_ax (base t) (ln (base t)) (ln (reverse (Side1 t))));\n trivial.\nintro H; elim H; (clear H; intro H'0).\ngeneralize (inc_ln2 (base t)); generalize (inc_ln1 (base t)).\nunfold Incident in |- *; tauto.\nelim H'0; [ intro H'1; clear H'0 | trivial ].\ngeneralize (inc_ln1 (reverse (Side1 t))).\nrewrite <- (ext_rev (Side1 t)).\nrewrite <- (auxs1 t).\nintro H'3; elim H'3; auto.\napply cong_eqln_diln with (m := ln (Side1 t)); auto.\nQed.\n", "definition": "\n forall t : Triangle, Apart (extremity (base t)) (ln (reverse (Side1 t))).\n", "proof": "\nintro t.\ngeneralize (thm4_3c t); intro H'.\nlapply (el_ax (base t) (ln (base t)) (ln (reverse (Side1 t))));\n trivial.\nintro H; elim H; (clear H; intro H'0).\ngeneralize (inc_ln2 (base t)); generalize (inc_ln1 (base t)).\nunfold Incident in |- *; tauto.\nelim H'0; [ intro H'1; clear H'0 | trivial ].\ngeneralize (inc_ln1 (reverse (Side1 t))).\nrewrite <- (ext_rev (Side1 t)).\nrewrite <- (auxs1 t).\nintro H'3; elim H'3; auto.\napply cong_eqln_diln with (m := ln (Side1 t)); auto.\n", "def_ranges": [45, 0, 46, 74], "proof_ranges": [47, 0, 61, 4], "proof_steps": [{"text": "intro t.", "goal_before": ["forall t : Triangle, Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": ["(fun t : Triangle => ?Goal)"]}, {"text": "generalize (thm4_3c t); intro H'.", "goal_before": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": ["(fun t : Triangle => ?Goal)"], "proof_term_after": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side1 t)) => ?Goal) (thm4_3c t))"]}, {"text": "lapply (el_ax (base t) (ln (base t)) (ln (reverse (Side1 t))));", "goal_before": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": ["(fun t : Triangle =>\n (fun H' : DiLn (ln (base t)) (ln (Side1 t)) => ?Goal) (thm4_3c t))"], "proof_term_after": []}, {"text": "trivial.", "goal_before": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H; elim H; (clear H; intro H'0).", "goal_before": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Apart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (inc_ln2 (base t)); generalize (inc_ln1 (base t)).", "goal_before": ["Incident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Incident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Incident in |- *; tauto.", "goal_before": ["Incident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Incident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0; [ intro H'1; clear H'0 | trivial ].", "goal_before": ["Incident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Incident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (inc_ln1 (reverse (Side1 t))).", "goal_before": ["Incident (origin (reverse (Side1 t))) (ln (reverse (Side1 t))) ->\nIncident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Incident (origin (reverse (Side1 t))) (ln (reverse (Side1 t))) ->\nIncident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (ext_rev (Side1 t)).", "goal_before": ["Incident (extremity (Side1 t)) (ln (reverse (Side1 t))) ->\nIncident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Incident (extremity (Side1 t)) (ln (reverse (Side1 t))) ->\nIncident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (auxs1 t).", "goal_before": ["Incident (origin (base t)) (ln (reverse (Side1 t))) ->\nIncident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Incident (origin (base t)) (ln (reverse (Side1 t))) ->\nIncident (origin (base t)) (ln (base t)) ->\nIncident (extremity (base t)) (ln (base t)) ->\nApart (extremity (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'3; elim H'3; auto.", "goal_before": ["Apart (origin (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Apart (origin (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply cong_eqln_diln with (m := ln (Side1 t)); auto.", "goal_before": ["Apart (origin (base t)) (ln (reverse (Side1 t)))"], "goal_after": ["Apart (origin (base t)) (ln (reverse (Side1 t)))"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "Triangle_axioms_iii", "text": "Theorem Triangle_axioms_iii :\n forall t : Triangle, Apart (summit t) (ln (reverse (base t))).\nProof.\nintro t; elim t.\nintros summit base Tri_cond.\napply cong_eqln_apt with (l := ln base); auto.\nQed.\n", "definition": "\n forall t : Triangle, Apart (summit t) (ln (reverse (base t))).\n", "proof": "\nintro t; elim t.\nintros summit base Tri_cond.\napply cong_eqln_apt with (l := ln base); auto.\n", "def_ranges": [63, 0, 64, 63], "proof_ranges": [65, 0, 69, 4], "proof_steps": [{"text": "intro t; elim t.", "goal_before": ["forall t : Triangle, Apart (summit t) (ln (reverse (base t)))"], "goal_after": ["forall (summit : Point) (base : Segment) (Tri_cond : Apart summit (ln base)),\nApart\n  (basis.summit {| summit := summit; base := base; Tri_cond := Tri_cond |})\n  (ln\n     (reverse\n        (basis.base\n           {| summit := summit; base := base; Tri_cond := Tri_cond |})))"], "proof_term_before": [], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (reverse (base t0)))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     ?Goal summit base Tri_cond\n end)"]}, {"text": "intros summit base Tri_cond.", "goal_before": ["forall (summit : Point) (base : Segment) (Tri_cond : Apart summit (ln base)),\nApart\n  (basis.summit {| summit := summit; base := base; Tri_cond := Tri_cond |})\n  (ln\n     (reverse\n        (basis.base\n           {| summit := summit; base := base; Tri_cond := Tri_cond |})))"], "goal_after": ["Apart\n  (basis.summit {| summit := summit; base := base; Tri_cond := Tri_cond |})\n  (ln\n     (reverse\n        (basis.base\n           {| summit := summit; base := base; Tri_cond := Tri_cond |})))"], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (reverse (base t0)))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     ?Goal summit base Tri_cond\n end)"], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (reverse (base t0)))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) =>\n      ?Goal@{summit:=summit0; base:=base0; Tri_cond:=Tri_cond0}) summit base\n       Tri_cond\n end)"]}, {"text": "apply cong_eqln_apt with (l := ln base); auto.", "goal_before": ["Apart\n  (basis.summit {| summit := summit; base := base; Tri_cond := Tri_cond |})\n  (ln\n     (reverse\n        (basis.base\n           {| summit := summit; base := base; Tri_cond := Tri_cond |})))"], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (reverse (base t0)))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     (fun (summit0 : Point) (base0 : Segment)\n        (Tri_cond0 : Apart summit0 (ln base0)) =>\n      ?Goal@{summit:=summit0; base:=base0; Tri_cond:=Tri_cond0}) summit base\n       Tri_cond\n end)"], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (reverse (base t0)))) with\n | {| summit := summit0; base := base0; Tri_cond := Tri_cond |} =>\n     (fun (summit1 : Point) (base1 : Segment)\n        (Tri_cond0 : Apart summit1 (ln base1)) =>\n      cong_eqln_apt\n        (summit {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})\n        (ln base1)\n        (ln\n           (reverse\n              (base\n                 {|\n                   summit := summit1; base := base1; Tri_cond := Tri_cond0\n                 |}))) Tri_cond0\n        (rev_defines_sameln\n           (base\n              {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})))\n       summit0 base0 Tri_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (reverse (base t0)))) with\n | {| summit := summit0; base := base0; Tri_cond := Tri_cond |} =>\n     (fun (summit1 : Point) (base1 : Segment)\n        (Tri_cond0 : Apart summit1 (ln base1)) =>\n      cong_eqln_apt\n        (summit {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})\n        (ln base1)\n        (ln\n           (reverse\n              (base\n                 {|\n                   summit := summit1; base := base1; Tri_cond := Tri_cond0\n                 |}))) Tri_cond0\n        (rev_defines_sameln\n           (base\n              {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})))\n       summit0 base0 Tri_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_5ia", "text": "Theorem thm4_5ia :\n forall (x : Segment) (l : Line),\n EqLn l (ln x) -> Incident (origin x) l /\\ Incident (extremity x) l.\nProof.\nunfold EqLn, Incident, Negation in |- *.\nintuition.\nQed.\n", "definition": "\n forall (x : Segment) (l : Line),\n EqLn l (ln x) -> Incident (origin x) l /\\ Incident (extremity x) l.\n", "proof": "\nunfold EqLn, Incident, Negation in |- *.\nintuition.\n", "def_ranges": [72, 0, 74, 68], "proof_ranges": [75, 0, 78, 4], "proof_steps": [{"text": "unfold EqLn, Incident, Negation in |- *.", "goal_before": ["forall (x : Segment) (l : Line),\nEqLn l (ln x) -> Incident (origin x) l /\\ Incident (extremity x) l"], "goal_after": ["forall (x : Segment) (l : Line),\n~ DiLn l (ln x) -> ~ Apart (origin x) l /\\ ~ Apart (extremity x) l"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall (x : Segment) (l : Line),\n EqLn l (ln x) -> Incident (origin x) l /\\ Incident (extremity x) l)"]}, {"text": "intuition.", "goal_before": ["forall (x : Segment) (l : Line),\n~ DiLn l (ln x) -> ~ Apart (origin x) l /\\ ~ Apart (extremity x) l"], "goal_after": [], "proof_term_before": ["(?Goal\n :\n forall (x : Segment) (l : Line),\n EqLn l (ln x) -> Incident (origin x) l /\\ Incident (extremity x) l)"], "proof_term_after": ["((fun (x : Segment) (l : Line) (H : ~ DiLn l (ln x)) =>\n  conj\n    ((fun H0 : Apart (origin x) l => H (thm4_1b x l (or_introl H0)) : False)\n     :\n     ~ Apart (origin x) l)\n    ((fun H0 : Apart (extremity x) l =>\n      H (thm4_1b x l (or_intror H0)) : False)\n     :\n     ~ Apart (extremity x) l))\n :\n forall (x : Segment) (l : Line),\n EqLn l (ln x) -> Incident (origin x) l /\\ Incident (extremity x) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (x : Segment) (l : Line) (H : ~ DiLn l (ln x)) =>\n  conj\n    ((fun H0 : Apart (origin x) l => H (thm4_1b x l (or_introl H0)) : False)\n     :\n     ~ Apart (origin x) l)\n    ((fun H0 : Apart (extremity x) l =>\n      H (thm4_1b x l (or_intror H0)) : False)\n     :\n     ~ Apart (extremity x) l))\n :\n forall (x : Segment) (l : Line),\n EqLn l (ln x) -> Incident (origin x) l /\\ Incident (extremity x) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_5ib", "text": "Theorem thm4_5ib :\n forall (x : Segment) (l : Line),\n Incident (origin x) l /\\ Incident (extremity x) l -> EqLn l (ln x).\nProof.\ngeneralize Uniqueness_of_constructed_lines; intuition.\nQed.\n", "definition": "\n forall (x : Segment) (l : Line),\n Incident (origin x) l /\\ Incident (extremity x) l -> EqLn l (ln x).\n", "proof": "\ngeneralize Uniqueness_of_constructed_lines; intuition.\n", "def_ranges": [80, 0, 82, 68], "proof_ranges": [83, 0, 85, 4], "proof_steps": [{"text": "generalize Uniqueness_of_constructed_lines; intuition.", "goal_before": ["forall (x : Segment) (l : Line),\nIncident (origin x) l /\\ Incident (extremity x) l -> EqLn l (ln x)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun\n    (H : forall (x : Segment) (l : Line),\n         Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n    (x : Segment) (l : Line)\n    (H0 : Incident (origin x) l /\\ Incident (extremity x) l) =>\n  and_ind\n    (fun (H1 : Incident (origin x) l) (H2 : Incident (extremity x) l) =>\n     H x l H1 H2 : EqLn l (ln x)) H0) Uniqueness_of_constructed_lines)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun\n    (H : forall (x : Segment) (l : Line),\n         Incident (origin x) l -> Incident (extremity x) l -> EqLn l (ln x))\n    (x : Segment) (l : Line)\n    (H0 : Incident (origin x) l /\\ Incident (extremity x) l) =>\n  and_ind\n    (fun (H1 : Incident (origin x) l) (H2 : Incident (extremity x) l) =>\n     H x l H1 H2 : EqLn l (ln x)) H0) Uniqueness_of_constructed_lines)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_5iia", "text": "Theorem thm4_5iia :\n forall (x : Twolines) (a : Point),\n EqPt a (pt x) -> Incident a (line1 x) /\\ Incident a (line2 x).\nProof.\nsplit; apply cong_eqpt_inc with (a := pt x); auto.\nQed.\n", "definition": "\n forall (x : Twolines) (a : Point),\n EqPt a (pt x) -> Incident a (line1 x) /\\ Incident a (line2 x).\n", "proof": "\nsplit; apply cong_eqpt_inc with (a := pt x); auto.\n", "def_ranges": [88, 0, 90, 63], "proof_ranges": [91, 0, 93, 4], "proof_steps": [{"text": "split; apply cong_eqpt_inc with (a := pt x); auto.", "goal_before": ["forall (x : Twolines) (a : Point),\nEqPt a (pt x) -> Incident a (line1 x) /\\ Incident a (line2 x)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x : Twolines) (a : Point) (H : EqPt a (pt x)) =>\n conj (cong_eqpt_inc (pt x) a (line1 x) (inc_pt1 x) (sym_EqPt a (pt x) H))\n   (cong_eqpt_inc (pt x) a (line2 x) (inc_pt2 x) (sym_EqPt a (pt x) H)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (a : Point) (H : EqPt a (pt x)) =>\n conj (cong_eqpt_inc (pt x) a (line1 x) (inc_pt1 x) (sym_EqPt a (pt x) H))\n   (cong_eqpt_inc (pt x) a (line2 x) (inc_pt2 x) (sym_EqPt a (pt x) H)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_5iib", "text": "Theorem thm4_5iib :\n forall (x : Twolines) (a : Point),\n Incident a (line1 x) /\\ Incident a (line2 x) -> EqPt a (pt x).\nProof.\nintuition.\napply Uniqueness_of_constructed_points; trivial.\nQed.\n", "definition": "\n forall (x : Twolines) (a : Point),\n Incident a (line1 x) /\\ Incident a (line2 x) -> EqPt a (pt x).\n", "proof": "\nintuition.\napply Uniqueness_of_constructed_points; trivial.\n", "def_ranges": [95, 0, 97, 63], "proof_ranges": [98, 0, 101, 4], "proof_steps": [{"text": "intuition.", "goal_before": ["forall (x : Twolines) (a : Point),\nIncident a (line1 x) /\\ Incident a (line2 x) -> EqPt a (pt x)"], "goal_after": ["EqPt a (pt x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Twolines) (a : Point)\n   (H : Incident a (line1 x) /\\ Incident a (line2 x)) =>\n and_ind\n   (fun (H0 : Incident a (line1 x)) (H1 : Incident a (line2 x)) => ?Goal) H)"]}, {"text": "apply Uniqueness_of_constructed_points; trivial.", "goal_before": ["EqPt a (pt x)"], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (a : Point)\n   (H : Incident a (line1 x) /\\ Incident a (line2 x)) =>\n and_ind\n   (fun (H0 : Incident a (line1 x)) (H1 : Incident a (line2 x)) => ?Goal) H)"], "proof_term_after": ["(fun (x : Twolines) (a : Point)\n   (H : Incident a (line1 x) /\\ Incident a (line2 x)) =>\n and_ind\n   (fun (H0 : Incident a (line1 x)) (H1 : Incident a (line2 x)) =>\n    Uniqueness_of_constructed_points x a H0 H1) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (a : Point)\n   (H : Incident a (line1 x) /\\ Incident a (line2 x)) =>\n and_ind\n   (fun (H0 : Incident a (line1 x)) (H1 : Incident a (line2 x)) =>\n    Uniqueness_of_constructed_points x a H0 H1) H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_6", "text": "Theorem thm4_6 :\n forall x y : Segment,\n Incident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\n Incident (origin y) (ln x) /\\ Incident (extremity y) (ln x).\nProof.\nunfold Incident in |- *.\nintros x y H'; generalize (Symmetry_of_Apart y x).\ntauto.\nQed.\n", "definition": "\n forall x y : Segment,\n Incident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\n Incident (origin y) (ln x) /\\ Incident (extremity y) (ln x).\n", "proof": "\nunfold Incident in |- *.\nintros x y H'; generalize (Symmetry_of_Apart y x).\ntauto.\n", "def_ranges": [103, 0, 106, 61], "proof_ranges": [107, 0, 111, 4], "proof_steps": [{"text": "unfold Incident in |- *.", "goal_before": ["forall x y : Segment,\nIncident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\nIncident (origin y) (ln x) /\\ Incident (extremity y) (ln x)"], "goal_after": ["forall x y : Segment,\n~ Apart (origin x) (ln y) /\\ ~ Apart (extremity x) (ln y) ->\n~ Apart (origin y) (ln x) /\\ ~ Apart (extremity y) (ln x)"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall x y : Segment,\n Incident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\n Incident (origin y) (ln x) /\\ Incident (extremity y) (ln x))"]}, {"text": "intros x y H'; generalize (Symmetry_of_Apart y x).", "goal_before": ["forall x y : Segment,\n~ Apart (origin x) (ln y) /\\ ~ Apart (extremity x) (ln y) ->\n~ Apart (origin y) (ln x) /\\ ~ Apart (extremity y) (ln x)"], "goal_after": ["(Apart (origin y) (ln x) \\/ Apart (extremity y) (ln x) ->\n Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y)) ->\n~ Apart (origin y) (ln x) /\\ ~ Apart (extremity y) (ln x)"], "proof_term_before": ["(?Goal\n :\n forall x y : Segment,\n Incident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\n Incident (origin y) (ln x) /\\ Incident (extremity y) (ln x))"], "proof_term_after": ["((fun (x y : Segment)\n    (H' : ~ Apart (origin x) (ln y) /\\ ~ Apart (extremity x) (ln y)) =>\n  ?Goal (Symmetry_of_Apart y x))\n :\n forall x y : Segment,\n Incident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\n Incident (origin y) (ln x) /\\ Incident (extremity y) (ln x))"]}, {"text": "tauto.", "goal_before": ["(Apart (origin y) (ln x) \\/ Apart (extremity y) (ln x) ->\n Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y)) ->\n~ Apart (origin y) (ln x) /\\ ~ Apart (extremity y) (ln x)"], "goal_after": [], "proof_term_before": ["((fun (x y : Segment)\n    (H' : ~ Apart (origin x) (ln y) /\\ ~ Apart (extremity x) (ln y)) =>\n  ?Goal (Symmetry_of_Apart y x))\n :\n forall x y : Segment,\n Incident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\n Incident (origin y) (ln x) /\\ Incident (extremity y) (ln x))"], "proof_term_after": ["((fun (x y : Segment)\n    (H' : ~ Apart (origin x) (ln y) /\\ ~ Apart (extremity x) (ln y)) =>\n  (fun\n     H : Apart (origin y) (ln x) \\/ Apart (extremity y) (ln x) ->\n         Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) =>\n   and_ind\n     (fun (H0 : ~ Apart (origin x) (ln y))\n        (H1 : ~ Apart (extremity x) (ln y)) =>\n      let H2 :\n        Apart (origin y) (ln x) ->\n        Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) :=\n        fun H2 : Apart (origin y) (ln x) => H (or_introl H2) in\n      let H3 :\n        Apart (extremity y) (ln x) ->\n        Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) :=\n        fun H3 : Apart (extremity y) (ln x) => H (or_intror H3) in\n      conj\n        ((fun H4 : Apart (origin y) (ln x) =>\n          let H5 : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) :=\n            H2 H4 in\n          or_ind\n            (fun H6 : Apart (origin x) (ln y) =>\n             let H7 : False := H0 H6 in False_ind False H7)\n            (fun H6 : Apart (extremity x) (ln y) =>\n             let H7 : False := H1 H6 in False_ind False H7) H5)\n         :\n         ~ Apart (origin y) (ln x))\n        ((fun H4 : Apart (extremity y) (ln x) =>\n          let H5 : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) :=\n            H3 H4 in\n          or_ind\n            (fun H6 : Apart (origin x) (ln y) =>\n             let H7 : False := H0 H6 in False_ind False H7)\n            (fun H6 : Apart (extremity x) (ln y) =>\n             let H7 : False := H1 H6 in False_ind False H7) H5)\n         :\n         ~ Apart (extremity y) (ln x))) H') (Symmetry_of_Apart y x))\n :\n forall x y : Segment,\n Incident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\n Incident (origin y) (ln x) /\\ Incident (extremity y) (ln x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (x y : Segment)\n    (H' : ~ Apart (origin x) (ln y) /\\ ~ Apart (extremity x) (ln y)) =>\n  (fun\n     H : Apart (origin y) (ln x) \\/ Apart (extremity y) (ln x) ->\n         Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) =>\n   and_ind\n     (fun (H0 : ~ Apart (origin x) (ln y))\n        (H1 : ~ Apart (extremity x) (ln y)) =>\n      let H2 :\n        Apart (origin y) (ln x) ->\n        Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) :=\n        fun H2 : Apart (origin y) (ln x) => H (or_introl H2) in\n      let H3 :\n        Apart (extremity y) (ln x) ->\n        Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) :=\n        fun H3 : Apart (extremity y) (ln x) => H (or_intror H3) in\n      conj\n        ((fun H4 : Apart (origin y) (ln x) =>\n          let H5 : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) :=\n            H2 H4 in\n          or_ind\n            (fun H6 : Apart (origin x) (ln y) =>\n             let H7 : False := H0 H6 in False_ind False H7)\n            (fun H6 : Apart (extremity x) (ln y) =>\n             let H7 : False := H1 H6 in False_ind False H7) H5)\n         :\n         ~ Apart (origin y) (ln x))\n        ((fun H4 : Apart (extremity y) (ln x) =>\n          let H5 : Apart (origin x) (ln y) \\/ Apart (extremity x) (ln y) :=\n            H3 H4 in\n          or_ind\n            (fun H6 : Apart (origin x) (ln y) =>\n             let H7 : False := H0 H6 in False_ind False H7)\n            (fun H6 : Apart (extremity x) (ln y) =>\n             let H7 : False := H1 H6 in False_ind False H7) H5)\n         :\n         ~ Apart (extremity y) (ln x))) H') (Symmetry_of_Apart y x))\n :\n forall x y : Segment,\n Incident (origin x) (ln y) /\\ Incident (extremity x) (ln y) ->\n Incident (origin y) (ln x) /\\ Incident (extremity y) (ln x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_7i", "text": "Theorem thm4_7i :\n forall (a b c : Point) (H1 : DiPt a b) (H2 : DiPt b c),\n Incident c (ln (Seg a b H1)) -> Incident a (ln (reverse (Seg b c H2))).\nProof.\nintros a b c H1 H2 H'.\nlapply (thm4_6 (reverse (Seg b c H2)) (Seg a b H1));\n [ intro H'1; elim H'1; trivial | idtac ].\ngeneralize (inc_ln2 (Seg a b H1)); auto.\nQed.\n", "definition": "\n forall (a b c : Point) (H1 : DiPt a b) (H2 : DiPt b c),\n Incident c (ln (Seg a b H1)) -> Incident a (ln (reverse (Seg b c H2))).\n", "proof": "\nintros a b c H1 H2 H'.\nlapply (thm4_6 (reverse (Seg b c H2)) (Seg a b H1));\n [ intro H'1; elim H'1; trivial | idtac ].\ngeneralize (inc_ln2 (Seg a b H1)); auto.\n", "def_ranges": [113, 0, 115, 72], "proof_ranges": [116, 0, 121, 4], "proof_steps": [{"text": "intros a b c H1 H2 H'.", "goal_before": ["forall (a b c : Point) (H1 : DiPt a b) (H2 : DiPt b c),\nIncident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\nIncident a (ln (reverse {| origin := b; extremity := c; Seg_cond := H2 |}))"], "goal_after": ["Incident a (ln (reverse {| origin := b; extremity := c; Seg_cond := H2 |}))"], "proof_term_before": [], "proof_term_after": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : DiPt b c)\n   (H' : Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n => ?Goal)"]}, {"text": "lapply (thm4_6 (reverse (Seg b c H2)) (Seg a b H1));", "goal_before": ["Incident a (ln (reverse {| origin := b; extremity := c; Seg_cond := H2 |}))"], "goal_after": ["Incident a (ln (reverse {| origin := b; extremity := c; Seg_cond := H2 |}))"], "proof_term_before": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : DiPt b c)\n   (H' : Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n => ?Goal)"], "proof_term_after": []}, {"text": "[ intro H'1; elim H'1; trivial | idtac ].", "goal_before": ["Incident a (ln (reverse {| origin := b; extremity := c; Seg_cond := H2 |}))"], "goal_after": ["Incident a (ln (reverse {| origin := b; extremity := c; Seg_cond := H2 |}))"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (inc_ln2 (Seg a b H1)); auto.", "goal_before": ["Incident (extremity {| origin := a; extremity := b; Seg_cond := H1 |})\n  (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\nIncident a (ln (reverse {| origin := b; extremity := c; Seg_cond := H2 |}))"], "goal_after": ["Incident (extremity {| origin := a; extremity := b; Seg_cond := H1 |})\n  (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\nIncident a (ln (reverse {| origin := b; extremity := c; Seg_cond := H2 |}))"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_7ii", "text": "Theorem thm4_7ii :\n forall (a b c : Point) (H1 : DiPt a b) (H2 : DiPt a c),\n Incident c (ln (Seg a b H1)) -> Incident b (ln (Seg a c H2)).\nProof.\nintros a b c H1 H2 H'.\nlapply (thm4_6 (Seg a c H2) (Seg a b H1));\n [ intro H'1; elim H'1; trivial | idtac ].\ngeneralize (inc_ln1 (Seg a b H1)); auto.\nQed.\n", "definition": "\n forall (a b c : Point) (H1 : DiPt a b) (H2 : DiPt a c),\n Incident c (ln (Seg a b H1)) -> Incident b (ln (Seg a c H2)).\n", "proof": "\nintros a b c H1 H2 H'.\nlapply (thm4_6 (Seg a c H2) (Seg a b H1));\n [ intro H'1; elim H'1; trivial | idtac ].\ngeneralize (inc_ln1 (Seg a b H1)); auto.\n", "def_ranges": [123, 0, 125, 62], "proof_ranges": [126, 0, 131, 4], "proof_steps": [{"text": "intros a b c H1 H2 H'.", "goal_before": ["forall (a b c : Point) (H1 : DiPt a b) (H2 : DiPt a c),\nIncident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\nIncident b (ln {| origin := a; extremity := c; Seg_cond := H2 |})"], "goal_after": ["Incident b (ln {| origin := a; extremity := c; Seg_cond := H2 |})"], "proof_term_before": [], "proof_term_after": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : DiPt a c)\n   (H' : Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n => ?Goal)"]}, {"text": "lapply (thm4_6 (Seg a c H2) (Seg a b H1));", "goal_before": ["Incident b (ln {| origin := a; extremity := c; Seg_cond := H2 |})"], "goal_after": ["Incident b (ln {| origin := a; extremity := c; Seg_cond := H2 |})"], "proof_term_before": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : DiPt a c)\n   (H' : Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n => ?Goal)"], "proof_term_after": []}, {"text": "[ intro H'1; elim H'1; trivial | idtac ].", "goal_before": ["Incident b (ln {| origin := a; extremity := c; Seg_cond := H2 |})"], "goal_after": ["Incident b (ln {| origin := a; extremity := c; Seg_cond := H2 |})"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (inc_ln1 (Seg a b H1)); auto.", "goal_before": ["Incident (origin {| origin := a; extremity := b; Seg_cond := H1 |})\n  (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\nIncident b (ln {| origin := a; extremity := c; Seg_cond := H2 |})"], "goal_after": ["Incident (origin {| origin := a; extremity := b; Seg_cond := H1 |})\n  (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\nIncident b (ln {| origin := a; extremity := c; Seg_cond := H2 |})"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_7iii", "text": "Theorem thm4_7iii :\n forall (x : Segment) (c : Point),\n Incident c (ln x) -> Incident c (ln (reverse x)).\nProof.\nintros x c H'.\napply cong_eqln_inc with (l := ln x); auto.\nQed.\n", "definition": "\n forall (x : Segment) (c : Point),\n Incident c (ln x) -> Incident c (ln (reverse x)).\n", "proof": "\nintros x c H'.\napply cong_eqln_inc with (l := ln x); auto.\n", "def_ranges": [133, 0, 135, 50], "proof_ranges": [136, 0, 139, 4], "proof_steps": [{"text": "intros x c H'.", "goal_before": ["forall (x : Segment) (c : Point),\nIncident c (ln x) -> Incident c (ln (reverse x))"], "goal_after": ["Incident c (ln (reverse x))"], "proof_term_before": [], "proof_term_after": ["(fun (x : Segment) (c : Point) (H' : Incident c (ln x)) => ?Goal)"]}, {"text": "apply cong_eqln_inc with (l := ln x); auto.", "goal_before": ["Incident c (ln (reverse x))"], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (c : Point) (H' : Incident c (ln x)) => ?Goal)"], "proof_term_after": ["(fun (x : Segment) (c : Point) (H' : Incident c (ln x)) =>\n cong_eqln_inc c (ln x) (ln (reverse x)) H' (rev_defines_sameln x))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : Segment) (c : Point) (H' : Incident c (ln x)) =>\n cong_eqln_inc c (ln x) (ln (reverse x)) H' (rev_defines_sameln x))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "Symmetry_of_Apart'", "text": "Theorem Symmetry_of_Apart' :\n forall x y : Twolines,\n Apart (pt y) (line1 x) \\/ Apart (pt y) (line2 x) ->\n Apart (pt x) (line1 y) \\/ Apart (pt x) (line2 y).\nProof.\nintros x y H'.\napply thm4_1c.\napply sym_DiPt; auto.\nQed.\n", "definition": "\n forall x y : Twolines,\n Apart (pt y) (line1 x) \\/ Apart (pt y) (line2 x) ->\n Apart (pt x) (line1 y) \\/ Apart (pt x) (line2 y).\n", "proof": "\nintros x y H'.\napply thm4_1c.\napply sym_DiPt; auto.\n", "def_ranges": [141, 0, 144, 50], "proof_ranges": [145, 0, 149, 4], "proof_steps": [{"text": "intros x y H'.", "goal_before": ["forall x y : Twolines,\nApart (pt y) (line1 x) \\/ Apart (pt y) (line2 x) ->\nApart (pt x) (line1 y) \\/ Apart (pt x) (line2 y)"], "goal_after": ["Apart (pt x) (line1 y) \\/ Apart (pt x) (line2 y)"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Twolines) (H' : Apart (pt y) (line1 x) \\/ Apart (pt y) (line2 x))\n => ?Goal)"]}, {"text": "apply thm4_1c.", "goal_before": ["Apart (pt x) (line1 y) \\/ Apart (pt x) (line2 y)"], "goal_after": ["DiPt (pt x) (pt y)"], "proof_term_before": ["(fun (x y : Twolines) (H' : Apart (pt y) (line1 x) \\/ Apart (pt y) (line2 x))\n => ?Goal)"], "proof_term_after": ["(fun (x y : Twolines) (H' : Apart (pt y) (line1 x) \\/ Apart (pt y) (line2 x))\n => thm4_1c y (pt x) ?Goal)"]}, {"text": "apply sym_DiPt; auto.", "goal_before": ["DiPt (pt x) (pt y)"], "goal_after": [], "proof_term_before": ["(fun (x y : Twolines) (H' : Apart (pt y) (line1 x) \\/ Apart (pt y) (line2 x))\n => thm4_1c y (pt x) ?Goal)"], "proof_term_after": ["(fun (x y : Twolines) (H' : Apart (pt y) (line1 x) \\/ Apart (pt y) (line2 x))\n => thm4_1c y (pt x) (sym_DiPt (pt y) (pt x) (thm4_1d x (pt y) H')))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : Twolines) (H' : Apart (pt y) (line1 x) \\/ Apart (pt y) (line2 x))\n => thm4_1c y (pt x) (sym_DiPt (pt y) (pt x) (thm4_1d x (pt y) H')))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_9a", "text": "Theorem thm4_9a :\n forall (x : Twolines) (c : Line), Apart (pt x) c -> DiLn c (line1 x).\nProof.\nintros x c H'.\nlapply (cmp_apt_diln (pt x) c (line1 x));\n [ intro H'3; elim H'3; [ trivial | intro H'4; clear H'3 ] | idtac ];\n trivial.\nelim (inc_pt1 x); trivial.\nQed.\n", "definition": "\n forall (x : Twolines) (c : Line), Apart (pt x) c -> DiLn c (line1 x).\n", "proof": "\nintros x c H'.\nlapply (cmp_apt_diln (pt x) c (line1 x));\n [ intro H'3; elim H'3; [ trivial | intro H'4; clear H'3 ] | idtac ];\n trivial.\nelim (inc_pt1 x); trivial.\n", "def_ranges": [151, 0, 152, 70], "proof_ranges": [153, 0, 159, 4], "proof_steps": [{"text": "intros x c H'.", "goal_before": ["forall (x : Twolines) (c : Line), Apart (pt x) c -> DiLn c (line1 x)"], "goal_after": ["DiLn c (line1 x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) => ?Goal)"]}, {"text": "lapply (cmp_apt_diln (pt x) c (line1 x));", "goal_before": ["DiLn c (line1 x)"], "goal_after": ["DiLn c (line1 x)"], "proof_term_before": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) => ?Goal)"], "proof_term_after": []}, {"text": "[ intro H'3; elim H'3; [ trivial | intro H'4; clear H'3 ] | idtac ];", "goal_before": ["DiLn c (line1 x)"], "goal_after": ["DiLn c (line1 x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) => ?Goal)"]}, {"text": "trivial.", "goal_before": ["DiLn c (line1 x)"], "goal_after": ["Apart (pt x) (line1 x)"], "proof_term_before": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) => ?Goal)"], "proof_term_after": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) =>\n False_ind (DiLn c (line1 x)) (inc_pt1 x ?Goal))"]}, {"text": "elim (inc_pt1 x); trivial.", "goal_before": ["Apart (pt x) (line1 x)"], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) =>\n False_ind (DiLn c (line1 x)) (inc_pt1 x ?Goal))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm4_9b", "text": "Theorem thm4_9b :\n forall (x : Twolines) (c : Line), Apart (pt x) c -> DiLn c (line2 x).\nProof.\nintros x c H'.\nlapply (cmp_apt_diln (pt x) c (line2 x));\n [ intro H'3; elim H'3; [ trivial | intro H'4; clear H'3 ] | idtac ];\n trivial.\nelim (inc_pt2 x); trivial.\nQed.\n", "definition": "\n forall (x : Twolines) (c : Line), Apart (pt x) c -> DiLn c (line2 x).\n", "proof": "\nintros x c H'.\nlapply (cmp_apt_diln (pt x) c (line2 x));\n [ intro H'3; elim H'3; [ trivial | intro H'4; clear H'3 ] | idtac ];\n trivial.\nelim (inc_pt2 x); trivial.\n", "def_ranges": [161, 0, 162, 70], "proof_ranges": [163, 0, 169, 4], "proof_steps": [{"text": "intros x c H'.", "goal_before": ["forall (x : Twolines) (c : Line), Apart (pt x) c -> DiLn c (line2 x)"], "goal_after": ["DiLn c (line2 x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) => ?Goal)"]}, {"text": "lapply (cmp_apt_diln (pt x) c (line2 x));", "goal_before": ["DiLn c (line2 x)"], "goal_after": ["DiLn c (line2 x)"], "proof_term_before": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) => ?Goal)"], "proof_term_after": []}, {"text": "[ intro H'3; elim H'3; [ trivial | intro H'4; clear H'3 ] | idtac ];", "goal_before": ["DiLn c (line2 x)"], "goal_after": ["DiLn c (line2 x)"], "proof_term_before": [], "proof_term_after": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) => ?Goal)"]}, {"text": "trivial.", "goal_before": ["DiLn c (line2 x)"], "goal_after": ["Apart (pt x) (line2 x)"], "proof_term_before": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) => ?Goal)"], "proof_term_after": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) =>\n False_ind (DiLn c (line2 x)) (inc_pt2 x ?Goal))"]}, {"text": "elim (inc_pt2 x); trivial.", "goal_before": ["Apart (pt x) (line2 x)"], "goal_after": [], "proof_term_before": ["(fun (x : Twolines) (c : Line) (H' : Apart (pt x) c) =>\n False_ind (DiLn c (line2 x)) (inc_pt2 x ?Goal))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm5_3", "text": "Theorem thm5_3 :\n forall (x y : Segment) (z : Twolines),\n origin x = origin y ->\n line1 z = ln x -> line2 z = ln y -> EqPt (pt z) (origin x).\nProof.\nintros x y z; elim z; simpl in |- *.\nintros line1 line2 Twol_cond H' H'0 H'1.\nlapply (Convergent_imp_distinct line1 line2); trivial.\nintro H'2; red in |- *; red in |- *; red in |- *; intro H.\nlapply\n (el_ax (Seg (pt (Twol line1 line2 Twol_cond)) (origin x) H) line1 line2);\n [ intro H'7 | trivial ].\nsimpl in H'7.\nelim H'7; clear H'7; (intro H'3; elim H'3; (clear H'3; intro H'4)).\nelim (inc_pt1 (Twol line1 line2 Twol_cond)); auto.\napply (inc_ln1 x); rewrite <- H'0; assumption.\nelim (inc_pt2 (Twol line1 line2 Twol_cond)); auto.\napply (inc_ln1 y); rewrite <- H'1; rewrite <- H'; assumption.\nQed.\n", "definition": "\n forall (x y : Segment) (z : Twolines),\n origin x = origin y ->\n line1 z = ln x -> line2 z = ln y -> EqPt (pt z) (origin x).\n", "proof": "\nintros x y z; elim z; simpl in |- *.\nintros line1 line2 Twol_cond H' H'0 H'1.\nlapply (Convergent_imp_distinct line1 line2); trivial.\nintro H'2; red in |- *; red in |- *; red in |- *; intro H.\nlapply\n (el_ax (Seg (pt (Twol line1 line2 Twol_cond)) (origin x) H) line1 line2);\n [ intro H'7 | trivial ].\nsimpl in H'7.\nelim H'7; clear H'7; (intro H'3; elim H'3; (clear H'3; intro H'4)).\nelim (inc_pt1 (Twol line1 line2 Twol_cond)); auto.\napply (inc_ln1 x); rewrite <- H'0; assumption.\nelim (inc_pt2 (Twol line1 line2 Twol_cond)); auto.\napply (inc_ln1 y); rewrite <- H'1; rewrite <- H'; assumption.\n", "def_ranges": [171, 0, 174, 60], "proof_ranges": [175, 0, 189, 4], "proof_steps": [{"text": "intros x y z; elim z; simpl in |- *.", "goal_before": ["forall (x y : Segment) (z : Twolines),\norigin x = origin y ->\nline1 z = ln x -> line2 z = ln y -> EqPt (pt z) (origin x)"], "goal_after": ["forall (line1 line2 : Line) (Twol_cond : ConLn line1 line2),\norigin x = origin y ->\nline1 = ln x ->\nline2 = ln y ->\nEqPt (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (origin x)"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (?Goal\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "intros line1 line2 Twol_cond H' H'0 H'1.", "goal_before": ["forall (line1 line2 : Line) (Twol_cond : ConLn line1 line2),\norigin x = origin y ->\nline1 = ln x ->\nline2 = ln y ->\nEqPt (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (origin x)"], "goal_after": ["EqPt (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (origin x)"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (?Goal\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) => ?Goal@{Twol_cond:=Twol_cond0})\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "lapply (Convergent_imp_distinct line1 line2); trivial.", "goal_before": ["EqPt (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (origin x)"], "goal_after": ["DiLn line1 line2 ->\nEqPt (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (origin x)"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) => ?Goal@{Twol_cond:=Twol_cond0})\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       ?Goal@{Twol_cond:=Twol_cond0}\n         (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "intro H'2; red in |- *; red in |- *; red in |- *; intro H.", "goal_before": ["DiLn line1 line2 ->\nEqPt (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (origin x)"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       ?Goal@{Twol_cond:=Twol_cond0}\n         (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) => ?Goal@{Twol_cond:=Twol_cond0})\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "lapply", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) => ?Goal@{Twol_cond:=Twol_cond0})\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": []}, {"text": "(el_ax (Seg (pt (Twol line1 line2 Twol_cond)) (origin x) H) line1 line2);", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) => ?Goal@{Twol_cond:=Twol_cond0})\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "[ intro H'7 | trivial ].", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) => ?Goal@{Twol_cond:=Twol_cond0})\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) => ?Goal@{Twol_cond:=Twol_cond0})\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "simpl in H'7.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) => ?Goal@{Twol_cond:=Twol_cond0})\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) => ?Goal@{Twol_cond:=Twol_cond0})\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "elim H'7; clear H'7; (intro H'3; elim H'3; (clear H'3; intro H'4)).", "goal_before": ["False"], "goal_after": ["Apart (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (basis.line1 {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) => ?Goal@{Twol_cond:=Twol_cond0})\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) =>\n           False_ind False\n             (inc_pt1\n                {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |}\n                ?Goal@{Twol_cond:=Twol_cond0}))\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "elim (inc_pt1 (Twol line1 line2 Twol_cond)); auto.", "goal_before": ["Apart (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (basis.line1 {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})"], "goal_after": ["Apart (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (basis.line1 {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) =>\n           False_ind False\n             (inc_pt1\n                {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |}\n                ?Goal@{Twol_cond:=Twol_cond0}))\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) =>\n           False_ind False\n             (inc_pt1\n                {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |}\n                ?Goal@{Twol_cond:=Twol_cond0}))\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "apply (inc_ln1 x); rewrite <- H'0; assumption.", "goal_before": ["Apart (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (basis.line1 {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})"], "goal_after": ["Apart (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (basis.line2 {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line1 line2 : Line) (Twol_cond0 : ConLn line1 line2)\n         (H' : origin x = origin y) (H'0 : line1 = ln x) \n         (H'1 : line2 = ln y) =>\n       (fun H'2 : DiLn line1 line2 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line1;\n                        line2 := line2;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) =>\n           False_ind False\n             (inc_pt1\n                {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |}\n                ?Goal@{Twol_cond:=Twol_cond0}))\n          :\n          ~\n          DiPt\n            (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line1 line2 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line2 line5 : Line) (Twol_cond0 : ConLn line2 line5)\n         (H' : origin x = origin y) (H'0 : line2 = ln x) \n         (H'1 : line5 = ln y) =>\n       (fun H'2 : DiLn line2 line5 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line2;\n                        line2 := line5;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) =>\n           False_ind False\n             (inc_pt1\n                {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |}\n                (False_ind\n                   (Apart\n                      (pt\n                         {|\n                           line1 := line2;\n                           line2 := line5;\n                           Twol_cond := Twol_cond0\n                         |})\n                      (line1\n                         {|\n                           line1 := line2;\n                           line2 := line5;\n                           Twol_cond := Twol_cond0\n                         |}))\n                   (inc_pt2\n                      {|\n                        line1 := line2;\n                        line2 := line5;\n                        Twol_cond := Twol_cond0\n                      |}\n                      ?Goal@{line1:=line2; line2:=line5;\n                             Twol_cond:=Twol_cond0}))))\n          :\n          ~\n          DiPt\n            (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line2 line5 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "elim (inc_pt2 (Twol line1 line2 Twol_cond)); auto.", "goal_before": ["Apart (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (basis.line2 {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})"], "goal_after": ["Apart (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (basis.line2 {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})"], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line2 line5 : Line) (Twol_cond0 : ConLn line2 line5)\n         (H' : origin x = origin y) (H'0 : line2 = ln x) \n         (H'1 : line5 = ln y) =>\n       (fun H'2 : DiLn line2 line5 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line2;\n                        line2 := line5;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) =>\n           False_ind False\n             (inc_pt1\n                {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |}\n                (False_ind\n                   (Apart\n                      (pt\n                         {|\n                           line1 := line2;\n                           line2 := line5;\n                           Twol_cond := Twol_cond0\n                         |})\n                      (line1\n                         {|\n                           line1 := line2;\n                           line2 := line5;\n                           Twol_cond := Twol_cond0\n                         |}))\n                   (inc_pt2\n                      {|\n                        line1 := line2;\n                        line2 := line5;\n                        Twol_cond := Twol_cond0\n                      |}\n                      ?Goal@{line1:=line2; line2:=line5;\n                             Twol_cond:=Twol_cond0}))))\n          :\n          ~\n          DiPt\n            (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line2 line5 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line2 line5 : Line) (Twol_cond0 : ConLn line2 line5)\n         (H' : origin x = origin y) (H'0 : line2 = ln x) \n         (H'1 : line5 = ln y) =>\n       (fun H'2 : DiLn line2 line5 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line2;\n                        line2 := line5;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) =>\n           False_ind False\n             (inc_pt1\n                {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |}\n                (False_ind\n                   (Apart\n                      (pt\n                         {|\n                           line1 := line2;\n                           line2 := line5;\n                           Twol_cond := Twol_cond0\n                         |})\n                      (line1\n                         {|\n                           line1 := line2;\n                           line2 := line5;\n                           Twol_cond := Twol_cond0\n                         |}))\n                   (inc_pt2\n                      {|\n                        line1 := line2;\n                        line2 := line5;\n                        Twol_cond := Twol_cond0\n                      |}\n                      ?Goal@{line1:=line2; line2:=line5;\n                             Twol_cond:=Twol_cond0}))))\n          :\n          ~\n          DiPt\n            (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line2 line5 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"]}, {"text": "apply (inc_ln1 y); rewrite <- H'1; rewrite <- H'; assumption.", "goal_before": ["Apart (pt {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})\n  (basis.line2 {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |})"], "goal_after": [], "proof_term_before": ["(fun (x y : Segment) (z : Twolines) =>\n match\n   z as t\n   return\n     (origin x = origin y ->\n      line1 t = ln x -> line2 t = ln y -> EqPt (pt t) (origin x))\n with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     ((fun (line2 line5 : Line) (Twol_cond0 : ConLn line2 line5)\n         (H' : origin x = origin y) (H'0 : line2 = ln x) \n         (H'1 : line5 = ln y) =>\n       (fun H'2 : DiLn line2 line5 =>\n        (((fun\n             H : DiPt\n                   (pt\n                      {|\n                        line1 := line2;\n                        line2 := line5;\n                        Twol_cond := Twol_cond0\n                      |}) (origin x) =>\n           False_ind False\n             (inc_pt1\n                {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |}\n                (False_ind\n                   (Apart\n                      (pt\n                         {|\n                           line1 := line2;\n                           line2 := line5;\n                           Twol_cond := Twol_cond0\n                         |})\n                      (line1\n                         {|\n                           line1 := line2;\n                           line2 := line5;\n                           Twol_cond := Twol_cond0\n                         |}))\n                   (inc_pt2\n                      {|\n                        line1 := line2;\n                        line2 := line5;\n                        Twol_cond := Twol_cond0\n                      |}\n                      ?Goal@{line1:=line2; line2:=line5;\n                             Twol_cond:=Twol_cond0}))))\n          :\n          ~\n          DiPt\n            (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n            (origin x))\n         :\n         Negation Point DiPt\n           (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n           (origin x))\n        :\n        EqPt\n          (pt {| line1 := line2; line2 := line5; Twol_cond := Twol_cond0 |})\n          (origin x)) (Convergent_imp_distinct line2 line5 Twol_cond0))\n      :\n      forall (line5 line6 : Line) (Twol_cond0 : ConLn line5 line6),\n      origin x = origin y ->\n      line1 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln x ->\n      line2 {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |} =\n      ln y ->\n      EqPt (pt {| line1 := line5; line2 := line6; Twol_cond := Twol_cond0 |})\n        (origin x)) line3 line4 Twol_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm5_4", "text": "Theorem thm5_4 :\n forall (x y : Twolines) (z : Segment),\n line1 x = line1 y ->\n origin z = pt x -> extremity z = pt y -> EqLn (ln z) (line1 x).\nProof.\nintros x y z; elim z; simpl in |- *.\nintros origin extremity Seg_cond H' H'0 H'1.\nred in |- *; red in |- *; red in |- *; intro H'2.\nlapply\n (el_ax (Seg origin extremity Seg_cond) (ln (Seg origin extremity Seg_cond))\n    (line1 x)); [ intro H'7 | trivial ].\nsimpl in H'7.\nelim H'7; clear H'7; (intro H'3; elim H'3; (clear H'3; intro H'4)).\nelim (inc_ln1 (Seg origin extremity Seg_cond)); auto.\nelim (inc_ln2 (Seg origin extremity Seg_cond)); auto.\napply (inc_pt1 x); rewrite <- H'0; assumption.\napply (inc_pt1 y); rewrite <- H'1; rewrite <- H'; assumption.\nQed.\n", "definition": "\n forall (x y : Twolines) (z : Segment),\n line1 x = line1 y ->\n origin z = pt x -> extremity z = pt y -> EqLn (ln z) (line1 x).\n", "proof": "\nintros x y z; elim z; simpl in |- *.\nintros origin extremity Seg_cond H' H'0 H'1.\nred in |- *; red in |- *; red in |- *; intro H'2.\nlapply\n (el_ax (Seg origin extremity Seg_cond) (ln (Seg origin extremity Seg_cond))\n    (line1 x)); [ intro H'7 | trivial ].\nsimpl in H'7.\nelim H'7; clear H'7; (intro H'3; elim H'3; (clear H'3; intro H'4)).\nelim (inc_ln1 (Seg origin extremity Seg_cond)); auto.\nelim (inc_ln2 (Seg origin extremity Seg_cond)); auto.\napply (inc_pt1 x); rewrite <- H'0; assumption.\napply (inc_pt1 y); rewrite <- H'1; rewrite <- H'; assumption.\n", "def_ranges": [191, 0, 194, 64], "proof_ranges": [195, 0, 208, 4], "proof_steps": [{"text": "intros x y z; elim z; simpl in |- *.", "goal_before": ["forall (x y : Twolines) (z : Segment),\nline1 x = line1 y ->\norigin z = pt x -> extremity z = pt y -> EqLn (ln z) (line1 x)"], "goal_after": ["forall (origin extremity : Point) (Seg_cond : DiPt origin extremity),\nline1 x = line1 y ->\norigin = pt x ->\nextremity = pt y ->\nEqLn\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (line1 x)"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (?Goal\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "intros origin extremity Seg_cond H' H'0 H'1.", "goal_before": ["forall (origin extremity : Point) (Seg_cond : DiPt origin extremity),\nline1 x = line1 y ->\norigin = pt x ->\nextremity = pt y ->\nEqLn\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (line1 x)"], "goal_after": ["EqLn\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (line1 x)"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (?Goal\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) => ?Goal@{Seg_cond:=Seg_cond0})\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "red in |- *; red in |- *; red in |- *; intro H'2.", "goal_before": ["EqLn\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (line1 x)"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) => ?Goal@{Seg_cond:=Seg_cond0})\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) => ?Goal@{Seg_cond:=Seg_cond0})\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "lapply", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) => ?Goal@{Seg_cond:=Seg_cond0})\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": []}, {"text": "(el_ax (Seg origin extremity Seg_cond) (ln (Seg origin extremity Seg_cond))", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) => ?Goal@{Seg_cond:=Seg_cond0})\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "(line1 x)); [ intro H'7 | trivial ].", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) => ?Goal@{Seg_cond:=Seg_cond0})\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) => ?Goal@{Seg_cond:=Seg_cond0})\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "simpl in H'7.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) => ?Goal@{Seg_cond:=Seg_cond0})\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) => ?Goal@{Seg_cond:=Seg_cond0})\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "elim H'7; clear H'7; (intro H'3; elim H'3; (clear H'3; intro H'4)).", "goal_before": ["False"], "goal_after": ["Apart\n  (basis.origin\n     {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) => ?Goal@{Seg_cond:=Seg_cond0})\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) =>\n          False_ind False\n            (inc_ln1\n               {|\n                 origin := origin;\n                 extremity := extremity;\n                 Seg_cond := Seg_cond0\n               |} ?Goal@{Seg_cond:=Seg_cond0}))\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "elim (inc_ln1 (Seg origin extremity Seg_cond)); auto.", "goal_before": ["Apart\n  (basis.origin\n     {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})"], "goal_after": ["Apart\n  (basis.extremity\n     {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin extremity : Point) (Seg_cond0 : DiPt origin extremity)\n         (H' : line1 x = line1 y) (H'0 : origin = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) =>\n          False_ind False\n            (inc_ln1\n               {|\n                 origin := origin;\n                 extremity := extremity;\n                 Seg_cond := Seg_cond0\n               |} ?Goal@{Seg_cond:=Seg_cond0}))\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin; extremity := extremity; Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin1 extremity : Point) (Seg_cond0 : DiPt origin1 extremity)\n         (H' : line1 x = line1 y) (H'0 : origin1 = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin1;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) =>\n          False_ind False\n            (inc_ln1\n               {|\n                 origin := origin1;\n                 extremity := extremity;\n                 Seg_cond := Seg_cond0\n               |}\n               (False_ind\n                  (Apart\n                     (origin\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |})\n                     (ln\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |}))\n                  (inc_ln2\n                     {|\n                       origin := origin1;\n                       extremity := extremity;\n                       Seg_cond := Seg_cond0\n                     |} ?Goal@{origin:=origin1; Seg_cond:=Seg_cond0}))))\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin1;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin1;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin1;\n              extremity := extremity;\n              Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "elim (inc_ln2 (Seg origin extremity Seg_cond)); auto.", "goal_before": ["Apart\n  (basis.extremity\n     {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})"], "goal_after": ["Apart\n  (basis.extremity\n     {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin1 extremity : Point) (Seg_cond0 : DiPt origin1 extremity)\n         (H' : line1 x = line1 y) (H'0 : origin1 = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin1;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) =>\n          False_ind False\n            (inc_ln1\n               {|\n                 origin := origin1;\n                 extremity := extremity;\n                 Seg_cond := Seg_cond0\n               |}\n               (False_ind\n                  (Apart\n                     (origin\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |})\n                     (ln\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |}))\n                  (inc_ln2\n                     {|\n                       origin := origin1;\n                       extremity := extremity;\n                       Seg_cond := Seg_cond0\n                     |} ?Goal@{origin:=origin1; Seg_cond:=Seg_cond0}))))\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin1;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin1;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin1;\n              extremity := extremity;\n              Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin1 extremity : Point) (Seg_cond0 : DiPt origin1 extremity)\n         (H' : line1 x = line1 y) (H'0 : origin1 = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin1;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) =>\n          False_ind False\n            (inc_ln1\n               {|\n                 origin := origin1;\n                 extremity := extremity;\n                 Seg_cond := Seg_cond0\n               |}\n               (False_ind\n                  (Apart\n                     (origin\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |})\n                     (ln\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |}))\n                  (inc_ln2\n                     {|\n                       origin := origin1;\n                       extremity := extremity;\n                       Seg_cond := Seg_cond0\n                     |} ?Goal@{origin:=origin1; Seg_cond:=Seg_cond0}))))\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin1;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin1;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin1;\n              extremity := extremity;\n              Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "apply (inc_pt1 x); rewrite <- H'0; assumption.", "goal_before": ["Apart\n  (basis.extremity\n     {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})"], "goal_after": ["Apart\n  (basis.extremity\n     {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})"], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin1 extremity : Point) (Seg_cond0 : DiPt origin1 extremity)\n         (H' : line1 x = line1 y) (H'0 : origin1 = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin1;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) =>\n          False_ind False\n            (inc_ln1\n               {|\n                 origin := origin1;\n                 extremity := extremity;\n                 Seg_cond := Seg_cond0\n               |}\n               (False_ind\n                  (Apart\n                     (origin\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |})\n                     (ln\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |}))\n                  (inc_ln2\n                     {|\n                       origin := origin1;\n                       extremity := extremity;\n                       Seg_cond := Seg_cond0\n                     |} ?Goal@{origin:=origin1; Seg_cond:=Seg_cond0}))))\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin1;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin1;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin1;\n              extremity := extremity;\n              Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin1 extremity : Point) (Seg_cond0 : DiPt origin1 extremity)\n         (H' : line1 x = line1 y) (H'0 : origin1 = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin1;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) =>\n          False_ind False\n            (inc_ln1\n               {|\n                 origin := origin1;\n                 extremity := extremity;\n                 Seg_cond := Seg_cond0\n               |}\n               (False_ind\n                  (Apart\n                     (origin\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |})\n                     (ln\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |}))\n                  (inc_ln2\n                     {|\n                       origin := origin1;\n                       extremity := extremity;\n                       Seg_cond := Seg_cond0\n                     |} ?Goal@{origin:=origin1; Seg_cond:=Seg_cond0}))))\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin1;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin1;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin1;\n              extremity := extremity;\n              Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"]}, {"text": "apply (inc_pt1 y); rewrite <- H'1; rewrite <- H'; assumption.", "goal_before": ["Apart\n  (basis.extremity\n     {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})\n  (ln {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |})"], "goal_after": [], "proof_term_before": ["(fun (x y : Twolines) (z : Segment) =>\n match\n   z as s\n   return\n     (line1 x = line1 y ->\n      origin s = pt x -> extremity s = pt y -> EqLn (ln s) (line1 x))\n with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     ((fun (origin1 extremity : Point) (Seg_cond0 : DiPt origin1 extremity)\n         (H' : line1 x = line1 y) (H'0 : origin1 = pt x)\n         (H'1 : extremity = pt y) =>\n       (((fun\n            H'2 : DiLn\n                    (ln\n                       {|\n                         origin := origin1;\n                         extremity := extremity;\n                         Seg_cond := Seg_cond0\n                       |}) (line1 x) =>\n          False_ind False\n            (inc_ln1\n               {|\n                 origin := origin1;\n                 extremity := extremity;\n                 Seg_cond := Seg_cond0\n               |}\n               (False_ind\n                  (Apart\n                     (origin\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |})\n                     (ln\n                        {|\n                          origin := origin1;\n                          extremity := extremity;\n                          Seg_cond := Seg_cond0\n                        |}))\n                  (inc_ln2\n                     {|\n                       origin := origin1;\n                       extremity := extremity;\n                       Seg_cond := Seg_cond0\n                     |} ?Goal@{origin:=origin1; Seg_cond:=Seg_cond0}))))\n         :\n         ~\n         DiLn\n           (ln\n              {|\n                origin := origin1;\n                extremity := extremity;\n                Seg_cond := Seg_cond0\n              |}) (line1 x))\n        :\n        Negation Line DiLn\n          (ln\n             {|\n               origin := origin1;\n               extremity := extremity;\n               Seg_cond := Seg_cond0\n             |}) (line1 x))\n       :\n       EqLn\n         (ln\n            {|\n              origin := origin1;\n              extremity := extremity;\n              Seg_cond := Seg_cond0\n            |}) (line1 x))\n      :\n      forall (origin1 extremity1 : Point)\n        (Seg_cond0 : DiPt origin1 extremity1),\n      line1 x = line1 y ->\n      origin\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt x ->\n      extremity\n        {|\n          origin := origin1; extremity := extremity1; Seg_cond := Seg_cond0\n        |} = pt y ->\n      EqLn\n        (ln\n           {|\n             origin := origin1;\n             extremity := extremity1;\n             Seg_cond := Seg_cond0\n           |}) (line1 x)) origin0 extremity0 Seg_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm5_5", "text": "Theorem thm5_5 :\n forall (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c),\n EqLn (ln (Seg a b H1)) (ln (Seg a c (cong_eqpt_dipt a b c H1 H2))).\nProof.\nintros a b c H1 H2; apply Uniqueness_of_constructed_lines; simpl in |- *.\nexact (inc_ln1 (Seg a b H1)).\ngeneralize (inc_ln2 (Seg a b H1)); simpl in |- *; intro H'.\napply cong_eqpt_inc with (a := b); trivial.\nQed.\n", "definition": "\n forall (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c),\n EqLn (ln (Seg a b H1)) (ln (Seg a c (cong_eqpt_dipt a b c H1 H2))).\n", "proof": "\nintros a b c H1 H2; apply Uniqueness_of_constructed_lines; simpl in |- *.\nexact (inc_ln1 (Seg a b H1)).\ngeneralize (inc_ln2 (Seg a b H1)); simpl in |- *; intro H'.\napply cong_eqpt_inc with (a := b); trivial.\n", "def_ranges": [210, 0, 212, 68], "proof_ranges": [213, 0, 218, 4], "proof_steps": [{"text": "intros a b c H1 H2; apply Uniqueness_of_constructed_lines; simpl in |- *.", "goal_before": ["forall (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c),\nEqLn (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n  (ln\n     {|\n       origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2\n     |})"], "goal_after": ["Incident a (ln {| origin := a; extremity := b; Seg_cond := H1 |})", "Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |})"], "proof_term_before": [], "proof_term_after": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c) =>\n Uniqueness_of_constructed_lines\n   {| origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2 |}\n   (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n   (?Goal\n    :\n    Incident\n      (origin\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n   (?Goal0\n    :\n    Incident\n      (extremity\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |})))"]}, {"text": "exact (inc_ln1 (Seg a b H1)).", "goal_before": ["Incident a (ln {| origin := a; extremity := b; Seg_cond := H1 |})", "Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |})"], "goal_after": ["Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |})"], "proof_term_before": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c) =>\n Uniqueness_of_constructed_lines\n   {| origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2 |}\n   (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n   (?Goal\n    :\n    Incident\n      (origin\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n   (?Goal0\n    :\n    Incident\n      (extremity\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |})))"], "proof_term_after": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c) =>\n Uniqueness_of_constructed_lines\n   {| origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2 |}\n   (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n   (inc_ln1 {| origin := a; extremity := b; Seg_cond := H1 |}\n    :\n    Incident\n      (origin\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n   (?Goal\n    :\n    Incident\n      (extremity\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |})))"]}, {"text": "generalize (inc_ln2 (Seg a b H1)); simpl in |- *; intro H'.", "goal_before": ["Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |})"], "goal_after": ["Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |})"], "proof_term_before": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c) =>\n Uniqueness_of_constructed_lines\n   {| origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2 |}\n   (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n   (inc_ln1 {| origin := a; extremity := b; Seg_cond := H1 |}\n    :\n    Incident\n      (origin\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n   (?Goal\n    :\n    Incident\n      (extremity\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |})))"], "proof_term_after": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c) =>\n Uniqueness_of_constructed_lines\n   {| origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2 |}\n   (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n   (inc_ln1 {| origin := a; extremity := b; Seg_cond := H1 |}\n    :\n    Incident\n      (origin\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n   (((fun\n        H' : Incident b\n               (ln {| origin := a; extremity := b; Seg_cond := H1 |}) =>\n      ?Goal)\n     :\n     Incident (extremity {| origin := a; extremity := b; Seg_cond := H1 |})\n       (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\n     Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n      (inc_ln2 {| origin := a; extremity := b; Seg_cond := H1 |})\n    :\n    Incident\n      (extremity\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |})))"]}, {"text": "apply cong_eqpt_inc with (a := b); trivial.", "goal_before": ["Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |})"], "goal_after": [], "proof_term_before": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c) =>\n Uniqueness_of_constructed_lines\n   {| origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2 |}\n   (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n   (inc_ln1 {| origin := a; extremity := b; Seg_cond := H1 |}\n    :\n    Incident\n      (origin\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n   (((fun\n        H' : Incident b\n               (ln {| origin := a; extremity := b; Seg_cond := H1 |}) =>\n      ?Goal)\n     :\n     Incident (extremity {| origin := a; extremity := b; Seg_cond := H1 |})\n       (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\n     Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n      (inc_ln2 {| origin := a; extremity := b; Seg_cond := H1 |})\n    :\n    Incident\n      (extremity\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |})))"], "proof_term_after": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c) =>\n Uniqueness_of_constructed_lines\n   {| origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2 |}\n   (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n   (inc_ln1 {| origin := a; extremity := b; Seg_cond := H1 |}\n    :\n    Incident\n      (origin\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n   (((fun\n        H' : Incident b\n               (ln {| origin := a; extremity := b; Seg_cond := H1 |}) =>\n      cong_eqpt_inc b c\n        (ln {| origin := a; extremity := b; Seg_cond := H1 |}) H' H2)\n     :\n     Incident (extremity {| origin := a; extremity := b; Seg_cond := H1 |})\n       (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\n     Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n      (inc_ln2 {| origin := a; extremity := b; Seg_cond := H1 |})\n    :\n    Incident\n      (extremity\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |})))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b c : Point) (H1 : DiPt a b) (H2 : EqPt b c) =>\n Uniqueness_of_constructed_lines\n   {| origin := a; extremity := c; Seg_cond := cong_eqpt_dipt a b c H1 H2 |}\n   (ln {| origin := a; extremity := b; Seg_cond := H1 |})\n   (inc_ln1 {| origin := a; extremity := b; Seg_cond := H1 |}\n    :\n    Incident\n      (origin\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n   (((fun\n        H' : Incident b\n               (ln {| origin := a; extremity := b; Seg_cond := H1 |}) =>\n      cong_eqpt_inc b c\n        (ln {| origin := a; extremity := b; Seg_cond := H1 |}) H' H2)\n     :\n     Incident (extremity {| origin := a; extremity := b; Seg_cond := H1 |})\n       (ln {| origin := a; extremity := b; Seg_cond := H1 |}) ->\n     Incident c (ln {| origin := a; extremity := b; Seg_cond := H1 |}))\n      (inc_ln2 {| origin := a; extremity := b; Seg_cond := H1 |})\n    :\n    Incident\n      (extremity\n         {|\n           origin := a;\n           extremity := c;\n           Seg_cond := cong_eqpt_dipt a b c H1 H2\n         |}) (ln {| origin := a; extremity := b; Seg_cond := H1 |})))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/part3.v", "name": "thm5_6", "text": "Theorem thm5_6 :\n forall (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n),\n EqPt (pt (Twol l m H1)) (pt (Twol l n (cong_eqln_con l m n H1 H2))).\nProof.\nintros l m n H1 H2; apply Uniqueness_of_constructed_points; simpl in |- *.\nexact (inc_pt1 (Twol l m H1)).\ngeneralize (inc_pt2 (Twol l m H1)); simpl in |- *; intro H'.\napply cong_eqln_inc with (l := m); trivial.\nQed.\n", "definition": "\n forall (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n),\n EqPt (pt (Twol l m H1)) (pt (Twol l n (cong_eqln_con l m n H1 H2))).\n", "proof": "\nintros l m n H1 H2; apply Uniqueness_of_constructed_points; simpl in |- *.\nexact (inc_pt1 (Twol l m H1)).\ngeneralize (inc_pt2 (Twol l m H1)); simpl in |- *; intro H'.\napply cong_eqln_inc with (l := m); trivial.\n", "def_ranges": [220, 0, 222, 69], "proof_ranges": [223, 0, 228, 4], "proof_steps": [{"text": "intros l m n H1 H2; apply Uniqueness_of_constructed_points; simpl in |- *.", "goal_before": ["forall (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n),\nEqPt (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n  (pt {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})"], "goal_after": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) l", "Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n"], "proof_term_before": [], "proof_term_after": ["(fun (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n) =>\n Uniqueness_of_constructed_points\n   {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}\n   (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n   (?Goal\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line1\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}))\n   (?Goal0\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line2\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})))"]}, {"text": "exact (inc_pt1 (Twol l m H1)).", "goal_before": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) l", "Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n"], "goal_after": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n"], "proof_term_before": ["(fun (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n) =>\n Uniqueness_of_constructed_points\n   {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}\n   (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n   (?Goal\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line1\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}))\n   (?Goal0\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line2\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})))"], "proof_term_after": ["(fun (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n) =>\n Uniqueness_of_constructed_points\n   {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}\n   (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n   (inc_pt1 {| line1 := l; line2 := m; Twol_cond := H1 |}\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line1\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}))\n   (?Goal\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line2\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})))"]}, {"text": "generalize (inc_pt2 (Twol l m H1)); simpl in |- *; intro H'.", "goal_before": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n"], "goal_after": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n"], "proof_term_before": ["(fun (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n) =>\n Uniqueness_of_constructed_points\n   {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}\n   (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n   (inc_pt1 {| line1 := l; line2 := m; Twol_cond := H1 |}\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line1\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}))\n   (?Goal\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line2\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})))"], "proof_term_after": ["(fun (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n) =>\n Uniqueness_of_constructed_points\n   {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}\n   (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n   (inc_pt1 {| line1 := l; line2 := m; Twol_cond := H1 |}\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line1\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}))\n   (((fun H' : Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) m\n      => ?Goal)\n     :\n     Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n       (line2 {| line1 := l; line2 := m; Twol_cond := H1 |}) ->\n     Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n)\n      (inc_pt2 {| line1 := l; line2 := m; Twol_cond := H1 |})\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line2\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})))"]}, {"text": "apply cong_eqln_inc with (l := m); trivial.", "goal_before": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n"], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n) =>\n Uniqueness_of_constructed_points\n   {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}\n   (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n   (inc_pt1 {| line1 := l; line2 := m; Twol_cond := H1 |}\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line1\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}))\n   (((fun H' : Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) m\n      => ?Goal)\n     :\n     Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n       (line2 {| line1 := l; line2 := m; Twol_cond := H1 |}) ->\n     Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n)\n      (inc_pt2 {| line1 := l; line2 := m; Twol_cond := H1 |})\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line2\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})))"], "proof_term_after": ["(fun (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n) =>\n Uniqueness_of_constructed_points\n   {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}\n   (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n   (inc_pt1 {| line1 := l; line2 := m; Twol_cond := H1 |}\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line1\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}))\n   (((fun H' : Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) m\n      =>\n      cong_eqln_inc (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) m n H'\n        H2)\n     :\n     Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n       (line2 {| line1 := l; line2 := m; Twol_cond := H1 |}) ->\n     Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n)\n      (inc_pt2 {| line1 := l; line2 := m; Twol_cond := H1 |})\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line2\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H1 : ConLn l m) (H2 : EqLn m n) =>\n Uniqueness_of_constructed_points\n   {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}\n   (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n   (inc_pt1 {| line1 := l; line2 := m; Twol_cond := H1 |}\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line1\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |}))\n   (((fun H' : Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) m\n      =>\n      cong_eqln_inc (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) m n H'\n        H2)\n     :\n     Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n       (line2 {| line1 := l; line2 := m; Twol_cond := H1 |}) ->\n     Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |}) n)\n      (inc_pt2 {| line1 := l; line2 := m; Twol_cond := H1 |})\n    :\n    Incident (pt {| line1 := l; line2 := m; Twol_cond := H1 |})\n      (line2\n         {| line1 := l; line2 := n; Twol_cond := cong_eqln_con l m n H1 H2 |})))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/affinity.v", "name": "Ax1_i", "text": "Theorem Ax1_i : forall (l : Line) (a : Point), Par (par l a) l.\nProof.\nintros l a.\nunfold par at 1 in |- *.\nelim (constructed_parallel l a).\nsimpl in |- *; tauto.\nQed.\n", "definition": " forall (l : Line) (a : Point), Par (par l a) l.\n", "proof": "\nintros l a.\nunfold par at 1 in |- *.\nelim (constructed_parallel l a).\nsimpl in |- *; tauto.\n", "def_ranges": [45, 0, 45, 63], "proof_ranges": [46, 0, 51, 4], "proof_steps": [{"text": "intros l a.", "goal_before": ["forall (l : Line) (a : Point), Par (par l a) l"], "goal_after": ["Par (par l a) l"], "proof_term_before": [], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal)"]}, {"text": "unfold par at 1 in |- *.", "goal_before": ["Par (par l a) l"], "goal_after": ["Par\n  (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n     (fun (x : Line) (_ : Par x l /\\ Incident a x) => x)\n     (constructed_parallel l a)) l"], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal)"], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal : Par (par l a) l)"]}, {"text": "elim (constructed_parallel l a).", "goal_before": ["Par\n  (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n     (fun (x : Line) (_ : Par x l /\\ Incident a x) => x)\n     (constructed_parallel l a)) l"], "goal_after": ["forall (x : Line) (p : Par x l /\\ Incident a x),\nPar\n  (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n     (fun (x0 : Line) (_ : Par x0 l /\\ Incident a x0) => x0)\n     (exist (fun l' : Line => Par l' l /\\ Incident a l') x p)) l"], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal : Par (par l a) l)"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Par l' l /\\ Incident a l'} =>\n    Par\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Par x l /\\ Incident a x) => x) s) l) \n   ?Goal (constructed_parallel l a)\n :\n Par (par l a) l)"]}, {"text": "simpl in |- *; tauto.", "goal_before": ["forall (x : Line) (p : Par x l /\\ Incident a x),\nPar\n  (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n     (fun (x0 : Line) (_ : Par x0 l /\\ Incident a x0) => x0)\n     (exist (fun l' : Line => Par l' l /\\ Incident a l') x p)) l"], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Par l' l /\\ Incident a l'} =>\n    Par\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Par x l /\\ Incident a x) => x) s) l) \n   ?Goal (constructed_parallel l a)\n :\n Par (par l a) l)"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Par l' l /\\ Incident a l'} =>\n    Par\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Par x l /\\ Incident a x) => x) s) l)\n   ((fun (x : Line) (p : Par x l /\\ Incident a x) =>\n     and_ind (fun (H : Par x l) (_ : Incident a x) => H) p)\n    :\n    forall (x : Line) (p : Par x l /\\ Incident a x),\n    Par\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x0 : Line) (_ : Par x0 l /\\ Incident a x0) => x0)\n         (exist (fun l' : Line => Par l' l /\\ Incident a l') x p)) l)\n   (constructed_parallel l a)\n :\n Par (par l a) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Par l' l /\\ Incident a l'} =>\n    Par\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Par x l /\\ Incident a x) => x) s) l)\n   ((fun (x : Line) (p : Par x l /\\ Incident a x) =>\n     and_ind (fun (H : Par x l) (_ : Incident a x) => H) p)\n    :\n    forall (x : Line) (p : Par x l /\\ Incident a x),\n    Par\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x0 : Line) (_ : Par x0 l /\\ Incident a x0) => x0)\n         (exist (fun l' : Line => Par l' l /\\ Incident a l') x p)) l)\n   (constructed_parallel l a)\n :\n Par (par l a) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/affinity.v", "name": "Ax1_ii", "text": "Theorem Ax1_ii : forall (l : Line) (a : Point), Incident a (par l a).\nProof.\nintros l a.\nunfold par at 1 in |- *.\nelim (constructed_parallel l a).\nsimpl in |- *; tauto.\nQed.\n", "definition": " forall (l : Line) (a : Point), Incident a (par l a).\n", "proof": "\nintros l a.\nunfold par at 1 in |- *.\nelim (constructed_parallel l a).\nsimpl in |- *; tauto.\n", "def_ranges": [53, 0, 53, 69], "proof_ranges": [54, 0, 59, 4], "proof_steps": [{"text": "intros l a.", "goal_before": ["forall (l : Line) (a : Point), Incident a (par l a)"], "goal_after": ["Incident a (par l a)"], "proof_term_before": [], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal)"]}, {"text": "unfold par at 1 in |- *.", "goal_before": ["Incident a (par l a)"], "goal_after": ["Incident a\n  (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n     (fun (x : Line) (_ : Par x l /\\ Incident a x) => x)\n     (constructed_parallel l a))"], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal)"], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal : Incident a (par l a))"]}, {"text": "elim (constructed_parallel l a).", "goal_before": ["Incident a\n  (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n     (fun (x : Line) (_ : Par x l /\\ Incident a x) => x)\n     (constructed_parallel l a))"], "goal_after": ["forall (x : Line) (p : Par x l /\\ Incident a x),\nIncident a\n  (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n     (fun (x0 : Line) (_ : Par x0 l /\\ Incident a x0) => x0)\n     (exist (fun l' : Line => Par l' l /\\ Incident a l') x p))"], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal : Incident a (par l a))"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Par l' l /\\ Incident a l'} =>\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Par x l /\\ Incident a x) => x) s)) \n   ?Goal (constructed_parallel l a)\n :\n Incident a (par l a))"]}, {"text": "simpl in |- *; tauto.", "goal_before": ["forall (x : Line) (p : Par x l /\\ Incident a x),\nIncident a\n  (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n     (fun (x0 : Line) (_ : Par x0 l /\\ Incident a x0) => x0)\n     (exist (fun l' : Line => Par l' l /\\ Incident a l') x p))"], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Par l' l /\\ Incident a l'} =>\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Par x l /\\ Incident a x) => x) s)) \n   ?Goal (constructed_parallel l a)\n :\n Incident a (par l a))"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Par l' l /\\ Incident a l'} =>\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Par x l /\\ Incident a x) => x) s))\n   ((fun (x : Line) (p : Par x l /\\ Incident a x) =>\n     and_ind (fun (_ : Par x l) (H0 : Incident a x) => H0) p)\n    :\n    forall (x : Line) (p : Par x l /\\ Incident a x),\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x0 : Line) (_ : Par x0 l /\\ Incident a x0) => x0)\n         (exist (fun l' : Line => Par l' l /\\ Incident a l') x p)))\n   (constructed_parallel l a)\n :\n Incident a (par l a))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Par l' l /\\ Incident a l'} =>\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Par x l /\\ Incident a x) => x) s))\n   ((fun (x : Line) (p : Par x l /\\ Incident a x) =>\n     and_ind (fun (_ : Par x l) (H0 : Incident a x) => H0) p)\n    :\n    forall (x : Line) (p : Par x l /\\ Incident a x),\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Par l' l /\\ Incident a l'} => Line)\n         (fun (x0 : Line) (_ : Par x0 l /\\ Incident a x0) => x0)\n         (exist (fun l' : Line => Par l' l /\\ Incident a l') x p)))\n   (constructed_parallel l a)\n :\n Incident a (par l a))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/affinity.v", "name": "thm7_1", "text": "Theorem thm7_1 :\n forall (l m : Line) (a : Point), Incident a l /\\ Par l m -> EqLn l (par m a).\nProof.\nintros l m a H'; elim H'; intros H'0 H'1; try exact H'1; clear H'.\ngeneralize (Ax1_i m a); intro H'2.\nelim equiv_Par.\nintros H'3 H'4 H'5.\nred in H'5.\nassert (H'8 := H'5 (par m a) m l); lapply H'8;\n [ intro H'9; lapply H'9; [ intro H'10; clear H'9 H'8 | clear H'9 H'8 ]\n | clear H'8 ]; auto.\nred in |- *; red in |- *; red in |- *; intro H'6.\nlapply (constructive_uniqueness_for_parallels l (par m a) a);\n [ intro H'11 | assumption ].\nelim H'11;\n [ intro H'; elim H'; [ idtac | intro H'7; clear H' H'11 ] | idtac ];\n auto.\nelim (Ax1_ii m a); auto.\nQed.\n", "definition": "\n forall (l m : Line) (a : Point), Incident a l /\\ Par l m -> EqLn l (par m a).\n", "proof": "\nintros l m a H'; elim H'; intros H'0 H'1; try exact H'1; clear H'.\ngeneralize (Ax1_i m a); intro H'2.\nelim equiv_Par.\nintros H'3 H'4 H'5.\nred in H'5.\nassert (H'8 := H'5 (par m a) m l); lapply H'8;\n [ intro H'9; lapply H'9; [ intro H'10; clear H'9 H'8 | clear H'9 H'8 ]\n | clear H'8 ]; auto.\nred in |- *; red in |- *; red in |- *; intro H'6.\nlapply (constructive_uniqueness_for_parallels l (par m a) a);\n [ intro H'11 | assumption ].\nelim H'11;\n [ intro H'; elim H'; [ idtac | intro H'7; clear H' H'11 ] | idtac ];\n auto.\nelim (Ax1_ii m a); auto.\n", "def_ranges": [62, 0, 63, 78], "proof_ranges": [64, 0, 80, 4], "proof_steps": [{"text": "intros l m a H'; elim H'; intros H'0 H'1; try exact H'1; clear H'.", "goal_before": ["forall (l m : Line) (a : Point), Incident a l /\\ Par l m -> EqLn l (par m a)"], "goal_after": ["EqLn l (par m a)"], "proof_term_before": [], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind (fun (H'0 : Incident a l) (H'1 : Par l m) => ?Goal) H')"]}, {"text": "generalize (Ax1_i m a); intro H'2.", "goal_before": ["EqLn l (par m a)"], "goal_after": ["EqLn l (par m a)"], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind (fun (H'0 : Incident a l) (H'1 : Par l m) => ?Goal) H')"], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m => ?Goal) (Ax1_i m a)) H')"]}, {"text": "elim equiv_Par.", "goal_before": ["EqLn l (par m a)"], "goal_after": ["Reflexive Line Par ->\nSymmetric Line Par -> Transitive Line Par -> EqLn l (par m a)"], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m => ?Goal) (Ax1_i m a)) H')"], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a)) ?Goal equiv_Par) \n      (Ax1_i m a)) H')"]}, {"text": "intros H'3 H'4 H'5.", "goal_before": ["Reflexive Line Par ->\nSymmetric Line Par -> Transitive Line Par -> EqLn l (par m a)"], "goal_after": ["EqLn l (par m a)"], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a)) ?Goal equiv_Par) \n      (Ax1_i m a)) H')"], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a))\n       (fun (H'3 : Reflexive Line Par) (H'4 : Symmetric Line Par)\n          (H'5 : Transitive Line Par) => ?Goal) equiv_Par) \n      (Ax1_i m a)) H')"]}, {"text": "red in H'5.", "goal_before": ["EqLn l (par m a)"], "goal_after": ["EqLn l (par m a)"], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a))\n       (fun (H'3 : Reflexive Line Par) (H'4 : Symmetric Line Par)\n          (H'5 : Transitive Line Par) => ?Goal) equiv_Par) \n      (Ax1_i m a)) H')"], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a))\n       (fun (H'3 : Reflexive Line Par) (H'4 : Symmetric Line Par)\n          (H'5 : Transitive Line Par) => ?Goal) equiv_Par) \n      (Ax1_i m a)) H')"]}, {"text": "assert (H'8 := H'5 (par m a) m l); lapply H'8;", "goal_before": ["EqLn l (par m a)"], "goal_after": ["EqLn l (par m a)"], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a))\n       (fun (H'3 : Reflexive Line Par) (H'4 : Symmetric Line Par)\n          (H'5 : Transitive Line Par) => ?Goal) equiv_Par) \n      (Ax1_i m a)) H')"], "proof_term_after": []}, {"text": "[ intro H'9; lapply H'9; [ intro H'10; clear H'9 H'8 | clear H'9 H'8 ]", "goal_before": ["EqLn l (par m a)"], "goal_after": ["EqLn l (par m a)"], "proof_term_before": [], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a))\n       (fun (H'3 : Reflexive Line Par) (H'4 : Symmetric Line Par)\n          (H'5 : Transitive Line Par) => ?Goal) equiv_Par) \n      (Ax1_i m a)) H')"]}, {"text": "| clear H'8 ]; auto.", "goal_before": ["EqLn l (par m a)"], "goal_after": ["False"], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a))\n       (fun (H'3 : Reflexive Line Par) (H'4 : Symmetric Line Par)\n          (H'5 : Transitive Line Par) => ?Goal) equiv_Par) \n      (Ax1_i m a)) H')"], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a))\n       (fun (H'3 : Reflexive Line Par) (H'4 : Symmetric Line Par)\n          (H'5 : Transitive Line Par) =>\n        (((fun H'6 : DiLn l (par m a) => ?Goal) : ~ DiLn l (par m a))\n         :\n         Negation Line DiLn l (par m a))\n        :\n        EqLn l (par m a)) equiv_Par) (Ax1_i m a)) H')"]}, {"text": "red in |- *; red in |- *; red in |- *; intro H'6.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Par l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Par l m) =>\n    (fun H'2 : Par (par m a) m =>\n     Equivalence_ind Line Par (EqLn l (par m a))\n       (fun (H'3 : Reflexive Line Par) (H'4 : Symmetric Line Par)\n          (H'5 : Transitive Line Par) =>\n        (((fun H'6 : DiLn l (par m a) => ?Goal) : ~ DiLn l (par m a))\n         :\n         Negation Line DiLn l (par m a))\n        :\n        EqLn l (par m a)) equiv_Par) (Ax1_i m a)) H')"], "proof_term_after": []}, {"text": "lapply (constructive_uniqueness_for_parallels l (par m a) a);", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'11 | assumption ].", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'11;", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'; elim H'; [ idtac | intro H'7; clear H' H'11 ] | idtac ];", "goal_before": ["Apart a (par m a)"], "goal_after": ["Apart a (par m a)"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/affinity.v", "name": "thm7_3", "text": "Theorem thm7_3 :\n forall (l m : Line) (a : Point),\n Incident a l -> Incident a m -> Par l m -> EqLn l m.\nProof.\nelim equiv_EqLn.\nintros H' H'0 H'1 l m a H'2 H'3 H'4.\nunfold Transitive at 1 in H'1.\napply H'1 with (y := par m a); auto.\napply H'0.\nelim equiv_Par; auto.\nQed.\n", "definition": "\n forall (l m : Line) (a : Point),\n Incident a l -> Incident a m -> Par l m -> EqLn l m.\n", "proof": "\nelim equiv_EqLn.\nintros H' H'0 H'1 l m a H'2 H'3 H'4.\nunfold Transitive at 1 in H'1.\napply H'1 with (y := par m a); auto.\napply H'0.\nelim equiv_Par; auto.\n", "def_ranges": [83, 0, 85, 53], "proof_ranges": [86, 0, 93, 4], "proof_steps": [{"text": "elim equiv_EqLn.", "goal_before": ["forall (l m : Line) (a : Point),\nIncident a l -> Incident a m -> Par l m -> EqLn l m"], "goal_after": ["Reflexive Line EqLn ->\nSymmetric Line EqLn ->\nTransitive Line EqLn ->\nforall (l m : Line) (a : Point),\nIncident a l -> Incident a m -> Par l m -> EqLn l m"], "proof_term_before": [], "proof_term_after": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m) \n   ?Goal equiv_EqLn)"]}, {"text": "intros H' H'0 H'1 l m a H'2 H'3 H'4.", "goal_before": ["Reflexive Line EqLn ->\nSymmetric Line EqLn ->\nTransitive Line EqLn ->\nforall (l m : Line) (a : Point),\nIncident a l -> Incident a m -> Par l m -> EqLn l m"], "goal_after": ["EqLn l m"], "proof_term_before": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m) \n   ?Goal equiv_EqLn)"], "proof_term_after": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (H' : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) => \n    ?Goal) equiv_EqLn)"]}, {"text": "unfold Transitive at 1 in H'1.", "goal_before": ["EqLn l m"], "goal_after": ["EqLn l m"], "proof_term_before": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (H' : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) => \n    ?Goal) equiv_EqLn)"], "proof_term_after": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (H' : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) => \n    ?Goal) equiv_EqLn)"]}, {"text": "apply H'1 with (y := par m a); auto.", "goal_before": ["EqLn l m"], "goal_after": ["EqLn (par m a) m"], "proof_term_before": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (H' : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) => \n    ?Goal) equiv_EqLn)"], "proof_term_after": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (H' : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) =>\n    H'1 l (par m a) m\n      (H'0 (par m a) l (H'0 l (par m a) (thm7_1 l m a (conj H'2 H'4)))) \n      ?Goal) equiv_EqLn)"]}, {"text": "apply H'0.", "goal_before": ["EqLn (par m a) m"], "goal_after": ["EqLn m (par m a)"], "proof_term_before": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (H' : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) =>\n    H'1 l (par m a) m\n      (H'0 (par m a) l (H'0 l (par m a) (thm7_1 l m a (conj H'2 H'4)))) \n      ?Goal) equiv_EqLn)"], "proof_term_after": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (H' : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) =>\n    H'1 l (par m a) m\n      (H'0 (par m a) l (H'0 l (par m a) (thm7_1 l m a (conj H'2 H'4))))\n      (H'0 m (par m a) ?Goal)) equiv_EqLn)"]}, {"text": "elim equiv_Par; auto.", "goal_before": ["EqLn m (par m a)"], "goal_after": [], "proof_term_before": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (H' : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) =>\n    H'1 l (par m a) m\n      (H'0 (par m a) l (H'0 l (par m a) (thm7_1 l m a (conj H'2 H'4))))\n      (H'0 m (par m a) ?Goal)) equiv_EqLn)"], "proof_term_after": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (_ : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) =>\n    H'1 l (par m a) m\n      (H'0 (par m a) l (H'0 l (par m a) (thm7_1 l m a (conj H'2 H'4))))\n      (H'0 m (par m a)\n         (Equivalence_ind Line Par (EqLn m (par m a))\n            (fun (H : Reflexive Line Par) (_ : Symmetric Line Par)\n               (_ : Transitive Line Par) =>\n             H'0 (par m a) m\n               (H'0 m (par m a) (thm7_1 m m a (conj H'3 (H m))))) equiv_Par)))\n   equiv_EqLn)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(Equivalence_ind Line EqLn\n   (forall (l m : Line) (a : Point),\n    Incident a l -> Incident a m -> Par l m -> EqLn l m)\n   (fun (_ : Reflexive Line EqLn) (H'0 : Symmetric Line EqLn)\n      (H'1 : Transitive Line EqLn) (l m : Line) (a : Point)\n      (H'2 : Incident a l) (H'3 : Incident a m) (H'4 : Par l m) =>\n    H'1 l (par m a) m\n      (H'0 (par m a) l (H'0 l (par m a) (thm7_1 l m a (conj H'2 H'4))))\n      (H'0 m (par m a)\n         (Equivalence_ind Line Par (EqLn m (par m a))\n            (fun (H : Reflexive Line Par) (_ : Symmetric Line Par)\n               (_ : Transitive Line Par) =>\n             H'0 (par m a) m\n               (H'0 m (par m a) (thm7_1 m m a (conj H'3 (H m))))) equiv_Par)))\n   equiv_EqLn)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/affinity.v", "name": "thm7_4", "text": "Theorem thm7_4 :\n forall (l m n : Line) (a : Point),\n Apart a l -> Incident a m -> Incident a n -> Par n l -> Par m l -> EqLn m n.\nProof.\nintros l m n a H' H'0 H'1 H'2 H'3; try assumption.\napply thm7_3 with (a := a); auto.\nelim equiv_Par.\nintros H'4 H'5 H'6; red in H'6.\napply H'6 with (y := l); auto.\nQed.\n", "definition": "\n forall (l m n : Line) (a : Point),\n Apart a l -> Incident a m -> Incident a n -> Par n l -> Par m l -> EqLn m n.\n", "proof": "\nintros l m n a H' H'0 H'1 H'2 H'3; try assumption.\napply thm7_3 with (a := a); auto.\nelim equiv_Par.\nintros H'4 H'5 H'6; red in H'6.\napply H'6 with (y := l); auto.\n", "def_ranges": [95, 0, 97, 77], "proof_ranges": [98, 0, 104, 4], "proof_steps": [{"text": "intros l m n a H' H'0 H'1 H'2 H'3; try assumption.", "goal_before": ["forall (l m n : Line) (a : Point),\nApart a l -> Incident a m -> Incident a n -> Par n l -> Par m l -> EqLn m n"], "goal_after": ["EqLn m n"], "proof_term_before": [], "proof_term_after": ["(fun (l m n : Line) (a : Point) (H' : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) => \n ?Goal)"]}, {"text": "apply thm7_3 with (a := a); auto.", "goal_before": ["EqLn m n"], "goal_after": ["Par m n"], "proof_term_before": ["(fun (l m n : Line) (a : Point) (H' : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) => \n ?Goal)"], "proof_term_after": ["(fun (l m n : Line) (a : Point) (H' : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) =>\n thm7_3 m n a H'0 H'1 ?Goal)"]}, {"text": "elim equiv_Par.", "goal_before": ["Par m n"], "goal_after": ["Reflexive Line Par -> Symmetric Line Par -> Transitive Line Par -> Par m n"], "proof_term_before": ["(fun (l m n : Line) (a : Point) (H' : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) =>\n thm7_3 m n a H'0 H'1 ?Goal)"], "proof_term_after": ["(fun (l m n : Line) (a : Point) (H' : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) =>\n thm7_3 m n a H'0 H'1 (Equivalence_ind Line Par (Par m n) ?Goal equiv_Par))"]}, {"text": "intros H'4 H'5 H'6; red in H'6.", "goal_before": ["Reflexive Line Par -> Symmetric Line Par -> Transitive Line Par -> Par m n"], "goal_after": ["Par m n"], "proof_term_before": ["(fun (l m n : Line) (a : Point) (H' : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) =>\n thm7_3 m n a H'0 H'1 (Equivalence_ind Line Par (Par m n) ?Goal equiv_Par))"], "proof_term_after": ["(fun (l m n : Line) (a : Point) (H' : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) =>\n thm7_3 m n a H'0 H'1\n   (Equivalence_ind Line Par (Par m n)\n      (fun (H'4 : Reflexive Line Par) (H'5 : Symmetric Line Par)\n         (H'6 : Transitive Line Par) => ?Goal) equiv_Par))"]}, {"text": "apply H'6 with (y := l); auto.", "goal_before": ["Par m n"], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (a : Point) (H' : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) =>\n thm7_3 m n a H'0 H'1\n   (Equivalence_ind Line Par (Par m n)\n      (fun (H'4 : Reflexive Line Par) (H'5 : Symmetric Line Par)\n         (H'6 : Transitive Line Par) => ?Goal) equiv_Par))"], "proof_term_after": ["(fun (l m n : Line) (a : Point) (_ : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) =>\n thm7_3 m n a H'0 H'1\n   (Equivalence_ind Line Par (Par m n)\n      (fun (_ : Reflexive Line Par) (H'5 : Symmetric Line Par)\n         (H'6 : Transitive Line Par) => H'6 m l n H'3 (H'5 n l H'2))\n      equiv_Par))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (a : Point) (_ : Apart a l) (H'0 : Incident a m)\n   (H'1 : Incident a n) (H'2 : Par n l) (H'3 : Par m l) =>\n thm7_3 m n a H'0 H'1\n   (Equivalence_ind Line Par (Par m n)\n      (fun (_ : Reflexive Line Par) (H'5 : Symmetric Line Par)\n         (H'6 : Transitive Line Par) => H'6 m l n H'3 (H'5 n l H'2))\n      equiv_Par))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/affinity.v", "name": "DiLn_qimp_con", "text": "Theorem DiLn_qimp_con :\n forall l m : Line,\n DiLn l m -> ex (fun b : Point => Incident b l /\\ Incident b m) -> ConLn l m.\nProof.\nunfold Incident, Negation in |- *.\nintros l m H' H'0; elim H'0; intros b E; elim E; intros H'1 H'2; clear E H'0.\nlapply (constructive_uniqueness_for_parallels l m b);\n [ intro H'5 | trivial ].\ntauto.\nQed.\n", "definition": "\n forall l m : Line,\n DiLn l m -> ex (fun b : Point => Incident b l /\\ Incident b m) -> ConLn l m.\n", "proof": "\nunfold Incident, Negation in |- *.\nintros l m H' H'0; elim H'0; intros b E; elim E; intros H'1 H'2; clear E H'0.\nlapply (constructive_uniqueness_for_parallels l m b);\n [ intro H'5 | trivial ].\ntauto.\n", "def_ranges": [106, 0, 108, 77], "proof_ranges": [109, 0, 115, 4], "proof_steps": [{"text": "unfold Incident, Negation in |- *.", "goal_before": ["forall l m : Line,\nDiLn l m -> (exists b : Point, Incident b l /\\ Incident b m) -> ConLn l m"], "goal_after": ["forall l m : Line,\nDiLn l m -> (exists b : Point, ~ Apart b l /\\ ~ Apart b m) -> ConLn l m"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall l m : Line,\n DiLn l m -> (exists b : Point, Incident b l /\\ Incident b m) -> ConLn l m)"]}, {"text": "intros l m H' H'0; elim H'0; intros b E; elim E; intros H'1 H'2; clear E H'0.", "goal_before": ["forall l m : Line,\nDiLn l m -> (exists b : Point, ~ Apart b l /\\ ~ Apart b m) -> ConLn l m"], "goal_after": ["ConLn l m"], "proof_term_before": ["(?Goal\n :\n forall l m : Line,\n DiLn l m -> (exists b : Point, Incident b l /\\ Incident b m) -> ConLn l m)"], "proof_term_after": ["((fun (l m : Line) (H' : DiLn l m)\n    (H'0 : exists b : Point, ~ Apart b l /\\ ~ Apart b m) =>\n  ex_ind\n    (fun (b : Point) (E : ~ Apart b l /\\ ~ Apart b m) =>\n     and_ind (fun (H'1 : ~ Apart b l) (H'2 : ~ Apart b m) => ?Goal) E) H'0)\n :\n forall l m : Line,\n DiLn l m -> (exists b : Point, Incident b l /\\ Incident b m) -> ConLn l m)"]}, {"text": "lapply (constructive_uniqueness_for_parallels l m b);", "goal_before": ["ConLn l m"], "goal_after": ["ConLn l m"], "proof_term_before": ["((fun (l m : Line) (H' : DiLn l m)\n    (H'0 : exists b : Point, ~ Apart b l /\\ ~ Apart b m) =>\n  ex_ind\n    (fun (b : Point) (E : ~ Apart b l /\\ ~ Apart b m) =>\n     and_ind (fun (H'1 : ~ Apart b l) (H'2 : ~ Apart b m) => ?Goal) E) H'0)\n :\n forall l m : Line,\n DiLn l m -> (exists b : Point, Incident b l /\\ Incident b m) -> ConLn l m)"], "proof_term_after": []}, {"text": "[ intro H'5 | trivial ].", "goal_before": ["ConLn l m"], "goal_after": ["ConLn l m"], "proof_term_before": [], "proof_term_after": []}, {"text": "tauto.", "goal_before": ["ConLn l m"], "goal_after": ["ConLn l m"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/affinity.v", "name": "strict_parallel", "text": "Theorem strict_parallel :\n forall (a : Point) (l : Line), Apart a l -> DiLn l (par l a).\nProof.\nintros a l H'.\nlapply (cmp_apt_diln a l (par l a)); [ intro H'3 | trivial ].\nelim H'3; [ trivial | intro H'0; clear H'3 ].\nelim (Ax1_ii l a); auto.\nQed.\n", "definition": "\n forall (a : Point) (l : Line), Apart a l -> DiLn l (par l a).\n", "proof": "\nintros a l H'.\nlapply (cmp_apt_diln a l (par l a)); [ intro H'3 | trivial ].\nelim H'3; [ trivial | intro H'0; clear H'3 ].\nelim (Ax1_ii l a); auto.\n", "def_ranges": [117, 0, 118, 62], "proof_ranges": [119, 0, 124, 4], "proof_steps": [{"text": "intros a l H'.", "goal_before": ["forall (a : Point) (l : Line), Apart a l -> DiLn l (par l a)"], "goal_after": ["DiLn l (par l a)"], "proof_term_before": [], "proof_term_after": ["(fun (a : Point) (l : Line) (H' : Apart a l) => ?Goal)"]}, {"text": "lapply (cmp_apt_diln a l (par l a)); [ intro H'3 | trivial ].", "goal_before": ["DiLn l (par l a)"], "goal_after": ["DiLn l (par l a)"], "proof_term_before": ["(fun (a : Point) (l : Line) (H' : Apart a l) => ?Goal)"], "proof_term_after": ["(fun (a : Point) (l : Line) (H' : Apart a l) =>\n (fun H'3 : DiLn l (par l a) \\/ Apart a (par l a) => ?Goal)\n   (cmp_apt_diln a l (par l a) H'))"]}, {"text": "elim H'3; [ trivial | intro H'0; clear H'3 ].", "goal_before": ["DiLn l (par l a)"], "goal_after": ["DiLn l (par l a)"], "proof_term_before": ["(fun (a : Point) (l : Line) (H' : Apart a l) =>\n (fun H'3 : DiLn l (par l a) \\/ Apart a (par l a) => ?Goal)\n   (cmp_apt_diln a l (par l a) H'))"], "proof_term_after": ["(fun (a : Point) (l : Line) (H' : Apart a l) =>\n (fun H'3 : DiLn l (par l a) \\/ Apart a (par l a) =>\n  or_ind (fun H : DiLn l (par l a) => H)\n    (fun H'0 : Apart a (par l a) => ?Goal) H'3)\n   (cmp_apt_diln a l (par l a) H'))"]}, {"text": "elim (Ax1_ii l a); auto.", "goal_before": ["DiLn l (par l a)"], "goal_after": [], "proof_term_before": ["(fun (a : Point) (l : Line) (H' : Apart a l) =>\n (fun H'3 : DiLn l (par l a) \\/ Apart a (par l a) =>\n  or_ind (fun H : DiLn l (par l a) => H)\n    (fun H'0 : Apart a (par l a) => ?Goal) H'3)\n   (cmp_apt_diln a l (par l a) H'))"], "proof_term_after": ["(fun (a : Point) (l : Line) (H' : Apart a l) =>\n (fun H'3 : DiLn l (par l a) \\/ Apart a (par l a) =>\n  or_ind (fun H : DiLn l (par l a) => H)\n    (fun H'0 : Apart a (par l a) =>\n     False_ind (DiLn l (par l a)) (Ax1_ii l a H'0)) H'3)\n   (cmp_apt_diln a l (par l a) H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : Point) (l : Line) (H' : Apart a l) =>\n (fun H'3 : DiLn l (par l a) \\/ Apart a (par l a) =>\n  or_ind (fun H : DiLn l (par l a) => H)\n    (fun H'0 : Apart a (par l a) =>\n     False_ind (DiLn l (par l a)) (Ax1_ii l a H'0)) H'3)\n   (cmp_apt_diln a l (par l a) H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/affinity.v", "name": "spar", "text": "Theorem spar : forall (a : Point) (l : Line), Apart a l -> SPar l (par l a).\nProof.\nintros a l H'; red in |- *; auto.\nQed.\n", "definition": " forall (a : Point) (l : Line), Apart a l -> SPar l (par l a).\n", "proof": "\nintros a l H'; red in |- *; auto.\n", "def_ranges": [127, 0, 127, 76], "proof_ranges": [128, 0, 130, 4], "proof_steps": [{"text": "intros a l H'; red in |- *; auto.", "goal_before": ["forall (a : Point) (l : Line), Apart a l -> SPar l (par l a)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (a : Point) (l : Line) (H' : Apart a l) =>\n conj (sym_Par (par l a) l (Ax1_i l a)) (strict_parallel a l H')\n :\n SPar l (par l a))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a : Point) (l : Line) (H' : Apart a l) =>\n conj (sym_Par (par l a) l (Ax1_i l a)) (strict_parallel a l H')\n :\n SPar l (par l a))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "O3_i", "text": "Theorem O3_i : forall (l : Line) (a : Point), Ort (ort l a) l.\nProof.\nintros l a.\nunfold ort at 1 in |- *.\nelim (constructed_orthogonal l a).\nsimpl in |- *; tauto.\nQed.\n", "definition": " forall (l : Line) (a : Point), Ort (ort l a) l.\n", "proof": "\nintros l a.\nunfold ort at 1 in |- *.\nelim (constructed_orthogonal l a).\nsimpl in |- *; tauto.\n", "def_ranges": [53, 0, 53, 62], "proof_ranges": [54, 0, 59, 4], "proof_steps": [{"text": "intros l a.", "goal_before": ["forall (l : Line) (a : Point), Ort (ort l a) l"], "goal_after": ["Ort (ort l a) l"], "proof_term_before": [], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal)"]}, {"text": "unfold ort at 1 in |- *.", "goal_before": ["Ort (ort l a) l"], "goal_after": ["Ort\n  (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n     (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x)\n     (constructed_orthogonal l a)) l"], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal)"], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal : Ort (ort l a) l)"]}, {"text": "elim (constructed_orthogonal l a).", "goal_before": ["Ort\n  (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n     (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x)\n     (constructed_orthogonal l a)) l"], "goal_after": ["forall (x : Line) (p : Ort x l /\\ Incident a x),\nOrt\n  (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n     (fun (x0 : Line) (_ : Ort x0 l /\\ Incident a x0) => x0)\n     (exist (fun l' : Line => Ort l' l /\\ Incident a l') x p)) l"], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal : Ort (ort l a) l)"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Ort l' l /\\ Incident a l'} =>\n    Ort\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x) s) l) \n   ?Goal (constructed_orthogonal l a)\n :\n Ort (ort l a) l)"]}, {"text": "simpl in |- *; tauto.", "goal_before": ["forall (x : Line) (p : Ort x l /\\ Incident a x),\nOrt\n  (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n     (fun (x0 : Line) (_ : Ort x0 l /\\ Incident a x0) => x0)\n     (exist (fun l' : Line => Ort l' l /\\ Incident a l') x p)) l"], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Ort l' l /\\ Incident a l'} =>\n    Ort\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x) s) l) \n   ?Goal (constructed_orthogonal l a)\n :\n Ort (ort l a) l)"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Ort l' l /\\ Incident a l'} =>\n    Ort\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x) s) l)\n   ((fun (x : Line) (p : Ort x l /\\ Incident a x) =>\n     and_ind (fun (H : Ort x l) (_ : Incident a x) => H) p)\n    :\n    forall (x : Line) (p : Ort x l /\\ Incident a x),\n    Ort\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x0 : Line) (_ : Ort x0 l /\\ Incident a x0) => x0)\n         (exist (fun l' : Line => Ort l' l /\\ Incident a l') x p)) l)\n   (constructed_orthogonal l a)\n :\n Ort (ort l a) l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Ort l' l /\\ Incident a l'} =>\n    Ort\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x) s) l)\n   ((fun (x : Line) (p : Ort x l /\\ Incident a x) =>\n     and_ind (fun (H : Ort x l) (_ : Incident a x) => H) p)\n    :\n    forall (x : Line) (p : Ort x l /\\ Incident a x),\n    Ort\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x0 : Line) (_ : Ort x0 l /\\ Incident a x0) => x0)\n         (exist (fun l' : Line => Ort l' l /\\ Incident a l') x p)) l)\n   (constructed_orthogonal l a)\n :\n Ort (ort l a) l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "O3_ii", "text": "Theorem O3_ii : forall (l : Line) (a : Point), Incident a (ort l a).\nProof.\nintros l a.\nunfold ort at 1 in |- *.\nelim (constructed_orthogonal l a).\nsimpl in |- *; tauto.\nQed.\n", "definition": " forall (l : Line) (a : Point), Incident a (ort l a).\n", "proof": "\nintros l a.\nunfold ort at 1 in |- *.\nelim (constructed_orthogonal l a).\nsimpl in |- *; tauto.\n", "def_ranges": [61, 0, 61, 68], "proof_ranges": [62, 0, 67, 4], "proof_steps": [{"text": "intros l a.", "goal_before": ["forall (l : Line) (a : Point), Incident a (ort l a)"], "goal_after": ["Incident a (ort l a)"], "proof_term_before": [], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal)"]}, {"text": "unfold ort at 1 in |- *.", "goal_before": ["Incident a (ort l a)"], "goal_after": ["Incident a\n  (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n     (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x)\n     (constructed_orthogonal l a))"], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal)"], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal : Incident a (ort l a))"]}, {"text": "elim (constructed_orthogonal l a).", "goal_before": ["Incident a\n  (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n     (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x)\n     (constructed_orthogonal l a))"], "goal_after": ["forall (x : Line) (p : Ort x l /\\ Incident a x),\nIncident a\n  (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n     (fun (x0 : Line) (_ : Ort x0 l /\\ Incident a x0) => x0)\n     (exist (fun l' : Line => Ort l' l /\\ Incident a l') x p))"], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal : Incident a (ort l a))"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Ort l' l /\\ Incident a l'} =>\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x) s)) \n   ?Goal (constructed_orthogonal l a)\n :\n Incident a (ort l a))"]}, {"text": "simpl in |- *; tauto.", "goal_before": ["forall (x : Line) (p : Ort x l /\\ Incident a x),\nIncident a\n  (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n     (fun (x0 : Line) (_ : Ort x0 l /\\ Incident a x0) => x0)\n     (exist (fun l' : Line => Ort l' l /\\ Incident a l') x p))"], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Ort l' l /\\ Incident a l'} =>\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x) s)) \n   ?Goal (constructed_orthogonal l a)\n :\n Incident a (ort l a))"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Ort l' l /\\ Incident a l'} =>\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x) s))\n   ((fun (x : Line) (p : Ort x l /\\ Incident a x) =>\n     and_ind (fun (_ : Ort x l) (H0 : Incident a x) => H0) p)\n    :\n    forall (x : Line) (p : Ort x l /\\ Incident a x),\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x0 : Line) (_ : Ort x0 l /\\ Incident a x0) => x0)\n         (exist (fun l' : Line => Ort l' l /\\ Incident a l') x p)))\n   (constructed_orthogonal l a)\n :\n Incident a (ort l a))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sig_ind\n   (fun s : {l' : Line | Ort l' l /\\ Incident a l'} =>\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x : Line) (_ : Ort x l /\\ Incident a x) => x) s))\n   ((fun (x : Line) (p : Ort x l /\\ Incident a x) =>\n     and_ind (fun (_ : Ort x l) (H0 : Incident a x) => H0) p)\n    :\n    forall (x : Line) (p : Ort x l /\\ Incident a x),\n    Incident a\n      (sig_rec (fun _ : {l' : Line | Ort l' l /\\ Incident a l'} => Line)\n         (fun (x0 : Line) (_ : Ort x0 l /\\ Incident a x0) => x0)\n         (exist (fun l' : Line => Ort l' l /\\ Incident a l') x p)))\n   (constructed_orthogonal l a)\n :\n Incident a (ort l a))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "O4'", "text": "Theorem O4' :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m.\nProof.\nunfold Incident, Ort, EqLn, Negation in |- *.\nintros l m n a.\ngeneralize (constructive_uniqueness_for_orthogonals l m n a).\ntauto.\nQed.\n", "definition": "\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m.\n", "proof": "\nunfold Incident, Ort, EqLn, Negation in |- *.\nintros l m n a.\ngeneralize (constructive_uniqueness_for_orthogonals l m n a).\ntauto.\n", "def_ranges": [70, 0, 72, 66], "proof_ranges": [73, 0, 78, 4], "proof_steps": [{"text": "unfold Incident, Ort, EqLn, Negation in |- *.", "goal_before": ["forall (l m n : Line) (a : Point),\n(Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m"], "goal_after": ["forall (l m n : Line) (a : Point),\n(~ Apart a l /\\ ~ Apart a m) /\\ ~ Unort l n /\\ ~ Unort m n -> ~ DiLn l m"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m)"]}, {"text": "intros l m n a.", "goal_before": ["forall (l m n : Line) (a : Point),\n(~ Apart a l /\\ ~ Apart a m) /\\ ~ Unort l n /\\ ~ Unort m n -> ~ DiLn l m"], "goal_after": ["(~ Apart a l /\\ ~ Apart a m) /\\ ~ Unort l n /\\ ~ Unort m n -> ~ DiLn l m"], "proof_term_before": ["(?Goal\n :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m)"], "proof_term_after": ["((fun (l m n : Line) (a : Point) => ?Goal)\n :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m)"]}, {"text": "generalize (constructive_uniqueness_for_orthogonals l m n a).", "goal_before": ["(~ Apart a l /\\ ~ Apart a m) /\\ ~ Unort l n /\\ ~ Unort m n -> ~ DiLn l m"], "goal_after": ["(DiLn l m -> (Apart a l \\/ Apart a m) \\/ Unort l n \\/ Unort m n) ->\n(~ Apart a l /\\ ~ Apart a m) /\\ ~ Unort l n /\\ ~ Unort m n -> ~ DiLn l m"], "proof_term_before": ["((fun (l m n : Line) (a : Point) => ?Goal)\n :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m)"], "proof_term_after": ["((fun (l m n : Line) (a : Point) =>\n  ?Goal (constructive_uniqueness_for_orthogonals l m n a))\n :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m)"]}, {"text": "tauto.", "goal_before": ["(DiLn l m -> (Apart a l \\/ Apart a m) \\/ Unort l n \\/ Unort m n) ->\n(~ Apart a l /\\ ~ Apart a m) /\\ ~ Unort l n /\\ ~ Unort m n -> ~ DiLn l m"], "goal_after": [], "proof_term_before": ["((fun (l m n : Line) (a : Point) =>\n  ?Goal (constructive_uniqueness_for_orthogonals l m n a))\n :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m)"], "proof_term_after": ["((fun (l m n : Line) (a : Point) =>\n  (fun (H : DiLn l m -> (Apart a l \\/ Apart a m) \\/ Unort l n \\/ Unort m n)\n     (H0 : (~ Apart a l /\\ ~ Apart a m) /\\ ~ Unort l n /\\ ~ Unort m n) =>\n   (fun H1 : DiLn l m =>\n    and_ind\n      (fun (H2 : ~ Apart a l /\\ ~ Apart a m)\n         (H3 : ~ Unort l n /\\ ~ Unort m n) =>\n       and_ind\n         (fun (H4 : ~ Apart a l) (H5 : ~ Apart a m) =>\n          and_ind\n            (fun (H6 : ~ Unort l n) (H7 : ~ Unort m n) =>\n             let H8 : (Apart a l \\/ Apart a m) \\/ Unort l n \\/ Unort m n :=\n               H H1 in\n             or_ind\n               (fun H9 : Apart a l \\/ Apart a m =>\n                or_ind\n                  (fun H10 : Apart a l =>\n                   let H11 : False := H4 H10 in False_ind False H11)\n                  (fun H10 : Apart a m =>\n                   let H11 : False := H5 H10 in False_ind False H11) H9)\n               (fun H9 : Unort l n \\/ Unort m n =>\n                or_ind\n                  (fun H10 : Unort l n =>\n                   let H11 : False := H6 H10 in False_ind False H11)\n                  (fun H10 : Unort m n =>\n                   let H11 : False := H7 H10 in False_ind False H11) H9) H8)\n            H3) H2) H0)\n   :\n   ~ DiLn l m) (constructive_uniqueness_for_orthogonals l m n a))\n :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (l m n : Line) (a : Point) =>\n  (fun (H : DiLn l m -> (Apart a l \\/ Apart a m) \\/ Unort l n \\/ Unort m n)\n     (H0 : (~ Apart a l /\\ ~ Apart a m) /\\ ~ Unort l n /\\ ~ Unort m n) =>\n   (fun H1 : DiLn l m =>\n    and_ind\n      (fun (H2 : ~ Apart a l /\\ ~ Apart a m)\n         (H3 : ~ Unort l n /\\ ~ Unort m n) =>\n       and_ind\n         (fun (H4 : ~ Apart a l) (H5 : ~ Apart a m) =>\n          and_ind\n            (fun (H6 : ~ Unort l n) (H7 : ~ Unort m n) =>\n             let H8 : (Apart a l \\/ Apart a m) \\/ Unort l n \\/ Unort m n :=\n               H H1 in\n             or_ind\n               (fun H9 : Apart a l \\/ Apart a m =>\n                or_ind\n                  (fun H10 : Apart a l =>\n                   let H11 : False := H4 H10 in False_ind False H11)\n                  (fun H10 : Apart a m =>\n                   let H11 : False := H5 H10 in False_ind False H11) H9)\n               (fun H9 : Unort l n \\/ Unort m n =>\n                or_ind\n                  (fun H10 : Unort l n =>\n                   let H11 : False := H6 H10 in False_ind False H11)\n                  (fun H10 : Unort m n =>\n                   let H11 : False := H7 H10 in False_ind False H11) H9) H8)\n            H3) H2) H0)\n   :\n   ~ DiLn l m) (constructive_uniqueness_for_orthogonals l m n a))\n :\n forall (l m n : Line) (a : Point),\n (Incident a l /\\ Incident a m) /\\ Ort l n /\\ Ort m n -> EqLn l m)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "Uniqueness_of_orthogonality", "text": "Theorem Uniqueness_of_orthogonality :\n forall (l m : Line) (a : Point), Incident a l /\\ Ort l m -> EqLn l (ort m a).\nProof.\nintros l m a H'; elim H'; intros H'0 H'1; clear H'.\napply O4' with (n := m) (a := a); auto.\nQed.\n", "definition": "\n forall (l m : Line) (a : Point), Incident a l /\\ Ort l m -> EqLn l (ort m a).\n", "proof": "\nintros l m a H'; elim H'; intros H'0 H'1; clear H'.\napply O4' with (n := m) (a := a); auto.\n", "def_ranges": [80, 0, 81, 78], "proof_ranges": [82, 0, 85, 4], "proof_steps": [{"text": "intros l m a H'; elim H'; intros H'0 H'1; clear H'.", "goal_before": ["forall (l m : Line) (a : Point), Incident a l /\\ Ort l m -> EqLn l (ort m a)"], "goal_after": ["EqLn l (ort m a)"], "proof_term_before": [], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Ort l m) =>\n and_ind (fun (H'0 : Incident a l) (H'1 : Ort l m) => ?Goal) H')"]}, {"text": "apply O4' with (n := m) (a := a); auto.", "goal_before": ["EqLn l (ort m a)"], "goal_after": [], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Ort l m) =>\n and_ind (fun (H'0 : Incident a l) (H'1 : Ort l m) => ?Goal) H')"], "proof_term_after": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Ort l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Ort l m) =>\n    O4' l (ort m a) m a (conj (conj H'0 (O3_ii m a)) (conj H'1 (O3_i m a))))\n   H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m : Line) (a : Point) (H' : Incident a l /\\ Ort l m) =>\n and_ind\n   (fun (H'0 : Incident a l) (H'1 : Ort l m) =>\n    O4' l (ort m a) m a (conj (conj H'0 (O3_ii m a)) (conj H'1 (O3_i m a))))\n   H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "Unort_reflexive", "text": "Theorem Unort_reflexive : Reflexive Line Unort.\nProof.\nred in |- *.\nintro l.\ngeneralize (O1 l l); intro H'.\nelim H'; [ intro H'0; clear H' | trivial ].\nelim apart_con.\nintro H'; elim (H' l); auto.\nQed.\n", "definition": " Reflexive Line Unort.\n", "proof": "\nred in |- *.\nintro l.\ngeneralize (O1 l l); intro H'.\nelim H'; [ intro H'0; clear H' | trivial ].\nelim apart_con.\nintro H'; elim (H' l); auto.\n", "def_ranges": [87, 0, 87, 47], "proof_ranges": [88, 0, 95, 4], "proof_steps": [{"text": "red in |- *.", "goal_before": ["Reflexive Line Unort"], "goal_after": ["forall x : Line, Unort x x"], "proof_term_before": [], "proof_term_after": ["(?Goal : Reflexive Line Unort)"]}, {"text": "intro l.", "goal_before": ["forall x : Line, Unort x x"], "goal_after": ["Unort l l"], "proof_term_before": ["(?Goal : Reflexive Line Unort)"], "proof_term_after": ["((fun l : Line => ?Goal) : Reflexive Line Unort)"]}, {"text": "generalize (O1 l l); intro H'.", "goal_before": ["Unort l l"], "goal_after": ["Unort l l"], "proof_term_before": ["((fun l : Line => ?Goal) : Reflexive Line Unort)"], "proof_term_after": ["((fun l : Line => (fun H' : ConLn l l \\/ Unort l l => ?Goal) (O1 l l))\n :\n Reflexive Line Unort)"]}, {"text": "elim H'; [ intro H'0; clear H' | trivial ].", "goal_before": ["Unort l l"], "goal_after": ["Unort l l"], "proof_term_before": ["((fun l : Line => (fun H' : ConLn l l \\/ Unort l l => ?Goal) (O1 l l))\n :\n Reflexive Line Unort)"], "proof_term_after": ["((fun l : Line =>\n  (fun H' : ConLn l l \\/ Unort l l =>\n   or_ind (fun H'0 : ConLn l l => ?Goal) (fun H : Unort l l => H) H')\n    (O1 l l))\n :\n Reflexive Line Unort)"]}, {"text": "elim apart_con.", "goal_before": ["Unort l l"], "goal_after": ["Irreflexive Line ConLn -> Separating Line ConLn -> Unort l l"], "proof_term_before": ["((fun l : Line =>\n  (fun H' : ConLn l l \\/ Unort l l =>\n   or_ind (fun H'0 : ConLn l l => ?Goal) (fun H : Unort l l => H) H')\n    (O1 l l))\n :\n Reflexive Line Unort)"], "proof_term_after": ["((fun l : Line =>\n  (fun H' : ConLn l l \\/ Unort l l =>\n   or_ind\n     (fun H'0 : ConLn l l =>\n      Apartness_ind Line ConLn (Unort l l) ?Goal apart_con)\n     (fun H : Unort l l => H) H') (O1 l l))\n :\n Reflexive Line Unort)"]}, {"text": "intro H'; elim (H' l); auto.", "goal_before": ["Irreflexive Line ConLn -> Separating Line ConLn -> Unort l l"], "goal_after": [], "proof_term_before": ["((fun l : Line =>\n  (fun H' : ConLn l l \\/ Unort l l =>\n   or_ind\n     (fun H'0 : ConLn l l =>\n      Apartness_ind Line ConLn (Unort l l) ?Goal apart_con)\n     (fun H : Unort l l => H) H') (O1 l l))\n :\n Reflexive Line Unort)"], "proof_term_after": ["((fun l : Line =>\n  (fun H' : ConLn l l \\/ Unort l l =>\n   or_ind\n     (fun H'0 : ConLn l l =>\n      Apartness_ind Line ConLn (Unort l l)\n        (fun H'1 : Irreflexive Line ConLn =>\n         False_ind (Separating Line ConLn -> Unort l l) (H'1 l H'0))\n        apart_con) (fun H : Unort l l => H) H') (O1 l l))\n :\n Reflexive Line Unort)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun l : Line =>\n  (fun H' : ConLn l l \\/ Unort l l =>\n   or_ind\n     (fun H'0 : ConLn l l =>\n      Apartness_ind Line ConLn (Unort l l)\n        (fun H'1 : Irreflexive Line ConLn =>\n         False_ind (Separating Line ConLn -> Unort l l) (H'1 l H'0))\n        apart_con) (fun H : Unort l l => H) H') (O1 l l))\n :\n Reflexive Line Unort)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "cmp_unort_con", "text": "Theorem cmp_unort_con :\n forall l m n : Line, Unort l m -> ConLn l n \\/ Unort m n.\nProof.\nintros l m n H'.\ngeneralize (O1 m n); intro H'1.\nelim H'1; [ intro H'0; clear H'1 | auto ].\nelim apart_con.\nintros H'1 H'2; red in H'2.\nlapply (H'2 m n l); [ intro H'6 | assumption ].\nelim H'6; [ intro H'3; clear H'6 | auto ].\ngeneralize O2.\nintro H'4; red in H'4.\nlapply (H'4 l m n); intuition.\nQed.\n", "definition": "\n forall l m n : Line, Unort l m -> ConLn l n \\/ Unort m n.\n", "proof": "\nintros l m n H'.\ngeneralize (O1 m n); intro H'1.\nelim H'1; [ intro H'0; clear H'1 | auto ].\nelim apart_con.\nintros H'1 H'2; red in H'2.\nlapply (H'2 m n l); [ intro H'6 | assumption ].\nelim H'6; [ intro H'3; clear H'6 | auto ].\ngeneralize O2.\nintro H'4; red in H'4.\nlapply (H'4 l m n); intuition.\n", "def_ranges": [97, 0, 98, 58], "proof_ranges": [99, 0, 110, 4], "proof_steps": [{"text": "intros l m n H'.", "goal_before": ["forall l m n : Line, Unort l m -> ConLn l n \\/ Unort m n"], "goal_after": ["ConLn l n \\/ Unort m n"], "proof_term_before": [], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) => ?Goal)"]}, {"text": "generalize (O1 m n); intro H'1.", "goal_before": ["ConLn l n \\/ Unort m n"], "goal_after": ["ConLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) => ?Goal)"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n => ?Goal) (O1 m n))"]}, {"text": "elim H'1; [ intro H'0; clear H'1 | auto ].", "goal_before": ["ConLn l n \\/ Unort m n"], "goal_after": ["ConLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n => ?Goal) (O1 m n))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind (fun H'0 : ConLn m n => ?Goal) (fun H : Unort m n => or_intror H)\n    H'1) (O1 m n))"]}, {"text": "elim apart_con.", "goal_before": ["ConLn l n \\/ Unort m n"], "goal_after": ["Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind (fun H'0 : ConLn m n => ?Goal) (fun H : Unort m n => or_intror H)\n    H'1) (O1 m n))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n) ?Goal apart_con)\n    (fun H : Unort m n => or_intror H) H'1) (O1 m n))"]}, {"text": "intros H'1 H'2; red in H'2.", "goal_before": ["Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l n \\/ Unort m n"], "goal_after": ["ConLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n) ?Goal apart_con)\n    (fun H : Unort m n => or_intror H) H'1) (O1 m n))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        ?Goal@{H'1:=H'2; H'2:=H'3}) apart_con)\n    (fun H : Unort m n => or_intror H) H'1) (O1 m n))"]}, {"text": "lapply (H'2 m n l); [ intro H'6 | assumption ].", "goal_before": ["ConLn l n \\/ Unort m n"], "goal_after": ["ConLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        ?Goal@{H'1:=H'2; H'2:=H'3}) apart_con)\n    (fun H : Unort m n => or_intror H) H'1) (O1 m n))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l => ?Goal@{H'1:=H'2; H'2:=H'3})\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"]}, {"text": "elim H'6; [ intro H'3; clear H'6 | auto ].", "goal_before": ["ConLn l n \\/ Unort m n"], "goal_after": ["ConLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l => ?Goal@{H'1:=H'2; H'2:=H'3})\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l =>\n         or_ind (fun H'4 : ConLn m l => ?Goal@{H'1:=H'2; H'2:=H'3; H'3:=H'4})\n           (fun H : ConLn n l => or_introl (sym_ConLn n l H)) H'6)\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"]}, {"text": "generalize O2.", "goal_before": ["ConLn l n \\/ Unort m n"], "goal_after": ["Separating Line (fun l0 m0 : Line => ConLn l0 m0 /\\ Unort l0 m0) ->\nConLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l =>\n         or_ind (fun H'4 : ConLn m l => ?Goal@{H'1:=H'2; H'2:=H'3; H'3:=H'4})\n           (fun H : ConLn n l => or_introl (sym_ConLn n l H)) H'6)\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l =>\n         or_ind\n           (fun H'4 : ConLn m l => ?Goal@{H'1:=H'2; H'2:=H'3; H'3:=H'4} O2)\n           (fun H : ConLn n l => or_introl (sym_ConLn n l H)) H'6)\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"]}, {"text": "intro H'4; red in H'4.", "goal_before": ["Separating Line (fun l0 m0 : Line => ConLn l0 m0 /\\ Unort l0 m0) ->\nConLn l n \\/ Unort m n"], "goal_after": ["ConLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l =>\n         or_ind\n           (fun H'4 : ConLn m l => ?Goal@{H'1:=H'2; H'2:=H'3; H'3:=H'4} O2)\n           (fun H : ConLn n l => or_introl (sym_ConLn n l H)) H'6)\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l =>\n         or_ind\n           (fun H'4 : ConLn m l =>\n            (fun\n               H'5 : Separating Line\n                       (fun l0 m0 : Line => ConLn l0 m0 /\\ Unort l0 m0) =>\n             ?Goal@{H'1:=H'2; H'2:=H'3; H'3:=H'4; H'4:=H'5}) O2)\n           (fun H : ConLn n l => or_introl (sym_ConLn n l H)) H'6)\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"]}, {"text": "lapply (H'4 l m n); intuition.", "goal_before": ["ConLn l n \\/ Unort m n"], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (H'2 : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l =>\n         or_ind\n           (fun H'4 : ConLn m l =>\n            (fun\n               H'5 : Separating Line\n                       (fun l0 m0 : Line => ConLn l0 m0 /\\ Unort l0 m0) =>\n             ?Goal@{H'1:=H'2; H'2:=H'3; H'3:=H'4; H'4:=H'5}) O2)\n           (fun H : ConLn n l => or_introl (sym_ConLn n l H)) H'6)\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (_ : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l =>\n         or_ind\n           (fun H'4 : ConLn m l =>\n            (fun\n               H'5 : Separating Line\n                       (fun l0 m0 : Line => ConLn l0 m0 /\\ Unort l0 m0) =>\n             (fun H : ConLn l n /\\ Unort l n \\/ ConLn m n /\\ Unort m n =>\n              or_ind\n                (fun H0 : ConLn l n /\\ Unort l n =>\n                 and_ind\n                   (fun (H1 : ConLn l n) (_ : Unort l n) => or_introl H1) H0)\n                (fun H0 : ConLn m n /\\ Unort m n =>\n                 and_ind\n                   (fun (_ : ConLn m n) (H2 : Unort m n) => or_intror H2) H0)\n                H) (H'5 l m n (conj (sym_ConLn m l H'4 : ConLn l m) H'))) O2)\n           (fun H : ConLn n l => or_introl (sym_ConLn n l H)) H'6)\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'1 : ConLn m n \\/ Unort m n =>\n  or_ind\n    (fun H'0 : ConLn m n =>\n     Apartness_ind Line ConLn (ConLn l n \\/ Unort m n)\n       (fun (_ : Irreflexive Line ConLn) (H'3 : Separating Line ConLn) =>\n        (fun H'6 : ConLn m l \\/ ConLn n l =>\n         or_ind\n           (fun H'4 : ConLn m l =>\n            (fun\n               H'5 : Separating Line\n                       (fun l0 m0 : Line => ConLn l0 m0 /\\ Unort l0 m0) =>\n             (fun H : ConLn l n /\\ Unort l n \\/ ConLn m n /\\ Unort m n =>\n              or_ind\n                (fun H0 : ConLn l n /\\ Unort l n =>\n                 and_ind\n                   (fun (H1 : ConLn l n) (_ : Unort l n) => or_introl H1) H0)\n                (fun H0 : ConLn m n /\\ Unort m n =>\n                 and_ind\n                   (fun (_ : ConLn m n) (H2 : Unort m n) => or_intror H2) H0)\n                H) (H'5 l m n (conj (sym_ConLn m l H'4 : ConLn l m) H'))) O2)\n           (fun H : ConLn n l => or_introl (sym_ConLn n l H)) H'6)\n          (H'3 m n l H'0)) apart_con) (fun H : Unort m n => or_intror H) H'1)\n   (O1 m n))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "cmp_unort_diln", "text": "Theorem cmp_unort_diln :\n forall l m n : Line, Unort l m -> DiLn l n \\/ Unort m n.\nProof.\nintros l m n H'.\nlapply (cmp_unort_con l m n); [ intro H'3 | assumption ]; auto.\nintuition.\nQed.\n", "definition": "\n forall l m n : Line, Unort l m -> DiLn l n \\/ Unort m n.\n", "proof": "\nintros l m n H'.\nlapply (cmp_unort_con l m n); [ intro H'3 | assumption ]; auto.\nintuition.\n", "def_ranges": [112, 0, 113, 57], "proof_ranges": [114, 0, 118, 4], "proof_steps": [{"text": "intros l m n H'.", "goal_before": ["forall l m n : Line, Unort l m -> DiLn l n \\/ Unort m n"], "goal_after": ["DiLn l n \\/ Unort m n"], "proof_term_before": [], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) => ?Goal)"]}, {"text": "lapply (cmp_unort_con l m n); [ intro H'3 | assumption ]; auto.", "goal_before": ["DiLn l n \\/ Unort m n"], "goal_after": ["DiLn l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) => ?Goal)"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'3 : ConLn l n \\/ Unort m n => ?Goal) (cmp_unort_con l m n H'))"]}, {"text": "intuition.", "goal_before": ["DiLn l n \\/ Unort m n"], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'3 : ConLn l n \\/ Unort m n => ?Goal) (cmp_unort_con l m n H'))"], "proof_term_after": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'3 : ConLn l n \\/ Unort m n =>\n  or_ind\n    (fun H : ConLn l n =>\n     or_introl (Convergent_imp_distinct l n H : DiLn l n))\n    (fun H : Unort m n => or_intror H) H'3) (cmp_unort_con l m n H'))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l m n : Line) (H' : Unort l m) =>\n (fun H'3 : ConLn l n \\/ Unort m n =>\n  or_ind\n    (fun H : ConLn l n =>\n     or_introl (Convergent_imp_distinct l n H : DiLn l n))\n    (fun H : Unort m n => or_intror H) H'3) (cmp_unort_con l m n H'))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "Unort_symmetric", "text": "Theorem Unort_symmetric : Symmetric Line Unort.\nProof.\nunfold Symmetric at 1 in |- *.\nintros l m H'.\nlapply (cmp_unort_con l m l);\n [ intro H'3; elim H'3; [ intro H'4; clear H'3 | trivial ] | idtac ];\n auto.\ncut (Irreflexive Line ConLn); auto.\nintro H'0; red in H'0.\nelim (H'0 l); auto.\nelim apart_con; auto.\nQed.\n", "definition": " Symmetric Line Unort.\n", "proof": "\nunfold Symmetric at 1 in |- *.\nintros l m H'.\nlapply (cmp_unort_con l m l);\n [ intro H'3; elim H'3; [ intro H'4; clear H'3 | trivial ] | idtac ];\n auto.\ncut (Irreflexive Line ConLn); auto.\nintro H'0; red in H'0.\nelim (H'0 l); auto.\nelim apart_con; auto.\n", "def_ranges": [120, 0, 120, 47], "proof_ranges": [121, 0, 131, 4], "proof_steps": [{"text": "unfold Symmetric at 1 in |- *.", "goal_before": ["Symmetric Line Unort"], "goal_after": ["forall x y : Line, Unort x y -> Unort y x"], "proof_term_before": [], "proof_term_after": ["(?Goal : Symmetric Line Unort)"]}, {"text": "intros l m H'.", "goal_before": ["forall x y : Line, Unort x y -> Unort y x"], "goal_after": ["Unort m l"], "proof_term_before": ["(?Goal : Symmetric Line Unort)"], "proof_term_after": ["((fun (l m : Line) (H' : Unort l m) => ?Goal) : Symmetric Line Unort)"]}, {"text": "lapply (cmp_unort_con l m l);", "goal_before": ["Unort m l"], "goal_after": ["Unort m l"], "proof_term_before": ["((fun (l m : Line) (H' : Unort l m) => ?Goal) : Symmetric Line Unort)"], "proof_term_after": []}, {"text": "[ intro H'3; elim H'3; [ intro H'4; clear H'3 | trivial ] | idtac ];", "goal_before": ["Unort m l"], "goal_after": ["Unort m l"], "proof_term_before": [], "proof_term_after": ["((fun (l m : Line) (H' : Unort l m) => ?Goal) : Symmetric Line Unort)"]}, {"text": "auto.", "goal_before": ["Unort m l"], "goal_after": ["Irreflexive Line ConLn -> Unort m l", "Irreflexive Line ConLn"], "proof_term_before": ["((fun (l m : Line) (H' : Unort l m) => ?Goal) : Symmetric Line Unort)"], "proof_term_after": ["((fun (l m : Line) (H' : Unort l m) =>\n  let H : Irreflexive Line ConLn := ?Goal0 in ?Goal H)\n :\n Symmetric Line Unort)"]}, {"text": "cut (Irreflexive Line ConLn); auto.", "goal_before": ["Irreflexive Line ConLn -> Unort m l", "Irreflexive Line ConLn"], "goal_after": ["Unort m l", "Irreflexive Line ConLn"], "proof_term_before": ["((fun (l m : Line) (H' : Unort l m) =>\n  let H : Irreflexive Line ConLn := ?Goal0 in ?Goal H)\n :\n Symmetric Line Unort)"], "proof_term_after": ["((fun (l m : Line) (H' : Unort l m) =>\n  let H : Irreflexive Line ConLn := ?Goal in\n  (fun H'0 : Irreflexive Line ConLn => ?Goal0) H)\n :\n Symmetric Line Unort)"]}, {"text": "intro H'0; red in H'0.", "goal_before": ["Unort m l", "Irreflexive Line ConLn"], "goal_after": ["ConLn l l", "Irreflexive Line ConLn"], "proof_term_before": ["((fun (l m : Line) (H' : Unort l m) =>\n  let H : Irreflexive Line ConLn := ?Goal in\n  (fun H'0 : Irreflexive Line ConLn => ?Goal0) H)\n :\n Symmetric Line Unort)"], "proof_term_after": ["((fun (l m : Line) (H' : Unort l m) =>\n  let H : Irreflexive Line ConLn := ?Goal in\n  (fun H'0 : Irreflexive Line ConLn => False_ind (Unort m l) (H'0 l ?Goal0))\n    H)\n :\n Symmetric Line Unort)"]}, {"text": "elim (H'0 l); auto.", "goal_before": ["ConLn l l", "Irreflexive Line ConLn"], "goal_after": ["Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l l", "Irreflexive Line ConLn"], "proof_term_before": ["((fun (l m : Line) (H' : Unort l m) =>\n  let H : Irreflexive Line ConLn := ?Goal in\n  (fun H'0 : Irreflexive Line ConLn => False_ind (Unort m l) (H'0 l ?Goal0))\n    H)\n :\n Symmetric Line Unort)"], "proof_term_after": ["((fun (l m : Line) (H' : Unort l m) =>\n  let H : Irreflexive Line ConLn := ?Goal in\n  (fun H'0 : Irreflexive Line ConLn =>\n   False_ind (Unort m l)\n     (H'0 l (Apartness_ind Line ConLn (ConLn l l) ?Goal0 apart_con))) H)\n :\n Symmetric Line Unort)"]}, {"text": "elim apart_con; auto.", "goal_before": ["Irreflexive Line ConLn -> Separating Line ConLn -> ConLn l l", "Irreflexive Line ConLn"], "goal_after": [], "proof_term_before": ["((fun (l m : Line) (H' : Unort l m) =>\n  let H : Irreflexive Line ConLn := ?Goal in\n  (fun H'0 : Irreflexive Line ConLn =>\n   False_ind (Unort m l)\n     (H'0 l (Apartness_ind Line ConLn (ConLn l l) ?Goal0 apart_con))) H)\n :\n Symmetric Line Unort)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "thm8_6", "text": "Theorem thm8_6 : forall l m n : Line, ConLn l m -> Unort l n \\/ Unort m n.\nProof.\nintros l m n H'.\nlapply (Convergent_imp_distinct l m); [ intro H'2 | assumption ].\nlapply (constructive_uniqueness_for_orthogonals l m n (pt (Twol l m H')));\n [ intro H'5 | assumption ].\nelim H'5; [ intro H'0; clear H'5 | trivial ].\ngeneralize (inc_pt1 (Twol l m H')); generalize (inc_pt2 (Twol l m H')).\nsimpl in |- *; unfold Incident, Negation in |- *; tauto.\nQed.\n", "definition": " forall l m n : Line, ConLn l m -> Unort l n \\/ Unort m n.\n", "proof": "\nintros l m n H'.\nlapply (Convergent_imp_distinct l m); [ intro H'2 | assumption ].\nlapply (constructive_uniqueness_for_orthogonals l m n (pt (Twol l m H')));\n [ intro H'5 | assumption ].\nelim H'5; [ intro H'0; clear H'5 | trivial ].\ngeneralize (inc_pt1 (Twol l m H')); generalize (inc_pt2 (Twol l m H')).\nsimpl in |- *; unfold Incident, Negation in |- *; tauto.\n", "def_ranges": [133, 0, 133, 74], "proof_ranges": [134, 0, 142, 4], "proof_steps": [{"text": "intros l m n H'.", "goal_before": ["forall l m n : Line, ConLn l m -> Unort l n \\/ Unort m n"], "goal_after": ["Unort l n \\/ Unort m n"], "proof_term_before": [], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) => ?Goal)"]}, {"text": "lapply (Convergent_imp_distinct l m); [ intro H'2 | assumption ].", "goal_before": ["Unort l n \\/ Unort m n"], "goal_after": ["Unort l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) => ?Goal)"], "proof_term_after": ["(fun (l m n : Line) (H' : ConLn l m) =>\n (fun H'2 : DiLn l m => ?Goal) (Convergent_imp_distinct l m H'))"]}, {"text": "lapply (constructive_uniqueness_for_orthogonals l m n (pt (Twol l m H')));", "goal_before": ["Unort l n \\/ Unort m n"], "goal_after": ["Unort l n \\/ Unort m n"], "proof_term_before": ["(fun (l m n : Line) (H' : ConLn l m) =>\n (fun H'2 : DiLn l m => ?Goal) (Convergent_imp_distinct l m H'))"], "proof_term_after": []}, {"text": "[ intro H'5 | assumption ].", "goal_before": ["Unort l n \\/ Unort m n"], "goal_after": ["Unort l n \\/ Unort m n"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'5; [ intro H'0; clear H'5 | trivial ].", "goal_before": ["Unort l n \\/ Unort m n"], "goal_after": ["Unort l n \\/ Unort m n"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (inc_pt1 (Twol l m H')); generalize (inc_pt2 (Twol l m H')).", "goal_before": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H' |})\n  (line2 {| line1 := l; line2 := m; Twol_cond := H' |}) ->\nIncident (pt {| line1 := l; line2 := m; Twol_cond := H' |})\n  (line1 {| line1 := l; line2 := m; Twol_cond := H' |}) ->\nUnort l n \\/ Unort m n"], "goal_after": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H' |})\n  (line2 {| line1 := l; line2 := m; Twol_cond := H' |}) ->\nIncident (pt {| line1 := l; line2 := m; Twol_cond := H' |})\n  (line1 {| line1 := l; line2 := m; Twol_cond := H' |}) ->\nUnort l n \\/ Unort m n"], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; unfold Incident, Negation in |- *; tauto.", "goal_before": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H' |})\n  (line2 {| line1 := l; line2 := m; Twol_cond := H' |}) ->\nIncident (pt {| line1 := l; line2 := m; Twol_cond := H' |})\n  (line1 {| line1 := l; line2 := m; Twol_cond := H' |}) ->\nUnort l n \\/ Unort m n"], "goal_after": ["Incident (pt {| line1 := l; line2 := m; Twol_cond := H' |})\n  (line2 {| line1 := l; line2 := m; Twol_cond := H' |}) ->\nIncident (pt {| line1 := l; line2 := m; Twol_cond := H' |})\n  (line1 {| line1 := l; line2 := m; Twol_cond := H' |}) ->\nUnort l n \\/ Unort m n"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "apart_obl", "text": "Theorem apart_obl : Apartness Line Oblique.\nProof.\napply Definition_of_apartness.\nunfold Irreflexive, Negation, Oblique in |- *.\nintro l; red in |- *; intro H'; elim H'; intros H'0 H'1; clear H'.\nelim apart_con.\nintros H' H'2; apply (H' l); assumption.\nunfold Oblique in |- *; exact O2.\nQed.\n", "definition": " Apartness Line Oblique.\n", "proof": "\napply Definition_of_apartness.\nunfold Irreflexive, Negation, Oblique in |- *.\nintro l; red in |- *; intro H'; elim H'; intros H'0 H'1; clear H'.\nelim apart_con.\nintros H' H'2; apply (H' l); assumption.\nunfold Oblique in |- *; exact O2.\n", "def_ranges": [147, 0, 147, 43], "proof_ranges": [148, 0, 155, 4], "proof_steps": [{"text": "apply Definition_of_apartness.", "goal_before": ["Apartness Line Oblique"], "goal_after": ["Irreflexive Line Oblique", "Separating Line Oblique"], "proof_term_before": [], "proof_term_after": ["(Definition_of_apartness Line Oblique ?Goal ?Goal0)"]}, {"text": "unfold Irreflexive, Negation, Oblique in |- *.", "goal_before": ["Irreflexive Line Oblique", "Separating Line Oblique"], "goal_after": ["forall x : Line, ~ (ConLn x x /\\ Unort x x)", "Separating Line Oblique"], "proof_term_before": ["(Definition_of_apartness Line Oblique ?Goal ?Goal0)"], "proof_term_after": ["(Definition_of_apartness Line Oblique (?Goal0 : Irreflexive Line Oblique)\n   ?Goal)"]}, {"text": "intro l; red in |- *; intro H'; elim H'; intros H'0 H'1; clear H'.", "goal_before": ["forall x : Line, ~ (ConLn x x /\\ Unort x x)", "Separating Line Oblique"], "goal_after": ["False", "Separating Line Oblique"], "proof_term_before": ["(Definition_of_apartness Line Oblique (?Goal0 : Irreflexive Line Oblique)\n   ?Goal)"], "proof_term_after": ["(Definition_of_apartness Line Oblique\n   ((fun l : Line =>\n     (fun H' : ConLn l l /\\ Unort l l =>\n      and_ind (fun (H'0 : ConLn l l) (H'1 : Unort l l) => ?Goal0) H')\n     :\n     ~ (ConLn l l /\\ Unort l l))\n    :\n    Irreflexive Line Oblique) ?Goal)"]}, {"text": "elim apart_con.", "goal_before": ["False", "Separating Line Oblique"], "goal_after": ["Irreflexive Line ConLn -> Separating Line ConLn -> False", "Separating Line Oblique"], "proof_term_before": ["(Definition_of_apartness Line Oblique\n   ((fun l : Line =>\n     (fun H' : ConLn l l /\\ Unort l l =>\n      and_ind (fun (H'0 : ConLn l l) (H'1 : Unort l l) => ?Goal0) H')\n     :\n     ~ (ConLn l l /\\ Unort l l))\n    :\n    Irreflexive Line Oblique) ?Goal)"], "proof_term_after": ["(Definition_of_apartness Line Oblique\n   ((fun l : Line =>\n     (fun H' : ConLn l l /\\ Unort l l =>\n      and_ind\n        (fun (H'0 : ConLn l l) (H'1 : Unort l l) =>\n         Apartness_ind Line ConLn False ?Goal0 apart_con) H')\n     :\n     ~ (ConLn l l /\\ Unort l l))\n    :\n    Irreflexive Line Oblique) ?Goal)"]}, {"text": "intros H' H'2; apply (H' l); assumption.", "goal_before": ["Irreflexive Line ConLn -> Separating Line ConLn -> False", "Separating Line Oblique"], "goal_after": ["Separating Line Oblique"], "proof_term_before": ["(Definition_of_apartness Line Oblique\n   ((fun l : Line =>\n     (fun H' : ConLn l l /\\ Unort l l =>\n      and_ind\n        (fun (H'0 : ConLn l l) (H'1 : Unort l l) =>\n         Apartness_ind Line ConLn False ?Goal0 apart_con) H')\n     :\n     ~ (ConLn l l /\\ Unort l l))\n    :\n    Irreflexive Line Oblique) ?Goal)"], "proof_term_after": ["(Definition_of_apartness Line Oblique\n   ((fun l : Line =>\n     (fun H' : ConLn l l /\\ Unort l l =>\n      and_ind\n        (fun (H'0 : ConLn l l) (_ : Unort l l) =>\n         Apartness_ind Line ConLn False\n           (fun (H'2 : Irreflexive Line ConLn) (_ : Separating Line ConLn) =>\n            H'2 l H'0) apart_con) H')\n     :\n     ~ (ConLn l l /\\ Unort l l))\n    :\n    Irreflexive Line Oblique) ?Goal)"]}, {"text": "unfold Oblique in |- *; exact O2.", "goal_before": ["Separating Line Oblique"], "goal_after": [], "proof_term_before": ["(Definition_of_apartness Line Oblique\n   ((fun l : Line =>\n     (fun H' : ConLn l l /\\ Unort l l =>\n      and_ind\n        (fun (H'0 : ConLn l l) (_ : Unort l l) =>\n         Apartness_ind Line ConLn False\n           (fun (H'2 : Irreflexive Line ConLn) (_ : Separating Line ConLn) =>\n            H'2 l H'0) apart_con) H')\n     :\n     ~ (ConLn l l /\\ Unort l l))\n    :\n    Irreflexive Line Oblique) ?Goal)"], "proof_term_after": ["(Definition_of_apartness Line Oblique\n   ((fun l : Line =>\n     (fun H' : ConLn l l /\\ Unort l l =>\n      and_ind\n        (fun (H'0 : ConLn l l) (_ : Unort l l) =>\n         Apartness_ind Line ConLn False\n           (fun (H'2 : Irreflexive Line ConLn) (_ : Separating Line ConLn) =>\n            H'2 l H'0) apart_con) H')\n     :\n     ~ (ConLn l l /\\ Unort l l))\n    :\n    Irreflexive Line Oblique) (O2 : Separating Line Oblique))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(Definition_of_apartness Line Oblique\n   ((fun l : Line =>\n     (fun H' : ConLn l l /\\ Unort l l =>\n      and_ind\n        (fun (H'0 : ConLn l l) (_ : Unort l l) =>\n         Apartness_ind Line ConLn False\n           (fun (H'2 : Irreflexive Line ConLn) (_ : Separating Line ConLn) =>\n            H'2 l H'0) apart_con) H')\n     :\n     ~ (ConLn l l /\\ Unort l l))\n    :\n    Irreflexive Line Oblique) (O2 : Separating Line Oblique))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "ort_ort_like_par_i", "text": "Theorem ort_ort_like_par_i :\n forall (l : Line) (a : Point), Incident a (ort (ort l a) a).\nProof.\nauto.\nQed.\n", "definition": "\n forall (l : Line) (a : Point), Incident a (ort (ort l a) a).\n", "proof": "\nauto.\n", "def_ranges": [157, 0, 158, 61], "proof_ranges": [159, 0, 161, 4], "proof_steps": [{"text": "auto.", "goal_before": ["forall (l : Line) (a : Point), Incident a (ort (ort l a) a)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (l : Line) (a : Point) => O3_ii (ort l a) a)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) => O3_ii (ort l a) a)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "thm8_8", "text": "Theorem thm8_8 :\n forall (l : Line) (a b : Point),\n Incident b (ort l a) -> EqLn (ort l a) (ort l b).\nProof.\nintros l a b H'.\napply O4' with (n := l) (a := b); auto.\nQed.\n", "definition": "\n forall (l : Line) (a b : Point),\n Incident b (ort l a) -> EqLn (ort l a) (ort l b).\n", "proof": "\nintros l a b H'.\napply O4' with (n := l) (a := b); auto.\n", "def_ranges": [163, 0, 165, 50], "proof_ranges": [166, 0, 169, 4], "proof_steps": [{"text": "intros l a b H'.", "goal_before": ["forall (l : Line) (a b : Point),\nIncident b (ort l a) -> EqLn (ort l a) (ort l b)"], "goal_after": ["EqLn (ort l a) (ort l b)"], "proof_term_before": [], "proof_term_after": ["(fun (l : Line) (a b : Point) (H' : Incident b (ort l a)) => ?Goal)"]}, {"text": "apply O4' with (n := l) (a := b); auto.", "goal_before": ["EqLn (ort l a) (ort l b)"], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a b : Point) (H' : Incident b (ort l a)) => ?Goal)"], "proof_term_after": ["(fun (l : Line) (a b : Point) (H' : Incident b (ort l a)) =>\n O4' (ort l a) (ort l b) l b\n   (conj (conj H' (O3_ii l b)) (conj (O3_i l a) (O3_i l b))))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a b : Point) (H' : Incident b (ort l a)) =>\n O4' (ort l a) (ort l b) l b\n   (conj (conj H' (O3_ii l b)) (conj (O3_i l a) (O3_i l b))))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "thm8_9_aux", "text": "Theorem thm8_9_aux : False.\nProof.\ngeneralize (inc_pt1 t); intro H'0; simpl in H'0.\ngeneralize (inc_pt2 t); intro H'1; simpl in H'1.\nlapply (Convergent_imp_distinct l (ort (ort l a) a));\n [ intro H'4 | assumption ].\nlapply (thm8_8 (ort l a) a b); [ intro H'6 | assumption ].\nlapply (cong_eqln_diln l (ort (ort l a) a) (ort (ort l a) b));\n [ intro H'7; lapply H'7; [ intro H'8; clear H'7 | clear H'7 ] | idtac ];\n auto.\nlapply\n (constructive_uniqueness_for_orthogonals l (ort (ort l a) b) (ort l a) b);\n [ intro H'9 | assumption ].\nelim H'9;\n [ intro H'2; elim H'2;\n    [ intro H'3; clear H'2 H'9 | intro H'3; clear H'2 H'9 ]\n | intro H'2; clear H'9 ].\nunfold b at 1 in H'3; elim H'0; auto.\nelim (O3_ii (ort l a) b); auto.\ngeneralize Unort_symmetric.\nintro H'; red in H'.\nelim H'2; (intro H'3; clear H'2).\nelim (O3_i l a); auto.\nelim (O3_i (ort l a) b); auto.\nQed.\n", "definition": " False.\n", "proof": "\ngeneralize (inc_pt1 t); intro H'0; simpl in H'0.\ngeneralize (inc_pt2 t); intro H'1; simpl in H'1.\nlapply (Convergent_imp_distinct l (ort (ort l a) a));\n [ intro H'4 | assumption ].\nlapply (thm8_8 (ort l a) a b); [ intro H'6 | assumption ].\nlapply (cong_eqln_diln l (ort (ort l a) a) (ort (ort l a) b));\n [ intro H'7; lapply H'7; [ intro H'8; clear H'7 | clear H'7 ] | idtac ];\n auto.\nlapply\n (constructive_uniqueness_for_orthogonals l (ort (ort l a) b) (ort l a) b);\n [ intro H'9 | assumption ].\nelim H'9;\n [ intro H'2; elim H'2;\n    [ intro H'3; clear H'2 H'9 | intro H'3; clear H'2 H'9 ]\n | intro H'2; clear H'9 ].\nunfold b at 1 in H'3; elim H'0; auto.\nelim (O3_ii (ort l a) b); auto.\ngeneralize Unort_symmetric.\nintro H'; red in H'.\nelim H'2; (intro H'3; clear H'2).\nelim (O3_i l a); auto.\nelim (O3_i (ort l a) b); auto.\n", "def_ranges": [180, 0, 180, 27], "proof_ranges": [181, 0, 204, 4], "proof_steps": [{"text": "generalize (inc_pt1 t); intro H'0; simpl in H'0.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) => ?Goal) (inc_pt1 t))"]}, {"text": "generalize (inc_pt2 t); intro H'1; simpl in H'1.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) => ?Goal) (inc_pt1 t))"], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) => ?Goal) (inc_pt2 t)) \n   (inc_pt1 t))"]}, {"text": "lapply (Convergent_imp_distinct l (ort (ort l a) a));", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) => ?Goal) (inc_pt2 t)) \n   (inc_pt1 t))"], "proof_term_after": []}, {"text": "[ intro H'4 | assumption ].", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (thm8_8 (ort l a) a b); [ intro H'6 | assumption ].", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (cong_eqln_diln l (ort (ort l a) a) (ort (ort l a) b));", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'7; lapply H'7; [ intro H'8; clear H'7 | clear H'7 ] | idtac ];", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "(constructive_uniqueness_for_orthogonals l (ort (ort l a) b) (ort l a) b);", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'9 | assumption ].", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) => ?Goal)\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"]}, {"text": "elim H'9;", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) => ?Goal)\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) => ?Goal)\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"]}, {"text": "[ intro H'2; elim H'2;", "goal_before": ["False"], "goal_after": ["Apart b (ort (ort l a) b)"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) => ?Goal)\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False (O3_ii (ort l a) b ?Goal)) (thm8_8 (ort l a) a b H'1))\n    (inc_pt2 t)) (inc_pt1 t))"]}, {"text": "[ intro H'3; clear H'2 H'9 | intro H'3; clear H'2 H'9 ]", "goal_before": ["Apart b (ort (ort l a) b)"], "goal_after": ["Symmetric Line Unort -> Apart b (ort (ort l a) b)"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False (O3_ii (ort l a) b ?Goal)) (thm8_8 (ort l a) a b H'1))\n    (inc_pt2 t)) (inc_pt1 t))"], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False (O3_ii (ort l a) b (?Goal Unort_symmetric)))\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"]}, {"text": "| intro H'2; clear H'9 ].", "goal_before": ["Symmetric Line Unort -> Apart b (ort (ort l a) b)"], "goal_after": ["Apart b (ort (ort l a) b)"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False (O3_ii (ort l a) b (?Goal Unort_symmetric)))\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False\n      (O3_ii (ort l a) b\n         ((fun H' : Symmetric Line Unort => ?Goal) Unort_symmetric)))\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"]}, {"text": "unfold b at 1 in H'3; elim H'0; auto.", "goal_before": ["Apart b (ort (ort l a) b)"], "goal_after": ["Apart b (ort (ort l a) b)"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False\n      (O3_ii (ort l a) b\n         ((fun H' : Symmetric Line Unort => ?Goal) Unort_symmetric)))\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False\n      (O3_ii (ort l a) b\n         ((fun H' : Symmetric Line Unort => ?Goal) Unort_symmetric)))\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"]}, {"text": "elim (O3_ii (ort l a) b); auto.", "goal_before": ["Apart b (ort (ort l a) b)"], "goal_after": ["Unort (ort l a) l"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False\n      (O3_ii (ort l a) b\n         ((fun H' : Symmetric Line Unort => ?Goal) Unort_symmetric)))\n     (thm8_8 (ort l a) a b H'1)) (inc_pt2 t)) (inc_pt1 t))"], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False\n      (O3_ii (ort l a) b\n         ((fun H' : Symmetric Line Unort =>\n           False_ind (Apart b (ort (ort l a) b)) (O3_i l a ?Goal))\n            Unort_symmetric))) (thm8_8 (ort l a) a b H'1)) \n    (inc_pt2 t)) (inc_pt1 t))"]}, {"text": "generalize Unort_symmetric.", "goal_before": ["Unort (ort l a) l"], "goal_after": ["Unort (ort (ort l a) b) (ort l a)"], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False\n      (O3_ii (ort l a) b\n         ((fun H' : Symmetric Line Unort =>\n           False_ind (Apart b (ort (ort l a) b)) (O3_i l a ?Goal))\n            Unort_symmetric))) (thm8_8 (ort l a) a b H'1)) \n    (inc_pt2 t)) (inc_pt1 t))"], "proof_term_after": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False\n      (O3_ii (ort l a) b\n         ((fun H' : Symmetric Line Unort =>\n           False_ind (Apart b (ort (ort l a) b))\n             (O3_i l a\n                (False_ind (Unort (ort l a) l) (O3_i (ort l a) b ?Goal))))\n            Unort_symmetric))) (thm8_8 (ort l a) a b H'1)) \n    (inc_pt2 t)) (inc_pt1 t))"]}, {"text": "intro H'; red in H'.", "goal_before": ["Unort (ort (ort l a) b) (ort l a)"], "goal_after": [], "proof_term_before": ["((fun H'0 : Incident (pt t) (line1 t) =>\n  (fun H'1 : Incident (pt t) (line2 t) =>\n   (fun H'6 : EqLn (ort (ort l a) a) (ort (ort l a) b) =>\n    False_ind False\n      (O3_ii (ort l a) b\n         ((fun H' : Symmetric Line Unort =>\n           False_ind (Apart b (ort (ort l a) b))\n             (O3_i l a\n                (False_ind (Unort (ort l a) l) (O3_i (ort l a) b ?Goal))))\n            Unort_symmetric))) (thm8_8 (ort l a) a b H'1)) \n    (inc_pt2 t)) (inc_pt1 t))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "thm8_9", "text": "Theorem thm8_9 : forall (l : Line) (a : Point), Par l (ort (ort l a) a).\nProof.\nintros l a; unfold Par, Negation in |- *.\nred in |- *; intro H'; apply (thm8_9_aux a l); trivial.\nQed.\n", "definition": " forall (l : Line) (a : Point), Par l (ort (ort l a) a).\n", "proof": "\nintros l a; unfold Par, Negation in |- *.\nred in |- *; intro H'; apply (thm8_9_aux a l); trivial.\n", "def_ranges": [208, 0, 208, 72], "proof_ranges": [209, 0, 212, 4], "proof_steps": [{"text": "intros l a; unfold Par, Negation in |- *.", "goal_before": ["forall (l : Line) (a : Point), Par l (ort (ort l a) a)"], "goal_after": ["~ ConLn l (ort (ort l a) a)"], "proof_term_before": [], "proof_term_after": ["(fun (l : Line) (a : Point) => ?Goal : Par l (ort (ort l a) a))"]}, {"text": "red in |- *; intro H'; apply (thm8_9_aux a l); trivial.", "goal_before": ["~ ConLn l (ort (ort l a) a)"], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) => ?Goal : Par l (ort (ort l a) a))"], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n ((fun H' : ConLn l (ort (ort l a) a) => thm8_9_aux a l H')\n  :\n  ~ ConLn l (ort (ort l a) a))\n :\n Par l (ort (ort l a) a))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n ((fun H' : ConLn l (ort (ort l a) a) => thm8_9_aux a l H')\n  :\n  ~ ConLn l (ort (ort l a) a))\n :\n Par l (ort (ort l a) a))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/orthogonality.v", "name": "thm8_10", "text": "Theorem thm8_10 :\n forall (l : Line) (a : Point), EqLn (par l a) (ort (ort l a) a).\nProof.\nintros l a; apply sym_EqLn; auto.\nQed.\n", "definition": "\n forall (l : Line) (a : Point), EqLn (par l a) (ort (ort l a) a).\n", "proof": "\nintros l a; apply sym_EqLn; auto.\n", "def_ranges": [215, 0, 216, 65], "proof_ranges": [217, 0, 219, 4], "proof_steps": [{"text": "intros l a; apply sym_EqLn; auto.", "goal_before": ["forall (l : Line) (a : Point), EqLn (par l a) (ort (ort l a) a)"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (l : Line) (a : Point) =>\n sym_EqLn (ort (ort l a) a) (par l a)\n   (thm7_1 (ort (ort l a) a) l a\n      (conj (O3_ii (ort l a) a) (sym_Par l (ort (ort l a) a) (thm8_9 l a)))))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (l : Line) (a : Point) =>\n sym_EqLn (ort (ort l a) a) (par l a)\n   (thm7_1 (ort (ort l a) a) l a\n      (conj (O3_ii (ort l a) a) (sym_Par l (ort (ort l a) a) (thm8_9 l a)))))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "Sym_imp_NegSym", "text": "Theorem Sym_imp_NegSym :\n forall (U : Set) (R : Relation U),\n Symmetric U R -> Symmetric U (Negation U R).\nunfold Symmetric, Negation in |- *.\nintros U R H' x y H'0; red in |- *; intro H'1; auto.\nQed.\n", "definition": "\n forall (U : Set) (R : Relation U),\n Symmetric U R -> Symmetric U (Negation U R).", "proof": "\nunfold Symmetric, Negation in |- *.\nintros U R H' x y H'0; red in |- *; intro H'1; auto.\n", "def_ranges": [45, 0, 47, 45], "proof_ranges": [48, 0, 50, 4], "proof_steps": [{"text": "unfold Symmetric, Negation in |- *.", "goal_before": ["forall (U : Set) (R : Relation U),\nSymmetric U R -> Symmetric U (Negation U R)"], "goal_after": ["forall (U : Set) (R : Relation U),\n(forall x y : U, R x y -> R y x) -> forall x y : U, ~ R x y -> ~ R y x"], "proof_term_before": [], "proof_term_after": ["(?Goal\n :\n forall (U : Set) (R : Relation U),\n Symmetric U R -> Symmetric U (Negation U R))"]}, {"text": "intros U R H' x y H'0; red in |- *; intro H'1; auto.", "goal_before": ["forall (U : Set) (R : Relation U),\n(forall x y : U, R x y -> R y x) -> forall x y : U, ~ R x y -> ~ R y x"], "goal_after": [], "proof_term_before": ["(?Goal\n :\n forall (U : Set) (R : Relation U),\n Symmetric U R -> Symmetric U (Negation U R))"], "proof_term_after": ["((fun (U : Set) (R : Relation U) (H' : forall x y : U, R x y -> R y x)\n    (x y : U) (H'0 : ~ R x y) =>\n  (fun H'1 : R y x => H'0 (H' y x H'1)) : ~ R y x)\n :\n forall (U : Set) (R : Relation U),\n Symmetric U R -> Symmetric U (Negation U R))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (U : Set) (R : Relation U) (H' : forall x y : U, R x y -> R y x)\n    (x y : U) (H'0 : ~ R x y) =>\n  (fun H'1 : R y x => H'0 (H' y x H'1)) : ~ R y x)\n :\n forall (U : Set) (R : Relation U),\n Symmetric U R -> Symmetric U (Negation U R))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "Apart_imp_Sym", "text": "Theorem Apart_imp_Sym :\n forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.\nProof.\nintros U R H'; elim H'.\nintros H'0 H'1; red in |- *.\nintros x y H'2; red in H'1.\nelim (H'1 x y x); trivial.\nintro H'3; elim (H'0 x); trivial.\nQed.\n", "definition": "\n forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R.\n", "proof": "\nintros U R H'; elim H'.\nintros H'0 H'1; red in |- *.\nintros x y H'2; red in H'1.\nelim (H'1 x y x); trivial.\nintro H'3; elim (H'0 x); trivial.\n", "def_ranges": [82, 0, 83, 67], "proof_ranges": [84, 0, 90, 4], "proof_steps": [{"text": "intros U R H'; elim H'.", "goal_before": ["forall (U : Set) (R : Relation U), Apartness U R -> Symmetric U R"], "goal_after": ["Irreflexive U R -> Separating U R -> Symmetric U R"], "proof_term_before": [], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R) ?Goal H')"]}, {"text": "intros H'0 H'1; red in |- *.", "goal_before": ["Irreflexive U R -> Separating U R -> Symmetric U R"], "goal_after": ["forall x y : U, R x y -> R y x"], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R) ?Goal H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R)\n   (fun (H'0 : Irreflexive U R) (H'1 : Separating U R) =>\n    ?Goal : Symmetric U R) H')"]}, {"text": "intros x y H'2; red in H'1.", "goal_before": ["forall x y : U, R x y -> R y x"], "goal_after": ["R y x"], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R)\n   (fun (H'0 : Irreflexive U R) (H'1 : Separating U R) =>\n    ?Goal : Symmetric U R) H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R)\n   (fun (H'0 : Irreflexive U R) (H'1 : Separating U R) =>\n    (fun (x y : U) (H'2 : R x y) => ?Goal) : Symmetric U R) H')"]}, {"text": "elim (H'1 x y x); trivial.", "goal_before": ["R y x"], "goal_after": ["R x x -> R y x"], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R)\n   (fun (H'0 : Irreflexive U R) (H'1 : Separating U R) =>\n    (fun (x y : U) (H'2 : R x y) => ?Goal) : Symmetric U R) H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R)\n   (fun (H'0 : Irreflexive U R) (H'1 : Separating U R) =>\n    (fun (x y : U) (H'2 : R x y) =>\n     or_ind ?Goal (fun H : R y x => H) (H'1 x y x H'2))\n    :\n    Symmetric U R) H')"]}, {"text": "intro H'3; elim (H'0 x); trivial.", "goal_before": ["R x x -> R y x"], "goal_after": [], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R)\n   (fun (H'0 : Irreflexive U R) (H'1 : Separating U R) =>\n    (fun (x y : U) (H'2 : R x y) =>\n     or_ind ?Goal (fun H : R y x => H) (H'1 x y x H'2))\n    :\n    Symmetric U R) H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R)\n   (fun (H'0 : Irreflexive U R) (H'1 : Separating U R) =>\n    (fun (x y : U) (H'2 : R x y) =>\n     or_ind (fun H'3 : R x x => False_ind (R y x) (H'0 x H'3))\n       (fun H : R y x => H) (H'1 x y x H'2))\n    :\n    Symmetric U R) H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Symmetric U R)\n   (fun (H'0 : Irreflexive U R) (H'1 : Separating U R) =>\n    (fun (x y : U) (H'2 : R x y) =>\n     or_ind (fun H'3 : R x x => False_ind (R y x) (H'0 x H'3))\n       (fun H : R y x => H) (H'1 x y x H'2))\n    :\n    Symmetric U R) H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "sym_DiPt", "text": "Theorem sym_DiPt : forall x y : Point, DiPt x y -> DiPt y x.\nProof.\nintros x y H'; cut (Symmetric Point DiPt); auto.\nQed.\n", "definition": " forall x y : Point, DiPt x y -> DiPt y x.\n", "proof": "\nintros x y H'; cut (Symmetric Point DiPt); auto.\n", "def_ranges": [93, 0, 93, 60], "proof_ranges": [94, 0, 96, 4], "proof_steps": [{"text": "intros x y H'; cut (Symmetric Point DiPt); auto.", "goal_before": ["forall x y : Point, DiPt x y -> DiPt y x"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x y : Point) (H' : DiPt x y) =>\n let H : Symmetric Point DiPt := Apart_imp_Sym Point DiPt apart_dipt in\n (fun H0 : Symmetric Point DiPt => H0 x y H') H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : Point) (H' : DiPt x y) =>\n let H : Symmetric Point DiPt := Apart_imp_Sym Point DiPt apart_dipt in\n (fun H0 : Symmetric Point DiPt => H0 x y H') H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "sym_DiLn", "text": "Theorem sym_DiLn : forall x y : Line, DiLn x y -> DiLn y x.\nProof.\nintros x y H'; cut (Symmetric Line DiLn); auto.\nQed.\n", "definition": " forall x y : Line, DiLn x y -> DiLn y x.\n", "proof": "\nintros x y H'; cut (Symmetric Line DiLn); auto.\n", "def_ranges": [98, 0, 98, 59], "proof_ranges": [99, 0, 101, 4], "proof_steps": [{"text": "intros x y H'; cut (Symmetric Line DiLn); auto.", "goal_before": ["forall x y : Line, DiLn x y -> DiLn y x"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x y : Line) (H' : DiLn x y) =>\n let H : Symmetric Line DiLn := Apart_imp_Sym Line DiLn apart_diln in\n (fun H0 : Symmetric Line DiLn => H0 x y H') H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : Line) (H' : DiLn x y) =>\n let H : Symmetric Line DiLn := Apart_imp_Sym Line DiLn apart_diln in\n (fun H0 : Symmetric Line DiLn => H0 x y H') H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "sym_ConLn", "text": "Theorem sym_ConLn : forall x y : Line, ConLn x y -> ConLn y x.\nProof.\nintros x y H'; cut (Symmetric Line ConLn); auto.\nQed.\n", "definition": " forall x y : Line, ConLn x y -> ConLn y x.\n", "proof": "\nintros x y H'; cut (Symmetric Line ConLn); auto.\n", "def_ranges": [103, 0, 103, 62], "proof_ranges": [104, 0, 106, 4], "proof_steps": [{"text": "intros x y H'; cut (Symmetric Line ConLn); auto.", "goal_before": ["forall x y : Line, ConLn x y -> ConLn y x"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x y : Line) (H' : ConLn x y) =>\n let H : Symmetric Line ConLn := Apart_imp_Sym Line ConLn apart_con in\n (fun H0 : Symmetric Line ConLn => H0 x y H') H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : Line) (H' : ConLn x y) =>\n let H : Symmetric Line ConLn := Apart_imp_Sym Line ConLn apart_con in\n (fun H0 : Symmetric Line ConLn => H0 x y H') H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "Neg_apart_equiv", "text": "Theorem Neg_apart_equiv :\n forall (U : Set) (R : Relation U),\n Apartness U R -> Equivalence U (Negation U R).\nProof.\nintros U R H'; elim H'.\nconstructor 1; auto.\nunfold Transitive, Negation in |- *.\nintros x y z H'2 H'3; red in |- *; intro H'4.\nred in H0.\nelim (H0 x z y); auto.\ncut (Symmetric U R); auto.\nQed.\n", "definition": "\n forall (U : Set) (R : Relation U),\n Apartness U R -> Equivalence U (Negation U R).\n", "proof": "\nintros U R H'; elim H'.\nconstructor 1; auto.\nunfold Transitive, Negation in |- *.\nintros x y z H'2 H'3; red in |- *; intro H'4.\nred in H0.\nelim (H0 x z y); auto.\ncut (Symmetric U R); auto.\n", "def_ranges": [109, 0, 111, 47], "proof_ranges": [112, 0, 120, 4], "proof_steps": [{"text": "intros U R H'; elim H'.", "goal_before": ["forall (U : Set) (R : Relation U),\nApartness U R -> Equivalence U (Negation U R)"], "goal_after": ["Irreflexive U R -> Separating U R -> Equivalence U (Negation U R)"], "proof_term_before": [], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R)) ?Goal H')"]}, {"text": "constructor 1; auto.", "goal_before": ["Irreflexive U R -> Separating U R -> Equivalence U (Negation U R)"], "goal_after": ["Transitive U (Negation U R)"], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R)) ?Goal H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H')) \n      ?Goal) H')"]}, {"text": "unfold Transitive, Negation in |- *.", "goal_before": ["Transitive U (Negation U R)"], "goal_after": ["forall x y z : U, ~ R x y -> ~ R y z -> ~ R x z"], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H')) \n      ?Goal) H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      (?Goal : Transitive U (Negation U R))) H')"]}, {"text": "intros x y z H'2 H'3; red in |- *; intro H'4.", "goal_before": ["forall x y z : U, ~ R x y -> ~ R y z -> ~ R x z"], "goal_after": ["False"], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      (?Goal : Transitive U (Negation U R))) H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      ((fun (x y z : U) (H'2 : ~ R x y) (H'3 : ~ R y z) =>\n        (fun H'4 : R x z => ?Goal) : ~ R x z)\n       :\n       Transitive U (Negation U R))) H')"]}, {"text": "red in H0.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      ((fun (x y z : U) (H'2 : ~ R x y) (H'3 : ~ R y z) =>\n        (fun H'4 : R x z => ?Goal) : ~ R x z)\n       :\n       Transitive U (Negation U R))) H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      ((fun (x y z : U) (H'2 : ~ R x y) (H'3 : ~ R y z) =>\n        (fun H'4 : R x z => ?Goal) : ~ R x z)\n       :\n       Transitive U (Negation U R))) H')"]}, {"text": "elim (H0 x z y); auto.", "goal_before": ["False"], "goal_after": ["R z y -> False"], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      ((fun (x y z : U) (H'2 : ~ R x y) (H'3 : ~ R y z) =>\n        (fun H'4 : R x z => ?Goal) : ~ R x z)\n       :\n       Transitive U (Negation U R))) H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      ((fun (x y z : U) (H'2 : ~ R x y) (H'3 : ~ R y z) =>\n        (fun H'4 : R x z => or_ind H'2 ?Goal (H0 x z y H'4)) : ~ R x z)\n       :\n       Transitive U (Negation U R))) H')"]}, {"text": "cut (Symmetric U R); auto.", "goal_before": ["R z y -> False"], "goal_after": [], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      ((fun (x y z : U) (H'2 : ~ R x y) (H'3 : ~ R y z) =>\n        (fun H'4 : R x z => or_ind H'2 ?Goal (H0 x z y H'4)) : ~ R x z)\n       :\n       Transitive U (Negation U R))) H')"], "proof_term_after": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      ((fun (x y z : U) (H'2 : ~ R x y) (H'3 : ~ R y z) =>\n        (fun H'4 : R x z =>\n         or_ind H'2\n           (let H1 : Symmetric U R := Apart_imp_Sym U R H' in\n            (fun (H2 : Symmetric U R) (H3 : R z y) => H'3 (H2 z y H3)) H1)\n           (H0 x z y H'4))\n        :\n        ~ R x z)\n       :\n       Transitive U (Negation U R))) H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (U : Set) (R : Relation U) (H' : Apartness U R) =>\n Apartness_ind U R (Equivalence U (Negation U R))\n   (fun (H : Irreflexive U R) (H0 : Separating U R) =>\n    Definition_of_equivalence U (Negation U R) H\n      (Sym_imp_NegSym U R (Apart_imp_Sym U R H'))\n      ((fun (x y z : U) (H'2 : ~ R x y) (H'3 : ~ R y z) =>\n        (fun H'4 : R x z =>\n         or_ind H'2\n           (let H1 : Symmetric U R := Apart_imp_Sym U R H' in\n            (fun (H2 : Symmetric U R) (H3 : R z y) => H'3 (H2 z y H3)) H1)\n           (H0 x z y H'4))\n        :\n        ~ R x z)\n       :\n       Transitive U (Negation U R))) H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "equiv_EqPt", "text": "Theorem equiv_EqPt : Equivalence Point EqPt.\nProof.\nunfold EqPt in |- *; auto.\nQed.\n", "definition": " Equivalence Point EqPt.\n", "proof": "\nunfold EqPt in |- *; auto.\n", "def_ranges": [129, 0, 129, 44], "proof_ranges": [130, 0, 132, 4], "proof_steps": [{"text": "unfold EqPt in |- *; auto.", "goal_before": ["Equivalence Point EqPt"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(Neg_apart_equiv Point DiPt apart_dipt : Equivalence Point EqPt)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(Neg_apart_equiv Point DiPt apart_dipt : Equivalence Point EqPt)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "equiv_EqLn", "text": "Theorem equiv_EqLn : Equivalence Line EqLn.\nProof.\nunfold EqLn in |- *; auto.\nQed.\n", "definition": " Equivalence Line EqLn.\n", "proof": "\nunfold EqLn in |- *; auto.\n", "def_ranges": [135, 0, 135, 43], "proof_ranges": [136, 0, 138, 4], "proof_steps": [{"text": "unfold EqLn in |- *; auto.", "goal_before": ["Equivalence Line EqLn"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(Neg_apart_equiv Line DiLn apart_diln : Equivalence Line EqLn)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(Neg_apart_equiv Line DiLn apart_diln : Equivalence Line EqLn)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "equiv_Par", "text": "Theorem equiv_Par : Equivalence Line Par.\nProof.\nunfold Par in |- *; auto.\nQed.\n", "definition": " Equivalence Line Par.\n", "proof": "\nunfold Par in |- *; auto.\n", "def_ranges": [141, 0, 141, 41], "proof_ranges": [142, 0, 144, 4], "proof_steps": [{"text": "unfold Par in |- *; auto.", "goal_before": ["Equivalence Line Par"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(Neg_apart_equiv Line ConLn apart_con : Equivalence Line Par)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(Neg_apart_equiv Line ConLn apart_con : Equivalence Line Par)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "sym_EqPt", "text": "Theorem sym_EqPt : forall x y : Point, EqPt x y -> EqPt y x.\nProof.\nintros x y H'; cut (Symmetric Point EqPt); auto.\nunfold EqPt at 1 in |- *; auto.\nQed.\n", "definition": " forall x y : Point, EqPt x y -> EqPt y x.\n", "proof": "\nintros x y H'; cut (Symmetric Point EqPt); auto.\nunfold EqPt at 1 in |- *; auto.\n", "def_ranges": [147, 0, 147, 60], "proof_ranges": [148, 0, 151, 4], "proof_steps": [{"text": "intros x y H'; cut (Symmetric Point EqPt); auto.", "goal_before": ["forall x y : Point, EqPt x y -> EqPt y x"], "goal_after": ["Symmetric Point EqPt"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Point) (H' : EqPt x y) =>\n let H : Symmetric Point EqPt := ?Goal in\n (fun H0 : Symmetric Point EqPt => H0 x y H') H)"]}, {"text": "unfold EqPt at 1 in |- *; auto.", "goal_before": ["Symmetric Point EqPt"], "goal_after": [], "proof_term_before": ["(fun (x y : Point) (H' : EqPt x y) =>\n let H : Symmetric Point EqPt := ?Goal in\n (fun H0 : Symmetric Point EqPt => H0 x y H') H)"], "proof_term_after": ["(fun (x y : Point) (H' : EqPt x y) =>\n let H : Symmetric Point EqPt :=\n   Sym_imp_NegSym Point DiPt (Apart_imp_Sym Point DiPt apart_dipt)\n   :\n   Symmetric Point EqPt in\n (fun H0 : Symmetric Point EqPt => H0 x y H') H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : Point) (H' : EqPt x y) =>\n let H : Symmetric Point EqPt :=\n   Sym_imp_NegSym Point DiPt (Apart_imp_Sym Point DiPt apart_dipt)\n   :\n   Symmetric Point EqPt in\n (fun H0 : Symmetric Point EqPt => H0 x y H') H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "sym_EqLn", "text": "Theorem sym_EqLn : forall x y : Line, EqLn x y -> EqLn y x.\nProof.\nintros x y H'; cut (Symmetric Line EqLn); auto.\nunfold EqLn at 1 in |- *; auto.\nQed.\n", "definition": " forall x y : Line, EqLn x y -> EqLn y x.\n", "proof": "\nintros x y H'; cut (Symmetric Line EqLn); auto.\nunfold EqLn at 1 in |- *; auto.\n", "def_ranges": [153, 0, 153, 59], "proof_ranges": [154, 0, 157, 4], "proof_steps": [{"text": "intros x y H'; cut (Symmetric Line EqLn); auto.", "goal_before": ["forall x y : Line, EqLn x y -> EqLn y x"], "goal_after": ["Symmetric Line EqLn"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Line) (H' : EqLn x y) =>\n let H : Symmetric Line EqLn := ?Goal in\n (fun H0 : Symmetric Line EqLn => H0 x y H') H)"]}, {"text": "unfold EqLn at 1 in |- *; auto.", "goal_before": ["Symmetric Line EqLn"], "goal_after": [], "proof_term_before": ["(fun (x y : Line) (H' : EqLn x y) =>\n let H : Symmetric Line EqLn := ?Goal in\n (fun H0 : Symmetric Line EqLn => H0 x y H') H)"], "proof_term_after": ["(fun (x y : Line) (H' : EqLn x y) =>\n let H : Symmetric Line EqLn :=\n   Sym_imp_NegSym Line DiLn (Apart_imp_Sym Line DiLn apart_diln)\n   :\n   Symmetric Line EqLn in\n (fun H0 : Symmetric Line EqLn => H0 x y H') H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : Line) (H' : EqLn x y) =>\n let H : Symmetric Line EqLn :=\n   Sym_imp_NegSym Line DiLn (Apart_imp_Sym Line DiLn apart_diln)\n   :\n   Symmetric Line EqLn in\n (fun H0 : Symmetric Line EqLn => H0 x y H') H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "sym_Par", "text": "Theorem sym_Par : forall x y : Line, Par x y -> Par y x.\nProof.\nintros x y H'; cut (Symmetric Line Par); auto.\nunfold Par at 1 in |- *; auto.\nQed.\n", "definition": " forall x y : Line, Par x y -> Par y x.\n", "proof": "\nintros x y H'; cut (Symmetric Line Par); auto.\nunfold Par at 1 in |- *; auto.\n", "def_ranges": [159, 0, 159, 56], "proof_ranges": [160, 0, 163, 4], "proof_steps": [{"text": "intros x y H'; cut (Symmetric Line Par); auto.", "goal_before": ["forall x y : Line, Par x y -> Par y x"], "goal_after": ["Symmetric Line Par"], "proof_term_before": [], "proof_term_after": ["(fun (x y : Line) (H' : Par x y) =>\n let H : Symmetric Line Par := ?Goal in\n (fun H0 : Symmetric Line Par => H0 x y H') H)"]}, {"text": "unfold Par at 1 in |- *; auto.", "goal_before": ["Symmetric Line Par"], "goal_after": [], "proof_term_before": ["(fun (x y : Line) (H' : Par x y) =>\n let H : Symmetric Line Par := ?Goal in\n (fun H0 : Symmetric Line Par => H0 x y H') H)"], "proof_term_after": ["(fun (x y : Line) (H' : Par x y) =>\n let H : Symmetric Line Par :=\n   Sym_imp_NegSym Line ConLn (Apart_imp_Sym Line ConLn apart_con)\n   :\n   Symmetric Line Par in\n (fun H0 : Symmetric Line Par => H0 x y H') H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : Line) (H' : Par x y) =>\n let H : Symmetric Line Par :=\n   Sym_imp_NegSym Line ConLn (Apart_imp_Sym Line ConLn apart_con)\n   :\n   Symmetric Line Par in\n (fun H0 : Symmetric Line Par => H0 x y H') H)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "inc_ln1", "text": "Theorem inc_ln1 : forall x : Segment, Incident (origin x) (ln x).\nProof.\nintro x; elim x.\nintros a b d; unfold ln in |- *; simpl in |- *.\nelim (line (Seg a b d)); simpl in |- *.\ntauto.\nQed.\n", "definition": " forall x : Segment, Incident (origin x) (ln x).\n", "proof": "\nintro x; elim x.\nintros a b d; unfold ln in |- *; simpl in |- *.\nelim (line (Seg a b d)); simpl in |- *.\ntauto.\n", "def_ranges": [202, 0, 202, 65], "proof_ranges": [203, 0, 208, 4], "proof_steps": [{"text": "intro x; elim x.", "goal_before": ["forall x : Segment, Incident (origin x) (ln x)"], "goal_after": ["forall (origin0 extremity0 : Point) (Seg_cond0 : DiPt origin0 extremity0),\nIncident\n  (origin\n     {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond0 |})\n  (ln {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond0 |})"], "proof_term_before": [], "proof_term_after": ["(fun x : Segment =>\n match x as s return (Incident (origin s) (ln s)) with\n | {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |} =>\n     ?Goal origin extremity Seg_cond\n end)"]}, {"text": "intros a b d; unfold ln in |- *; simpl in |- *.", "goal_before": ["forall (origin0 extremity0 : Point) (Seg_cond0 : DiPt origin0 extremity0),\nIncident\n  (origin\n     {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond0 |})\n  (ln {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond0 |})"], "goal_after": ["Incident a\n  (sig_rec (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n     (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0)\n     (line {| origin := a; extremity := b; Seg_cond := d |}))"], "proof_term_before": ["(fun x : Segment =>\n match x as s return (Incident (origin s) (ln s)) with\n | {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |} =>\n     ?Goal origin extremity Seg_cond\n end)"], "proof_term_after": ["(fun x : Segment =>\n match x as s return (Incident (origin s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (?Goal\n       :\n       Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"]}, {"text": "elim (line (Seg a b d)); simpl in |- *.", "goal_before": ["Incident a\n  (sig_rec (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n     (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0)\n     (line {| origin := a; extremity := b; Seg_cond := d |}))"], "goal_after": ["forall x0 : Line, Incident a x0 /\\ Incident b x0 -> Incident a x0"], "proof_term_before": ["(fun x : Segment =>\n match x as s return (Incident (origin s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (?Goal\n       :\n       Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun x : Segment =>\n match x as s return (Incident (origin s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (sig_ind\n         (fun\n            s : {l : Line\n                | Incident\n                    (origin {| origin := a; extremity := b; Seg_cond := d |})\n                    l /\\\n                  Incident\n                    (extremity\n                       {| origin := a; extremity := b; Seg_cond := d |}) l}\n          =>\n          Incident a\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0) s))\n         (?Goal\n          :\n          forall (x0 : Line)\n            (p : Incident\n                   (origin {| origin := a; extremity := b; Seg_cond := d |})\n                   x0 /\\\n                 Incident\n                   (extremity\n                      {| origin := a; extremity := b; Seg_cond := d |}) x0),\n          Incident a\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x1 : Line) (_ : Incident a x1 /\\ Incident b x1) => x1)\n               (exist\n                  (fun l : Line =>\n                   Incident\n                     (origin {| origin := a; extremity := b; Seg_cond := d |})\n                     l /\\\n                   Incident\n                     (extremity\n                        {| origin := a; extremity := b; Seg_cond := d |}) l)\n                  x0 p)))\n         (line {| origin := a; extremity := b; Seg_cond := d |})\n       :\n       Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"]}, {"text": "tauto.", "goal_before": ["forall x0 : Line, Incident a x0 /\\ Incident b x0 -> Incident a x0"], "goal_after": [], "proof_term_before": ["(fun x : Segment =>\n match x as s return (Incident (origin s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (sig_ind\n         (fun\n            s : {l : Line\n                | Incident\n                    (origin {| origin := a; extremity := b; Seg_cond := d |})\n                    l /\\\n                  Incident\n                    (extremity\n                       {| origin := a; extremity := b; Seg_cond := d |}) l}\n          =>\n          Incident a\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0) s))\n         (?Goal\n          :\n          forall (x0 : Line)\n            (p : Incident\n                   (origin {| origin := a; extremity := b; Seg_cond := d |})\n                   x0 /\\\n                 Incident\n                   (extremity\n                      {| origin := a; extremity := b; Seg_cond := d |}) x0),\n          Incident a\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x1 : Line) (_ : Incident a x1 /\\ Incident b x1) => x1)\n               (exist\n                  (fun l : Line =>\n                   Incident\n                     (origin {| origin := a; extremity := b; Seg_cond := d |})\n                     l /\\\n                   Incident\n                     (extremity\n                        {| origin := a; extremity := b; Seg_cond := d |}) l)\n                  x0 p)))\n         (line {| origin := a; extremity := b; Seg_cond := d |})\n       :\n       Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun x : Segment =>\n match x as s return (Incident (origin s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (sig_ind\n         (fun\n            s : {l : Line\n                | Incident\n                    (origin {| origin := a; extremity := b; Seg_cond := d |})\n                    l /\\\n                  Incident\n                    (extremity\n                       {| origin := a; extremity := b; Seg_cond := d |}) l}\n          =>\n          Incident a\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0) s))\n         ((fun (x0 : Line) (p : Incident a x0 /\\ Incident b x0) =>\n           and_ind (fun (H : Incident a x0) (_ : Incident b x0) => H) p)\n          :\n          forall (x0 : Line)\n            (p : Incident\n                   (origin {| origin := a; extremity := b; Seg_cond := d |})\n                   x0 /\\\n                 Incident\n                   (extremity\n                      {| origin := a; extremity := b; Seg_cond := d |}) x0),\n          Incident a\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x1 : Line) (_ : Incident a x1 /\\ Incident b x1) => x1)\n               (exist\n                  (fun l : Line =>\n                   Incident\n                     (origin {| origin := a; extremity := b; Seg_cond := d |})\n                     l /\\\n                   Incident\n                     (extremity\n                        {| origin := a; extremity := b; Seg_cond := d |}) l)\n                  x0 p)))\n         (line {| origin := a; extremity := b; Seg_cond := d |})\n       :\n       Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Segment =>\n match x as s return (Incident (origin s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (sig_ind\n         (fun\n            s : {l : Line\n                | Incident\n                    (origin {| origin := a; extremity := b; Seg_cond := d |})\n                    l /\\\n                  Incident\n                    (extremity\n                       {| origin := a; extremity := b; Seg_cond := d |}) l}\n          =>\n          Incident a\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0) s))\n         ((fun (x0 : Line) (p : Incident a x0 /\\ Incident b x0) =>\n           and_ind (fun (H : Incident a x0) (_ : Incident b x0) => H) p)\n          :\n          forall (x0 : Line)\n            (p : Incident\n                   (origin {| origin := a; extremity := b; Seg_cond := d |})\n                   x0 /\\\n                 Incident\n                   (extremity\n                      {| origin := a; extremity := b; Seg_cond := d |}) x0),\n          Incident a\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x1 : Line) (_ : Incident a x1 /\\ Incident b x1) => x1)\n               (exist\n                  (fun l : Line =>\n                   Incident\n                     (origin {| origin := a; extremity := b; Seg_cond := d |})\n                     l /\\\n                   Incident\n                     (extremity\n                        {| origin := a; extremity := b; Seg_cond := d |}) l)\n                  x0 p)))\n         (line {| origin := a; extremity := b; Seg_cond := d |})\n       :\n       Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (origin {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "inc_ln2", "text": "Theorem inc_ln2 : forall x : Segment, Incident (extremity x) (ln x).\nProof.\nintro x; elim x.\nintros a b d; unfold ln in |- *; simpl in |- *.\nelim (line (Seg a b d)); simpl in |- *.\ntauto.\nQed.\n", "definition": " forall x : Segment, Incident (extremity x) (ln x).\n", "proof": "\nintro x; elim x.\nintros a b d; unfold ln in |- *; simpl in |- *.\nelim (line (Seg a b d)); simpl in |- *.\ntauto.\n", "def_ranges": [210, 0, 210, 68], "proof_ranges": [211, 0, 216, 4], "proof_steps": [{"text": "intro x; elim x.", "goal_before": ["forall x : Segment, Incident (extremity x) (ln x)"], "goal_after": ["forall (origin0 extremity0 : Point) (Seg_cond0 : DiPt origin0 extremity0),\nIncident\n  (extremity\n     {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond0 |})\n  (ln {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond0 |})"], "proof_term_before": [], "proof_term_after": ["(fun x : Segment =>\n match x as s return (Incident (extremity s) (ln s)) with\n | {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |} =>\n     ?Goal origin extremity Seg_cond\n end)"]}, {"text": "intros a b d; unfold ln in |- *; simpl in |- *.", "goal_before": ["forall (origin0 extremity0 : Point) (Seg_cond0 : DiPt origin0 extremity0),\nIncident\n  (extremity\n     {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond0 |})\n  (ln {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond0 |})"], "goal_after": ["Incident b\n  (sig_rec (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n     (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0)\n     (line {| origin := a; extremity := b; Seg_cond := d |}))"], "proof_term_before": ["(fun x : Segment =>\n match x as s return (Incident (extremity s) (ln s)) with\n | {| origin := origin; extremity := extremity; Seg_cond := Seg_cond |} =>\n     ?Goal origin extremity Seg_cond\n end)"], "proof_term_after": ["(fun x : Segment =>\n match x as s return (Incident (extremity s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (?Goal\n       :\n       Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"]}, {"text": "elim (line (Seg a b d)); simpl in |- *.", "goal_before": ["Incident b\n  (sig_rec (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n     (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0)\n     (line {| origin := a; extremity := b; Seg_cond := d |}))"], "goal_after": ["forall x0 : Line, Incident a x0 /\\ Incident b x0 -> Incident b x0"], "proof_term_before": ["(fun x : Segment =>\n match x as s return (Incident (extremity s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (?Goal\n       :\n       Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun x : Segment =>\n match x as s return (Incident (extremity s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (sig_ind\n         (fun\n            s : {l : Line\n                | Incident\n                    (origin {| origin := a; extremity := b; Seg_cond := d |})\n                    l /\\\n                  Incident\n                    (extremity\n                       {| origin := a; extremity := b; Seg_cond := d |}) l}\n          =>\n          Incident b\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0) s))\n         (?Goal\n          :\n          forall (x0 : Line)\n            (p : Incident\n                   (origin {| origin := a; extremity := b; Seg_cond := d |})\n                   x0 /\\\n                 Incident\n                   (extremity\n                      {| origin := a; extremity := b; Seg_cond := d |}) x0),\n          Incident b\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x1 : Line) (_ : Incident a x1 /\\ Incident b x1) => x1)\n               (exist\n                  (fun l : Line =>\n                   Incident\n                     (origin {| origin := a; extremity := b; Seg_cond := d |})\n                     l /\\\n                   Incident\n                     (extremity\n                        {| origin := a; extremity := b; Seg_cond := d |}) l)\n                  x0 p)))\n         (line {| origin := a; extremity := b; Seg_cond := d |})\n       :\n       Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"]}, {"text": "tauto.", "goal_before": ["forall x0 : Line, Incident a x0 /\\ Incident b x0 -> Incident b x0"], "goal_after": [], "proof_term_before": ["(fun x : Segment =>\n match x as s return (Incident (extremity s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (sig_ind\n         (fun\n            s : {l : Line\n                | Incident\n                    (origin {| origin := a; extremity := b; Seg_cond := d |})\n                    l /\\\n                  Incident\n                    (extremity\n                       {| origin := a; extremity := b; Seg_cond := d |}) l}\n          =>\n          Incident b\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0) s))\n         (?Goal\n          :\n          forall (x0 : Line)\n            (p : Incident\n                   (origin {| origin := a; extremity := b; Seg_cond := d |})\n                   x0 /\\\n                 Incident\n                   (extremity\n                      {| origin := a; extremity := b; Seg_cond := d |}) x0),\n          Incident b\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x1 : Line) (_ : Incident a x1 /\\ Incident b x1) => x1)\n               (exist\n                  (fun l : Line =>\n                   Incident\n                     (origin {| origin := a; extremity := b; Seg_cond := d |})\n                     l /\\\n                   Incident\n                     (extremity\n                        {| origin := a; extremity := b; Seg_cond := d |}) l)\n                  x0 p)))\n         (line {| origin := a; extremity := b; Seg_cond := d |})\n       :\n       Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"], "proof_term_after": ["(fun x : Segment =>\n match x as s return (Incident (extremity s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (sig_ind\n         (fun\n            s : {l : Line\n                | Incident\n                    (origin {| origin := a; extremity := b; Seg_cond := d |})\n                    l /\\\n                  Incident\n                    (extremity\n                       {| origin := a; extremity := b; Seg_cond := d |}) l}\n          =>\n          Incident b\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0) s))\n         ((fun (x0 : Line) (p : Incident a x0 /\\ Incident b x0) =>\n           and_ind (fun (_ : Incident a x0) (H0 : Incident b x0) => H0) p)\n          :\n          forall (x0 : Line)\n            (p : Incident\n                   (origin {| origin := a; extremity := b; Seg_cond := d |})\n                   x0 /\\\n                 Incident\n                   (extremity\n                      {| origin := a; extremity := b; Seg_cond := d |}) x0),\n          Incident b\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x1 : Line) (_ : Incident a x1 /\\ Incident b x1) => x1)\n               (exist\n                  (fun l : Line =>\n                   Incident\n                     (origin {| origin := a; extremity := b; Seg_cond := d |})\n                     l /\\\n                   Incident\n                     (extremity\n                        {| origin := a; extremity := b; Seg_cond := d |}) l)\n                  x0 p)))\n         (line {| origin := a; extremity := b; Seg_cond := d |})\n       :\n       Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Segment =>\n match x as s return (Incident (extremity s) (ln s)) with\n | {| origin := origin0; extremity := extremity0; Seg_cond := Seg_cond |} =>\n     (fun (a b : Point) (d : DiPt a b) =>\n      (sig_ind\n         (fun\n            s : {l : Line\n                | Incident\n                    (origin {| origin := a; extremity := b; Seg_cond := d |})\n                    l /\\\n                  Incident\n                    (extremity\n                       {| origin := a; extremity := b; Seg_cond := d |}) l}\n          =>\n          Incident b\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x0 : Line) (_ : Incident a x0 /\\ Incident b x0) => x0) s))\n         ((fun (x0 : Line) (p : Incident a x0 /\\ Incident b x0) =>\n           and_ind (fun (_ : Incident a x0) (H0 : Incident b x0) => H0) p)\n          :\n          forall (x0 : Line)\n            (p : Incident\n                   (origin {| origin := a; extremity := b; Seg_cond := d |})\n                   x0 /\\\n                 Incident\n                   (extremity\n                      {| origin := a; extremity := b; Seg_cond := d |}) x0),\n          Incident b\n            (sig_rec\n               (fun _ : {l : Line | Incident a l /\\ Incident b l} => Line)\n               (fun (x1 : Line) (_ : Incident a x1 /\\ Incident b x1) => x1)\n               (exist\n                  (fun l : Line =>\n                   Incident\n                     (origin {| origin := a; extremity := b; Seg_cond := d |})\n                     l /\\\n                   Incident\n                     (extremity\n                        {| origin := a; extremity := b; Seg_cond := d |}) l)\n                  x0 p)))\n         (line {| origin := a; extremity := b; Seg_cond := d |})\n       :\n       Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n         (sig_rec\n            (fun\n               _ : {l : Line\n                   | Incident\n                       (origin\n                          {| origin := a; extremity := b; Seg_cond := d |}) l /\\\n                     Incident\n                       (extremity\n                          {| origin := a; extremity := b; Seg_cond := d |}) l}\n             => Line)\n            (fun (x0 : Line)\n               (_ : Incident\n                      (origin\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0 /\\\n                    Incident\n                      (extremity\n                         {| origin := a; extremity := b; Seg_cond := d |}) x0)\n             => x0) (line {| origin := a; extremity := b; Seg_cond := d |})))\n      :\n      Incident (extremity {| origin := a; extremity := b; Seg_cond := d |})\n        (ln {| origin := a; extremity := b; Seg_cond := d |})) origin0\n       extremity0 Seg_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "inc_pt1", "text": "Theorem inc_pt1 : forall x : Twolines, Incident (pt x) (line1 x).\nProof.\nintro x; elim x.\nintros a b d; unfold pt in |- *; simpl in |- *.\nelim (point (Twol a b d)); simpl in |- *.\ntauto.\nQed.\n", "definition": " forall x : Twolines, Incident (pt x) (line1 x).\n", "proof": "\nintro x; elim x.\nintros a b d; unfold pt in |- *; simpl in |- *.\nelim (point (Twol a b d)); simpl in |- *.\ntauto.\n", "def_ranges": [218, 0, 218, 65], "proof_ranges": [219, 0, 224, 4], "proof_steps": [{"text": "intro x; elim x.", "goal_before": ["forall x : Twolines, Incident (pt x) (line1 x)"], "goal_after": ["forall (line3 line4 : Line) (Twol_cond0 : ConLn line3 line4),\nIncident (pt {| line1 := line3; line2 := line4; Twol_cond := Twol_cond0 |})\n  (line1 {| line1 := line3; line2 := line4; Twol_cond := Twol_cond0 |})"], "proof_term_before": [], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line1 t)) with\n | {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |} =>\n     ?Goal line1 line2 Twol_cond\n end)"]}, {"text": "intros a b d; unfold pt in |- *; simpl in |- *.", "goal_before": ["forall (line3 line4 : Line) (Twol_cond0 : ConLn line3 line4),\nIncident (pt {| line1 := line3; line2 := line4; Twol_cond := Twol_cond0 |})\n  (line1 {| line1 := line3; line2 := line4; Twol_cond := Twol_cond0 |})"], "goal_after": ["Incident\n  (sig_rec (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} => Point)\n     (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n     (point {| line1 := a; line2 := b; Twol_cond := d |})) a"], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line1 t)) with\n | {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |} =>\n     ?Goal line1 line2 Twol_cond\n end)"], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line1 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (?Goal\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line1 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line1 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"]}, {"text": "elim (point (Twol a b d)); simpl in |- *.", "goal_before": ["Incident\n  (sig_rec (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} => Point)\n     (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n     (point {| line1 := a; line2 := b; Twol_cond := d |})) a"], "goal_after": ["forall x0 : Point, Incident x0 a /\\ Incident x0 b -> Incident x0 a"], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line1 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (?Goal\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line1 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line1 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line1 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (sig_ind\n         (fun\n            s : {a0 : Point\n                | Incident a0\n                    (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                  Incident a0\n                    (line2 {| line1 := a; line2 := b; Twol_cond := d |})} =>\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n               s) a)\n         (?Goal\n          :\n          forall (x0 : Point)\n            (p : Incident x0\n                   (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                 Incident x0\n                   (line2 {| line1 := a; line2 := b; Twol_cond := d |})),\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x1 : Point) (_ : Incident x1 a /\\ Incident x1 b) => x1)\n               (exist\n                  (fun a0 : Point =>\n                   Incident a0\n                     (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                   Incident a0\n                     (line2 {| line1 := a; line2 := b; Twol_cond := d |})) x0\n                  p)) a) (point {| line1 := a; line2 := b; Twol_cond := d |})\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line1 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line1 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"]}, {"text": "tauto.", "goal_before": ["forall x0 : Point, Incident x0 a /\\ Incident x0 b -> Incident x0 a"], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line1 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (sig_ind\n         (fun\n            s : {a0 : Point\n                | Incident a0\n                    (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                  Incident a0\n                    (line2 {| line1 := a; line2 := b; Twol_cond := d |})} =>\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n               s) a)\n         (?Goal\n          :\n          forall (x0 : Point)\n            (p : Incident x0\n                   (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                 Incident x0\n                   (line2 {| line1 := a; line2 := b; Twol_cond := d |})),\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x1 : Point) (_ : Incident x1 a /\\ Incident x1 b) => x1)\n               (exist\n                  (fun a0 : Point =>\n                   Incident a0\n                     (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                   Incident a0\n                     (line2 {| line1 := a; line2 := b; Twol_cond := d |})) x0\n                  p)) a) (point {| line1 := a; line2 := b; Twol_cond := d |})\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line1 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line1 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line1 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (sig_ind\n         (fun\n            s : {a0 : Point\n                | Incident a0\n                    (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                  Incident a0\n                    (line2 {| line1 := a; line2 := b; Twol_cond := d |})} =>\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n               s) a)\n         ((fun (x0 : Point) (p : Incident x0 a /\\ Incident x0 b) =>\n           and_ind (fun (H : Incident x0 a) (_ : Incident x0 b) => H) p)\n          :\n          forall (x0 : Point)\n            (p : Incident x0\n                   (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                 Incident x0\n                   (line2 {| line1 := a; line2 := b; Twol_cond := d |})),\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x1 : Point) (_ : Incident x1 a /\\ Incident x1 b) => x1)\n               (exist\n                  (fun a0 : Point =>\n                   Incident a0\n                     (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                   Incident a0\n                     (line2 {| line1 := a; line2 := b; Twol_cond := d |})) x0\n                  p)) a) (point {| line1 := a; line2 := b; Twol_cond := d |})\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line1 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line1 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line1 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (sig_ind\n         (fun\n            s : {a0 : Point\n                | Incident a0\n                    (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                  Incident a0\n                    (line2 {| line1 := a; line2 := b; Twol_cond := d |})} =>\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n               s) a)\n         ((fun (x0 : Point) (p : Incident x0 a /\\ Incident x0 b) =>\n           and_ind (fun (H : Incident x0 a) (_ : Incident x0 b) => H) p)\n          :\n          forall (x0 : Point)\n            (p : Incident x0\n                   (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                 Incident x0\n                   (line2 {| line1 := a; line2 := b; Twol_cond := d |})),\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x1 : Point) (_ : Incident x1 a /\\ Incident x1 b) => x1)\n               (exist\n                  (fun a0 : Point =>\n                   Incident a0\n                     (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                   Incident a0\n                     (line2 {| line1 := a; line2 := b; Twol_cond := d |})) x0\n                  p)) a) (point {| line1 := a; line2 := b; Twol_cond := d |})\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line1 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line1 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "inc_pt2", "text": "Theorem inc_pt2 : forall x : Twolines, Incident (pt x) (line2 x).\nProof.\nintro x; elim x.\nintros a b d; unfold pt in |- *; simpl in |- *.\nelim (point (Twol a b d)); simpl in |- *.\ntauto.\nQed.\n", "definition": " forall x : Twolines, Incident (pt x) (line2 x).\n", "proof": "\nintro x; elim x.\nintros a b d; unfold pt in |- *; simpl in |- *.\nelim (point (Twol a b d)); simpl in |- *.\ntauto.\n", "def_ranges": [226, 0, 226, 65], "proof_ranges": [227, 0, 232, 4], "proof_steps": [{"text": "intro x; elim x.", "goal_before": ["forall x : Twolines, Incident (pt x) (line2 x)"], "goal_after": ["forall (line3 line4 : Line) (Twol_cond0 : ConLn line3 line4),\nIncident (pt {| line1 := line3; line2 := line4; Twol_cond := Twol_cond0 |})\n  (line2 {| line1 := line3; line2 := line4; Twol_cond := Twol_cond0 |})"], "proof_term_before": [], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line2 t)) with\n | {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |} =>\n     ?Goal line1 line2 Twol_cond\n end)"]}, {"text": "intros a b d; unfold pt in |- *; simpl in |- *.", "goal_before": ["forall (line3 line4 : Line) (Twol_cond0 : ConLn line3 line4),\nIncident (pt {| line1 := line3; line2 := line4; Twol_cond := Twol_cond0 |})\n  (line2 {| line1 := line3; line2 := line4; Twol_cond := Twol_cond0 |})"], "goal_after": ["Incident\n  (sig_rec (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} => Point)\n     (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n     (point {| line1 := a; line2 := b; Twol_cond := d |})) b"], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line2 t)) with\n | {| line1 := line1; line2 := line2; Twol_cond := Twol_cond |} =>\n     ?Goal line1 line2 Twol_cond\n end)"], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line2 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (?Goal\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line2 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"]}, {"text": "elim (point (Twol a b d)); simpl in |- *.", "goal_before": ["Incident\n  (sig_rec (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} => Point)\n     (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n     (point {| line1 := a; line2 := b; Twol_cond := d |})) b"], "goal_after": ["forall x0 : Point, Incident x0 a /\\ Incident x0 b -> Incident x0 b"], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line2 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (?Goal\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line2 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line2 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (sig_ind\n         (fun\n            s : {a0 : Point\n                | Incident a0\n                    (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                  Incident a0\n                    (line2 {| line1 := a; line2 := b; Twol_cond := d |})} =>\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n               s) b)\n         (?Goal\n          :\n          forall (x0 : Point)\n            (p : Incident x0\n                   (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                 Incident x0\n                   (line2 {| line1 := a; line2 := b; Twol_cond := d |})),\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x1 : Point) (_ : Incident x1 a /\\ Incident x1 b) => x1)\n               (exist\n                  (fun a0 : Point =>\n                   Incident a0\n                     (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                   Incident a0\n                     (line2 {| line1 := a; line2 := b; Twol_cond := d |})) x0\n                  p)) b) (point {| line1 := a; line2 := b; Twol_cond := d |})\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line2 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"]}, {"text": "tauto.", "goal_before": ["forall x0 : Point, Incident x0 a /\\ Incident x0 b -> Incident x0 b"], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line2 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (sig_ind\n         (fun\n            s : {a0 : Point\n                | Incident a0\n                    (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                  Incident a0\n                    (line2 {| line1 := a; line2 := b; Twol_cond := d |})} =>\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n               s) b)\n         (?Goal\n          :\n          forall (x0 : Point)\n            (p : Incident x0\n                   (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                 Incident x0\n                   (line2 {| line1 := a; line2 := b; Twol_cond := d |})),\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x1 : Point) (_ : Incident x1 a /\\ Incident x1 b) => x1)\n               (exist\n                  (fun a0 : Point =>\n                   Incident a0\n                     (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                   Incident a0\n                     (line2 {| line1 := a; line2 := b; Twol_cond := d |})) x0\n                  p)) b) (point {| line1 := a; line2 := b; Twol_cond := d |})\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line2 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"], "proof_term_after": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line2 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (sig_ind\n         (fun\n            s : {a0 : Point\n                | Incident a0\n                    (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                  Incident a0\n                    (line2 {| line1 := a; line2 := b; Twol_cond := d |})} =>\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n               s) b)\n         ((fun (x0 : Point) (p : Incident x0 a /\\ Incident x0 b) =>\n           and_ind (fun (_ : Incident x0 a) (H0 : Incident x0 b) => H0) p)\n          :\n          forall (x0 : Point)\n            (p : Incident x0\n                   (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                 Incident x0\n                   (line2 {| line1 := a; line2 := b; Twol_cond := d |})),\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x1 : Point) (_ : Incident x1 a /\\ Incident x1 b) => x1)\n               (exist\n                  (fun a0 : Point =>\n                   Incident a0\n                     (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                   Incident a0\n                     (line2 {| line1 := a; line2 := b; Twol_cond := d |})) x0\n                  p)) b) (point {| line1 := a; line2 := b; Twol_cond := d |})\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line2 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : Twolines =>\n match x as t return (Incident (pt t) (line2 t)) with\n | {| line1 := line3; line2 := line4; Twol_cond := Twol_cond |} =>\n     (fun (a b : Line) (d : ConLn a b) =>\n      (sig_ind\n         (fun\n            s : {a0 : Point\n                | Incident a0\n                    (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                  Incident a0\n                    (line2 {| line1 := a; line2 := b; Twol_cond := d |})} =>\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x0 : Point) (_ : Incident x0 a /\\ Incident x0 b) => x0)\n               s) b)\n         ((fun (x0 : Point) (p : Incident x0 a /\\ Incident x0 b) =>\n           and_ind (fun (_ : Incident x0 a) (H0 : Incident x0 b) => H0) p)\n          :\n          forall (x0 : Point)\n            (p : Incident x0\n                   (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                 Incident x0\n                   (line2 {| line1 := a; line2 := b; Twol_cond := d |})),\n          Incident\n            (sig_rec\n               (fun _ : {a0 : Point | Incident a0 a /\\ Incident a0 b} =>\n                Point)\n               (fun (x1 : Point) (_ : Incident x1 a /\\ Incident x1 b) => x1)\n               (exist\n                  (fun a0 : Point =>\n                   Incident a0\n                     (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                   Incident a0\n                     (line2 {| line1 := a; line2 := b; Twol_cond := d |})) x0\n                  p)) b) (point {| line1 := a; line2 := b; Twol_cond := d |})\n       :\n       Incident\n         (sig_rec\n            (fun\n               _ : {a0 : Point\n                   | Incident a0\n                       (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                     Incident a0\n                       (line2 {| line1 := a; line2 := b; Twol_cond := d |})}\n             => Point)\n            (fun (x0 : Point)\n               (_ : Incident x0\n                      (line1 {| line1 := a; line2 := b; Twol_cond := d |}) /\\\n                    Incident x0\n                      (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n             => x0) (point {| line1 := a; line2 := b; Twol_cond := d |}))\n         (line2 {| line1 := a; line2 := b; Twol_cond := d |}))\n      :\n      Incident (pt {| line1 := a; line2 := b; Twol_cond := d |})\n        (line2 {| line1 := a; line2 := b; Twol_cond := d |})) line3 line4\n       Twol_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/constructive-geometry/basis.v", "name": "Triangle_def", "text": "Theorem Triangle_def : forall t : Triangle, Apart (summit t) (ln (base t)).\nProof.\nintro t; elim t.\nsimpl in |- *.\nintros s b H'; exact H'.\nQed.\n", "definition": " forall t : Triangle, Apart (summit t) (ln (base t)).\n", "proof": "\nintro t; elim t.\nsimpl in |- *.\nintros s b H'; exact H'.\n", "def_ranges": [259, 0, 259, 75], "proof_ranges": [260, 0, 264, 4], "proof_steps": [{"text": "intro t; elim t.", "goal_before": ["forall t : Triangle, Apart (summit t) (ln (base t))"], "goal_after": ["forall (summit0 : Point) (base0 : Segment)\n  (Tri_cond0 : Apart summit0 (ln base0)),\nApart (summit {| summit := summit0; base := base0; Tri_cond := Tri_cond0 |})\n  (ln (base {| summit := summit0; base := base0; Tri_cond := Tri_cond0 |}))"], "proof_term_before": [], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (base t0))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     ?Goal summit base Tri_cond\n end)"]}, {"text": "simpl in |- *.", "goal_before": ["forall (summit0 : Point) (base0 : Segment)\n  (Tri_cond0 : Apart summit0 (ln base0)),\nApart (summit {| summit := summit0; base := base0; Tri_cond := Tri_cond0 |})\n  (ln (base {| summit := summit0; base := base0; Tri_cond := Tri_cond0 |}))"], "goal_after": ["forall (summit0 : Point) (base0 : Segment),\nApart summit0 (ln base0) -> Apart summit0 (ln base0)"], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (base t0))) with\n | {| summit := summit; base := base; Tri_cond := Tri_cond |} =>\n     ?Goal summit base Tri_cond\n end)"], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (base t0))) with\n | {| summit := summit0; base := base0; Tri_cond := Tri_cond |} =>\n     (?Goal\n      :\n      forall (summit1 : Point) (base1 : Segment)\n        (Tri_cond0 : Apart summit1 (ln base1)),\n      Apart\n        (summit {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})\n        (ln\n           (base\n              {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})))\n       summit0 base0 Tri_cond\n end)"]}, {"text": "intros s b H'; exact H'.", "goal_before": ["forall (summit0 : Point) (base0 : Segment),\nApart summit0 (ln base0) -> Apart summit0 (ln base0)"], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (base t0))) with\n | {| summit := summit0; base := base0; Tri_cond := Tri_cond |} =>\n     (?Goal\n      :\n      forall (summit1 : Point) (base1 : Segment)\n        (Tri_cond0 : Apart summit1 (ln base1)),\n      Apart\n        (summit {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})\n        (ln\n           (base\n              {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})))\n       summit0 base0 Tri_cond\n end)"], "proof_term_after": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (base t0))) with\n | {| summit := summit0; base := base0; Tri_cond := Tri_cond |} =>\n     ((fun (s : Point) (b : Segment) (H' : Apart s (ln b)) => H')\n      :\n      forall (summit1 : Point) (base1 : Segment)\n        (Tri_cond0 : Apart summit1 (ln base1)),\n      Apart\n        (summit {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})\n        (ln\n           (base\n              {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})))\n       summit0 base0 Tri_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun t : Triangle =>\n match t as t0 return (Apart (summit t0) (ln (base t0))) with\n | {| summit := summit0; base := base0; Tri_cond := Tri_cond |} =>\n     ((fun (s : Point) (b : Segment) (H' : Apart s (ln b)) => H')\n      :\n      forall (summit1 : Point) (base1 : Segment)\n        (Tri_cond0 : Apart summit1 (ln base1)),\n      Apart\n        (summit {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})\n        (ln\n           (base\n              {| summit := summit1; base := base1; Tri_cond := Tri_cond0 |})))\n       summit0 base0 Tri_cond\n end)"], "proof_term_after": []}], "ends_qed": true}]