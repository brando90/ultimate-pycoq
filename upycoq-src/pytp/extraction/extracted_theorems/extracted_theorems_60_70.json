[{"path": "/home/jizej/proverbot9001/coq-projects/subst/Newman.v", "name": "Newman", "text": "Theorem Newman : explicit_confluence _ R.\n   unfold explicit_confluence in |- *; intro x; pattern x in |- *;\n    apply (noetherian_induction1 A R N).\n   intros y H1; unfold confluence_en in |- *.\n   intros y0 z H2 H3; elim (star_case A R y z H3); intro H4.\n   exists y0; split.\n   apply star_refl.\n   rewrite <- H4; assumption.\n   elim (star_case A R y y0 H2); intro H5.\n   exists z; split.\n   rewrite <- H5; assumption.\n   apply star_refl.\n   elim H5; intros y0' H6; elim H6; intros H7 H8.\n   elim H4; intros z' H9; elim H9; intros H10 H11.\n   elim (C y y0' z' H7 H10); intros y' H12.\n   elim H12; intros H13 H14.\n   elim (H1 y0' H7 y0 y' H8 H13); intros y'' H15.\n   elim H15; intros H16 H17.\n   elim (H1 z' H10 y'' z (star_trans A R z' y' y'' H14 H17) H11).\n   intros u H18; elim H18; intros H19 H20.\n   exists u; split.\n   apply star_trans with y''; assumption.\n   assumption.\n   Qed.\n", "definition": " explicit_confluence _ R.", "proof": "\n   unfold explicit_confluence in |- *; intro x; pattern x in |- *;\n    apply (noetherian_induction1 A R N).\n   intros y H1; unfold confluence_en in |- *.\n   intros y0 z H2 H3; elim (star_case A R y z H3); intro H4.\n   exists y0; split.\n   apply star_refl.\n   rewrite <- H4; assumption.\n   elim (star_case A R y y0 H2); intro H5.\n   exists z; split.\n   rewrite <- H5; assumption.\n   apply star_refl.\n   elim H5; intros y0' H6; elim H6; intros H7 H8.\n   elim H4; intros z' H9; elim H9; intros H10 H11.\n   elim (C y y0' z' H7 H10); intros y' H12.\n   elim H12; intros H13 H14.\n   elim (H1 y0' H7 y0 y' H8 H13); intros y'' H15.\n   elim H15; intros H16 H17.\n   elim (H1 z' H10 y'' z (star_trans A R z' y' y'' H14 H17) H11).\n   intros u H18; elim H18; intros H19 H20.\n   exists u; split.\n   apply star_trans with y''; assumption.\n   assumption.\n   ", "def_ranges": [39, 0, 39, 44], "proof_ranges": [40, 0, 62, 7], "proof_steps": [{"text": "unfold explicit_confluence in |- *; intro x; pattern x in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (noetherian_induction1 A R N).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H1; unfold confluence_en in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y0 z H2 H3; elim (star_case A R y z H3); intro H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists y0; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply star_refl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H4; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (star_case A R y y0 H2); intro H5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists z; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H5; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply star_refl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H5; intros y0' H6; elim H6; intros H7 H8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H4; intros z' H9; elim H9; intros H10 H11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (C y y0' z' H7 H10); intros y' H12.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H12; intros H13 H14.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 y0' H7 y0 y' H8 H13); intros y'' H15.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H15; intros H16 H17.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 z' H10 y'' z (star_trans A R z' y' y'' H14 H17) H11).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros u H18; elim H18; intros H19 H20.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists u; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply star_trans with y''; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/confluence_LSL.v", "name": "confluence_LSL", "text": "Theorem confluence_LSL : forall b : wsort, explicit_confluence _ (e_relLSL b).\nProof.\nintro b; apply inclus_conf with (e_slstar_bp_slstar b).\napply relLSL_inclus_slbpsl.\nchange (explicit_inclus _ (e_slstar_bp_slstar b) (e_relLSLstar b)) in |- *.\napply slbpsl_inclus_relLSLstar.\napply confluence_slbpsl.\nQed.\n", "definition": " forall b : wsort, explicit_confluence _ (e_relLSL b).\n", "proof": "\nintro b; apply inclus_conf with (e_slstar_bp_slstar b).\napply relLSL_inclus_slbpsl.\nchange (explicit_inclus _ (e_slstar_bp_slstar b) (e_relLSLstar b)) in |- *.\napply slbpsl_inclus_relLSLstar.\napply confluence_slbpsl.\n", "def_ranges": [78, 0, 78, 78], "proof_ranges": [79, 0, 85, 4], "proof_steps": [{"text": "intro b; apply inclus_conf with (e_slstar_bp_slstar b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply relLSL_inclus_slbpsl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (explicit_inclus _ (e_slstar_bp_slstar b) (e_relLSLstar b)) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply slbpsl_inclus_relLSLstar.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply confluence_slbpsl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_systemSL", "text": "Theorem lexfg_systemSL :\n forall (b : wsort) (M N : TS b),\n e_systemSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N.\nProof.\nred in |- *; simple induction 1; auto with arith.\nQed.\n", "definition": "\n forall (b : wsort) (M N : TS b),\n e_systemSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N.\n", "proof": "\nred in |- *; simple induction 1; auto with arith.\n", "def_ranges": [110, 0, 112, 53], "proof_ranges": [113, 0, 115, 4], "proof_steps": [{"text": "red in |- *; simple induction 1; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_app_l", "text": "Theorem lexfg_app_l :\n forall a a' b : terms,\n e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (app a b) (app a' b).\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall a a' b : terms,\n e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (app a b) (app a' b).\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [118, 0, 121, 52], "proof_ranges": [122, 0, 125, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_app_r", "text": "Theorem lexfg_app_r :\n forall a b b' : terms,\n e_lexfg _ (e_P1 wt) (e_P2 wt) b b' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (app a b) (app a b').\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall a b b' : terms,\n e_lexfg _ (e_P1 wt) (e_P2 wt) b b' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (app a b) (app a b').\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [128, 0, 131, 52], "proof_ranges": [132, 0, 135, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_lambda", "text": "Theorem lexfg_lambda :\n forall a a' : terms,\n e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (lambda a) (lambda a').\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall a a' : terms,\n e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (lambda a) (lambda a').\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [138, 0, 141, 54], "proof_ranges": [142, 0, 145, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_env_t", "text": "Theorem lexfg_env_t :\n forall (a a' : terms) (s : sub_explicits),\n e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a' s).\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall (a a' : terms) (s : sub_explicits),\n e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a' s).\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [148, 0, 151, 52], "proof_ranges": [152, 0, 155, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_env_s", "text": "Theorem lexfg_env_s :\n forall (a : terms) (s s' : sub_explicits),\n e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a s').\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall (a : terms) (s s' : sub_explicits),\n e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->\n e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a s').\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [158, 0, 161, 52], "proof_ranges": [162, 0, 165, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_cons_t", "text": "Theorem lexfg_cons_t :\n forall (a a' : terms) (s : sub_explicits),\n e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a' s).\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall (a a' : terms) (s : sub_explicits),\n e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a' s).\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [168, 0, 171, 54], "proof_ranges": [172, 0, 175, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_cons_s", "text": "Theorem lexfg_cons_s :\n forall (a : terms) (s s' : sub_explicits),\n e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a s').\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall (a : terms) (s s' : sub_explicits),\n e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a s').\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [178, 0, 181, 54], "proof_ranges": [182, 0, 185, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_comp_l", "text": "Theorem lexfg_comp_l :\n forall s s' t : sub_explicits,\n e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s' t).\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall s s' t : sub_explicits,\n e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s' t).\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [188, 0, 191, 54], "proof_ranges": [192, 0, 195, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_comp_r", "text": "Theorem lexfg_comp_r :\n forall s t t' : sub_explicits,\n e_lexfg _ (e_P1 ws) (e_P2 ws) t t' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s t').\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\nQed.\n", "definition": "\n forall s t t' : sub_explicits,\n e_lexfg _ (e_P1 ws) (e_P2 ws) t t' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s t').\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.\nintros; elim H0; auto with arith.\n", "def_ranges": [198, 0, 201, 54], "proof_ranges": [202, 0, 205, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_lift", "text": "Theorem lexfg_lift :\n forall s s' : sub_explicits,\n e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (lift s) (lift s').\nProof.\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; intros.\nauto with arith.\nelim H0; intros; right; split.\nassumption.\nchange (4 * e_P2 _ s > 4 * e_P2 _ s') in |- *.\nauto with arith.\nQed.\n", "definition": "\n forall s s' : sub_explicits,\n e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->\n e_lexfg _ (e_P1 ws) (e_P2 ws) (lift s) (lift s').\n", "proof": "\nunfold e_lexfg in |- *; simple induction 1; simpl in |- *; intros.\nauto with arith.\nelim H0; intros; right; split.\nassumption.\nchange (4 * e_P2 _ s > 4 * e_P2 _ s') in |- *.\nauto with arith.\n", "def_ranges": [208, 0, 211, 50], "proof_ranges": [212, 0, 219, 4], "proof_steps": [{"text": "unfold e_lexfg in |- *; simple induction 1; simpl in |- *; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H0; intros; right; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (4 * e_P2 _ s > 4 * e_P2 _ s') in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "lexfg_relSL", "text": "Theorem lexfg_relSL :\n forall (b : wsort) (M N : TS b),\n e_relSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N.\nProof.\nsimple induction 1; auto with arith.\nQed.\n", "definition": "\n forall (b : wsort) (M N : TS b),\n e_relSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N.\n", "proof": "\nsimple induction 1; auto with arith.\n", "def_ranges": [222, 0, 224, 50], "proof_ranges": [225, 0, 227, 4], "proof_steps": [{"text": "simple induction 1; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/terminaison_SL.v", "name": "relSL_noetherian", "text": "Theorem relSL_noetherian :\n forall b : wsort, explicit_noetherian _ (e_relSL b).\nProof.\nintro b; apply noether_inclus with (e_lexfg _ (e_P1 b) (e_P2 b)).\napply lexfg_notherian.\nexact (lexfg_relSL b).\nQed.\n", "definition": "\n forall b : wsort, explicit_noetherian _ (e_relSL b).\n", "proof": "\nintro b; apply noether_inclus with (e_lexfg _ (e_P1 b) (e_P2 b)).\napply lexfg_notherian.\nexact (lexfg_relSL b).\n", "def_ranges": [234, 0, 235, 53], "proof_ranges": [236, 0, 240, 4], "proof_steps": [{"text": "intro b; apply noether_inclus with (e_lexfg _ (e_P1 b) (e_P2 b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply lexfg_notherian.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact (lexfg_relSL b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/conf_strong_betapar.v", "name": "sconf_betapar", "text": "Theorem sconf_betapar :\n forall b : wsort, explicit_strong_confluence _ (e_beta_par b).\nred in |- *; red in |- *; intros b x y z H; generalize z; elim H.\n(* regle var *)\nintros n z0 H1; pattern z0 in |- *; apply case_bvar with n.\n2: assumption.\nexists (var n); auto.\n(* regle id  *)\nintros z0 H1; pattern z0 in |- *; apply case_bid.\n2: assumption.\nexists id; auto.\n(*  regle |  *)\nintros z0 H1; pattern z0 in |- *; apply case_bshift.\n2: assumption.\nexists shift; auto.\n(* regle app *)\nintros M N M' N' H0 H1 H2 H3 z0 H4.\ngeneralize H0 H1; pattern z0 in |- *; apply case_bapp with M N.\n3: assumption.\n(* 1-regle app *)\nintros M'' N'' H5 H6 H7 H8.\nelim (H3 N'' H6); intros N_ H9; elim H9; intros H10 H11.\nelim (H1 M'' H5); intros M_ H12; elim H12; intros H13 H14.\nexists (app M_ N_); auto.\n(* 2-regle beta *)\nintros M1 M1'' N'' H5 H6 H7; rewrite H5; intros H8.\npattern M' in |- *; apply case_blambda with M1.\n2: assumption.\nintros M1' H9 H10.\nelim (sconf_lambda_bpar M1 M1' H10 M1'' H6); intros M1_ H11.\nelim H11; intros H12 H13.\nelim (H3 N'' H7); intros N_ H14; elim H14; intros H15 H16.\nexists (env M1_ (cons N_ id)); auto.\n(* regle lam *)\nintros M M' H0 H1 z0 H2; pattern z0 in |- *; apply case_blambda with M.\n2: assumption.\nintros M'' H3; elim (H1 M'' H3); intros M_ H4; elim H4; intros H5 H6.\nexists (lambda M_); auto.\n(* regle env *)\nintros M M' s s' H0 H1 H2 H3 z0 H4.\npattern z0 in |- *; apply case_benv with M s.\n2: assumption.\nintros M'' s'' H5 H6.\nelim (H1 M'' H5); intros M_ H7; elim H7; intros H8 H9.\nelim (H3 s'' H6); intros s_ H10; elim H10; intros H11 H12.\nexists (env M_ s_); auto.\n(* regle beta *)\nintros M N M' N' H0 H1 H2 H3 z0 H4.\npattern z0 in |- *; apply case_bapp with (lambda M) N.\n3: assumption.\n(* 1-regle app *)\nintros M1'' N'' H5 H6.\npattern M1'' in |- *; apply case_blambda with M.\n2: assumption.\nintros M'' H7.\nelim (H1 M'' H7); intros M_ H8; elim H8; intros H9 H10.\nelim (H3 N'' H6); intros N_ H11; elim H11; intros H12 H13.\nexists (env M_ (cons N_ id)); auto.\n(* 2-regle beta *)\nintros M1 M1'' N'' H5 H6 H7; generalize H6; elim (proj_lambda M M1 H5);\n intro H8.\nelim (H1 M1'' H8); intros M_ H9; elim H9; intros H10 H11.\nelim (H3 N'' H7); intros N_ H12; elim H12; intros H13 H14.\nexists (env M_ (cons N_ id)); auto.\n(* regle . *)\nintros M M' s s' H0 H1 H2 H3 z0 H4.\npattern z0 in |- *; apply case_bcons with M s.\n2: assumption.\nintros M'' s'' H5 H6.\nelim (H1 M'' H5); intros M_ H7; elim H7; intros H8 H9.\nelim (H3 s'' H6); intros s_ H10; elim H10; intros H11 H12.\nexists (cons M_ s_); auto.\n(* regle || *)\nintros s s' H0 H1 z0 H2.\npattern z0 in |- *; apply case_blift with s.\n2: assumption.\nintros s'' H3.\nelim (H1 s'' H3); intros s_ H4; elim H4; intros H5 H6.\nexists (lift s_); auto.\n(* regle comp *)\nintros s s' t t' H0 H1 H2 H3 z0 H4.\npattern z0 in |- *; apply case_bcomp with s t.\n2: assumption.\nintros s'' t'' H5 H6.\nelim (H1 s'' H5); intros s_ H7; elim H7; intros H8 H9.\nelim (H3 t'' H6); intros t_ H10; elim H10; intros H11 H12.\nexists (comp s_ t_); auto.\n(* regle X *)\nintros n z0 H1; pattern z0 in |- *; apply case_bmetaX with n.\n2: assumption.\nexists (meta_X n); auto.\n(* regle x *)\nintros n z0 H1; pattern z0 in |- *; apply case_bmetax with n.\n2: assumption.\nexists (meta_x n); auto.\nQed.\n", "definition": "\n forall b : wsort, explicit_strong_confluence _ (e_beta_par b).", "proof": "\nred in |- *; red in |- *; intros b x y z H; generalize z; elim H.\n(* regle var *)\nintros n z0 H1; pattern z0 in |- *; apply case_bvar with n.\n2: assumption.\nexists (var n); auto.\n(* regle id  *)\nintros z0 H1; pattern z0 in |- *; apply case_bid.\n2: assumption.\nexists id; auto.\n(*  regle |  *)\nintros z0 H1; pattern z0 in |- *; apply case_bshift.\n2: assumption.\nexists shift; auto.\n(* regle app *)\nintros M N M' N' H0 H1 H2 H3 z0 H4.\ngeneralize H0 H1; pattern z0 in |- *; apply case_bapp with M N.\n3: assumption.\n(* 1-regle app *)\nintros M'' N'' H5 H6 H7 H8.\nelim (H3 N'' H6); intros N_ H9; elim H9; intros H10 H11.\nelim (H1 M'' H5); intros M_ H12; elim H12; intros H13 H14.\nexists (app M_ N_); auto.\n(* 2-regle beta *)\nintros M1 M1'' N'' H5 H6 H7; rewrite H5; intros H8.\npattern M' in |- *; apply case_blambda with M1.\n2: assumption.\nintros M1' H9 H10.\nelim (sconf_lambda_bpar M1 M1' H10 M1'' H6); intros M1_ H11.\nelim H11; intros H12 H13.\nelim (H3 N'' H7); intros N_ H14; elim H14; intros H15 H16.\nexists (env M1_ (cons N_ id)); auto.\n(* regle lam *)\nintros M M' H0 H1 z0 H2; pattern z0 in |- *; apply case_blambda with M.\n2: assumption.\nintros M'' H3; elim (H1 M'' H3); intros M_ H4; elim H4; intros H5 H6.\nexists (lambda M_); auto.\n(* regle env *)\nintros M M' s s' H0 H1 H2 H3 z0 H4.\npattern z0 in |- *; apply case_benv with M s.\n2: assumption.\nintros M'' s'' H5 H6.\nelim (H1 M'' H5); intros M_ H7; elim H7; intros H8 H9.\nelim (H3 s'' H6); intros s_ H10; elim H10; intros H11 H12.\nexists (env M_ s_); auto.\n(* regle beta *)\nintros M N M' N' H0 H1 H2 H3 z0 H4.\npattern z0 in |- *; apply case_bapp with (lambda M) N.\n3: assumption.\n(* 1-regle app *)\nintros M1'' N'' H5 H6.\npattern M1'' in |- *; apply case_blambda with M.\n2: assumption.\nintros M'' H7.\nelim (H1 M'' H7); intros M_ H8; elim H8; intros H9 H10.\nelim (H3 N'' H6); intros N_ H11; elim H11; intros H12 H13.\nexists (env M_ (cons N_ id)); auto.\n(* 2-regle beta *)\nintros M1 M1'' N'' H5 H6 H7; generalize H6; elim (proj_lambda M M1 H5);\n intro H8.\nelim (H1 M1'' H8); intros M_ H9; elim H9; intros H10 H11.\nelim (H3 N'' H7); intros N_ H12; elim H12; intros H13 H14.\nexists (env M_ (cons N_ id)); auto.\n(* regle . *)\nintros M M' s s' H0 H1 H2 H3 z0 H4.\npattern z0 in |- *; apply case_bcons with M s.\n2: assumption.\nintros M'' s'' H5 H6.\nelim (H1 M'' H5); intros M_ H7; elim H7; intros H8 H9.\nelim (H3 s'' H6); intros s_ H10; elim H10; intros H11 H12.\nexists (cons M_ s_); auto.\n(* regle || *)\nintros s s' H0 H1 z0 H2.\npattern z0 in |- *; apply case_blift with s.\n2: assumption.\nintros s'' H3.\nelim (H1 s'' H3); intros s_ H4; elim H4; intros H5 H6.\nexists (lift s_); auto.\n(* regle comp *)\nintros s s' t t' H0 H1 H2 H3 z0 H4.\npattern z0 in |- *; apply case_bcomp with s t.\n2: assumption.\nintros s'' t'' H5 H6.\nelim (H1 s'' H5); intros s_ H7; elim H7; intros H8 H9.\nelim (H3 t'' H6); intros t_ H10; elim H10; intros H11 H12.\nexists (comp s_ t_); auto.\n(* regle X *)\nintros n z0 H1; pattern z0 in |- *; apply case_bmetaX with n.\n2: assumption.\nexists (meta_X n); auto.\n(* regle x *)\nintros n z0 H1; pattern z0 in |- *; apply case_bmetax with n.\n2: assumption.\nexists (meta_x n); auto.\n", "def_ranges": [63, 0, 64, 63], "proof_ranges": [65, 0, 158, 4], "proof_steps": [{"text": "red in |- *; red in |- *; intros b x y z H; generalize z; elim H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n z0 H1; pattern z0 in |- *; apply case_bvar with n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (var n); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros z0 H1; pattern z0 in |- *; apply case_bid.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists id; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros z0 H1; pattern z0 in |- *; apply case_bshift.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists shift; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M N M' N' H0 H1 H2 H3 z0 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H0 H1; pattern z0 in |- *; apply case_bapp with M N.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "3: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M'' N'' H5 H6 H7 H8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H3 N'' H6); intros N_ H9; elim H9; intros H10 H11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 M'' H5); intros M_ H12; elim H12; intros H13 H14.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (app M_ N_); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M1 M1'' N'' H5 H6 H7; rewrite H5; intros H8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern M' in |- *; apply case_blambda with M1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M1' H9 H10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (sconf_lambda_bpar M1 M1' H10 M1'' H6); intros M1_ H11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H11; intros H12 H13.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H3 N'' H7); intros N_ H14; elim H14; intros H15 H16.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (env M1_ (cons N_ id)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M M' H0 H1 z0 H2; pattern z0 in |- *; apply case_blambda with M.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M'' H3; elim (H1 M'' H3); intros M_ H4; elim H4; intros H5 H6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (lambda M_); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M M' s s' H0 H1 H2 H3 z0 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern z0 in |- *; apply case_benv with M s.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M'' s'' H5 H6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 M'' H5); intros M_ H7; elim H7; intros H8 H9.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H3 s'' H6); intros s_ H10; elim H10; intros H11 H12.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (env M_ s_); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M N M' N' H0 H1 H2 H3 z0 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern z0 in |- *; apply case_bapp with (lambda M) N.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "3: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M1'' N'' H5 H6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern M1'' in |- *; apply case_blambda with M.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M'' H7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 M'' H7); intros M_ H8; elim H8; intros H9 H10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H3 N'' H6); intros N_ H11; elim H11; intros H12 H13.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (env M_ (cons N_ id)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M1 M1'' N'' H5 H6 H7; generalize H6; elim (proj_lambda M M1 H5);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 M1'' H8); intros M_ H9; elim H9; intros H10 H11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H3 N'' H7); intros N_ H12; elim H12; intros H13 H14.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (env M_ (cons N_ id)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M M' s s' H0 H1 H2 H3 z0 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern z0 in |- *; apply case_bcons with M s.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros M'' s'' H5 H6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 M'' H5); intros M_ H7; elim H7; intros H8 H9.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H3 s'' H6); intros s_ H10; elim H10; intros H11 H12.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (cons M_ s_); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros s s' H0 H1 z0 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern z0 in |- *; apply case_blift with s.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros s'' H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 s'' H3); intros s_ H4; elim H4; intros H5 H6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (lift s_); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros s s' t t' H0 H1 H2 H3 z0 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern z0 in |- *; apply case_bcomp with s t.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros s'' t'' H5 H6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H1 s'' H5); intros s_ H7; elim H7; intros H8 H9.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H3 t'' H6); intros t_ H10; elim H10; intros H11 H12.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (comp s_ t_); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n z0 H1; pattern z0 in |- *; apply case_bmetaX with n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (meta_X n); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros n z0 H1; pattern z0 in |- *; apply case_bmetax with n.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (meta_x n); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "gt_P1_1", "text": "Theorem gt_P1_1 : forall (b : wsort) (M : TS b), e_P1 _ M > 1.\nProof.\nsimple induction M; intros; simpl in |- *; auto with arith.\n(* var *)\nelim plus_n_O; elim n; simpl in |- *.\nauto with arith.\nintros; elim plus_n_O; auto with arith.\nQed.\n", "definition": " forall (b : wsort) (M : TS b), e_P1 _ M > 1.\n", "proof": "\nsimple induction M; intros; simpl in |- *; auto with arith.\n(* var *)\nelim plus_n_O; elim n; simpl in |- *.\nauto with arith.\nintros; elim plus_n_O; auto with arith.\n", "def_ranges": [73, 0, 73, 62], "proof_ranges": [74, 0, 80, 4], "proof_steps": [{"text": "simple induction M; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_O; elim n; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim plus_n_O; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_app", "text": "Theorem P1_app : forall M N : terms, reg_app M N -> e_P1 _ M = e_P1 _ N.\nProof. \nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": " forall M N : terms, reg_app M N -> e_P1 _ M = e_P1 _ N.\n", "proof": " \nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [83, 0, 83, 72], "proof_ranges": [84, 0, 86, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_lambda", "text": "Theorem P1_lambda : forall M N : terms, reg_lambda M N -> e_P1 _ M > e_P1 _ N.\nProof. \nsimple induction 1; intros; simpl in |- *; rewrite Mult.mult_plus_distr_r;\n auto with arith.\nQed.\n", "definition": " forall M N : terms, reg_lambda M N -> e_P1 _ M > e_P1 _ N.\n", "proof": " \nsimple induction 1; intros; simpl in |- *; rewrite Mult.mult_plus_distr_r;\n auto with arith.\n", "def_ranges": [89, 0, 89, 78], "proof_ranges": [90, 0, 93, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; rewrite Mult.mult_plus_distr_r;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_clos", "text": "Theorem P1_clos : forall M N : terms, reg_clos M N -> e_P1 _ M = e_P1 _ N.\nProof. \nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": " forall M N : terms, reg_clos M N -> e_P1 _ M = e_P1 _ N.\n", "proof": " \nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [96, 0, 96, 74], "proof_ranges": [97, 0, 99, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_varshift1", "text": "Theorem P1_varshift1 :\n forall M N : terms, reg_varshift1 M N -> e_P1 _ M = e_P1 _ N.\nProof. \nsimple induction 1; intros.\nchange (power2 (S n) * 2 = 2 * power2 (S n)) in |- *.\nauto with arith.\nQed.\n", "definition": "\n forall M N : terms, reg_varshift1 M N -> e_P1 _ M = e_P1 _ N.\n", "proof": " \nsimple induction 1; intros.\nchange (power2 (S n) * 2 = 2 * power2 (S n)) in |- *.\nauto with arith.\n", "def_ranges": [102, 0, 103, 62], "proof_ranges": [104, 0, 108, 4], "proof_steps": [{"text": "simple induction 1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (power2 (S n) * 2 = 2 * power2 (S n)) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_varshift2", "text": "Theorem P1_varshift2 :\n forall M N : terms, reg_varshift2 M N -> e_P1 _ M = e_P1 _ N.\nProof. \nsimple induction 1; intros.\nchange (power2 (S n) * (2 * e_P1 _ s) = 2 * power2 (S n) * e_P1 _ s) in |- *.\nelim mult_permut; auto with arith.\nQed.\n", "definition": "\n forall M N : terms, reg_varshift2 M N -> e_P1 _ M = e_P1 _ N.\n", "proof": " \nsimple induction 1; intros.\nchange (power2 (S n) * (2 * e_P1 _ s) = 2 * power2 (S n) * e_P1 _ s) in |- *.\nelim mult_permut; auto with arith.\n", "def_ranges": [111, 0, 112, 62], "proof_ranges": [113, 0, 117, 4], "proof_steps": [{"text": "simple induction 1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (power2 (S n) * (2 * e_P1 _ s) = 2 * power2 (S n) * e_P1 _ s) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim mult_permut; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_fvarcons", "text": "Theorem P1_fvarcons :\n forall M N : terms, reg_fvarcons M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.\nQed.\n", "definition": "\n forall M N : terms, reg_fvarcons M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.\n", "def_ranges": [120, 0, 121, 61], "proof_ranges": [122, 0, 124, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_fvarlift1", "text": "Theorem P1_fvarlift1 :\n forall M N : terms, reg_fvarlift1 M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros.\nchange (2 * e_P1 _ s > 2) in |- *.\nauto with arith.\nQed.\n", "definition": "\n forall M N : terms, reg_fvarlift1 M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros.\nchange (2 * e_P1 _ s > 2) in |- *.\nauto with arith.\n", "def_ranges": [127, 0, 128, 62], "proof_ranges": [129, 0, 133, 4], "proof_steps": [{"text": "simple induction 1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (2 * e_P1 _ s > 2) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_fvarlift2", "text": "Theorem P1_fvarlift2 :\n forall M N : terms, reg_fvarlift2 M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros.\nchange (2 * (e_P1 _ s * e_P1 _ t) > 2 * e_P1 _ t) in |- *.\nauto with arith.\nQed.\n", "definition": "\n forall M N : terms, reg_fvarlift2 M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros.\nchange (2 * (e_P1 _ s * e_P1 _ t) > 2 * e_P1 _ t) in |- *.\nauto with arith.\n", "def_ranges": [136, 0, 137, 62], "proof_ranges": [138, 0, 142, 4], "proof_steps": [{"text": "simple induction 1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (2 * (e_P1 _ s * e_P1 _ t) > 2 * e_P1 _ t) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_rvarcons", "text": "Theorem P1_rvarcons :\n forall M N : terms, reg_rvarcons M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros.\nchange (2 * power2 (S n) * (e_P1 _ a + e_P1 _ s) > power2 (S n) * e_P1 _ s)\n in |- *.\nrewrite comparith.mult_plus_distr_r; auto with arith.\nQed.\n", "definition": "\n forall M N : terms, reg_rvarcons M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros.\nchange (2 * power2 (S n) * (e_P1 _ a + e_P1 _ s) > power2 (S n) * e_P1 _ s)\n in |- *.\nrewrite comparith.mult_plus_distr_r; auto with arith.\n", "def_ranges": [145, 0, 146, 61], "proof_ranges": [147, 0, 152, 4], "proof_steps": [{"text": "simple induction 1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (2 * power2 (S n) * (e_P1 _ a + e_P1 _ s) > power2 (S n) * e_P1 _ s)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite comparith.mult_plus_distr_r; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_rvarlift1", "text": "Theorem P1_rvarlift1 :\n forall M N : terms, reg_rvarlift1 M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros.\nchange (2 * power2 (S n) * e_P1 _ s = power2 (S n) * (e_P1 _ s * 2)) in |- *.\nelim mult_assoc_l; elim (mult_permut (power2 (S n)) 2 (e_P1 _ s)).\nauto with arith.\nQed.\n", "definition": "\n forall M N : terms, reg_rvarlift1 M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros.\nchange (2 * power2 (S n) * e_P1 _ s = power2 (S n) * (e_P1 _ s * 2)) in |- *.\nelim mult_assoc_l; elim (mult_permut (power2 (S n)) 2 (e_P1 _ s)).\nauto with arith.\n", "def_ranges": [155, 0, 156, 62], "proof_ranges": [157, 0, 162, 4], "proof_steps": [{"text": "simple induction 1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (2 * power2 (S n) * e_P1 _ s = power2 (S n) * (e_P1 _ s * 2)) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim mult_assoc_l; elim (mult_permut (power2 (S n)) 2 (e_P1 _ s)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_rvarlift2", "text": "Theorem P1_rvarlift2 :\n forall M N : terms, reg_rvarlift2 M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros.\nchange\n  (2 * power2 (S n) * (e_P1 _ s * e_P1 _ t) =\n   power2 (S n) * (e_P1 _ s * (2 * e_P1 _ t))) in |- *.\nelim (mult_sym (power2 (S n)) 2); elim mult_assoc_l; auto with arith.\nQed.\n", "definition": "\n forall M N : terms, reg_rvarlift2 M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros.\nchange\n  (2 * power2 (S n) * (e_P1 _ s * e_P1 _ t) =\n   power2 (S n) * (e_P1 _ s * (2 * e_P1 _ t))) in |- *.\nelim (mult_sym (power2 (S n)) 2); elim mult_assoc_l; auto with arith.\n", "def_ranges": [165, 0, 166, 62], "proof_ranges": [167, 0, 173, 4], "proof_steps": [{"text": "simple induction 1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(2 * power2 (S n) * (e_P1 _ s * e_P1 _ t) =", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "power2 (S n) * (e_P1 _ s * (2 * e_P1 _ t))) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (mult_sym (power2 (S n)) 2); elim mult_assoc_l; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_assenv", "text": "Theorem P1_assenv :\n forall M N : sub_explicits, reg_assenv M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_assenv M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [176, 0, 177, 67], "proof_ranges": [178, 0, 180, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_mapenv", "text": "Theorem P1_mapenv :\n forall M N : sub_explicits, reg_mapenv M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_mapenv M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [183, 0, 184, 67], "proof_ranges": [185, 0, 187, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_shiftcons", "text": "Theorem P1_shiftcons :\n forall M N : sub_explicits, reg_shiftcons M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_shiftcons M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.\n", "def_ranges": [190, 0, 191, 70], "proof_ranges": [192, 0, 194, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_shiftlift1", "text": "Theorem P1_shiftlift1 :\n forall M N : sub_explicits, reg_shiftlift1 M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_shiftlift1 M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.\n", "def_ranges": [197, 0, 198, 71], "proof_ranges": [199, 0, 201, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_shiftlift2", "text": "Theorem P1_shiftlift2 :\n forall M N : sub_explicits, reg_shiftlift2 M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; do 2 elim plus_n_O;\n auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_shiftlift2 M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; do 2 elim plus_n_O;\n auto with arith.\n", "def_ranges": [204, 0, 205, 71], "proof_ranges": [206, 0, 209, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; do 2 elim plus_n_O;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_lift1", "text": "Theorem P1_lift1 :\n forall M N : sub_explicits, reg_lift1 M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_lift1 M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [212, 0, 213, 66], "proof_ranges": [214, 0, 216, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_lift2", "text": "Theorem P1_lift2 :\n forall M N : sub_explicits, reg_lift2 M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_lift2 M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [219, 0, 220, 66], "proof_ranges": [221, 0, 223, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_liftenv", "text": "Theorem P1_liftenv :\n forall M N : sub_explicits, reg_liftenv M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *;\n rewrite comparith.mult_plus_distr_r; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_liftenv M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *;\n rewrite comparith.mult_plus_distr_r; auto with arith.\n", "def_ranges": [226, 0, 227, 68], "proof_ranges": [228, 0, 231, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite comparith.mult_plus_distr_r; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_idl", "text": "Theorem P1_idl :\n forall M N : sub_explicits, reg_idl M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_idl M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.\n", "def_ranges": [234, 0, 235, 64], "proof_ranges": [236, 0, 238, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_idr", "text": "Theorem P1_idr :\n forall M N : sub_explicits, reg_idr M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_idr M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [241, 0, 242, 64], "proof_ranges": [243, 0, 245, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_liftid", "text": "Theorem P1_liftid :\n forall M N : sub_explicits, reg_liftid M N -> e_P1 _ M = e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": "\n forall M N : sub_explicits, reg_liftid M N -> e_P1 _ M = e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [248, 0, 249, 67], "proof_ranges": [250, 0, 252, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Pol1.v", "name": "P1_id", "text": "Theorem P1_id : forall M N : terms, reg_id M N -> e_P1 _ M > e_P1 _ N.\nProof.\nsimple induction 1; intros; simpl in |- *; auto with arith.\nQed.\n", "definition": " forall M N : terms, reg_id M N -> e_P1 _ M > e_P1 _ N.\n", "proof": "\nsimple induction 1; intros; simpl in |- *; auto with arith.\n", "def_ranges": [255, 0, 255, 70], "proof_ranges": [256, 0, 258, 4], "proof_steps": [{"text": "simple induction 1; intros; simpl in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/subst/Yokouchi.v", "name": "Yokouchi", "text": "Theorem Yokouchi : explicit_strong_confluence _ Rstar_S_Rstar.\n   unfold explicit_strong_confluence in |- *; intro f; pattern f in |- *;\n    apply (noetherian_induction1 A R N).\n   intros f0 H; unfold strong_confluence_en in |- *; intros g h H1 H2.\n   cut\n    (exists u : A,\n       explicit_star _ R f0 u /\\\n       explicit_comp_rel _ S (explicit_star _ R) u h).\n   2: apply comp_case; assumption.\n   intro H3; elim H3; intros f1 H4; elim H4; intros H5 H6.\n   cut\n    (exists u : A,\n       explicit_star _ R f0 u /\\\n       explicit_comp_rel _ S (explicit_star _ R) u g).\n   2: apply comp_case; assumption.\n   intro H7; elim H7; intros g1 H8; elim H8; intros H9 H10.\n   elim (star_case A R f0 f1 H5); intro H11.\n   elim (star_case A R f0 g1 H9); intro H12.\n   (* cas f0 SR* h et f0 SR* h *)\n   generalize H6; elim H11; intro H6'.\n   generalize H10; elim H12; intro H10'.\n   elim (comp_case A S (explicit_star _ R) f0 h H6'); intros f2 H13.\n   elim H13; intros H14 H15.\n   elim (comp_case A S (explicit_star _ R) f0 g H10'); intros g2 H16.\n   elim H16; intros H17 H18.\n   elim (SC f0 f2 g2 H14 H17); intros k1 H19; elim H19; intros H20 H21.\n   elim (commut2 g2 k1 g H18 H21); intros k2 H22; elim H22; intros H23 H24.\n   elim (commut2 f2 k1 h H15 H20); intros h1 H25; elim H25; intros H26 H27.\n   elim (C k1 h1 k2 H26 H23); intros k H28; elim H28; intros H29 H30.\n   exists k; split.\n   apply comp_r with k2; assumption.\n   apply comp_r with h1; assumption.\n   (* cas f0 R* g1 SR* g et f0 SR* h *)\n   elim H12; intros g2 H13; elim H13; intros H14 H15.   \n   generalize H6; elim H11; intro H6'.\n   elim (comp_case A S (explicit_star _ R) f0 h H6'); intros f2 H16.\n   elim H16; intros H17 H18. \n   elim (commut1 f0 f2 g2 H14 H17); intros k1 H19; elim H19; intros H20 H21.\n   elim (C f2 h k1 H18 H20); intros h1 H22; elim H22; intros H23 H24.\n   elim (H g2 H14 g h1).\n   2: red in |- *; apply comp_2rel with g1; assumption. \n   2: apply comp_r with k1; assumption.\n   intros k H25; elim H25; intros H26 H27.\n   exists k; split.\n   assumption.\n   apply comp_l with h1; assumption.\n   (* cas f0 RR* f1 SR* h et f0 R*SR* g *)\n   elim H11; intros f2 H12; elim H12; intros H13 H14. \n   elim (C f0 f2 g1).\n   2: apply star_trans1 with f2.\n   2: assumption.\n   2: apply star_refl.\n   2: assumption.\n   intros k1 H15; elim H15; intros H16 H17.\n   elim (comp_case A S (explicit_star _ R) g1 g H10); intros g2 H18.\n   elim H18; intros H19 H20.\n   elim (commut2 g1 g2 k1 H17 H19); intros k2 H21; elim H21; intros H22 H23.\n   elim (C g2 k2 g H22 H20); intros k3 H24; elim H24; intros H25 H26.\n   elim (H f2 H13 h k3).\n   2: red in |- *; apply comp_2rel with f1; assumption.\n   2: apply comp_l with k1.\n   2: assumption.\n   2: apply comp_r with k2; assumption.\n   intros k H27; elim H27; intros H28 H29.\n   exists k; split.\n   apply comp_l with k3; assumption.\n   assumption.\n   Qed.\n", "definition": " explicit_strong_confluence _ Rstar_S_Rstar.", "proof": "\n   unfold explicit_strong_confluence in |- *; intro f; pattern f in |- *;\n    apply (noetherian_induction1 A R N).\n   intros f0 H; unfold strong_confluence_en in |- *; intros g h H1 H2.\n   cut\n    (exists u : A,\n       explicit_star _ R f0 u /\\\n       explicit_comp_rel _ S (explicit_star _ R) u h).\n   2: apply comp_case; assumption.\n   intro H3; elim H3; intros f1 H4; elim H4; intros H5 H6.\n   cut\n    (exists u : A,\n       explicit_star _ R f0 u /\\\n       explicit_comp_rel _ S (explicit_star _ R) u g).\n   2: apply comp_case; assumption.\n   intro H7; elim H7; intros g1 H8; elim H8; intros H9 H10.\n   elim (star_case A R f0 f1 H5); intro H11.\n   elim (star_case A R f0 g1 H9); intro H12.\n   (* cas f0 SR* h et f0 SR* h *)\n   generalize H6; elim H11; intro H6'.\n   generalize H10; elim H12; intro H10'.\n   elim (comp_case A S (explicit_star _ R) f0 h H6'); intros f2 H13.\n   elim H13; intros H14 H15.\n   elim (comp_case A S (explicit_star _ R) f0 g H10'); intros g2 H16.\n   elim H16; intros H17 H18.\n   elim (SC f0 f2 g2 H14 H17); intros k1 H19; elim H19; intros H20 H21.\n   elim (commut2 g2 k1 g H18 H21); intros k2 H22; elim H22; intros H23 H24.\n   elim (commut2 f2 k1 h H15 H20); intros h1 H25; elim H25; intros H26 H27.\n   elim (C k1 h1 k2 H26 H23); intros k H28; elim H28; intros H29 H30.\n   exists k; split.\n   apply comp_r with k2; assumption.\n   apply comp_r with h1; assumption.\n   (* cas f0 R* g1 SR* g et f0 SR* h *)\n   elim H12; intros g2 H13; elim H13; intros H14 H15.   \n   generalize H6; elim H11; intro H6'.\n   elim (comp_case A S (explicit_star _ R) f0 h H6'); intros f2 H16.\n   elim H16; intros H17 H18. \n   elim (commut1 f0 f2 g2 H14 H17); intros k1 H19; elim H19; intros H20 H21.\n   elim (C f2 h k1 H18 H20); intros h1 H22; elim H22; intros H23 H24.\n   elim (H g2 H14 g h1).\n   2: red in |- *; apply comp_2rel with g1; assumption. \n   2: apply comp_r with k1; assumption.\n   intros k H25; elim H25; intros H26 H27.\n   exists k; split.\n   assumption.\n   apply comp_l with h1; assumption.\n   (* cas f0 RR* f1 SR* h et f0 R*SR* g *)\n   elim H11; intros f2 H12; elim H12; intros H13 H14. \n   elim (C f0 f2 g1).\n   2: apply star_trans1 with f2.\n   2: assumption.\n   2: apply star_refl.\n   2: assumption.\n   intros k1 H15; elim H15; intros H16 H17.\n   elim (comp_case A S (explicit_star _ R) g1 g H10); intros g2 H18.\n   elim H18; intros H19 H20.\n   elim (commut2 g1 g2 k1 H17 H19); intros k2 H21; elim H21; intros H22 H23.\n   elim (C g2 k2 g H22 H20); intros k3 H24; elim H24; intros H25 H26.\n   elim (H f2 H13 h k3).\n   2: red in |- *; apply comp_2rel with f1; assumption.\n   2: apply comp_l with k1.\n   2: assumption.\n   2: apply comp_r with k2; assumption.\n   intros k H27; elim H27; intros H28 H29.\n   exists k; split.\n   apply comp_l with k3; assumption.\n   assumption.\n   ", "def_ranges": [122, 0, 122, 65], "proof_ranges": [123, 0, 189, 7], "proof_steps": [{"text": "unfold explicit_strong_confluence in |- *; intro f; pattern f in |- *;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (noetherian_induction1 A R N).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros f0 H; unfold strong_confluence_en in |- *; intros g h H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(exists u : A,", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "explicit_star _ R f0 u /\\", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "explicit_comp_rel _ S (explicit_star _ R) u h).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply comp_case; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H3; elim H3; intros f1 H4; elim H4; intros H5 H6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(exists u : A,", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "explicit_star _ R f0 u /\\", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "explicit_comp_rel _ S (explicit_star _ R) u g).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply comp_case; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H7; elim H7; intros g1 H8; elim H8; intros H9 H10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (star_case A R f0 f1 H5); intro H11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (star_case A R f0 g1 H9); intro H12.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H6; elim H11; intro H6'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H10; elim H12; intro H10'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (comp_case A S (explicit_star _ R) f0 h H6'); intros f2 H13.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H13; intros H14 H15.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (comp_case A S (explicit_star _ R) f0 g H10'); intros g2 H16.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H16; intros H17 H18.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (SC f0 f2 g2 H14 H17); intros k1 H19; elim H19; intros H20 H21.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (commut2 g2 k1 g H18 H21); intros k2 H22; elim H22; intros H23 H24.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (commut2 f2 k1 h H15 H20); intros h1 H25; elim H25; intros H26 H27.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (C k1 h1 k2 H26 H23); intros k H28; elim H28; intros H29 H30.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists k; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply comp_r with k2; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply comp_r with h1; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H12; intros g2 H13; elim H13; intros H14 H15.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H6; elim H11; intro H6'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (comp_case A S (explicit_star _ R) f0 h H6'); intros f2 H16.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H16; intros H17 H18.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (commut1 f0 f2 g2 H14 H17); intros k1 H19; elim H19; intros H20 H21.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (C f2 h k1 H18 H20); intros h1 H22; elim H22; intros H23 H24.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H g2 H14 g h1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; apply comp_2rel with g1; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply comp_r with k1; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros k H25; elim H25; intros H26 H27.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists k; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply comp_l with h1; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H11; intros f2 H12; elim H12; intros H13 H14.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (C f0 f2 g1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply star_trans1 with f2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply star_refl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros k1 H15; elim H15; intros H16 H17.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (comp_case A S (explicit_star _ R) g1 g H10); intros g2 H18.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H18; intros H19 H20.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (commut2 g1 g2 k1 H17 H19); intros k2 H21; elim H21; intros H22 H23.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (C g2 k2 g H22 H20); intros k3 H24; elim H24; intros H25 H26.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H f2 H13 h k3).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; apply comp_2rel with f1; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply comp_l with k1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply comp_r with k2; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros k H27; elim H27; intros H28 H29.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/Noetherian.v", "name": "Noetherian_contains_Noetherian", "text": "Theorem Noetherian_contains_Noetherian :\n forall (U : Type) (R R' : Relation U),\n Noetherian R -> Contains R R' -> Noetherian R'.\nProof.\nunfold Noetherian at 2 in |- *.\nintros U R R' H' H'0 x.\nelim H' with x; auto.\nQed.\n", "definition": "\n forall (U : Type) (R R' : Relation U),\n Noetherian R -> Contains R R' -> Noetherian R'.\n", "proof": "\nunfold Noetherian at 2 in |- *.\nintros U R R' H' H'0 x.\nelim H' with x; auto.\n", "def_ranges": [50, 0, 52, 48], "proof_ranges": [53, 0, 57, 4], "proof_steps": [{"text": "unfold Noetherian at 2 in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros U R R' H' H'0 x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H' with x; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rstar_reflexive", "text": "Theorem Rstar_reflexive :\n forall (U : Type) (R : Relation U), Reflexive (Rstar R).\nProof.\nauto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Reflexive (Rstar R).\n", "proof": "\nauto.\n", "def_ranges": [39, 0, 40, 57], "proof_ranges": [41, 0, 43, 4], "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rplus_contains_R", "text": "Theorem Rplus_contains_R :\n forall (U : Type) (R : Relation U), Contains (Rplus R) R.\nProof.\nauto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Contains (Rplus R) R.\n", "proof": "\nauto.\n", "def_ranges": [45, 0, 46, 58], "proof_ranges": [47, 0, 49, 4], "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rstar_contains_R", "text": "Theorem Rstar_contains_R :\n forall (U : Type) (R : Relation U), Contains (Rstar R) R.\nProof.\nintros U R; red in |- *; intros x y H'; apply Rstar_n with y; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Contains (Rstar R) R.\n", "proof": "\nintros U R; red in |- *; intros x y H'; apply Rstar_n with y; auto.\n", "def_ranges": [51, 0, 52, 58], "proof_ranges": [53, 0, 55, 4], "proof_steps": [{"text": "intros U R; red in |- *; intros x y H'; apply Rstar_n with y; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rstar_contains_Rplus", "text": "Theorem Rstar_contains_Rplus :\n forall (U : Type) (R : Relation U), Contains (Rstar R) (Rplus R).\nProof.\nintros U R; red in |- *.\nintros x y H'; elim H'.\ngeneralize Rstar_contains_R; intro T; red in T; auto.\nintros x0 y0 z H'0 H'1 H'2; apply Rstar_n with y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Contains (Rstar R) (Rplus R).\n", "proof": "\nintros U R; red in |- *.\nintros x y H'; elim H'.\ngeneralize Rstar_contains_R; intro T; red in T; auto.\nintros x0 y0 z H'0 H'1 H'2; apply Rstar_n with y0; auto.\n", "def_ranges": [57, 0, 58, 66], "proof_ranges": [59, 0, 64, 4], "proof_steps": [{"text": "intros U R; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x y H'; elim H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize Rstar_contains_R; intro T; red in T; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y0 z H'0 H'1 H'2; apply Rstar_n with y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rstar_transitive", "text": "Theorem Rstar_transitive :\n forall (U : Type) (R : Relation U), Transitive (Rstar R).\nProof.\nintros U R; red in |- *.\nintros x y z H'; elim H'; auto.\nintros x0 y0 z0 H'0 H'1 H'2 H'3; apply Rstar_n with y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Transitive (Rstar R).\n", "proof": "\nintros U R; red in |- *.\nintros x y z H'; elim H'; auto.\nintros x0 y0 z0 H'0 H'1 H'2 H'3; apply Rstar_n with y0; auto.\n", "def_ranges": [66, 0, 67, 58], "proof_ranges": [68, 0, 72, 4], "proof_steps": [{"text": "intros U R; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x y z H'; elim H'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y0 z0 H'0 H'1 H'2 H'3; apply Rstar_n with y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rstar_cases", "text": "Theorem Rstar_cases :\n forall (U : Type) (R : Relation U) (x y : U),\n Rstar R x y -> x = y \\/ (exists u : U, R x u /\\ Rstar R u y).\nProof.\nintros U R x y H'; elim H'; auto.\nintros x0 y0 z H'0 H'1 H'2; right; exists y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U) (x y : U),\n Rstar R x y -> x = y \\/ (exists u : U, R x u /\\ Rstar R u y).\n", "proof": "\nintros U R x y H'; elim H'; auto.\nintros x0 y0 z H'0 H'1 H'2; right; exists y0; auto.\n", "def_ranges": [74, 0, 76, 62], "proof_ranges": [77, 0, 80, 4], "proof_steps": [{"text": "intros U R x y H'; elim H'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y0 z H'0 H'1 H'2; right; exists y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rstar_equiv_Rstar1", "text": "Theorem Rstar_equiv_Rstar1 :\n forall (U : Type) (R : Relation U), Same_relation (Rstar R) (Rstar1 R).\nProof.\ngeneralize Rstar_contains_R; intro T; red in T.\nintros U R; unfold Same_relation, Contains in |- *.\nsplit; intros x y H'; elim H'; auto.\ngeneralize Rstar_transitive; intro T1; red in T1.\nintros x0 y0 z H'0 H'1 H'2 H'3; apply T1 with y0; auto.\nintros x0 y0 z H'0 H'1 H'2; apply Rstar1_n with y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Same_relation (Rstar R) (Rstar1 R).\n", "proof": "\ngeneralize Rstar_contains_R; intro T; red in T.\nintros U R; unfold Same_relation, Contains in |- *.\nsplit; intros x y H'; elim H'; auto.\ngeneralize Rstar_transitive; intro T1; red in T1.\nintros x0 y0 z H'0 H'1 H'2 H'3; apply T1 with y0; auto.\nintros x0 y0 z H'0 H'1 H'2; apply Rstar1_n with y0; auto.\n", "def_ranges": [82, 0, 83, 72], "proof_ranges": [84, 0, 91, 4], "proof_steps": [{"text": "generalize Rstar_contains_R; intro T; red in T.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros U R; unfold Same_relation, Contains in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; intros x y H'; elim H'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize Rstar_transitive; intro T1; red in T1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y0 z H'0 H'1 H'2 H'3; apply T1 with y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y0 z H'0 H'1 H'2; apply Rstar1_n with y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rsym_imp_Rstarsym", "text": "Theorem Rsym_imp_Rstarsym :\n forall (U : Type) (R : Relation U), Symmetric R -> Symmetric (Rstar R).\nProof.\nintros U R H'; red in |- *.\nintros x y H'0; elim H'0; auto.\nintros x0 y0 z H'1 H'2 H'3.\ngeneralize Rstar_transitive; intro T; red in T.\napply T with y0; auto.\napply Rstar_n with x0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Symmetric R -> Symmetric (Rstar R).\n", "proof": "\nintros U R H'; red in |- *.\nintros x y H'0; elim H'0; auto.\nintros x0 y0 z H'1 H'2 H'3.\ngeneralize Rstar_transitive; intro T; red in T.\napply T with y0; auto.\napply Rstar_n with x0; auto.\n", "def_ranges": [93, 0, 94, 72], "proof_ranges": [95, 0, 102, 4], "proof_steps": [{"text": "intros U R H'; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x y H'0; elim H'0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y0 z H'1 H'2 H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize Rstar_transitive; intro T; red in T.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply T with y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rstar_n with x0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Sstar_contains_Rstar", "text": "Theorem Sstar_contains_Rstar :\n forall (U : Type) (R S : Relation U),\n Contains (Rstar S) R -> Contains (Rstar S) (Rstar R).\nProof.\nunfold Contains in |- *.\nintros U R S H' x y H'0; elim H'0; auto.\ngeneralize Rstar_transitive; intro T; red in T.\nintros x0 y0 z H'1 H'2 H'3; apply T with y0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R S : Relation U),\n Contains (Rstar S) R -> Contains (Rstar S) (Rstar R).\n", "proof": "\nunfold Contains in |- *.\nintros U R S H' x y H'0; elim H'0; auto.\ngeneralize Rstar_transitive; intro T; red in T.\nintros x0 y0 z H'1 H'2 H'3; apply T with y0; auto.\n", "def_ranges": [104, 0, 106, 54], "proof_ranges": [107, 0, 112, 4], "proof_steps": [{"text": "unfold Contains in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros U R S H' x y H'0; elim H'0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize Rstar_transitive; intro T; red in T.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y0 z H'1 H'2 H'3; apply T with y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "star_monotone", "text": "Theorem star_monotone :\n forall (U : Type) (R S : Relation U),\n Contains S R -> Contains (Rstar S) (Rstar R).\nProof.\nintros U R S H'.\napply Sstar_contains_Rstar.\ngeneralize (Rstar_contains_R (R:=S)); auto.\nQed.\n", "definition": "\n forall (U : Type) (R S : Relation U),\n Contains S R -> Contains (Rstar S) (Rstar R).\n", "proof": "\nintros U R S H'.\napply Sstar_contains_Rstar.\ngeneralize (Rstar_contains_R (R:=S)); auto.\n", "def_ranges": [114, 0, 116, 46], "proof_ranges": [117, 0, 121, 4], "proof_steps": [{"text": "intros U R S H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Sstar_contains_Rstar.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Rstar_contains_R (R:=S)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "RstarRplus_RRstar", "text": "Theorem RstarRplus_RRstar :\n forall (U : Type) (R : Relation U) (x y z : U),\n Rstar R x y -> Rplus R y z -> exists u : U, R x u /\\ Rstar R u z.\nProof.\ngeneralize Rstar_contains_Rplus; intro T; red in T.\ngeneralize Rstar_transitive; intro T1; red in T1.\nintros U R x y z H'; elim H'.\nintros x0 H'0; elim H'0.\nintros; exists y0; auto.\nintros; exists y0; auto.\nintros; exists y0; auto.\nsplit; [ try assumption | idtac ].\napply T1 with z0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U) (x y z : U),\n Rstar R x y -> Rplus R y z -> exists u : U, R x u /\\ Rstar R u z.\n", "proof": "\ngeneralize Rstar_contains_Rplus; intro T; red in T.\ngeneralize Rstar_transitive; intro T1; red in T1.\nintros U R x y z H'; elim H'.\nintros x0 H'0; elim H'0.\nintros; exists y0; auto.\nintros; exists y0; auto.\nintros; exists y0; auto.\nsplit; [ try assumption | idtac ].\napply T1 with z0; auto.\n", "def_ranges": [123, 0, 125, 66], "proof_ranges": [126, 0, 136, 4], "proof_steps": [{"text": "generalize Rstar_contains_Rplus; intro T; red in T.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize Rstar_transitive; intro T1; red in T1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros U R x y z H'; elim H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'0; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; exists y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; exists y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; exists y0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; [ try assumption | idtac ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply T1 with z0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "Rstar_imp_coherent", "text": "Theorem Rstar_imp_coherent :\n forall (U : Type) (R : Relation U) (x y : U), Rstar R x y -> coherent R x y.\nProof.\nintros U R x y H'; red in |- *.\nexists y; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U) (x y : U), Rstar R x y -> coherent R x y.\n", "proof": "\nintros U R x y H'; red in |- *.\nexists y; auto.\n", "def_ranges": [138, 0, 139, 77], "proof_ranges": [140, 0, 143, 4], "proof_steps": [{"text": "intros U R x y H'; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists y; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/Coherence.v", "name": "coherent_symmetric", "text": "Theorem coherent_symmetric :\n forall (U : Type) (R : Relation U), Symmetric (coherent R).\nProof.\nunfold coherent at 1 in |- *.\nintros U R; red in |- *.\nintros x y h; elim h; intros z h0; elim h0; intros H' H'0; clear h h0.\nexists z; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Symmetric (coherent R).\n", "proof": "\nunfold coherent at 1 in |- *.\nintros U R; red in |- *.\nintros x y h; elim h; intros z h0; elim h0; intros H' H'0; clear h h0.\nexists z; auto.\n", "def_ranges": [146, 0, 147, 60], "proof_ranges": [148, 0, 153, 4], "proof_steps": [{"text": "unfold coherent at 1 in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros U R; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x y h; elim h; intros z h0; elim h0; intros H' H'0; clear h h0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists z; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/TAIT/Tait.v", "name": "Strip", "text": "Theorem Strip :\n forall (U : Type) (R : Relation U),\n Strongly_confluent R ->\n forall x b : U,\n Rstar R x b -> forall a : U, R x a -> exists z : U, Rstar R a z /\\ R b z.\nProof.\nintros U R H' x b H'0; elim H'0.\nintros x0 a H'1; exists a; auto.\nintros x0 y z H'1 H'2 H'3 a H'4.\nred in H'.\ngeneralize (H' x0 a y); intro h; lapply h;\n [ intro H'5; lapply H'5;\n    [ intro h0; elim h0; intros t h1; elim h1; intros H'6 H'7;\n       clear h H'5 h0 h1; try exact H'6\n    | clear h ]\n | clear h ]; auto 10.\ngeneralize (H'3 t); intro h; lapply h;\n [ intro h0; elim h0; intros z1 h1; elim h1; intros H'5 H'8; clear h h0 h1;\n    try exact H'5\n | clear h ]; auto 10.\nexists z1; split; [ idtac | assumption ].\napply Rstar_n with t; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U),\n Strongly_confluent R ->\n forall x b : U,\n Rstar R x b -> forall a : U, R x a -> exists z : U, Rstar R a z /\\ R b z.\n", "proof": "\nintros U R H' x b H'0; elim H'0.\nintros x0 a H'1; exists a; auto.\nintros x0 y z H'1 H'2 H'3 a H'4.\nred in H'.\ngeneralize (H' x0 a y); intro h; lapply h;\n [ intro H'5; lapply H'5;\n    [ intro h0; elim h0; intros t h1; elim h1; intros H'6 H'7;\n       clear h H'5 h0 h1; try exact H'6\n    | clear h ]\n | clear h ]; auto 10.\ngeneralize (H'3 t); intro h; lapply h;\n [ intro h0; elim h0; intros z1 h1; elim h1; intros H'5 H'8; clear h h0 h1;\n    try exact H'5\n | clear h ]; auto 10.\nexists z1; split; [ idtac | assumption ].\napply Rstar_n with t; auto.\n", "def_ranges": [40, 0, 44, 74], "proof_ranges": [45, 0, 62, 4], "proof_steps": [{"text": "intros U R H' x b H'0; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 a H'1; exists a; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y z H'1 H'2 H'3 a H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H' x0 a y); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'5; lapply H'5;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros t h1; elim h1; intros H'6 H'7;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h H'5 h0 h1; try exact H'6", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto 10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'3 t); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros z1 h1; elim h1; intros H'5 H'8; clear h h0 h1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "try exact H'5", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/TAIT/Tait.v", "name": "Strong_confluence_confluence", "text": "Theorem Strong_confluence_confluence :\n forall (U : Type) (R : Relation U), Strongly_confluent R -> Confluent R.\nProof.\nintros U R H'; red in |- *.\nintro x; red in |- *; intros a b H'0.\nunfold coherent at 1 in |- *.\ngeneralize b; clear b.\nelim H'0; clear H'0.\nintros x0 b H'1; exists b; auto.\nintros x0 y z H'1 H'2 H'3 b H'4.\ngeneralize (Strip (U:=U) (R:=R)); intro h; lapply h;\n [ intro H'0; generalize (H'0 x0 b); intro h0; lapply h0;\n    [ intro H'5; generalize (H'5 y); intro h1; lapply h1;\n       [ intro h2; elim h2; intros z0 h3; elim h3; intros H'6 H'7;\n          clear h h0 h1 h2 h3\n       | clear h h0 h1 ]\n    | clear h h0 ]\n | clear h ]; auto.\ngeneralize (H'3 z0); intro h; lapply h;\n [ intro h0; elim h0; intros z1 h1; elim h1; intros H'8 H'9; clear h h0 h1\n | clear h ]; auto.\nexists z1; split; auto.\napply Rstar_n with z0; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U), Strongly_confluent R -> Confluent R.\n", "proof": "\nintros U R H'; red in |- *.\nintro x; red in |- *; intros a b H'0.\nunfold coherent at 1 in |- *.\ngeneralize b; clear b.\nelim H'0; clear H'0.\nintros x0 b H'1; exists b; auto.\nintros x0 y z H'1 H'2 H'3 b H'4.\ngeneralize (Strip (U:=U) (R:=R)); intro h; lapply h;\n [ intro H'0; generalize (H'0 x0 b); intro h0; lapply h0;\n    [ intro H'5; generalize (H'5 y); intro h1; lapply h1;\n       [ intro h2; elim h2; intros z0 h3; elim h3; intros H'6 H'7;\n          clear h h0 h1 h2 h3\n       | clear h h0 h1 ]\n    | clear h h0 ]\n | clear h ]; auto.\ngeneralize (H'3 z0); intro h; lapply h;\n [ intro h0; elim h0; intros z1 h1; elim h1; intros H'8 H'9; clear h h0 h1\n | clear h ]; auto.\nexists z1; split; auto.\napply Rstar_n with z0; auto.\n", "def_ranges": [64, 0, 65, 73], "proof_ranges": [66, 0, 87, 4], "proof_steps": [{"text": "intros U R H'; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro x; red in |- *; intros a b H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold coherent at 1 in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize b; clear b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0; clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 b H'1; exists b; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y z H'1 H'2 H'3 b H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Strip (U:=U) (R:=R)); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'0; generalize (H'0 x0 b); intro h0; lapply h0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'5; generalize (H'5 y); intro h1; lapply h1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h2; elim h2; intros z0 h3; elim h3; intros H'6 H'7;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h h0 h1 h2 h3", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h h0 h1 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h h0 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'3 z0); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/concat/RELATIONS/CONFLUENCE/NEWMAN/Newman.v", "name": "Newman", "text": "Theorem Newman :\n forall (U : Type) (R : Relation U),\n Noetherian R -> Locally_confluent R -> Confluent R.\nProof.\nintros U R H' H'0; red in |- *; intro x; red in |- *.\nred in H'; generalize (H' x); intro H'1; elim H'1.\nintros x0 H'2 H'3 y z H'4 H'5; clear H' H'1.\ngeneralize (Rstar_cases (U:=U) (R:=R) (x:=x0) (y:=y)); intro h; lapply h;\n [ intro H'6; clear h | clear h; assumption ].\ngeneralize (Rstar_cases (U:=U) (R:=R) (x:=x0) (y:=z)); intro h; lapply h;\n [ intro H'7; clear h | clear h; assumption ].\nelim H'6;\n [ clear H'6; intro h\n | intro h; elim h; intros u h0; elim h0; intros H' H'1; clear H'6 h h0 ].\nrewrite <- h; auto.\nelim H'7;\n [ clear H'7; intro h\n | intro h; elim h; intros v h0; elim h0; intros H'6 H'8; clear H'7 h h0 ].\nrewrite <- h; generalize coherent_symmetric; intro H_cs; red in H_cs; auto.\nunfold Locally_confluent, locally_confluent, coherent in H'0.\ngeneralize (H'0 x0 u v); intro h; lapply h;\n [ intro H'7; lapply H'7;\n    [ intro h0; elim h0; intros t h1; elim h1; intros H'9 H'10;\n       clear h H'7 h0 h1\n    | clear h ]\n | clear h ]; auto.\nclear H'0.\nunfold coherent at 1 in H'3.\ngeneralize (H'3 u); intro h; lapply h;\n [ intro H'0; generalize (H'0 y t); intro h0; lapply h0;\n    [ intro H'7; lapply H'7;\n       [ intro h1; elim h1; intros y1 h2; elim h2; intros H'11 H'12;\n          clear h h0 H'7 h1 h2\n       | clear h h0 ]\n    | clear h h0 ]\n | clear h ]; auto.\ngeneralize Rstar_transitive; intro H_Rst; red in H_Rst.\ngeneralize (H'3 v); intro h; lapply h;\n [ intro H'7; generalize (H'7 y1 z); intro h0; lapply h0;\n    [ intro H'13; lapply H'13;\n       [ intro h1; elim h1; intros z1 h2; elim h2; intros H'14 H'15;\n          clear h h0 H'13 h1 h2\n       | clear h h0 ]\n    | clear h h0 ]\n | clear h ]; auto.\nred in |- *; (exists z1; split); auto.\napply H_Rst with y1; auto.\napply H_Rst with t; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U),\n Noetherian R -> Locally_confluent R -> Confluent R.\n", "proof": "\nintros U R H' H'0; red in |- *; intro x; red in |- *.\nred in H'; generalize (H' x); intro H'1; elim H'1.\nintros x0 H'2 H'3 y z H'4 H'5; clear H' H'1.\ngeneralize (Rstar_cases (U:=U) (R:=R) (x:=x0) (y:=y)); intro h; lapply h;\n [ intro H'6; clear h | clear h; assumption ].\ngeneralize (Rstar_cases (U:=U) (R:=R) (x:=x0) (y:=z)); intro h; lapply h;\n [ intro H'7; clear h | clear h; assumption ].\nelim H'6;\n [ clear H'6; intro h\n | intro h; elim h; intros u h0; elim h0; intros H' H'1; clear H'6 h h0 ].\nrewrite <- h; auto.\nelim H'7;\n [ clear H'7; intro h\n | intro h; elim h; intros v h0; elim h0; intros H'6 H'8; clear H'7 h h0 ].\nrewrite <- h; generalize coherent_symmetric; intro H_cs; red in H_cs; auto.\nunfold Locally_confluent, locally_confluent, coherent in H'0.\ngeneralize (H'0 x0 u v); intro h; lapply h;\n [ intro H'7; lapply H'7;\n    [ intro h0; elim h0; intros t h1; elim h1; intros H'9 H'10;\n       clear h H'7 h0 h1\n    | clear h ]\n | clear h ]; auto.\nclear H'0.\nunfold coherent at 1 in H'3.\ngeneralize (H'3 u); intro h; lapply h;\n [ intro H'0; generalize (H'0 y t); intro h0; lapply h0;\n    [ intro H'7; lapply H'7;\n       [ intro h1; elim h1; intros y1 h2; elim h2; intros H'11 H'12;\n          clear h h0 H'7 h1 h2\n       | clear h h0 ]\n    | clear h h0 ]\n | clear h ]; auto.\ngeneralize Rstar_transitive; intro H_Rst; red in H_Rst.\ngeneralize (H'3 v); intro h; lapply h;\n [ intro H'7; generalize (H'7 y1 z); intro h0; lapply h0;\n    [ intro H'13; lapply H'13;\n       [ intro h1; elim h1; intros z1 h2; elim h2; intros H'14 H'15;\n          clear h h0 H'13 h1 h2\n       | clear h h0 ]\n    | clear h h0 ]\n | clear h ]; auto.\nred in |- *; (exists z1; split); auto.\napply H_Rst with y1; auto.\napply H_Rst with t; auto.\n", "def_ranges": [40, 0, 42, 52], "proof_ranges": [43, 0, 88, 4], "proof_steps": [{"text": "intros U R H' H'0; red in |- *; intro x; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in H'; generalize (H' x); intro H'1; elim H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'2 H'3 y z H'4 H'5; clear H' H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Rstar_cases (U:=U) (R:=R) (x:=x0) (y:=y)); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'6; clear h | clear h; assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (Rstar_cases (U:=U) (R:=R) (x:=x0) (y:=z)); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'7; clear h | clear h; assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'6;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ clear H'6; intro h", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| intro h; elim h; intros u h0; elim h0; intros H' H'1; clear H'6 h h0 ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- h; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'7;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ clear H'7; intro h", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| intro h; elim h; intros v h0; elim h0; intros H'6 H'8; clear H'7 h h0 ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- h; generalize coherent_symmetric; intro H_cs; red in H_cs; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Locally_confluent, locally_confluent, coherent in H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'0 x0 u v); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'7; lapply H'7;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h0; elim h0; intros t h1; elim h1; intros H'9 H'10;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h H'7 h0 h1", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold coherent at 1 in H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (H'3 u); intro h; lapply h;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'0; generalize (H'0 y t); intro h0; lapply h0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'7; lapply H'7;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro h1; elim h1; intros y1 h2; elim h2; intros H'11 H'12;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear h h0 H'7 h1 h2", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h h0 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h h0 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| clear h ]; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/circuits/ADDER/AdderProof.v", "name": "BV_full_adder_ok", "text": "Theorem BV_full_adder_ok :\n forall (v w : BV) (cin : bool),\n BV_to_nat (BV_full_adder v w cin) =\n BV_to_nat v + BV_to_nat w + bool_to_nat cin.\nsimple induction v.\nintros.\nrewrite BV_full_adder_sym.\nsimpl in |- *.\nrewrite BV_full_adder_nil_ok.\nauto with arith.\n\nunfold BV_full_adder in |- *.\nsimple induction w.\nsimpl in |- *.\nintro.\nrewrite H.\nsimpl in |- *.\nelim plus_n_O.\nelim plus_n_O.\nreplace\n (BV_to_nat l + bool_to_nat (half_adder_carry a cin) +\n  (BV_to_nat l + bool_to_nat (half_adder_carry a cin))) with\n (bool_to_nat (half_adder_carry a cin) + bool_to_nat (half_adder_carry a cin) +\n  (BV_to_nat l + BV_to_nat l)).\nrepeat rewrite plus_assoc.\nreplace\n (bool_to_nat (half_adder_sum a cin) + bool_to_nat (half_adder_carry a cin) +\n  bool_to_nat (half_adder_carry a cin)) with\n (bool_to_nat (half_adder_sum a cin) +\n  (bool_to_nat (half_adder_carry a cin) +\n   bool_to_nat (half_adder_carry a cin))).\nrewrite half_adder_ok.\nrewrite (plus_permute2 (bool_to_nat a) (bool_to_nat cin) (BV_to_nat l)).\nrewrite\n (plus_permute2 (bool_to_nat a + BV_to_nat l) (bool_to_nat cin) (BV_to_nat l))\n .\ntrivial with arith.\n\ntrivial with arith.\n\nrepeat rewrite plus_assoc.\nrewrite\n (plus_permute2 (bool_to_nat (half_adder_carry a cin))\n    (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l))\n .\nrewrite (plus_comm (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l)).\nrewrite\n (plus_permute2 (BV_to_nat l + bool_to_nat (half_adder_carry a cin))\n    (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l))\n .\ntrivial with arith.\n\nintros.\nsimpl in |- *.\nrewrite H.\nclear H.\nelim cin; elim a.\nrewrite full_adder_carry_sym1.\nrewrite full_adder_carry_true.\nrewrite full_adder_sum_sym1.\nrewrite full_adder_sum_true.\nsimpl in |- *.\nrepeat rewrite plus_n_SO.\nelim plus_n_Sm.\nelim plus_n_Sm.\nsimpl in |- *.\nelim plus_n_Sm.\nrepeat rewrite plus_assoc.\nrewrite\n (plus_permute2 (bool_to_nat a0 + BV_to_nat l) (BV_to_nat l0) (BV_to_nat l))\n .\nrewrite (plus_comm (bool_to_nat a0) (BV_to_nat l)).\nrewrite (plus_permute2 (BV_to_nat l) (bool_to_nat a0) (BV_to_nat l)).\ntrivial with arith.\n\nelim a0.\nsimpl in |- *.\nelim plus_n_Sm.\nsimpl in |- *.\nelim plus_n_O.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_O.\nrepeat rewrite plus_assoc.\nrewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).\ntrivial with arith.\n\nsimpl in |- *.\nrepeat rewrite <- plus_n_Sm.\nrepeat rewrite <- plus_n_O.\nrepeat rewrite plus_assoc.\ntry trivial with arith.\nrewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).\ntry trivial with arith.\n\nelim a0.\nsimpl in |- *.\nrepeat rewrite <- plus_n_Sm.\nrepeat rewrite <- plus_n_O.\nrepeat rewrite plus_assoc.\nsimpl in |- *.\nrewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).\ntrivial with arith.\n\nsimpl in |- *.\nrepeat rewrite <- plus_n_O.\nrepeat rewrite plus_assoc.\nrewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).\ntrivial with arith.\n\nelim a0; simpl in |- *; repeat rewrite <- plus_n_Sm;\n repeat rewrite <- plus_n_O; repeat rewrite plus_assoc;\n rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l));\n trivial with arith.\n\nQed.\n", "definition": "\n forall (v w : BV) (cin : bool),\n BV_to_nat (BV_full_adder v w cin) =\n BV_to_nat v + BV_to_nat w + bool_to_nat cin.", "proof": "\nsimple induction v.\nintros.\nrewrite BV_full_adder_sym.\nsimpl in |- *.\nrewrite BV_full_adder_nil_ok.\nauto with arith.\n\nunfold BV_full_adder in |- *.\nsimple induction w.\nsimpl in |- *.\nintro.\nrewrite H.\nsimpl in |- *.\nelim plus_n_O.\nelim plus_n_O.\nreplace\n (BV_to_nat l + bool_to_nat (half_adder_carry a cin) +\n  (BV_to_nat l + bool_to_nat (half_adder_carry a cin))) with\n (bool_to_nat (half_adder_carry a cin) + bool_to_nat (half_adder_carry a cin) +\n  (BV_to_nat l + BV_to_nat l)).\nrepeat rewrite plus_assoc.\nreplace\n (bool_to_nat (half_adder_sum a cin) + bool_to_nat (half_adder_carry a cin) +\n  bool_to_nat (half_adder_carry a cin)) with\n (bool_to_nat (half_adder_sum a cin) +\n  (bool_to_nat (half_adder_carry a cin) +\n   bool_to_nat (half_adder_carry a cin))).\nrewrite half_adder_ok.\nrewrite (plus_permute2 (bool_to_nat a) (bool_to_nat cin) (BV_to_nat l)).\nrewrite\n (plus_permute2 (bool_to_nat a + BV_to_nat l) (bool_to_nat cin) (BV_to_nat l))\n .\ntrivial with arith.\n\ntrivial with arith.\n\nrepeat rewrite plus_assoc.\nrewrite\n (plus_permute2 (bool_to_nat (half_adder_carry a cin))\n    (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l))\n .\nrewrite (plus_comm (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l)).\nrewrite\n (plus_permute2 (BV_to_nat l + bool_to_nat (half_adder_carry a cin))\n    (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l))\n .\ntrivial with arith.\n\nintros.\nsimpl in |- *.\nrewrite H.\nclear H.\nelim cin; elim a.\nrewrite full_adder_carry_sym1.\nrewrite full_adder_carry_true.\nrewrite full_adder_sum_sym1.\nrewrite full_adder_sum_true.\nsimpl in |- *.\nrepeat rewrite plus_n_SO.\nelim plus_n_Sm.\nelim plus_n_Sm.\nsimpl in |- *.\nelim plus_n_Sm.\nrepeat rewrite plus_assoc.\nrewrite\n (plus_permute2 (bool_to_nat a0 + BV_to_nat l) (BV_to_nat l0) (BV_to_nat l))\n .\nrewrite (plus_comm (bool_to_nat a0) (BV_to_nat l)).\nrewrite (plus_permute2 (BV_to_nat l) (bool_to_nat a0) (BV_to_nat l)).\ntrivial with arith.\n\nelim a0.\nsimpl in |- *.\nelim plus_n_Sm.\nsimpl in |- *.\nelim plus_n_O.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_Sm.\nelim plus_n_O.\nrepeat rewrite plus_assoc.\nrewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).\ntrivial with arith.\n\nsimpl in |- *.\nrepeat rewrite <- plus_n_Sm.\nrepeat rewrite <- plus_n_O.\nrepeat rewrite plus_assoc.\ntry trivial with arith.\nrewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).\ntry trivial with arith.\n\nelim a0.\nsimpl in |- *.\nrepeat rewrite <- plus_n_Sm.\nrepeat rewrite <- plus_n_O.\nrepeat rewrite plus_assoc.\nsimpl in |- *.\nrewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).\ntrivial with arith.\n\nsimpl in |- *.\nrepeat rewrite <- plus_n_O.\nrepeat rewrite plus_assoc.\nrewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).\ntrivial with arith.\n\nelim a0; simpl in |- *; repeat rewrite <- plus_n_Sm;\n repeat rewrite <- plus_n_O; repeat rewrite plus_assoc;\n rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l));\n trivial with arith.\n\n", "def_ranges": [61, 0, 64, 45], "proof_ranges": [65, 0, 177, 4], "proof_steps": [{"text": "simple induction v.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite BV_full_adder_sym.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite BV_full_adder_nil_ok.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold BV_full_adder in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction w.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_O.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_O.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(BV_to_nat l + bool_to_nat (half_adder_carry a cin) +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(BV_to_nat l + bool_to_nat (half_adder_carry a cin))) with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(bool_to_nat (half_adder_carry a cin) + bool_to_nat (half_adder_carry a cin) +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(BV_to_nat l + BV_to_nat l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(bool_to_nat (half_adder_sum a cin) + bool_to_nat (half_adder_carry a cin) +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "bool_to_nat (half_adder_carry a cin)) with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(bool_to_nat (half_adder_sum a cin) +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(bool_to_nat (half_adder_carry a cin) +", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "bool_to_nat (half_adder_carry a cin))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite half_adder_ok.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (plus_permute2 (bool_to_nat a) (bool_to_nat cin) (BV_to_nat l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus_permute2 (bool_to_nat a + BV_to_nat l) (bool_to_nat cin) (BV_to_nat l))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ".", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus_permute2 (bool_to_nat (half_adder_carry a cin))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(bool_to_nat (half_adder_carry a cin)) (BV_to_nat l))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ".", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (plus_comm (bool_to_nat (half_adder_carry a cin)) (BV_to_nat l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus_permute2 (BV_to_nat l + bool_to_nat (half_adder_carry a cin))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(bool_to_nat (half_adder_carry a cin)) (BV_to_nat l))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ".", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim cin; elim a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite full_adder_carry_sym1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite full_adder_carry_true.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite full_adder_sum_sym1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite full_adder_sum_true.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_n_SO.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus_permute2 (bool_to_nat a0 + BV_to_nat l) (BV_to_nat l0) (BV_to_nat l))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ".", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (plus_comm (bool_to_nat a0) (BV_to_nat l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (plus_permute2 (BV_to_nat l) (bool_to_nat a0) (BV_to_nat l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim a0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_O.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim plus_n_O.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite <- plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite <- plus_n_O.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "try trivial with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "try trivial with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim a0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite <- plus_n_Sm.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite <- plus_n_O.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite plus_assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (plus_permute2 (BV_to_nat l) (BV_to_nat l0) (BV_to_nat l)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/circuits/ADDER/HalfAdder.v", "name": "half_adder_ok", "text": "Theorem half_adder_ok :\n forall a b : bool,\n bool_to_nat (half_adder_sum a b) +\n (bool_to_nat (half_adder_carry a b) + bool_to_nat (half_adder_carry a b)) =\n bool_to_nat a + bool_to_nat b.\nsimple induction a; simple induction b; auto.\nQed.\n", "definition": "\n forall a b : bool,\n bool_to_nat (half_adder_sum a b) +\n (bool_to_nat (half_adder_carry a b) + bool_to_nat (half_adder_carry a b)) =\n bool_to_nat a + bool_to_nat b.", "proof": "\nsimple induction a; simple induction b; auto.\n", "def_ranges": [73, 0, 77, 31], "proof_ranges": [78, 0, 79, 4], "proof_steps": [{"text": "simple induction a; simple induction b; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/circuits/ADDER/FullAdder.v", "name": "full_adder_ok", "text": "Theorem full_adder_ok :\n forall a b c : bool,\n bool_to_nat (full_adder_sum a b c) +\n (bool_to_nat (full_adder_carry a b c) + bool_to_nat (full_adder_carry a b c)) =\n bool_to_nat a + bool_to_nat b + bool_to_nat c.\nsimple induction a; simple induction b; simple induction c; auto.\nQed.\n", "definition": "\n forall a b c : bool,\n bool_to_nat (full_adder_sum a b c) +\n (bool_to_nat (full_adder_carry a b c) + bool_to_nat (full_adder_carry a b c)) =\n bool_to_nat a + bool_to_nat b + bool_to_nat c.", "proof": "\nsimple induction a; simple induction b; simple induction c; auto.\n", "def_ranges": [131, 0, 135, 47], "proof_ranges": [136, 0, 137, 4], "proof_steps": [{"text": "simple induction a; simple induction b; simple induction c; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/circuits/BLOCK/Fill_proof.v", "name": "Fill_ok", "text": "Theorem Fill_ok :\n forall t : nat,\n di t di_init cx_init al_init mem_init =\n di' t di_init cx_init al_init mem_init DC_a DC_d /\\\n cx t di_init cx_init al_init mem_init =\n cx' t di_init cx_init al_init mem_init DC_a DC_d /\\\n al t di_init cx_init al_init mem_init =\n al' t di_init cx_init al_init mem_init DC_a DC_d /\\\n mem t di_init cx_init al_init mem_init =\n mem' t di_init cx_init al_init mem_init DC_a DC_d.\nsplit. apply di_di'.\nsplit. apply cx_cx'.\nsplit. apply al_al'. apply mem_mem'.\nQed.\n", "definition": "\n forall t : nat,\n di t di_init cx_init al_init mem_init =\n di' t di_init cx_init al_init mem_init DC_a DC_d /\\\n cx t di_init cx_init al_init mem_init =\n cx' t di_init cx_init al_init mem_init DC_a DC_d /\\\n al t di_init cx_init al_init mem_init =\n al' t di_init cx_init al_init mem_init DC_a DC_d /\\\n mem t di_init cx_init al_init mem_init =\n mem' t di_init cx_init al_init mem_init DC_a DC_d.", "proof": "\nsplit. apply di_di'.\nsplit. apply cx_cx'.\nsplit. apply al_al'. apply mem_mem'.\n", "def_ranges": [117, 0, 126, 51], "proof_ranges": [127, 0, 130, 4], "proof_steps": [{"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply di_di'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply cx_cx'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply al_al'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply mem_mem'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/circuits/GENE/Arith_compl.v", "name": "le_plus_n_m", "text": "Theorem le_plus_n_m : forall n m : nat, n <= m -> n + n <= m + m.\nsimple induction n. auto with arith.\nintros. inversion H0. auto with arith.\nsimpl in |- *. elim plus_n_Sm. elim plus_n_Sm.\napply le_n_S. apply le_n_S. apply H. apply le_Sn_le. exact H1.\nQed. Hint Resolve le_plus_n_m.\n", "definition": " forall n m : nat, n <= m -> n + n <= m + m.", "proof": "\nsimple induction n. auto with arith.\nintros. inversion H0. auto with arith.\nsimpl in |- *. elim plus_n_Sm. elim plus_n_Sm.\napply le_n_S. apply le_n_S. apply H. apply le_Sn_le. exact H1.\n", "def_ranges": [122, 0, 122, 65], "proof_ranges": [123, 0, 127, 4], "proof_steps": [{"text": "simple induction n.", "goal_before": ["forall n m : nat, n <= m -> n + n <= m + m"], "goal_after": ["forall m : nat, 0 <= m -> 0 + 0 <= m + m", "forall n0 : nat,\n(forall m : nat, n0 <= m -> n0 + n0 <= m + m) ->\nforall m : nat, S n0 <= m -> S n0 + S n0 <= m + m"], "proof_term_before": [], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m) \n   ?Goal ?Goal0 n)"]}, {"text": "auto with arith.", "goal_before": ["forall m : nat, 0 <= m -> 0 + 0 <= m + m", "forall n0 : nat,\n(forall m : nat, n0 <= m -> n0 + n0 <= m + m) ->\nforall m : nat, S n0 <= m -> S n0 + S n0 <= m + m"], "goal_after": ["forall n0 : nat,\n(forall m : nat, n0 <= m -> n0 + n0 <= m + m) ->\nforall m : nat, S n0 <= m -> S n0 + S n0 <= m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m) \n   ?Goal ?Goal0 n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m)) \n   ?Goal n)"]}, {"text": "intros.", "goal_before": ["forall n0 : nat,\n(forall m : nat, n0 <= m -> n0 + n0 <= m + m) ->\nforall m : nat, S n0 <= m -> S n0 + S n0 <= m + m"], "goal_after": ["S n0 + S n0 <= m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m)) \n   ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) => ?Goal) n)"]}, {"text": "inversion H0.", "goal_before": ["S n0 + S n0 <= m + m"], "goal_after": ["S n0 + S n0 <= S n0 + S n0", "S n0 + S n0 <= S m0 + S m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) => ?Goal) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             ?Goal@{H1:=H2} m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 => ?Goal0@{m0:=m1; H1:=H5; H2:=H3}) m H4)\n             H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "auto with arith.", "goal_before": ["S n0 + S n0 <= S n0 + S n0", "S n0 + S n0 <= S m0 + S m0"], "goal_after": ["S n0 + S n0 <= S m0 + S m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             ?Goal@{H1:=H2} m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 => ?Goal0@{m0:=m1; H1:=H5; H2:=H3}) m H4)\n             H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 => ?Goal@{m0:=m1; H1:=H5; H2:=H3}) m H4)\n             H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "simpl in |- *.", "goal_before": ["S n0 + S n0 <= S m0 + S m0"], "goal_after": ["S (n0 + S n0) <= S (m0 + S m0)"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 => ?Goal@{m0:=m1; H1:=H5; H2:=H3}) m H4)\n             H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               ?Goal@{m0:=m1; H1:=H5; H2:=H3} : S n0 + S n0 <= S m1 + S m1) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "elim plus_n_Sm.", "goal_before": ["S (n0 + S n0) <= S (m0 + S m0)"], "goal_after": ["S (S (n0 + n0)) <= S (m0 + S m0)"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               ?Goal@{m0:=m1; H1:=H5; H2:=H3} : S n0 + S n0 <= S m1 + S m1) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 ?Goal@{m0:=m1; H1:=H5; H2:=H3} (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "elim plus_n_Sm.", "goal_before": ["S (S (n0 + n0)) <= S (m0 + S m0)"], "goal_after": ["S (S (n0 + n0)) <= S (S (m0 + m0))"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 ?Goal@{m0:=m1; H1:=H5; H2:=H3} (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    ?Goal@{m0:=m1; H1:=H5; H2:=H3} \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply le_n_S.", "goal_before": ["S (S (n0 + n0)) <= S (S (m0 + m0))"], "goal_after": ["S (n0 + n0) <= S (m0 + m0)"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    ?Goal@{m0:=m1; H1:=H5; H2:=H3} \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       ?Goal@{m0:=m1; H1:=H5; H2:=H3}) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply le_n_S.", "goal_before": ["S (n0 + n0) <= S (m0 + m0)"], "goal_after": ["n0 + n0 <= m0 + m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       ?Goal@{m0:=m1; H1:=H5; H2:=H3}) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       (le_n_S (n0 + n0) (m1 + m1)\n                          ?Goal@{m0:=m1; H1:=H5; H2:=H3})) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply H.", "goal_before": ["n0 + n0 <= m0 + m0"], "goal_after": ["n0 <= m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       (le_n_S (n0 + n0) (m1 + m1)\n                          ?Goal@{m0:=m1; H1:=H5; H2:=H3})) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       (le_n_S (n0 + n0) (m1 + m1)\n                          (H m1 ?Goal@{m0:=m1; H1:=H5; H2:=H3}))) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply le_Sn_le.", "goal_before": ["n0 <= m0"], "goal_after": ["S n0 <= m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       (le_n_S (n0 + n0) (m1 + m1)\n                          (H m1 ?Goal@{m0:=m1; H1:=H5; H2:=H3}))) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       (le_n_S (n0 + n0) (m1 + m1)\n                          (H m1\n                             (le_Sn_le n0 m1 ?Goal@{m0:=m1; H1:=H5; H2:=H3}))))\n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "exact H1.", "goal_before": ["S n0 <= m0"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       (le_n_S (n0 + n0) (m1 + m1)\n                          (H m1\n                             (le_Sn_le n0 m1 ?Goal@{m0:=m1; H1:=H5; H2:=H3}))))\n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       (le_n_S (n0 + n0) (m1 + m1) (H m1 (le_Sn_le n0 m1 H5))))\n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n   (fun (m : nat) (_ : 0 <= m) => Nat.le_0_l (m + m))\n   (fun (n0 : nat) (H : forall m : nat, n0 <= m -> n0 + n0 <= m + m)\n      (m : nat) (H0 : S n0 <= m) =>\n    let H1 : m = m -> S n0 + S n0 <= m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S n0 + S n0 <= m + m) with\n      | le_n _ =>\n          fun H1 : S n0 = m =>\n          (fun H2 : S n0 = m =>\n           let H3 : S n0 = m := H2 in\n           eq_ind (S n0) (fun n1 : nat => S n0 + S n0 <= n1 + n1)\n             (le_n (S n0 + S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S n0 <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S n0 <= m1 -> S n0 + S n0 <= n1 + n1)\n              (fun H5 : S n0 <= m1 =>\n               eq_ind (S (n0 + n0)) (fun n1 : nat => S n1 <= S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (n0 + n0)) <= S n1)\n                    (le_n_S (S (n0 + n0)) (S (m1 + m1))\n                       (le_n_S (n0 + n0) (m1 + m1) (H m1 (le_Sn_le n0 m1 H5))))\n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S n0 + S n0 <= S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/circuits/GENE/Arith_compl.v", "name": "lt_plus_n_m", "text": "Theorem lt_plus_n_m : forall n m : nat, n < m -> S (n + n) < m + m.\nsimple induction n.\nsimpl in |- *. simple induction m. simpl in |- *. intros. absurd (0 < 0). apply le_not_lt. auto with arith.\nexact H.\nintros. simpl in |- *. elim plus_n_Sm. apply lt_n_S. auto with arith.\nintros. inversion H0. simpl in |- *. repeat elim plus_n_Sm. auto with arith.\nsimpl in |- *.\nrepeat elim plus_n_Sm. apply lt_n_S. apply lt_n_S. apply H. inversion H1. auto with arith.\napply le_lt_n_Sm. apply le_Sn_le. apply le_Sn_le. exact H3.\nQed.\n", "definition": " forall n m : nat, n < m -> S (n + n) < m + m.", "proof": "\nsimple induction n.\nsimpl in |- *. simple induction m. simpl in |- *. intros. absurd (0 < 0). apply le_not_lt. auto with arith.\nexact H.\nintros. simpl in |- *. elim plus_n_Sm. apply lt_n_S. auto with arith.\nintros. inversion H0. simpl in |- *. repeat elim plus_n_Sm. auto with arith.\nsimpl in |- *.\nrepeat elim plus_n_Sm. apply lt_n_S. apply lt_n_S. apply H. inversion H1. auto with arith.\napply le_lt_n_Sm. apply le_Sn_le. apply le_Sn_le. exact H3.\n", "def_ranges": [129, 0, 129, 67], "proof_ranges": [130, 0, 138, 4], "proof_steps": [{"text": "simple induction n.", "goal_before": ["forall n m : nat, n < m -> S (n + n) < m + m"], "goal_after": ["forall m : nat, 0 < m -> S (0 + 0) < m + m", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": [], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ?Goal ?Goal0 n)"]}, {"text": "simpl in |- *.", "goal_before": ["forall m : nat, 0 < m -> S (0 + 0) < m + m", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["forall m : nat, 0 < m -> 1 < m + m", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ?Goal ?Goal0 n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   (?Goal0 : forall m : nat, 0 < m -> S (0 + 0) < m + m) \n   ?Goal n)"]}, {"text": "simple induction m.", "goal_before": ["forall m : nat, 0 < m -> 1 < m + m", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["0 < 0 -> 1 < 0 + 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   (?Goal0 : forall m : nat, 0 < m -> S (0 + 0) < m + m) \n   ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0) ?Goal0 ?Goal1 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "simpl in |- *.", "goal_before": ["0 < 0 -> 1 < 0 + 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["0 < 0 -> 1 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0) ?Goal0 ?Goal1 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       (?Goal1 : 0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "intros.", "goal_before": ["0 < 0 -> 1 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["1 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       (?Goal1 : 0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => ?Goal1) : 0 < 0 -> 1 < 0 + 0) \n       ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "absurd (0 < 0).", "goal_before": ["1 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["~ 0 < 0", "0 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => ?Goal1) : 0 < 0 -> 1 < 0 + 0) \n       ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (?Goal1 ?Goal2))\n        :\n        0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "apply le_not_lt.", "goal_before": ["~ 0 < 0", "0 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["0 <= 0", "0 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (?Goal1 ?Goal2))\n        :\n        0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 ?Goal2 ?Goal1))\n        :\n        0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "auto with arith.", "goal_before": ["0 <= 0", "0 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["0 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 ?Goal2 ?Goal1))\n        :\n        0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) ?Goal1))\n        :\n        0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "exact H.", "goal_before": ["0 < 0", "forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) ?Goal1))\n        :\n        0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "intros.", "goal_before": ["forall n0 : nat, (0 < n0 -> 1 < n0 + n0) -> 0 < S n0 -> 1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0) ?Goal0 m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (H : 0 < n0 -> 1 < n0 + n0) (H0 : 0 < S n0) => ?Goal0)\n       m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "simpl in |- *.", "goal_before": ["1 < S n0 + S n0", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["1 < S (n0 + S n0)", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (H : 0 < n0 -> 1 < n0 + n0) (H0 : 0 < S n0) => ?Goal0)\n       m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (H : 0 < n0 -> 1 < n0 + n0) (H0 : 0 < S n0) =>\n        ?Goal0 : 1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "elim plus_n_Sm.", "goal_before": ["1 < S (n0 + S n0)", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["1 < S (S (n0 + n0))", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (H : 0 < n0 -> 1 < n0 + n0) (H0 : 0 < S n0) =>\n        ?Goal0 : 1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (H : 0 < n0 -> 1 < n0 + n0) (H0 : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1) \n          ?Goal0 (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "apply lt_n_S.", "goal_before": ["1 < S (S (n0 + n0))", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["0 < S (n0 + n0)", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (H : 0 < n0 -> 1 < n0 + n0) (H0 : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1) \n          ?Goal0 (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (H : 0 < n0 -> 1 < n0 + n0) (H0 : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0)) ?Goal0) (n0 + S n0) \n          (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "auto with arith.", "goal_before": ["0 < S (n0 + n0)", "forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (H : 0 < n0 -> 1 < n0 + n0) (H0 : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0)) ?Goal0) (n0 + S n0) \n          (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"]}, {"text": "intros.", "goal_before": ["forall n0 : nat,\n(forall m : nat, n0 < m -> S (n0 + n0) < m + m) ->\nforall m : nat, S n0 < m -> S (S n0 + S n0) < m + m"], "goal_after": ["S (S n0 + S n0) < m + m"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m) ?Goal n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) => ?Goal) n)"]}, {"text": "inversion H0.", "goal_before": ["S (S n0 + S n0) < m + m"], "goal_after": ["S (S n0 + S n0) < S (S n0) + S (S n0)", "S (S n0 + S n0) < S m0 + S m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) => ?Goal) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             ?Goal@{H1:=H2} m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 => ?Goal0@{m0:=m1; H1:=H5; H2:=H3}) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "simpl in |- *.", "goal_before": ["S (S n0 + S n0) < S (S n0) + S (S n0)", "S (S n0 + S n0) < S m0 + S m0"], "goal_after": ["S (S (n0 + S n0)) < S (S (n0 + S (S n0)))", "S (S n0 + S n0) < S m0 + S m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             ?Goal@{H1:=H2} m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 => ?Goal0@{m0:=m1; H1:=H5; H2:=H3}) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (?Goal0@{H1:=H2} : S (S n0 + S n0) < S (S n0) + S (S n0)) m H3)\n            H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 => ?Goal@{m0:=m1; H1:=H5; H2:=H3}) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "repeat elim plus_n_Sm.", "goal_before": ["S (S (n0 + S n0)) < S (S (n0 + S (S n0)))", "S (S n0 + S n0) < S m0 + S m0"], "goal_after": ["S (S (S (n0 + n0))) < S (S (S (S (n0 + n0))))", "S (S n0 + S n0) < S m0 + S m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (?Goal0@{H1:=H2} : S (S n0 + S n0) < S (S n0) + S (S n0)) m H3)\n            H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 => ?Goal@{m0:=m1; H1:=H5; H2:=H3}) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      ?Goal0@{H1:=H2} (n0 + S n0) \n                      (plus_n_Sm n0 n0)) (n0 + S (S n0))\n                   (plus_n_Sm n0 (S n0))) (n0 + S n0) \n                (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 => ?Goal@{m0:=m1; H1:=H5; H2:=H3}) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "auto with arith.", "goal_before": ["S (S (S (n0 + n0))) < S (S (S (S (n0 + n0))))", "S (S n0 + S n0) < S m0 + S m0"], "goal_after": ["S (S n0 + S n0) < S m0 + S m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      ?Goal0@{H1:=H2} (n0 + S n0) \n                      (plus_n_Sm n0 n0)) (n0 + S (S n0))\n                   (plus_n_Sm n0 (S n0))) (n0 + S n0) \n                (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 => ?Goal@{m0:=m1; H1:=H5; H2:=H3}) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 => ?Goal@{m0:=m1; H1:=H5; H2:=H3}) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "simpl in |- *.", "goal_before": ["S (S n0 + S n0) < S m0 + S m0"], "goal_after": ["S (S (n0 + S n0)) < S (m0 + S m0)"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 => ?Goal@{m0:=m1; H1:=H5; H2:=H3}) m\n              H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               ?Goal@{m0:=m1; H1:=H5; H2:=H3} : S (S n0 + S n0) < S m1 + S m1)\n              m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "repeat elim plus_n_Sm.", "goal_before": ["S (S (n0 + S n0)) < S (m0 + S m0)"], "goal_after": ["S (S (S (n0 + n0))) < S (S (m0 + m0))"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               ?Goal@{m0:=m1; H1:=H5; H2:=H3} : S (S n0 + S n0) < S m1 + S m1)\n              m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    ?Goal@{m0:=m1; H1:=H5; H2:=H3} \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply lt_n_S.", "goal_before": ["S (S (S (n0 + n0))) < S (S (m0 + m0))"], "goal_after": ["S (S (n0 + n0)) < S (m0 + m0)"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    ?Goal@{m0:=m1; H1:=H5; H2:=H3} \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       ?Goal@{m0:=m1; H1:=H5; H2:=H3}) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply lt_n_S.", "goal_before": ["S (S (n0 + n0)) < S (m0 + m0)"], "goal_after": ["S (n0 + n0) < m0 + m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       ?Goal@{m0:=m1; H1:=H5; H2:=H3}) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          ?Goal@{m0:=m1; H1:=H5; H2:=H3})) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply H.", "goal_before": ["S (n0 + n0) < m0 + m0"], "goal_after": ["n0 < m0"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          ?Goal@{m0:=m1; H1:=H5; H2:=H3})) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1 ?Goal@{m0:=m1; H1:=H5; H2:=H3}))) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "inversion H1.", "goal_before": ["n0 < m0"], "goal_after": ["n0 < S (S n0)", "n0 < S m1"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1 ?Goal@{m0:=m1; H1:=H5; H2:=H3}))) \n                    (m1 + S m1) (plus_n_Sm m1 m1)) \n                 (n0 + S n0) (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       ?Goal@{m0:=m1; H1:=H5; H2:=H3; H3:=H7}\n                                       m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         ?Goal0@{m0:=m1; H1:=H5; H2:=H3;\n                                                 m1:=m3; H3:=H10; H4:=H8}) m1\n                                        H9) H7 H6) m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "auto with arith.", "goal_before": ["n0 < S (S n0)", "n0 < S m1"], "goal_after": ["n0 < S m1"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       ?Goal@{m0:=m1; H1:=H5; H2:=H3; H3:=H7}\n                                       m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         ?Goal0@{m0:=m1; H1:=H5; H2:=H3;\n                                                 m1:=m3; H3:=H10; H4:=H8}) m1\n                                        H9) H7 H6) m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         ?Goal@{m0:=m1; H1:=H5; H2:=H3;\n                                                m1:=m3; H3:=H10; H4:=H8}) m1\n                                        H9) H7 H6) m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply le_lt_n_Sm.", "goal_before": ["n0 < S m1"], "goal_after": ["n0 <= m1"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         ?Goal@{m0:=m1; H1:=H5; H2:=H3;\n                                                m1:=m3; H3:=H10; H4:=H8}) m1\n                                        H9) H7 H6) m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         Arith_prebase.le_lt_n_Sm_stt n0 m3\n                                           ?Goal@{\n                                           m0:=m1; H1:=H5; H2:=H3; m1:=m3;\n                                           H3:=H10; H4:=H8}) m1 H9) H7 H6) m2\n                                      x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply le_Sn_le.", "goal_before": ["n0 <= m1"], "goal_after": ["S n0 <= m1"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         Arith_prebase.le_lt_n_Sm_stt n0 m3\n                                           ?Goal@{\n                                           m0:=m1; H1:=H5; H2:=H3; m1:=m3;\n                                           H3:=H10; H4:=H8}) m1 H9) H7 H6) m2\n                                      x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         Arith_prebase.le_lt_n_Sm_stt n0 m3\n                                           (le_Sn_le n0 m3\n                                              ?Goal@{\n                                              m0:=m1; H1:=H5; H2:=H3; m1:=m3;\n                                              H3:=H10; H4:=H8})) m1 H9) H7 H6)\n                                      m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "apply le_Sn_le.", "goal_before": ["S n0 <= m1"], "goal_after": ["S (S n0) <= m1"], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         Arith_prebase.le_lt_n_Sm_stt n0 m3\n                                           (le_Sn_le n0 m3\n                                              ?Goal@{\n                                              m0:=m1; H1:=H5; H2:=H3; m1:=m3;\n                                              H3:=H10; H4:=H8})) m1 H9) H7 H6)\n                                      m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         Arith_prebase.le_lt_n_Sm_stt n0 m3\n                                           (le_Sn_le n0 m3\n                                              (le_Sn_le \n                                                 (S n0) m3\n                                                 ?Goal@{\n                                                 m0:=m1; H1:=H5; H2:=H3;\n                                                 m1:=m3; H3:=H10; H4:=H8})))\n                                        m1 H9) H7 H6) m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "exact H3.", "goal_before": ["S (S n0) <= m1"], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         Arith_prebase.le_lt_n_Sm_stt n0 m3\n                                           (le_Sn_le n0 m3\n                                              (le_Sn_le \n                                                 (S n0) m3\n                                                 ?Goal@{\n                                                 m0:=m1; H1:=H5; H2:=H3;\n                                                 m1:=m3; H3:=H10; H4:=H8})))\n                                        m1 H9) H7 H6) m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         Arith_prebase.le_lt_n_Sm_stt n0 m3\n                                           (le_Sn_le n0 m3\n                                              (le_Sn_le (S n0) m3 H10))) m1\n                                        H9) H7 H6) m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat =>\n nat_ind (fun n0 : nat => forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n   ((fun m : nat =>\n     nat_ind (fun m0 : nat => 0 < m0 -> 1 < m0 + m0)\n       ((fun H : 0 < 0 => False_ind (1 < 0) (le_not_lt 0 0 (le_n 0) H))\n        :\n        0 < 0 -> 1 < 0 + 0)\n       (fun (n0 : nat) (_ : 0 < n0 -> 1 < n0 + n0) (_ : 0 < S n0) =>\n        eq_ind (S (n0 + n0)) (fun n1 : nat => 1 < S n1)\n          (lt_n_S 0 (S (n0 + n0))\n             (Nat.le_add_r 1 (n0 + n0) : 0 < S (n0 + n0))) \n          (n0 + S n0) (plus_n_Sm n0 n0)\n        :\n        1 < S n0 + S n0) m)\n    :\n    forall m : nat, 0 < m -> S (0 + 0) < m + m)\n   (fun (n0 : nat) (H : forall m : nat, n0 < m -> S (n0 + n0) < m + m)\n      (m : nat) (H0 : S n0 < m) =>\n    let H1 : m = m -> S (S n0 + S n0) < m + m :=\n      match H0 in (_ <= n1) return (n1 = m -> S (S n0 + S n0) < m + m) with\n      | le_n _ =>\n          fun H1 : S (S n0) = m =>\n          (fun H2 : S (S n0) = m =>\n           let H3 : S (S n0) = m := H2 in\n           eq_ind (S (S n0)) (fun n1 : nat => S (S n0 + S n0) < n1 + n1)\n             (eq_ind (S (n0 + n0))\n                (fun n1 : nat => S (S n1) < S (S (n0 + S (S n0))))\n                (eq_ind (S (n0 + S n0))\n                   (fun n1 : nat => S (S (S (n0 + n0))) < S (S n1))\n                   (eq_ind (S (n0 + n0))\n                      (fun n1 : nat => S (S (S (n0 + n0))) < S (S (S n1)))\n                      (le_n (S (S (S (S (n0 + n0)))))\n                       :\n                       S (S (S (n0 + n0))) < S (S (S (S (n0 + n0)))))\n                      (n0 + S n0) (plus_n_Sm n0 n0)) \n                   (n0 + S (S n0)) (plus_n_Sm n0 (S n0))) \n                (n0 + S n0) (plus_n_Sm n0 n0)\n              :\n              S (S n0 + S n0) < S (S n0) + S (S n0)) m H3) H1\n      | le_S _ m0 x =>\n          (fun (m1 : nat) (H1 : S (S n0) <= m1) (H2 : S m1 = m) =>\n           (fun H3 : S m1 = m =>\n            let H4 : S m1 = m := H3 in\n            eq_ind (S m1)\n              (fun n1 : nat => S (S n0) <= m1 -> S (S n0 + S n0) < n1 + n1)\n              (fun H5 : S (S n0) <= m1 =>\n               eq_ind (S (n0 + n0))\n                 (fun n1 : nat => S (S n1) < S (m1 + S m1))\n                 (eq_ind (S (m1 + m1))\n                    (fun n1 : nat => S (S (S (n0 + n0))) < S n1)\n                    (lt_n_S (S (S (n0 + n0))) (S (m1 + m1))\n                       (lt_n_S (S (n0 + n0)) (m1 + m1)\n                          (H m1\n                             (let H6 : m1 = m1 -> n0 < m1 :=\n                                match\n                                  H5 in (_ <= n1) return (n1 = m1 -> n0 < m1)\n                                with\n                                | le_n _ =>\n                                    fun H6 : S (S n0) = m1 =>\n                                    (fun H7 : S (S n0) = m1 =>\n                                     let H8 : S (S n0) = m1 := H7 in\n                                     eq_ind (S (S n0))\n                                       (fun n1 : nat => n0 < n1)\n                                       (le_S (S n0) (S n0) (le_n (S n0))\n                                        :\n                                        n0 < S (S n0)) m1 H8) H6\n                                | le_S _ m2 x0 =>\n                                    (fun (m3 : nat) \n                                       (H6 : S (S n0) <= m3) \n                                       (H7 : S m3 = m1) =>\n                                     (fun H8 : S m3 = m1 =>\n                                      let H9 : S m3 = m1 := H8 in\n                                      eq_ind (S m3)\n                                        (fun n1 : nat =>\n                                         S (S n0) <= m3 -> n0 < n1)\n                                        (fun H10 : S (S n0) <= m3 =>\n                                         Arith_prebase.le_lt_n_Sm_stt n0 m3\n                                           (le_Sn_le n0 m3\n                                              (le_Sn_le (S n0) m3 H10))) m1\n                                        H9) H7 H6) m2 x0\n                                end in\n                              H6 eq_refl)))) (m1 + S m1) \n                    (plus_n_Sm m1 m1)) (n0 + S n0) \n                 (plus_n_Sm n0 n0)\n               :\n               S (S n0 + S n0) < S m1 + S m1) m H4) H2 H1) m0 x\n      end in\n    H1 eq_refl) n)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/higman-s/higman.v", "name": "Higman", "text": "Theorem Higman : \n  Acc (continues leA) nil -> Acc (continues embeds) nil.\nProof.\nintro wqo_leA; apply (higman_aux wqo_leA) with (f:=nil (A := Tree)).\napply acc_ltF_nil.\nsplit; simpl; trivial.\nunfold is_forest; constructor 1 with (leA := leA) (leA_dec := leA_dec).\nintro HF; inversion HF; trivial.\nQed.\n", "definition": " \n  Acc (continues leA) nil -> Acc (continues embeds) nil.\n", "proof": "\nintro wqo_leA; apply (higman_aux wqo_leA) with (f:=nil (A := Tree)).\napply acc_ltF_nil.\nsplit; simpl; trivial.\nunfold is_forest; constructor 1 with (leA := leA) (leA_dec := leA_dec).\nintro HF; inversion HF; trivial.\n", "def_ranges": [296, 0, 297, 56], "proof_ranges": [298, 0, 304, 4], "proof_steps": [{"text": "intro wqo_leA; apply (higman_aux wqo_leA) with (f:=nil (A := Tree)).", "goal_before": ["Acc (continues leA) nil -> Acc (continues embeds) nil"], "goal_after": ["Acc ltF nil", "nil = bad_subsequence leA leA_dec (firsts nil) /\\ is_forest nil nil", "bad embeds nil"], "proof_term_before": [], "proof_term_after": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA ?Goal ?Goal0 ?Goal1)"]}, {"text": "apply acc_ltF_nil.", "goal_before": ["Acc ltF nil", "nil = bad_subsequence leA leA_dec (firsts nil) /\\ is_forest nil nil", "bad embeds nil"], "goal_after": ["nil = bad_subsequence leA leA_dec (firsts nil) /\\ is_forest nil nil", "bad embeds nil"], "proof_term_before": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA ?Goal ?Goal0 ?Goal1)"], "proof_term_after": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA acc_ltF_nil ?Goal ?Goal0)"]}, {"text": "split; simpl; trivial.", "goal_before": ["nil = bad_subsequence leA leA_dec (firsts nil) /\\ is_forest nil nil", "bad embeds nil"], "goal_after": ["is_forest nil nil", "bad embeds nil"], "proof_term_before": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA acc_ltF_nil ?Goal ?Goal0)"], "proof_term_after": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA acc_ltF_nil\n   (conj (eq_refl : nil = bad_subsequence leA leA_dec (firsts nil))\n      (?Goal0 : is_forest nil nil)) ?Goal)"]}, {"text": "unfold is_forest; constructor 1 with (leA := leA) (leA_dec := leA_dec).", "goal_before": ["is_forest nil nil", "bad embeds nil"], "goal_after": ["bad embeds nil"], "proof_term_before": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA acc_ltF_nil\n   (conj (eq_refl : nil = bad_subsequence leA leA_dec (firsts nil))\n      (?Goal0 : is_forest nil nil)) ?Goal)"], "proof_term_after": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA acc_ltF_nil\n   (conj (eq_refl : nil = bad_subsequence leA leA_dec (firsts nil))\n      ((is_f0 leA leA_dec : is_forest nil nil) : is_forest nil nil)) \n   ?Goal)"]}, {"text": "intro HF; inversion HF; trivial.", "goal_before": ["bad embeds nil"], "goal_after": [], "proof_term_before": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA acc_ltF_nil\n   (conj (eq_refl : nil = bad_subsequence leA leA_dec (firsts nil))\n      ((is_f0 leA leA_dec : is_forest nil nil) : is_forest nil nil)) \n   ?Goal)"], "proof_term_after": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA acc_ltF_nil\n   (conj (eq_refl : nil = bad_subsequence leA leA_dec (firsts nil))\n      ((is_f0 leA leA_dec : is_forest nil nil) : is_forest nil nil))\n   ((fun HF : good embeds nil =>\n     let H : nil = nil -> False :=\n       match HF in (good _ l) return (l = nil -> False) with\n       | @Gd0 _ _ a w x =>\n           (fun (a0 : list A) (w0 : list (list A)) \n              (H : greater embeds a0 w0) (H0 : a0 :: w0 = nil) =>\n            (fun H1 : a0 :: w0 = nil =>\n             let H2 : False :=\n               eq_ind (a0 :: w0)\n                 (fun e : list (list A) =>\n                  match e with\n                  | nil => False\n                  | _ :: _ => True\n                  end) I nil H1 in\n             False_ind (greater embeds a0 w0 -> False) H2) H0 H) a w x\n       | @Gd1 _ _ a w x =>\n           (fun (a0 : list A) (w0 : list (list A)) \n              (H : good embeds w0) (H0 : a0 :: w0 = nil) =>\n            (fun H1 : a0 :: w0 = nil =>\n             let H2 : False :=\n               eq_ind (a0 :: w0)\n                 (fun e : list (list A) =>\n                  match e with\n                  | nil => False\n                  | _ :: _ => True\n                  end) I nil H1 in\n             False_ind (good embeds w0 -> False) H2) H0 H) a w x\n       end in\n     H eq_refl)\n    :\n    bad embeds nil))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun wqo_leA : Acc (continues leA) nil =>\n higman_aux wqo_leA acc_ltF_nil\n   (conj (eq_refl : nil = bad_subsequence leA leA_dec (firsts nil))\n      ((is_f0 leA leA_dec : is_forest nil nil) : is_forest nil nil))\n   ((fun HF : good embeds nil =>\n     let H : nil = nil -> False :=\n       match HF in (good _ l) return (l = nil -> False) with\n       | @Gd0 _ _ a w x =>\n           (fun (a0 : list A) (w0 : list (list A)) \n              (H : greater embeds a0 w0) (H0 : a0 :: w0 = nil) =>\n            (fun H1 : a0 :: w0 = nil =>\n             let H2 : False :=\n               eq_ind (a0 :: w0)\n                 (fun e : list (list A) =>\n                  match e with\n                  | nil => False\n                  | _ :: _ => True\n                  end) I nil H1 in\n             False_ind (greater embeds a0 w0 -> False) H2) H0 H) a w x\n       | @Gd1 _ _ a w x =>\n           (fun (a0 : list A) (w0 : list (list A)) \n              (H : good embeds w0) (H0 : a0 :: w0 = nil) =>\n            (fun H1 : a0 :: w0 = nil =>\n             let H2 : False :=\n               eq_ind (a0 :: w0)\n                 (fun e : list (list A) =>\n                  match e with\n                  | nil => False\n                  | _ :: _ => True\n                  end) I nil H1 in\n             False_ind (good embeds w0 -> False) H2) H0 H) a w x\n       end in\n     H eq_refl)\n    :\n    bad embeds nil))"], "proof_term_after": []}], "ends_qed": true}]