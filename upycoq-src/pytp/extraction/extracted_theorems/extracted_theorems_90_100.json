[{"path": "/home/jizej/proverbot9001/coq-projects/group-theory/g3.v", "name": "remaining", "text": "Theorem remaining :\n forall a : U,\n In U H a ->\n exists r : nat, (exists m : nat, phi a r = phi a (S (S (r + m)))).\nProof.\nintros a ainH.\nlapply (not_injective_elim nat U (psi a));\n [ intro H'2 | apply psi_not_inj; auto ].\nelim H'2; clear H'2.\nintros x H'.\nelim H'; clear H'.\nintros x0 H'0; elim H'0; clear H'0.\nintros H'0 H'1.\nunfold psi in H'0; simpl in H'0.\ncut (x0 <> x).\n2: red in |- *; intro H'4; apply H'1; rewrite <- H'4; auto.\nintro H'.\nelim (nat_total_order x0 x).\nclear H'1 H'.\nintro H'.\nlapply (discrete_nat x0 x); [ intro H'4 | assumption ].\nelim H'4; intro H'1; clear H'4.\nexists x0; exists 0.\ngeneralize H'0.\nrewrite <- H'1.\nrewrite <- (tech_exp a x0).\nintro H'3.\nlapply (sym_eq (x:=phi a x0) (y:=star (phi a x0) a));\n [ intro H'9 | rewrite H'3; auto ].\nlapply (cancellation' (phi a x0) a); [ intro H'8 | assumption ].\nrewrite H'8.\nrewrite (tech_exp' x0).\nrewrite (tech_exp' (S (S (x0 + 0)))); auto.\nauto.\nelim H'1; intros r E; clear H'1.\nexists x0; exists r.\nrewrite <- E; auto.\nclear H'1 H'.\nintro H'.\nlapply (discrete_nat x x0); [ intro H'4 | assumption ].\nelim H'4; intro H'1; clear H'4.\nexists x; exists 0.\ngeneralize H'0.\nrewrite <- H'1.\nrewrite <- (tech_exp a x).\nintro H'3.\nlapply (cancellation' (phi a x) a); [ intro H'8 | rewrite <- H'3; auto ].\nrewrite H'8.\nrewrite (tech_exp' x).\nrewrite (tech_exp' (S (S (x + 0)))); auto.\nauto.\nelim H'1; intros r E; clear H'1.\nexists x; exists r.\nrewrite <- E; auto.\nauto.\nQed.\n", "definition": "\n forall a : U,\n In U H a ->\n exists r : nat, (exists m : nat, phi a r = phi a (S (S (r + m)))).\n", "proof": "\nintros a ainH.\nlapply (not_injective_elim nat U (psi a));\n [ intro H'2 | apply psi_not_inj; auto ].\nelim H'2; clear H'2.\nintros x H'.\nelim H'; clear H'.\nintros x0 H'0; elim H'0; clear H'0.\nintros H'0 H'1.\nunfold psi in H'0; simpl in H'0.\ncut (x0 <> x).\n2: red in |- *; intro H'4; apply H'1; rewrite <- H'4; auto.\nintro H'.\nelim (nat_total_order x0 x).\nclear H'1 H'.\nintro H'.\nlapply (discrete_nat x0 x); [ intro H'4 | assumption ].\nelim H'4; intro H'1; clear H'4.\nexists x0; exists 0.\ngeneralize H'0.\nrewrite <- H'1.\nrewrite <- (tech_exp a x0).\nintro H'3.\nlapply (sym_eq (x:=phi a x0) (y:=star (phi a x0) a));\n [ intro H'9 | rewrite H'3; auto ].\nlapply (cancellation' (phi a x0) a); [ intro H'8 | assumption ].\nrewrite H'8.\nrewrite (tech_exp' x0).\nrewrite (tech_exp' (S (S (x0 + 0)))); auto.\nauto.\nelim H'1; intros r E; clear H'1.\nexists x0; exists r.\nrewrite <- E; auto.\nclear H'1 H'.\nintro H'.\nlapply (discrete_nat x x0); [ intro H'4 | assumption ].\nelim H'4; intro H'1; clear H'4.\nexists x; exists 0.\ngeneralize H'0.\nrewrite <- H'1.\nrewrite <- (tech_exp a x).\nintro H'3.\nlapply (cancellation' (phi a x) a); [ intro H'8 | rewrite <- H'3; auto ].\nrewrite H'8.\nrewrite (tech_exp' x).\nrewrite (tech_exp' (S (S (x + 0)))); auto.\nauto.\nelim H'1; intros r E; clear H'1.\nexists x; exists r.\nrewrite <- E; auto.\nauto.\n", "def_ranges": [129, 0, 132, 67], "proof_ranges": [133, 0, 184, 4], "proof_steps": [{"text": "intros a ainH.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (not_injective_elim nat U (psi a));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'2 | apply psi_not_inj; auto ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'2; clear H'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'; clear H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'0; elim H'0; clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'0 H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold psi in H'0; simpl in H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (x0 <> x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; intro H'4; apply H'1; rewrite <- H'4; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (nat_total_order x0 x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'1 H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (discrete_nat x0 x); [ intro H'4 | assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'4; intro H'1; clear H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x0; exists 0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (tech_exp a x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (sym_eq (x:=phi a x0) (y:=star (phi a x0) a));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'9 | rewrite H'3; auto ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (cancellation' (phi a x0) a); [ intro H'8 | assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H'8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (tech_exp' x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (tech_exp' (S (S (x0 + 0)))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'1; intros r E; clear H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x0; exists r.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- E; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'1 H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (discrete_nat x x0); [ intro H'4 | assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'4; intro H'1; clear H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; exists 0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (tech_exp a x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (cancellation' (phi a x) a); [ intro H'8 | rewrite <- H'3; auto ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H'8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (tech_exp' x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (tech_exp' (S (S (x + 0)))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'1; intros r E; clear H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; exists r.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- E; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/g3.v", "name": "T_1_6_4", "text": "Theorem T_1_6_4 : Setsubgroup U H Gr.\nProof.\nelim H_inhabited.\nintros witness inH.\napply T_1_6_2 with (witness := witness); trivial.\nred in |- *.\nintros a H'.\ncut (exists n : nat, inv a = phi a n).\nintro H'0; elim H'0; intros n E; rewrite E; clear H'0.\napply positive_powers; trivial.\ncut (exists r : nat, ex (fun m : nat => phi a r = phi a (S (S (r + m))))).\nintro H'0; elim H'0; intros r E; elim E; intros m E0; try exact E0;\n clear E H'0.\ncut (inv a = phi a m).\nintro H'0; rewrite H'0.\nexists m; trivial.\nsymmetry  in |- *.\napply powers_repeat with (n := r); trivial.\napply H_included_in_G; auto.\napply remaining; auto.\nQed.\n", "definition": " Setsubgroup U H Gr.\n", "proof": "\nelim H_inhabited.\nintros witness inH.\napply T_1_6_2 with (witness := witness); trivial.\nred in |- *.\nintros a H'.\ncut (exists n : nat, inv a = phi a n).\nintro H'0; elim H'0; intros n E; rewrite E; clear H'0.\napply positive_powers; trivial.\ncut (exists r : nat, ex (fun m : nat => phi a r = phi a (S (S (r + m))))).\nintro H'0; elim H'0; intros r E; elim E; intros m E0; try exact E0;\n clear E H'0.\ncut (inv a = phi a m).\nintro H'0; rewrite H'0.\nexists m; trivial.\nsymmetry  in |- *.\napply powers_repeat with (n := r); trivial.\napply H_included_in_G; auto.\napply remaining; auto.\n", "def_ranges": [186, 0, 186, 37], "proof_ranges": [187, 0, 206, 4], "proof_steps": [{"text": "elim H_inhabited.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros witness inH.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply T_1_6_2 with (witness := witness); trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists n : nat, inv a = phi a n).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'0; elim H'0; intros n E; rewrite E; clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply positive_powers; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists r : nat, ex (fun m : nat => phi a r = phi a (S (S (r + m))))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'0; elim H'0; intros r E; elim E; intros m E0; try exact E0;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear E H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (inv a = phi a m).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'0; rewrite H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists m; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "symmetry  in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply powers_repeat with (n := r); trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H_included_in_G; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply remaining; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/g2.v", "name": "auxsub", "text": "Theorem auxsub :\n forall (H : Group U) (x : U), subgroup U H Gr -> In U (G_ U H) x -> In U G x.\nProof.\nintros H x H'; elim H'; auto with sets.\nQed.\n", "definition": "\n forall (H : Group U) (x : U), subgroup U H Gr -> In U (G_ U H) x -> In U G x.\n", "proof": "\nintros H x H'; elim H'; auto with sets.\n", "def_ranges": [24, 0, 25, 78], "proof_ranges": [26, 0, 28, 4], "proof_steps": [{"text": "intros H x H'; elim H'; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/g2.v", "name": "T4", "text": "Theorem T4 : Same_set U (Prod H K) (Prod K H) -> Setsubgroup U (Prod H K) Gr.\nProof.\ngeneralize (auxsub H); intro tH; generalize (auxsub K); intro tK.\nintro H'.\napply T_1_6_3 with (witness := e); auto with sets.\nrewrite <- (G2c' e); auto with sets.\napply Definition_of_Prod with (x := e) (y := e); auto with sets.\nrewrite <- (eh_is_e H); auto with sets.\nrewrite <- (eh_is_e K); auto with sets.\nred in |- *.\nintros x H'0; elim H'0.\nintros x0 y z H'1 H'2 H'3; rewrite <- H'3; auto with sets.\nintros a b H'0 H'1.\ngeneralize H'1; clear H'1.\nelim H'0.\nintros x y z H'1 H'2 H'3; rewrite <- H'3.\nintro H'4; elim H'4.\nintros x0 y0 z0 H'5 H'6 H'7; rewrite <- H'7.\nrewrite <- (inv_star' x0 y0); auto with sets.\nrewrite <- (G1' x y (star (inv y0) (inv x0))); auto with sets.\nred in H'.\nelim H'; intros H'8 H'9; red in H'9; clear H'.\nrewrite (G1' y (inv y0) (inv x0)); auto with sets.\nlapply (H'9 (star (star y (inv y0)) (inv x0)));\n [ intro H'10; elim H'10 | idtac ].\nintros x1 y1 z1 H' H'11 H'12; rewrite <- H'12.\nrewrite (G1' x x1 y1); auto with sets.\napply Definition_of_Prod with (x := star x x1) (y := y1); auto with sets.\nrewrite <- (starH_is_star H); auto with sets.\napply Definition_of_Prod with (x := star y (inv y0)) (y := inv x0).\nrewrite <- (starH_is_star K); auto with sets.\nrewrite <- (invH_is_inv K); auto with sets.\nrewrite <- (invH_is_inv H); auto with sets.\ntrivial with sets.\nQed.\n", "definition": " Same_set U (Prod H K) (Prod K H) -> Setsubgroup U (Prod H K) Gr.\n", "proof": "\ngeneralize (auxsub H); intro tH; generalize (auxsub K); intro tK.\nintro H'.\napply T_1_6_3 with (witness := e); auto with sets.\nrewrite <- (G2c' e); auto with sets.\napply Definition_of_Prod with (x := e) (y := e); auto with sets.\nrewrite <- (eh_is_e H); auto with sets.\nrewrite <- (eh_is_e K); auto with sets.\nred in |- *.\nintros x H'0; elim H'0.\nintros x0 y z H'1 H'2 H'3; rewrite <- H'3; auto with sets.\nintros a b H'0 H'1.\ngeneralize H'1; clear H'1.\nelim H'0.\nintros x y z H'1 H'2 H'3; rewrite <- H'3.\nintro H'4; elim H'4.\nintros x0 y0 z0 H'5 H'6 H'7; rewrite <- H'7.\nrewrite <- (inv_star' x0 y0); auto with sets.\nrewrite <- (G1' x y (star (inv y0) (inv x0))); auto with sets.\nred in H'.\nelim H'; intros H'8 H'9; red in H'9; clear H'.\nrewrite (G1' y (inv y0) (inv x0)); auto with sets.\nlapply (H'9 (star (star y (inv y0)) (inv x0)));\n [ intro H'10; elim H'10 | idtac ].\nintros x1 y1 z1 H' H'11 H'12; rewrite <- H'12.\nrewrite (G1' x x1 y1); auto with sets.\napply Definition_of_Prod with (x := star x x1) (y := y1); auto with sets.\nrewrite <- (starH_is_star H); auto with sets.\napply Definition_of_Prod with (x := star y (inv y0)) (y := inv x0).\nrewrite <- (starH_is_star K); auto with sets.\nrewrite <- (invH_is_inv K); auto with sets.\nrewrite <- (invH_is_inv H); auto with sets.\ntrivial with sets.\n", "def_ranges": [47, 0, 47, 77], "proof_ranges": [48, 0, 81, 4], "proof_steps": [{"text": "generalize (auxsub H); intro tH; generalize (auxsub K); intro tK.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply T_1_6_3 with (witness := e); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (G2c' e); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Prod with (x := e) (y := e); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (eh_is_e H); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (eh_is_e K); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H'0; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y z H'1 H'2 H'3; rewrite <- H'3; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b H'0 H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H'1; clear H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x y z H'1 H'2 H'3; rewrite <- H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'4; elim H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 y0 z0 H'5 H'6 H'7; rewrite <- H'7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (inv_star' x0 y0); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (G1' x y (star (inv y0) (inv x0))); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'; intros H'8 H'9; red in H'9; clear H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G1' y (inv y0) (inv x0)); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (H'9 (star (star y (inv y0)) (inv x0)));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'10; elim H'10 | idtac ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 y1 z1 H' H'11 H'12; rewrite <- H'12.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G1' x x1 y1); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Prod with (x := star x x1) (y := y1); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (starH_is_star H); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Prod with (x := star y (inv y0)) (y := inv x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (starH_is_star K); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv K); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv H); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/g2.v", "name": "T4R", "text": "Theorem T4R : Setsubgroup U (Prod H K) Gr -> Included U (Prod H K) (Prod K H).\nProof.\ngeneralize (auxsub H); intro tH; generalize (auxsub K); intro tK.\nintro H'; elim H'.\nintros x H'0; red in |- *.\nintros x0 H'1.\nelim H'0; intros L1 L2; clear H'0.\ngeneralize (auxsub x); intro tx.\ncut (exists t : U, In U (Prod H K) t /\\ t = inv x0).\nintro H'2; elim H'2.\nintros x1 H'3; elim H'3; intros H'4 H'5; try exact H'4; clear H'3.\ngeneralize H'5.\nelim H'4.\nintros x2 y z H'3 H'6 H'7; rewrite <- H'7.\nintro H'8.\nrewrite (inv_involution' x0); auto with sets.\nrewrite <- H'8.\nrewrite <- (inv_star' x2 y); auto with sets.\napply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.\nrewrite <- (invH_is_inv K subK y); auto with sets.\nrewrite <- (invH_is_inv H subH x2); auto with sets.\ngeneralize H'1.\nrewrite <- L2; auto with sets.\nintro H'0.\napply ex_intro with (x := inv x0).\nsplit; [ idtac | trivial with sets ].\nrewrite <- (invH_is_inv x L1 x0); auto with sets.\nQed.\n", "definition": " Setsubgroup U (Prod H K) Gr -> Included U (Prod H K) (Prod K H).\n", "proof": "\ngeneralize (auxsub H); intro tH; generalize (auxsub K); intro tK.\nintro H'; elim H'.\nintros x H'0; red in |- *.\nintros x0 H'1.\nelim H'0; intros L1 L2; clear H'0.\ngeneralize (auxsub x); intro tx.\ncut (exists t : U, In U (Prod H K) t /\\ t = inv x0).\nintro H'2; elim H'2.\nintros x1 H'3; elim H'3; intros H'4 H'5; try exact H'4; clear H'3.\ngeneralize H'5.\nelim H'4.\nintros x2 y z H'3 H'6 H'7; rewrite <- H'7.\nintro H'8.\nrewrite (inv_involution' x0); auto with sets.\nrewrite <- H'8.\nrewrite <- (inv_star' x2 y); auto with sets.\napply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.\nrewrite <- (invH_is_inv K subK y); auto with sets.\nrewrite <- (invH_is_inv H subH x2); auto with sets.\ngeneralize H'1.\nrewrite <- L2; auto with sets.\nintro H'0.\napply ex_intro with (x := inv x0).\nsplit; [ idtac | trivial with sets ].\nrewrite <- (invH_is_inv x L1 x0); auto with sets.\n", "def_ranges": [83, 0, 83, 78], "proof_ranges": [84, 0, 110, 4], "proof_steps": [{"text": "generalize (auxsub H); intro tH; generalize (auxsub K); intro tK.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'; elim H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H'0; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0; intros L1 L2; clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (auxsub x); intro tx.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists t : U, In U (Prod H K) t /\\ t = inv x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'2; elim H'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 H'3; elim H'3; intros H'4 H'5; try exact H'4; clear H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H'5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x2 y z H'3 H'6 H'7; rewrite <- H'7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (inv_involution' x0); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H'8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (inv_star' x2 y); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv K subK y); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv H subH x2); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- L2; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ex_intro with (x := inv x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; [ idtac | trivial with sets ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv x L1 x0); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/g2.v", "name": "T4R1", "text": "Theorem T4R1 :\n Setsubgroup U (Prod H K) Gr -> Included U (Prod K H) (Prod H K).\nProof.\ngeneralize (auxsub H); intro tH; generalize (auxsub K); intro tK.\nintro H'; elim H'.\nintros x H'0; red in |- *.\nintros x0 H'1.\nelim H'0; intros L1 L2; clear H'0.\ngeneralize (auxsub x); intro tx.\ncut (exists t : U, In U (Prod K H) t /\\ t = inv (inv x0)).\nintro H'0; elim H'0.\nintros x1 H'2.\nelim H'2; intros H'3 H'4; generalize H'4; clear H'2.\nelim H'3.\nintros x2 y z H'2 H'5 H'6; rewrite <- H'6.\nintro H'7.\nrewrite (inv_involution' x0).\nrewrite <- H'7.\nrewrite (inv_involution' (star x2 y)).\nrewrite <- (inv_star' x2 y).\nrewrite <- (invH_is_inv x L1 (star (inv y) (inv x2))).\nrewrite <- L2; auto with sets.\nelim L1; simpl in |- *; auto with sets.\nintros H'15 H'16; apply (G3a_ U x); auto with sets.\nrewrite L2.\napply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.\nrewrite <- (invH_is_inv H subH y); auto with sets.\nrewrite <- (invH_is_inv K subK x2); auto with sets.\nrewrite L2.\napply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.\nrewrite <- (invH_is_inv H subH y); auto with sets.\nrewrite <- (invH_is_inv K subK x2); auto with sets.\nelim H'1; intros x3 y0 z0 H'8 H'9 H'10; rewrite <- H'10.\napply ex_intro with (x := star x3 y0).\nsplit; [ idtac | auto with sets ].\napply Definition_of_Prod with (x := x3) (y := y0); trivial with sets.\nQed.\n", "definition": "\n Setsubgroup U (Prod H K) Gr -> Included U (Prod K H) (Prod H K).\n", "proof": "\ngeneralize (auxsub H); intro tH; generalize (auxsub K); intro tK.\nintro H'; elim H'.\nintros x H'0; red in |- *.\nintros x0 H'1.\nelim H'0; intros L1 L2; clear H'0.\ngeneralize (auxsub x); intro tx.\ncut (exists t : U, In U (Prod K H) t /\\ t = inv (inv x0)).\nintro H'0; elim H'0.\nintros x1 H'2.\nelim H'2; intros H'3 H'4; generalize H'4; clear H'2.\nelim H'3.\nintros x2 y z H'2 H'5 H'6; rewrite <- H'6.\nintro H'7.\nrewrite (inv_involution' x0).\nrewrite <- H'7.\nrewrite (inv_involution' (star x2 y)).\nrewrite <- (inv_star' x2 y).\nrewrite <- (invH_is_inv x L1 (star (inv y) (inv x2))).\nrewrite <- L2; auto with sets.\nelim L1; simpl in |- *; auto with sets.\nintros H'15 H'16; apply (G3a_ U x); auto with sets.\nrewrite L2.\napply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.\nrewrite <- (invH_is_inv H subH y); auto with sets.\nrewrite <- (invH_is_inv K subK x2); auto with sets.\nrewrite L2.\napply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.\nrewrite <- (invH_is_inv H subH y); auto with sets.\nrewrite <- (invH_is_inv K subK x2); auto with sets.\nelim H'1; intros x3 y0 z0 H'8 H'9 H'10; rewrite <- H'10.\napply ex_intro with (x := star x3 y0).\nsplit; [ idtac | auto with sets ].\napply Definition_of_Prod with (x := x3) (y := y0); trivial with sets.\n", "def_ranges": [112, 0, 113, 65], "proof_ranges": [114, 0, 148, 4], "proof_steps": [{"text": "generalize (auxsub H); intro tH; generalize (auxsub K); intro tK.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'; elim H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H'0; red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0; intros L1 L2; clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize (auxsub x); intro tx.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists t : U, In U (Prod K H) t /\\ t = inv (inv x0)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'0; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 H'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'2; intros H'3 H'4; generalize H'4; clear H'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x2 y z H'2 H'5 H'6; rewrite <- H'6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (inv_involution' x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H'7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (inv_involution' (star x2 y)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (inv_star' x2 y).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv x L1 (star (inv y) (inv x2))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- L2; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim L1; simpl in |- *; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'15 H'16; apply (G3a_ U x); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite L2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv H subH y); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv K subK x2); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite L2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv H subH y); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (invH_is_inv K subK x2); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'1; intros x3 y0 z0 H'8 H'9 H'10; rewrite <- H'10.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ex_intro with (x := star x3 y0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; [ idtac | auto with sets ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Prod with (x := x3) (y := y0); trivial with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/g2.v", "name": "T_1_6_8", "text": "Theorem T_1_6_8 :\n Same_set U (Prod H K) (Prod K H) <-> Setsubgroup U (Prod H K) Gr.\nProof.\nred in |- *; auto with sets.\nQed.\n", "definition": "\n Same_set U (Prod H K) (Prod K H) <-> Setsubgroup U (Prod H K) Gr.\n", "proof": "\nred in |- *; auto with sets.\n", "def_ranges": [151, 0, 152, 66], "proof_ranges": [153, 0, 155, 4], "proof_steps": [{"text": "red in |- *; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/gr.v", "name": "triv1", "text": "Theorem triv1 : forall a b : U, star (inv a) (star a b) = b.\nintros a b; try assumption.\nrewrite (G1 (inv a) a b); auto.\nrewrite G3c; auto.\nQed.\n", "definition": " forall a b : U, star (inv a) (star a b) = b.", "proof": "\nintros a b; try assumption.\nrewrite (G1 (inv a) a b); auto.\nrewrite G3c; auto.\n", "def_ranges": [55, 0, 55, 60], "proof_ranges": [56, 0, 59, 4], "proof_steps": [{"text": "intros a b; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G1 (inv a) a b); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite G3c; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/gr.v", "name": "triv2", "text": "Theorem triv2 : forall a b : U, star (star b a) (inv a) = b.\nintros a b; try assumption.\nrewrite <- (G1 b a (inv a)); auto.\nrewrite (G3b a); auto.\nQed.\n", "definition": " forall a b : U, star (star b a) (inv a) = b.", "proof": "\nintros a b; try assumption.\nrewrite <- (G1 b a (inv a)); auto.\nrewrite (G3b a); auto.\n", "def_ranges": [61, 0, 61, 60], "proof_ranges": [62, 0, 65, 4], "proof_steps": [{"text": "intros a b; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (G1 b a (inv a)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G3b a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/gr.v", "name": "resolve", "text": "Theorem resolve : forall a b : U, star b a = e -> b = inv a.\nintros a b H'1.\ncut (star (star b a) (inv a) = inv a).\nrewrite <- (G1 b a (inv a)); auto.\nrewrite (G3b a); auto.\nrewrite (G2c b); auto.\nrewrite H'1.\nrewrite (G2b (inv a)); auto.\nQed.\n", "definition": " forall a b : U, star b a = e -> b = inv a.", "proof": "\nintros a b H'1.\ncut (star (star b a) (inv a) = inv a).\nrewrite <- (G1 b a (inv a)); auto.\nrewrite (G3b a); auto.\nrewrite (G2c b); auto.\nrewrite H'1.\nrewrite (G2b (inv a)); auto.\n", "def_ranges": [67, 0, 67, 60], "proof_ranges": [68, 0, 75, 4], "proof_steps": [{"text": "intros a b H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (star (star b a) (inv a) = inv a).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (G1 b a (inv a)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G3b a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G2c b); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G2b (inv a)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/gr.v", "name": "self_inv", "text": "Theorem self_inv : e = inv e.\napply resolve; auto.\nQed.\n", "definition": " e = inv e.", "proof": "\napply resolve; auto.\n", "def_ranges": [77, 0, 77, 29], "proof_ranges": [78, 0, 79, 4], "proof_steps": [{"text": "apply resolve; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/gr.v", "name": "inv_star", "text": "Theorem inv_star : forall a b : U, star (inv b) (inv a) = inv (star a b).\nintros a b.\napply resolve.\nrewrite <- (G1 (inv b) (inv a) (star a b)).\nrewrite (G1 (inv a) a b).\nrewrite (G3c a).\nrewrite (G2b b); auto.\nQed.\n", "definition": " forall a b : U, star (inv b) (inv a) = inv (star a b).", "proof": "\nintros a b.\napply resolve.\nrewrite <- (G1 (inv b) (inv a) (star a b)).\nrewrite (G1 (inv a) a b).\nrewrite (G3c a).\nrewrite (G2b b); auto.\n", "def_ranges": [81, 0, 81, 73], "proof_ranges": [82, 0, 88, 4], "proof_steps": [{"text": "intros a b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply resolve.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (G1 (inv b) (inv a) (star a b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G1 (inv a) a b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G3c a).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G2b b); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/gr.v", "name": "cancellation", "text": "Theorem cancellation : forall a b : U, star a b = a -> b = e.\nintros a b H'.\ncut (star (inv a) (star a b) = b).\nrewrite H'.\nrewrite (G3c a); auto.\nrewrite (G1 (inv a) a b).\nrewrite (G3c a); auto.\nQed.\n", "definition": " forall a b : U, star a b = a -> b = e.", "proof": "\nintros a b H'.\ncut (star (inv a) (star a b) = b).\nrewrite H'.\nrewrite (G3c a); auto.\nrewrite (G1 (inv a) a b).\nrewrite (G3c a); auto.\n", "def_ranges": [90, 0, 90, 61], "proof_ranges": [91, 0, 97, 4], "proof_steps": [{"text": "intros a b H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (star (inv a) (star a b) = b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G3c a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G1 (inv a) a b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (G3c a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/gr.v", "name": "inv_involution", "text": "Theorem inv_involution : forall a : U, a = inv (inv a).\nintro a; apply resolve; auto.\nQed.\n", "definition": " forall a : U, a = inv (inv a).", "proof": "\nintro a; apply resolve; auto.\n", "def_ranges": [99, 0, 99, 55], "proof_ranges": [100, 0, 101, 4], "proof_steps": [{"text": "intro a; apply resolve; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/Relations.v", "name": "sym_not_P", "text": "Theorem sym_not_P :\n forall (U : Type) (P : Relation U) (x y : U),\n Symmetric U P -> ~ P x y -> ~ P y x.\n Proof.\nintros U P x y H' H'0; unfold not at 1 in |- *; intro H'1.\napply H'0; apply H'; auto.\nQed.\n", "definition": "\n forall (U : Type) (P : Relation U) (x y : U),\n Symmetric U P -> ~ P x y -> ~ P y x.\n ", "proof": "\nintros U P x y H' H'0; unfold not at 1 in |- *; intro H'1.\napply H'0; apply H'; auto.\n", "def_ranges": [44, 0, 46, 37], "proof_ranges": [47, 0, 50, 4], "proof_steps": [{"text": "intros U P x y H' H'0; unfold not at 1 in |- *; intro H'1.", "goal_before": ["forall (U : Type) (P : Relation U) (x y : U),\nSymmetric U P -> ~ P x y -> ~ P y x"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (P : Relation U) (x y : U) (H' : Symmetric U P)\n   (H'0 : ~ P x y) => (fun H'1 : P y x => ?Goal) : ~ P y x)"]}, {"text": "apply H'0; apply H'; auto.", "goal_before": ["False"], "goal_after": [], "proof_term_before": ["(fun (U : Type) (P : Relation U) (x y : U) (H' : Symmetric U P)\n   (H'0 : ~ P x y) => (fun H'1 : P y x => ?Goal) : ~ P y x)"], "proof_term_after": ["(fun (U : Type) (P : Relation U) (x y : U) (H' : Symmetric U P)\n   (H'0 : ~ P x y) => (fun H'1 : P y x => H'0 (H' y x H'1)) : ~ P y x)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (U : Type) (P : Relation U) (x y : U) (H' : Symmetric U P)\n   (H'0 : ~ P x y) => (fun H'1 : P y x => H'0 (H' y x H'1)) : ~ P y x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/Relations.v", "name": "Equiv_from_order", "text": "Theorem Equiv_from_order :\n forall (U : Type) (R : Relation U),\n Order U R -> Equivalence U (fun x y : U => R x y /\\ R y x).\n Proof.\nintros U R H'; red in |- *.\nelim H'; intros H'0 H'1; elim H'0; intros H'2 H'3; clear H' H'0.\nsplit; [ split; red in |- * | red in |- * ].\nintro x; split; try exact (H'2 x).\nintros x y H'; elim H'; intros H'0 H'4; clear H'; auto.\nintros x y z H' H'0; elim H'0; intros H'4 H'5; clear H'0; elim H';\n intros H'6 H'7; clear H'.\nred in H'3.\nsplit; apply H'3 with y; auto.\nQed.\n", "definition": "\n forall (U : Type) (R : Relation U),\n Order U R -> Equivalence U (fun x y : U => R x y /\\ R y x).\n ", "proof": "\nintros U R H'; red in |- *.\nelim H'; intros H'0 H'1; elim H'0; intros H'2 H'3; clear H' H'0.\nsplit; [ split; red in |- * | red in |- * ].\nintro x; split; try exact (H'2 x).\nintros x y H'; elim H'; intros H'0 H'4; clear H'; auto.\nintros x y z H' H'0; elim H'0; intros H'4 H'5; clear H'0; elim H';\n intros H'6 H'7; clear H'.\nred in H'3.\nsplit; apply H'3 with y; auto.\n", "def_ranges": [52, 0, 54, 60], "proof_ranges": [55, 0, 65, 4], "proof_steps": [{"text": "intros U R H'; red in |- *.", "goal_before": ["forall (U : Type) (R : Relation U),\nOrder U R -> Equivalence U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["(Reflexive U (fun x y : U => R x y /\\ R y x) /\\\n Symmetric U (fun x y : U => R x y /\\ R y x)) /\\\nTransitive U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": [], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n ?Goal : Equivalence U (fun x y : U => R x y /\\ R y x))"]}, {"text": "elim H'; intros H'0 H'1; elim H'0; intros H'2 H'3; clear H' H'0.", "goal_before": ["(Reflexive U (fun x y : U => R x y /\\ R y x) /\\\n Symmetric U (fun x y : U => R x y /\\ R y x)) /\\\nTransitive U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["(Reflexive U (fun x y : U => R x y /\\ R y x) /\\\n Symmetric U (fun x y : U => R x y /\\ R y x)) /\\\nTransitive U (fun x y : U => R x y /\\ R y x)"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n ?Goal : Equivalence U (fun x y : U => R x y /\\ R y x))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n and_ind\n   (fun (H'0 : Reflexive U R /\\ Transitive U R) (H'1 : Antisymmetric U R) =>\n    and_ind (fun (H'2 : Reflexive U R) (H'3 : Transitive U R) => ?Goal) H'0)\n   H'\n :\n Equivalence U (fun x y : U => R x y /\\ R y x))"]}, {"text": "split; [ split; red in |- * | red in |- * ].", "goal_before": ["(Reflexive U (fun x y : U => R x y /\\ R y x) /\\\n Symmetric U (fun x y : U => R x y /\\ R y x)) /\\\nTransitive U (fun x y : U => R x y /\\ R y x)"], "goal_after": ["forall x : U, R x x /\\ R x x", "forall x y : U, R x y /\\ R y x -> R y x /\\ R x y", "forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n and_ind\n   (fun (H'0 : Reflexive U R /\\ Transitive U R) (H'1 : Antisymmetric U R) =>\n    and_ind (fun (H'2 : Reflexive U R) (H'3 : Transitive U R) => ?Goal) H'0)\n   H'\n :\n Equivalence U (fun x y : U => R x y /\\ R y x))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n and_ind\n   (fun (H'0 : Reflexive U R /\\ Transitive U R) (H'1 : Antisymmetric U R) =>\n    and_ind\n      (fun (H'2 : Reflexive U R) (H'3 : Transitive U R) =>\n       conj\n         (conj (?Goal : Reflexive U (fun x y : U => R x y /\\ R y x))\n            (?Goal0 : Symmetric U (fun x y : U => R x y /\\ R y x)))\n         (?Goal1 : Transitive U (fun x y : U => R x y /\\ R y x))) H'0) H'\n :\n Equivalence U (fun x y : U => R x y /\\ R y x))"]}, {"text": "intro x; split; try exact (H'2 x).", "goal_before": ["forall x : U, R x x /\\ R x x", "forall x y : U, R x y /\\ R y x -> R y x /\\ R x y", "forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "goal_after": ["forall x y : U, R x y /\\ R y x -> R y x /\\ R x y", "forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n and_ind\n   (fun (H'0 : Reflexive U R /\\ Transitive U R) (H'1 : Antisymmetric U R) =>\n    and_ind\n      (fun (H'2 : Reflexive U R) (H'3 : Transitive U R) =>\n       conj\n         (conj (?Goal : Reflexive U (fun x y : U => R x y /\\ R y x))\n            (?Goal0 : Symmetric U (fun x y : U => R x y /\\ R y x)))\n         (?Goal1 : Transitive U (fun x y : U => R x y /\\ R y x))) H'0) H'\n :\n Equivalence U (fun x y : U => R x y /\\ R y x))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n and_ind\n   (fun (H'0 : Reflexive U R /\\ Transitive U R) (H'1 : Antisymmetric U R) =>\n    and_ind\n      (fun (H'2 : Reflexive U R) (H'3 : Transitive U R) =>\n       conj\n         (conj\n            ((fun x : U => conj (H'2 x) (H'2 x))\n             :\n             Reflexive U (fun x y : U => R x y /\\ R y x))\n            (?Goal : Symmetric U (fun x y : U => R x y /\\ R y x)))\n         (?Goal0 : Transitive U (fun x y : U => R x y /\\ R y x))) H'0) H'\n :\n Equivalence U (fun x y : U => R x y /\\ R y x))"]}, {"text": "intros x y H'; elim H'; intros H'0 H'4; clear H'; auto.", "goal_before": ["forall x y : U, R x y /\\ R y x -> R y x /\\ R x y", "forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "goal_after": ["forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n and_ind\n   (fun (H'0 : Reflexive U R /\\ Transitive U R) (H'1 : Antisymmetric U R) =>\n    and_ind\n      (fun (H'2 : Reflexive U R) (H'3 : Transitive U R) =>\n       conj\n         (conj\n            ((fun x : U => conj (H'2 x) (H'2 x))\n             :\n             Reflexive U (fun x y : U => R x y /\\ R y x))\n            (?Goal : Symmetric U (fun x y : U => R x y /\\ R y x)))\n         (?Goal0 : Transitive U (fun x y : U => R x y /\\ R y x))) H'0) H'\n :\n Equivalence U (fun x y : U => R x y /\\ R y x))"], "proof_term_after": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n and_ind\n   (fun (H'0 : Reflexive U R /\\ Transitive U R) (H'1 : Antisymmetric U R) =>\n    and_ind\n      (fun (H'2 : Reflexive U R) (H'3 : Transitive U R) =>\n       conj\n         (conj\n            ((fun x : U => conj (H'2 x) (H'2 x))\n             :\n             Reflexive U (fun x y : U => R x y /\\ R y x))\n            ((fun (x y : U) (H'4 : R x y /\\ R y x) =>\n              and_ind (fun (H'5 : R x y) (H'6 : R y x) => conj H'6 H'5) H'4)\n             :\n             Symmetric U (fun x y : U => R x y /\\ R y x)))\n         (?Goal : Transitive U (fun x y : U => R x y /\\ R y x))) H'0) H'\n :\n Equivalence U (fun x y : U => R x y /\\ R y x))"]}, {"text": "intros x y z H' H'0; elim H'0; intros H'4 H'5; clear H'0; elim H';", "goal_before": ["forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "goal_after": ["forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "proof_term_before": ["(fun (U : Type) (R : Relation U) (H' : Order U R) =>\n and_ind\n   (fun (H'0 : Reflexive U R /\\ Transitive U R) (H'1 : Antisymmetric U R) =>\n    and_ind\n      (fun (H'2 : Reflexive U R) (H'3 : Transitive U R) =>\n       conj\n         (conj\n            ((fun x : U => conj (H'2 x) (H'2 x))\n             :\n             Reflexive U (fun x y : U => R x y /\\ R y x))\n            ((fun (x y : U) (H'4 : R x y /\\ R y x) =>\n              and_ind (fun (H'5 : R x y) (H'6 : R y x) => conj H'6 H'5) H'4)\n             :\n             Symmetric U (fun x y : U => R x y /\\ R y x)))\n         (?Goal : Transitive U (fun x y : U => R x y /\\ R y x))) H'0) H'\n :\n Equivalence U (fun x y : U => R x y /\\ R y x))"], "proof_term_after": []}, {"text": "intros H'6 H'7; clear H'.", "goal_before": ["forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "goal_after": ["forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "proof_term_before": [], "proof_term_after": []}, {"text": "red in H'3.", "goal_before": ["forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "goal_after": ["forall x y z : U, R x y /\\ R y x -> R y z /\\ R z y -> R x z /\\ R z x"], "proof_term_before": [], "proof_term_after": []}, {"text": "split; apply H'3 with y; auto.", "goal_before": ["R x y", "R y z", "R z y", "R y x"], "goal_after": ["R x y", "R y z", "R z y", "R y x"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/group-theory/Z/Zle.v", "name": "leZ_antisymmetric", "text": "Theorem leZ_antisymmetric : forall x y : Z, leZ x y -> leZ y x -> x = y.\nintros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintro n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintro n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\nQed.\n", "definition": " forall x y : Z, leZ x y -> leZ y x -> x = y.", "proof": "\nintros x y; elim x.\nelim y.\nreflexivity.\nintros; elim H0.\nintros; elim H.\nintro n; elim y.\nintros; elim H.\nsimpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.\nintros; elim H.\nintro n; elim y.\nintros; elim H0.\nintros; elim H0.\nsimpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.\n", "def_ranges": [45, 0, 45, 72], "proof_ranges": [46, 0, 59, 4], "proof_steps": [{"text": "intros x y; elim x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro n; elim y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros; elim (le_antisym n n0 H H0); reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro n; elim y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros; elim (le_antisym n0 n H H0); reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/groups/Groups.v", "name": "E_is_a_group", "text": "Theorem E_is_a_group : group E.\n(******************************)\nProof.\n apply mkgroup with o e s; auto.\nQed.\n", "definition": " group E.\n(******************************)\n", "proof": "\n apply mkgroup with o e s; auto.\n", "def_ranges": [298, 0, 298, 31], "proof_ranges": [299, 0, 302, 4], "proof_steps": [{"text": "apply mkgroup with o e s; auto.", "goal_before": ["group E"], "goal_after": ["left_neutral o e", "right_neutral o e", "left_symmetric o e s", "right_symmetric o e s"], "proof_term_before": [], "proof_term_after": ["{|\n  group_law := o;\n  group_assoc := o_assoc;\n  group_neutral := e;\n  group_sym := s;\n  group_l_neutral := ?Goal;\n  group_r_neutral := ?Goal0;\n  group_l_sym := ?Goal1;\n  group_r_sym := ?Goal2\n|}"]}, {"text": "Qed.", "goal_before": ["left_neutral o e", "right_neutral o e", "left_symmetric o e s", "right_symmetric o e s"], "goal_after": [], "proof_term_before": ["{|\n  group_law := o;\n  group_assoc := o_assoc;\n  group_neutral := e;\n  group_sym := s;\n  group_l_neutral := ?Goal;\n  group_r_neutral := ?Goal0;\n  group_l_sym := ?Goal1;\n  group_r_sym := ?Goal2\n|}"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/lambda/Residuals.v", "name": "commutation", "text": "Theorem commutation :\n forall U1 U2 U3 V1 V2 V3 : redexes,\n residuals U1 U2 U3 ->\n residuals V1 V2 V3 ->\n residuals (subst_r V1 U1) (subst_r V2 U2) (subst_r V3 U3).\nProof.\nunfold subst_r in |- *; auto with arith.\nQed.\n", "definition": "\n forall U1 U2 U3 V1 V2 V3 : redexes,\n residuals U1 U2 U3 ->\n residuals V1 V2 V3 ->\n residuals (subst_r V1 U1) (subst_r V2 U2) (subst_r V3 U3).\n", "proof": "\nunfold subst_r in |- *; auto with arith.\n", "def_ranges": [125, 0, 129, 59], "proof_ranges": [130, 0, 132, 4], "proof_steps": [{"text": "unfold subst_r in |- *; auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/lambda/Conversion.v", "name": "Church_Rosser", "text": "Theorem Church_Rosser :\n forall M N : lambda, conv M N -> exists P : lambda, red M P /\\ red N P.\nProof.\nsimple induction 1.\nsimple induction 1; intros.\nexists N1; split; [ apply one_step_red; trivial | apply refl_red; trivial ].\nexists M1; split; [ apply refl_red; trivial | apply one_step_red; trivial ].\nintro M0; exists M0; split; apply refl_red; trivial.\nintros; elim H1; intros P0 C0; elim H3; intros P1 C1; elim C0; elim C1;\n intros.\nelim confluence_beta_reduction with N0 P0 P1; trivial.\nintros Q C3; exists Q; elim C3; split.\napply trans_red with P0; trivial.\napply trans_red with P1; trivial.\nQed.\n", "definition": "\n forall M N : lambda, conv M N -> exists P : lambda, red M P /\\ red N P.\n", "proof": "\nsimple induction 1.\nsimple induction 1; intros.\nexists N1; split; [ apply one_step_red; trivial | apply refl_red; trivial ].\nexists M1; split; [ apply refl_red; trivial | apply one_step_red; trivial ].\nintro M0; exists M0; split; apply refl_red; trivial.\nintros; elim H1; intros P0 C0; elim H3; intros P1 C1; elim C0; elim C1;\n intros.\nelim confluence_beta_reduction with N0 P0 P1; trivial.\nintros Q C3; exists Q; elim C3; split.\napply trans_red with P0; trivial.\napply trans_red with P1; trivial.\n", "def_ranges": [64, 0, 65, 72], "proof_ranges": [66, 0, 78, 4], "proof_steps": [{"text": "simple induction 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists N1; split; [ apply one_step_red; trivial | apply refl_red; trivial ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists M1; split; [ apply refl_red; trivial | apply one_step_red; trivial ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro M0; exists M0; split; apply refl_red; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; elim H1; intros P0 C0; elim H3; intros P1 C1; elim C0; elim C1;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim confluence_beta_reduction with N0 P0 P1; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Q C3; exists Q; elim C3; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply trans_red with P0; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply trans_red with P1; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/lambda/Confluence.v", "name": "confluence_beta_reduction", "text": "Theorem confluence_beta_reduction : confluence lambda red.\nProof.\napply lemma1; exact confluence_parallel_reduction.\nQed.", "definition": " confluence lambda red.\n", "proof": "\napply lemma1; exact confluence_parallel_reduction.\n", "def_ranges": [135, 0, 135, 58], "proof_ranges": [136, 0, 138, 4], "proof_steps": [{"text": "apply lemma1; exact confluence_parallel_reduction.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/lambda/Cube.v", "name": "prism", "text": "Theorem prism :\n forall U V W : redexes,\n sub V U ->\n forall UV : redexes,\n residuals U V UV ->\n forall WV : redexes,\n residuals W V WV ->\n forall WU : redexes, residuals W U WU <-> regular U /\\ residuals WV UV WU.\nProof.\nintros; unfold iff in |- *; split.\nintro; split.\napply residuals_regular with W WU; trivial.\napply prism1 with U V W; trivial.\nsimple induction 1; intros; apply prism2 with V UV WV; trivial.\nQed.\n", "definition": "\n forall U V W : redexes,\n sub V U ->\n forall UV : redexes,\n residuals U V UV ->\n forall WV : redexes,\n residuals W V WV ->\n forall WU : redexes, residuals W U WU <-> regular U /\\ residuals WV UV WU.\n", "proof": "\nintros; unfold iff in |- *; split.\nintro; split.\napply residuals_regular with W WU; trivial.\napply prism1 with U V W; trivial.\nsimple induction 1; intros; apply prism2 with V UV WV; trivial.\n", "def_ranges": [167, 0, 174, 75], "proof_ranges": [175, 0, 181, 4], "proof_steps": [{"text": "intros; unfold iff in |- *; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply residuals_regular with W WU; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply prism1 with U V W; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction 1; intros; apply prism2 with V UV WV; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/weak-up-to/Reductions.v", "name": "Weak_ind", "text": "Theorem Weak_ind:\n       forall P: Lbl -> X -> X -> Prop,\n       (forall x, P T x x) ->\n       (forall y l x z ,\n        Red T x y -> Weak l y z -> P l y z -> P l x z) ->\n       (forall y a x z,\n        Red (L a) x y -> Weak T y z -> P T y z -> P (L a) x z) ->\n       forall l x x', Weak l x x' -> P l x x'.\n    Proof.\n      intros P Hrefl Htau Ha l x x' Hxx'.\n      destruct l.\n      induction Hxx' as [ x | x1 x x' Hxx1 Hx1x' IH ]; [ apply Hrefl | apply Htau with x1; assumption ].\n      destruct Hxx' as [ x1 Hxx1 Hx1x' ].\n      destruct Hx1x' as [ x2 Hx1x2 Hx2x' ].\n      induction Hxx1 as [ x | w x x1 Hxw Hwx1 IH ].\n      apply Ha with x2; simpl; auto.\n      clear Hx1x2.\n      induction Hx2x' as [ x2 | u x2 x' Hux1 Hx1x' IH ]; [ apply Hrefl | apply Htau with u; assumption ].\n      apply Htau with w; auto.\n      exists x1; auto; exists x2; assumption.\n    Qed.\n", "definition": "\n       forall P: Lbl -> X -> X -> Prop,\n       (forall x, P T x x) ->\n       (forall y l x z ,\n        Red T x y -> Weak l y z -> P l y z -> P l x z) ->\n       (forall y a x z,\n        Red (L a) x y -> Weak T y z -> P T y z -> P (L a) x z) ->\n       forall l x x', Weak l x x' -> P l x x'.\n    ", "proof": "\n      intros P Hrefl Htau Ha l x x' Hxx'.\n      destruct l.\n      induction Hxx' as [ x | x1 x x' Hxx1 Hx1x' IH ]; [ apply Hrefl | apply Htau with x1; assumption ].\n      destruct Hxx' as [ x1 Hxx1 Hx1x' ].\n      destruct Hx1x' as [ x2 Hx1x2 Hx2x' ].\n      induction Hxx1 as [ x | w x x1 Hxw Hwx1 IH ].\n      apply Ha with x2; simpl; auto.\n      clear Hx1x2.\n      induction Hx2x' as [ x2 | u x2 x' Hux1 Hx1x' IH ]; [ apply Hrefl | apply Htau with u; assumption ].\n      apply Htau with w; auto.\n      exists x1; auto; exists x2; assumption.\n    ", "def_ranges": [101, 0, 108, 46], "proof_ranges": [109, 0, 121, 8], "proof_steps": [{"text": "intros P Hrefl Htau Ha l x x' Hxx'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct l.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction Hxx' as [ x | x1 x x' Hxx1 Hx1x' IH ]; [ apply Hrefl | apply Htau with x1; assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Hxx' as [ x1 Hxx1 Hx1x' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Hx1x' as [ x2 Hx1x2 Hx2x' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction Hxx1 as [ x | w x x1 Hxw Hwx1 IH ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Ha with x2; simpl; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear Hx1x2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction Hx2x' as [ x2 | u x2 x' Hux1 Hx1x' IH ]; [ apply Hrefl | apply Htau with u; assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Htau with w; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x1; auto; exists x2; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/weak-up-to/Controlled.v", "name": "wexpansion1_ctrl", "text": "Theorem wexpansion1_ctrl: wexpansion1 TX TX B -> controlled TX TY B.\n  Proof.\n    split; auto.\n    intros R S HR HS HRS HRS' a x x' y Hxx' xRy; destruct xRy as [ w xRw wRy ].\n    cgen Hxx'; cgen x'; induction xRw as [ x | z x w xRz zRw IH ]; intros x' Hxx'.\n    destruct (HRS _ _ _ _ Hxx' wRy) as [ y' Hyy' w'Ry' ]; exists y'; auto; exists x'; auto.\n    destruct (HB Hxx' xRz) as [ z' Hzz' x'Rz' ].\n    destruct Hzz' as [ z1 Hzz1 Hz1z' ].\n    destruct (IH wRy _ Hzz1) as [ y1 Hyy1 z1Ry1 ].\n    cut (simulation_t TX TY (comp (star B) S)).\n    intro HS'; destruct (weak_strong_t HS' _ Hz1z' z1Ry1) as [ y' Hy1y' z'Ry' ]; exists y'.\n    apply weak_taus with y1; auto.\n    destruct z'Ry' as [ w' ]; exists w'; auto; apply S_star with z'; auto.\n    apply wexpansion1_ctrl_t; auto.\n    unfold evolve_t; eapply evolve_incl; try apply HS; intros u v K; exists u; auto.\n  Qed.\n", "definition": " wexpansion1 TX TX B -> controlled TX TY B.\n  ", "proof": "\n    split; auto.\n    intros R S HR HS HRS HRS' a x x' y Hxx' xRy; destruct xRy as [ w xRw wRy ].\n    cgen Hxx'; cgen x'; induction xRw as [ x | z x w xRz zRw IH ]; intros x' Hxx'.\n    destruct (HRS _ _ _ _ Hxx' wRy) as [ y' Hyy' w'Ry' ]; exists y'; auto; exists x'; auto.\n    destruct (HB Hxx' xRz) as [ z' Hzz' x'Rz' ].\n    destruct Hzz' as [ z1 Hzz1 Hz1z' ].\n    destruct (IH wRy _ Hzz1) as [ y1 Hyy1 z1Ry1 ].\n    cut (simulation_t TX TY (comp (star B) S)).\n    intro HS'; destruct (weak_strong_t HS' _ Hz1z' z1Ry1) as [ y' Hy1y' z'Ry' ]; exists y'.\n    apply weak_taus with y1; auto.\n    destruct z'Ry' as [ w' ]; exists w'; auto; apply S_star with z'; auto.\n    apply wexpansion1_ctrl_t; auto.\n    unfold evolve_t; eapply evolve_incl; try apply HS; intros u v K; exists u; auto.\n  ", "def_ranges": [30, 0, 30, 70], "proof_ranges": [31, 0, 45, 6], "proof_steps": [{"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros R S HR HS HRS HRS' a x x' y Hxx' xRy; destruct xRy as [ w xRw wRy ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cgen Hxx'; cgen x'; induction xRw as [ x | z x w xRz zRw IH ]; intros x' Hxx'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (HRS _ _ _ _ Hxx' wRy) as [ y' Hyy' w'Ry' ]; exists y'; auto; exists x'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (HB Hxx' xRz) as [ z' Hzz' x'Rz' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Hzz' as [ z1 Hzz1 Hz1z' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (IH wRy _ Hzz1) as [ y1 Hyy1 z1Ry1 ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (simulation_t TX TY (comp (star B) S)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro HS'; destruct (weak_strong_t HS' _ Hz1z' z1Ry1) as [ y' Hy1y' z'Ry' ]; exists y'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply weak_taus with y1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct z'Ry' as [ w' ]; exists w'; auto; apply S_star with z'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply wexpansion1_ctrl_t; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold evolve_t; eapply evolve_incl; try apply HS; intros u v K; exists u; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/weak-up-to/Controlled.v", "name": "plus_wf_controlled", "text": "Theorem plus_wf_controlled: controlled TX TY B.\n  Proof.\n    split.\n    intros R HR x x' y Hxx' xRy; destruct xRy as [ w xRw wRy ]; destar xRw z.\n    apply (HR _ _ _ Hxx' wRy).\n    elim (diagram_plus_wf_2 (HB (l:=T _)) HB') with (eq (A:=X)) Y R R (TY (T A)) (eq (A:=Y)) x x' y; auto.\n    intros y' Hyy' x'Ry'; exists y'; auto; destruct Hyy' as [ y1 Hyy1 Hy1y' ]; destruct Hy1y'; auto.\n    intros u u' v Huu' uRv; destruct Huu'; exists v; auto; exists v; auto.\n    intros u u' v Huu' uRv; destruct Huu'; exists v; auto; (exists v || exists u); auto.\n    exists x'; auto.\n    exists w; auto.\n\n    intros R S HR HS HRS HRS' a x x' y Hxx' xRy. \n    elim (diagram_plus_wf_2 (HB (l:=T _)) HB') with \n      (comp (TX (L a)) (star (TX (T _)))) Y R S (TY (T _))\n      (comp (TY (L a)) (star (TY (T _)))) x x' y; auto.\n    intros y' Hyy' x'Ry'; exists y'; auto.\n    clear Hxx' xRy x x' y; intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ].\n    destruct (HB Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].\n    destruct (diagram_plus_wf (HB (l:=T _)) HB' Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ].\n    exists y'; auto; fold (Weak TX (L a)); apply weak_taus with y1; auto.  \n    clear Hxx' xRy x x' y; intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ].\n    destruct (HRS _ _ _ _ Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].\n    destruct (weak_strong_t HS _ Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ]; exists y'.\n    fold (Weak TY (L a)); apply weak_taus with y1; auto.  \n    exists x'; auto.\n    exists x; auto; exists x'; auto.\n  Qed.\n", "definition": " controlled TX TY B.\n  ", "proof": "\n    split.\n    intros R HR x x' y Hxx' xRy; destruct xRy as [ w xRw wRy ]; destar xRw z.\n    apply (HR _ _ _ Hxx' wRy).\n    elim (diagram_plus_wf_2 (HB (l:=T _)) HB') with (eq (A:=X)) Y R R (TY (T A)) (eq (A:=Y)) x x' y; auto.\n    intros y' Hyy' x'Ry'; exists y'; auto; destruct Hyy' as [ y1 Hyy1 Hy1y' ]; destruct Hy1y'; auto.\n    intros u u' v Huu' uRv; destruct Huu'; exists v; auto; exists v; auto.\n    intros u u' v Huu' uRv; destruct Huu'; exists v; auto; (exists v || exists u); auto.\n    exists x'; auto.\n    exists w; auto.\n\n    intros R S HR HS HRS HRS' a x x' y Hxx' xRy. \n    elim (diagram_plus_wf_2 (HB (l:=T _)) HB') with \n      (comp (TX (L a)) (star (TX (T _)))) Y R S (TY (T _))\n      (comp (TY (L a)) (star (TY (T _)))) x x' y; auto.\n    intros y' Hyy' x'Ry'; exists y'; auto.\n    clear Hxx' xRy x x' y; intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ].\n    destruct (HB Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].\n    destruct (diagram_plus_wf (HB (l:=T _)) HB' Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ].\n    exists y'; auto; fold (Weak TX (L a)); apply weak_taus with y1; auto.  \n    clear Hxx' xRy x x' y; intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ].\n    destruct (HRS _ _ _ _ Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].\n    destruct (weak_strong_t HS _ Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ]; exists y'.\n    fold (Weak TY (L a)); apply weak_taus with y1; auto.  \n    exists x'; auto.\n    exists x; auto; exists x'; auto.\n  ", "def_ranges": [64, 0, 64, 49], "proof_ranges": [65, 0, 91, 6], "proof_steps": [{"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros R HR x x' y Hxx' xRy; destruct xRy as [ w xRw wRy ]; destar xRw z.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (HR _ _ _ Hxx' wRy).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (diagram_plus_wf_2 (HB (l:=T _)) HB') with (eq (A:=X)) Y R R (TY (T A)) (eq (A:=Y)) x x' y; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y' Hyy' x'Ry'; exists y'; auto; destruct Hyy' as [ y1 Hyy1 Hy1y' ]; destruct Hy1y'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros u u' v Huu' uRv; destruct Huu'; exists v; auto; exists v; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros u u' v Huu' uRv; destruct Huu'; exists v; auto; (exists v || exists u); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists w; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros R S HR HS HRS HRS' a x x' y Hxx' xRy.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (diagram_plus_wf_2 (HB (l:=T _)) HB') with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(comp (TX (L a)) (star (TX (T _)))) Y R S (TY (T _))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(comp (TY (L a)) (star (TY (T _)))) x x' y; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y' Hyy' x'Ry'; exists y'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear Hxx' xRy x x' y; intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (HB Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (diagram_plus_wf (HB (l:=T _)) HB' Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists y'; auto; fold (Weak TX (L a)); apply weak_taus with y1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear Hxx' xRy x x' y; intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (HRS _ _ _ _ Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (weak_strong_t HS _ Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ]; exists y'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fold (Weak TY (L a)); apply weak_taus with y1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; auto; exists x'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/weak-up-to/Controlled.v", "name": "star_wf_controlled", "text": "Theorem star_wf_controlled: controlled TX TY B.\n  Proof.\n    split.\n    intros R HR; unfold simulation_t, evolve_t, evolve_1, Weak.\n    apply diagram_reverse; apply diagram_incl with (star (TX (T _))) (star (TY (T _))); auto; apply diagram_reverse.\n    apply diagram_star_wf_1; auto; exact (HB (l:=T _)).\n\n    intros R S HR HS HRS HRS' a; unfold evolve_1.\n    apply diagram_reverse; apply diagram_incl with (Weak TX (L a)) (Weak TY (L a)); auto; apply diagram_reverse.\n    unfold Weak; apply diagram_star_wf_2; auto; try exact (HB (l:=T _)); \n      intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ]. \n    destruct (HB Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].\n    destruct (diagram_star_wf (HB (l:=T _)) HB' Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ].\n    exists y'; auto; fold (Weak TX (L a)); apply weak_taus with y1; auto.  \n    destruct (HRS _ _ _ _ Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].\n    destruct (weak_strong_t HS _ Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ]; exists y'.\n    fold (Weak TY (L a)); apply weak_taus with y1; auto.  \n    exists x'; auto.\n  Qed.\n", "definition": " controlled TX TY B.\n  ", "proof": "\n    split.\n    intros R HR; unfold simulation_t, evolve_t, evolve_1, Weak.\n    apply diagram_reverse; apply diagram_incl with (star (TX (T _))) (star (TY (T _))); auto; apply diagram_reverse.\n    apply diagram_star_wf_1; auto; exact (HB (l:=T _)).\n\n    intros R S HR HS HRS HRS' a; unfold evolve_1.\n    apply diagram_reverse; apply diagram_incl with (Weak TX (L a)) (Weak TY (L a)); auto; apply diagram_reverse.\n    unfold Weak; apply diagram_star_wf_2; auto; try exact (HB (l:=T _)); \n      intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ]. \n    destruct (HB Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].\n    destruct (diagram_star_wf (HB (l:=T _)) HB' Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ].\n    exists y'; auto; fold (Weak TX (L a)); apply weak_taus with y1; auto.  \n    destruct (HRS _ _ _ _ Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].\n    destruct (weak_strong_t HS _ Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ]; exists y'.\n    fold (Weak TY (L a)); apply weak_taus with y1; auto.  \n    exists x'; auto.\n  ", "def_ranges": [109, 0, 109, 49], "proof_ranges": [110, 0, 127, 6], "proof_steps": [{"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros R HR; unfold simulation_t, evolve_t, evolve_1, Weak.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply diagram_reverse; apply diagram_incl with (star (TX (T _))) (star (TY (T _))); auto; apply diagram_reverse.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply diagram_star_wf_1; auto; exact (HB (l:=T _)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros R S HR HS HRS HRS' a; unfold evolve_1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply diagram_reverse; apply diagram_incl with (Weak TX (L a)) (Weak TY (L a)); auto; apply diagram_reverse.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Weak; apply diagram_star_wf_2; auto; try exact (HB (l:=T _));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x x' y Hxx' xRy; destruct Hxx' as [ x1 Hxx1 Hx1x' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (HB Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (diagram_star_wf (HB (l:=T _)) HB' Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists y'; auto; fold (Weak TX (L a)); apply weak_taus with y1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (HRS _ _ _ _ Hxx1 xRy) as [ y1 Hyy1 x1Ry1 ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (weak_strong_t HS _ Hx1x' x1Ry1) as [ y' Hy1y' x'Ry' ]; exists y'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "fold (Weak TY (L a)); apply weak_taus with y1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x'; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/weak-up-to/Applications.v", "name": "upto", "text": "Theorem upto: incl R (bisim TX TX).\n  Proof.\n    intros x y H; exists (UIter (UIter G) R).\n    split.\n    apply unified_correct with F; auto.\n    exact F_mon.\n    exact G_wmon.\n    exact FG.\n    apply simulation_eeq with (UIter (UIter G) (trans R)). \n    apply eeq_sym; repeat apply UIter_trans; repeat apply UIter_inc; try apply (wmon_m G_wmon). \n    apply G_reverse.\n    apply unified_correct with F; auto.\n    exact F_mon.\n    exact G_wmon.\n    exact FG.\n    exists 0; exact H.\n  Qed.\n", "definition": " incl R (bisim TX TX).\n  ", "proof": "\n    intros x y H; exists (UIter (UIter G) R).\n    split.\n    apply unified_correct with F; auto.\n    exact F_mon.\n    exact G_wmon.\n    exact FG.\n    apply simulation_eeq with (UIter (UIter G) (trans R)). \n    apply eeq_sym; repeat apply UIter_trans; repeat apply UIter_inc; try apply (wmon_m G_wmon). \n    apply G_reverse.\n    apply unified_correct with F; auto.\n    exact F_mon.\n    exact G_wmon.\n    exact FG.\n    exists 0; exact H.\n  ", "def_ranges": [56, 0, 56, 37], "proof_ranges": [57, 0, 72, 6], "proof_steps": [{"text": "intros x y H; exists (UIter (UIter G) R).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unified_correct with F; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact F_mon.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact G_wmon.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact FG.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply simulation_eeq with (UIter (UIter G) (trans R)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply eeq_sym; repeat apply UIter_trans; repeat apply UIter_inc; try apply (wmon_m G_wmon).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply G_reverse.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply unified_correct with F; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact F_mon.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact G_wmon.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact FG.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists 0; exact H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/weak-up-to/Applications.v", "name": "upto_ctrl", "text": "Theorem upto_ctrl: incl R (bisim TX TX).\n  Proof.\n    intros x y H; exists (UIter (UIter G) R).\n    split.\n    apply controlled_correct with B F; auto.\n    exact (proj1 HB).\n    unfold G; apply G_wmon.\n    unfold transparent, F, chaining_r; intro U;\n      apply (proj1 (comp_assoc (star B) U (bisim TX TX))).\n    apply simulation_eeq with (UIter (UIter G) (trans R)). \n    unfold G; apply eeq_sym; repeat apply UIter_trans; repeat apply UIter_inc; try apply (wmon_m (G_wmon TX)). \n    apply G_reverse.\n    apply controlled_correct with B' F; auto.\n    exact (proj1 HB').\n    unfold G; apply G_wmon.\n    unfold transparent, F, chaining_r; intro U;\n      apply (proj1 (comp_assoc (star B') U (bisim TX TX))).\n    exists 0; exact H.\n  Qed.\n", "definition": " incl R (bisim TX TX).\n  ", "proof": "\n    intros x y H; exists (UIter (UIter G) R).\n    split.\n    apply controlled_correct with B F; auto.\n    exact (proj1 HB).\n    unfold G; apply G_wmon.\n    unfold transparent, F, chaining_r; intro U;\n      apply (proj1 (comp_assoc (star B) U (bisim TX TX))).\n    apply simulation_eeq with (UIter (UIter G) (trans R)). \n    unfold G; apply eeq_sym; repeat apply UIter_trans; repeat apply UIter_inc; try apply (wmon_m (G_wmon TX)). \n    apply G_reverse.\n    apply controlled_correct with B' F; auto.\n    exact (proj1 HB').\n    unfold G; apply G_wmon.\n    unfold transparent, F, chaining_r; intro U;\n      apply (proj1 (comp_assoc (star B') U (bisim TX TX))).\n    exists 0; exact H.\n  ", "def_ranges": [131, 0, 131, 42], "proof_ranges": [132, 0, 149, 6], "proof_steps": [{"text": "intros x y H; exists (UIter (UIter G) R).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply controlled_correct with B F; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact (proj1 HB).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold G; apply G_wmon.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold transparent, F, chaining_r; intro U;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (proj1 (comp_assoc (star B) U (bisim TX TX))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply simulation_eeq with (UIter (UIter G) (trans R)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold G; apply eeq_sym; repeat apply UIter_trans; repeat apply UIter_inc; try apply (wmon_m (G_wmon TX)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply G_reverse.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply controlled_correct with B' F; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact (proj1 HB').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold G; apply G_wmon.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold transparent, F, chaining_r; intro U;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (proj1 (comp_assoc (star B') U (bisim TX TX))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists 0; exact H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/weak-up-to/Relations.v", "name": "plus_wf", "text": "Theorem plus_wf: well_founded (trans (plus R)).\n  Proof.\n    intro; auto.\n  Qed.\n", "definition": " well_founded (trans (plus R)).\n  ", "proof": "\n    intro; auto.\n  ", "def_ranges": [276, 0, 276, 49], "proof_ranges": [277, 0, 279, 6], "proof_steps": [{"text": "intro; auto.", "goal_before": ["well_founded (trans (plus R))"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["((fun a : X => Acc_clos_trans (Rwf a)) : well_founded (trans (plus R)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun a : X => Acc_clos_trans (Rwf a)) : well_founded (trans (plus R)))"], "proof_term_after": []}], "ends_qed": true}]