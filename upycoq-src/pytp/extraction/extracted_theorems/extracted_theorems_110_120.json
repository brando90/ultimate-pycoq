[{"path": "/home/jizej/proverbot9001/coq-projects/checker/Checker.v", "name": "Domino_covers_Black", "text": "Theorem Domino_covers_Black : Surjective _ _ Domino.\nProof.\napply Surjections_right with (f := BW).\napply (Finite_Board (BW o Domino)).\napply Injections_compose.\nexact BW_One_one.\nexact Domino_one_one.\nQed.\n", "definition": " Surjective _ _ Domino.\n", "proof": "\napply Surjections_right with (f := BW).\napply (Finite_Board (BW o Domino)).\napply Injections_compose.\nexact BW_One_one.\nexact Domino_one_one.\n", "def_ranges": [41, 0, 41, 52], "proof_ranges": [42, 0, 48, 4], "proof_steps": [{"text": "apply Surjections_right with (f := BW).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (Finite_Board (BW o Domino)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Injections_compose.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact BW_One_one.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact Domino_one_one.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cheerios/core/Core.v", "name": "channel_wrap_unwrap", "text": "Theorem channel_wrap_unwrap : forall x,\n      in_channel_unwrap (channel_send (out_channel_wrap x)) = unwrap x.\n  Proof.\n    reflexivity.\n  Qed.\n", "definition": " forall x,\n      in_channel_unwrap (channel_send (out_channel_wrap x)) = unwrap x.\n  ", "proof": "\n    reflexivity.\n  ", "def_ranges": [64, 0, 65, 71], "proof_ranges": [66, 0, 68, 6], "proof_steps": [{"text": "reflexivity.", "goal_before": ["forall x : iostream,\nin_channel_unwrap (channel_send (out_channel_wrap x)) = unwrap x"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun x : iostream => eq_refl)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x : iostream => eq_refl)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cheerios/core/Core.v", "name": "serialize_deserialize_top_id", "text": "Theorem serialize_deserialize_top_id : forall {A : Type} {sA: Serializer A} a,\n    deserialize_top deserialize (serialize_top (serialize a)) = Some a.\nProof.\n  intros.\n  apply serialize_deserialize_top_id'.\n  apply serialize_deserialize_id_nil.\nQed.\n", "definition": " forall {A : Type} {sA: Serializer A} a,\n    deserialize_top deserialize (serialize_top (serialize a)) = Some a.\n", "proof": "\n  intros.\n  apply serialize_deserialize_top_id'.\n  apply serialize_deserialize_id_nil.\n", "def_ranges": [225, 0, 226, 71], "proof_ranges": [227, 0, 231, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall (A : Type) (sA : Serializer A) (a : A),\ndeserialize_top deserialize (serialize_top (serialize a)) = Some a"], "goal_after": ["deserialize_top deserialize (serialize_top (serialize a)) = Some a"], "proof_term_before": [], "proof_term_after": ["(fun (A : Type) (sA : Serializer A) (a : A) => ?Goal)"]}, {"text": "apply serialize_deserialize_top_id'.", "goal_before": ["deserialize_top deserialize (serialize_top (serialize a)) = Some a"], "goal_after": ["ByteListReader.unwrap deserialize (IOStreamWriter.unwrap (serialize a)) =\nSome (a, [])"], "proof_term_before": ["(fun (A : Type) (sA : Serializer A) (a : A) => ?Goal)"], "proof_term_after": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n serialize_deserialize_top_id' ?Goal)"]}, {"text": "apply serialize_deserialize_id_nil.", "goal_before": ["ByteListReader.unwrap deserialize (IOStreamWriter.unwrap (serialize a)) =\nSome (a, [])"], "goal_after": [], "proof_term_before": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n serialize_deserialize_top_id' ?Goal)"], "proof_term_after": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n serialize_deserialize_top_id' (serialize_deserialize_id_nil sA a))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n serialize_deserialize_top_id' (serialize_deserialize_id_nil sA a))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cheerios/core/Core.v", "name": "serialize_deserialize_channel_id", "text": "Theorem serialize_deserialize_channel_id : forall {A} {sA : Serializer A} a,\n    from_channel deserialize (IOStreamWriter.channel_send (to_channel (serialize a))) = Some a.\nProof.\n  intros.\n  unfold to_channel, from_channel.\n  rewrite IOStreamWriter.channel_wrap_unwrap.\n  rewrite serialize_deserialize_id_nil.\n  reflexivity.\nQed.", "definition": " forall {A} {sA : Serializer A} a,\n    from_channel deserialize (IOStreamWriter.channel_send (to_channel (serialize a))) = Some a.\n", "proof": "\n  intros.\n  unfold to_channel, from_channel.\n  rewrite IOStreamWriter.channel_wrap_unwrap.\n  rewrite serialize_deserialize_id_nil.\n  reflexivity.\n", "def_ranges": [256, 0, 257, 95], "proof_ranges": [258, 0, 264, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall (A : Type) (sA : Serializer A) (a : A),\nfrom_channel deserialize\n  (IOStreamWriter.channel_send (to_channel (serialize a))) = \nSome a"], "goal_after": ["forall (A : Type) (sA : Serializer A) (a : A),\nfrom_channel deserialize\n  (IOStreamWriter.channel_send (to_channel (serialize a))) = \nSome a"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold to_channel, from_channel.", "goal_before": ["from_channel deserialize\n  (IOStreamWriter.channel_send (to_channel (serialize a))) = \nSome a"], "goal_after": ["from_channel deserialize\n  (IOStreamWriter.channel_send (to_channel (serialize a))) = \nSome a"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite IOStreamWriter.channel_wrap_unwrap.", "goal_before": ["match\n  ByteListReader.unwrap deserialize\n    (IOStreamWriter.in_channel_unwrap\n       (IOStreamWriter.channel_send\n          (IOStreamWriter.out_channel_wrap (serialize a))))\nwith\n| Some (a0, []) => Some a0\n| Some (a0, _ :: _) => None\n| None => None\nend = Some a"], "goal_after": ["match\n  ByteListReader.unwrap deserialize\n    (IOStreamWriter.in_channel_unwrap\n       (IOStreamWriter.channel_send\n          (IOStreamWriter.out_channel_wrap (serialize a))))\nwith\n| Some (a0, []) => Some a0\n| Some (a0, _ :: _) => None\n| None => None\nend = Some a"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite serialize_deserialize_id_nil.", "goal_before": ["match\n  ByteListReader.unwrap deserialize\n    (IOStreamWriter.in_channel_unwrap\n       (IOStreamWriter.channel_send\n          (IOStreamWriter.out_channel_wrap (serialize a))))\nwith\n| Some (a0, []) => Some a0\n| Some (a0, _ :: _) => None\n| None => None\nend = Some a"], "goal_after": ["match\n  ByteListReader.unwrap deserialize (IOStreamWriter.unwrap (serialize a))\nwith\n| Some (a0, []) => Some a0\n| Some (a0, _ :: _) => None\n| None => None\nend = Some a"], "proof_term_before": [], "proof_term_after": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n eq_ind_r\n   (fun l : list byte =>\n    match ByteListReader.unwrap deserialize l with\n    | Some (a0, []) => Some a0\n    | Some (a0, _ :: _) => None\n    | None => None\n    end = Some a) ?Goal (IOStreamWriter.channel_wrap_unwrap (serialize a))\n :\n from_channel deserialize\n   (IOStreamWriter.channel_send (to_channel (serialize a))) = \n Some a)"]}, {"text": "reflexivity.", "goal_before": ["match\n  ByteListReader.unwrap deserialize (IOStreamWriter.unwrap (serialize a))\nwith\n| Some (a0, []) => Some a0\n| Some (a0, _ :: _) => None\n| None => None\nend = Some a"], "goal_after": ["Some a = Some a"], "proof_term_before": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n eq_ind_r\n   (fun l : list byte =>\n    match ByteListReader.unwrap deserialize l with\n    | Some (a0, []) => Some a0\n    | Some (a0, _ :: _) => None\n    | None => None\n    end = Some a) ?Goal (IOStreamWriter.channel_wrap_unwrap (serialize a))\n :\n from_channel deserialize\n   (IOStreamWriter.channel_send (to_channel (serialize a))) = \n Some a)"], "proof_term_after": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n eq_ind_r\n   (fun l : list byte =>\n    match ByteListReader.unwrap deserialize l with\n    | Some (a0, []) => Some a0\n    | Some (a0, _ :: _) => None\n    | None => None\n    end = Some a)\n   (eq_ind_r\n      (fun o : option (A * list byte) =>\n       match o with\n       | Some (a0, []) => Some a0\n       | Some (a0, _ :: _) => None\n       | None => None\n       end = Some a) ?Goal (serialize_deserialize_id_nil sA a))\n   (IOStreamWriter.channel_wrap_unwrap (serialize a))\n :\n from_channel deserialize\n   (IOStreamWriter.channel_send (to_channel (serialize a))) = \n Some a)"]}, {"text": "Qed.", "goal_before": ["Some a = Some a"], "goal_after": [], "proof_term_before": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n eq_ind_r\n   (fun l : list byte =>\n    match ByteListReader.unwrap deserialize l with\n    | Some (a0, []) => Some a0\n    | Some (a0, _ :: _) => None\n    | None => None\n    end = Some a)\n   (eq_ind_r\n      (fun o : option (A * list byte) =>\n       match o with\n       | Some (a0, []) => Some a0\n       | Some (a0, _ :: _) => None\n       | None => None\n       end = Some a) ?Goal (serialize_deserialize_id_nil sA a))\n   (IOStreamWriter.channel_wrap_unwrap (serialize a))\n :\n from_channel deserialize\n   (IOStreamWriter.channel_send (to_channel (serialize a))) = \n Some a)"], "proof_term_after": ["(fun (A : Type) (sA : Serializer A) (a : A) =>\n eq_ind_r\n   (fun l : list byte =>\n    match ByteListReader.unwrap deserialize l with\n    | Some (a0, []) => Some a0\n    | Some (a0, _ :: _) => None\n    | None => None\n    end = Some a)\n   (eq_ind_r\n      (fun o : option (A * list byte) =>\n       match o with\n       | Some (a0, []) => Some a0\n       | Some (a0, _ :: _) => None\n       | None => None\n       end = Some a) eq_refl (serialize_deserialize_id_nil sA a))\n   (IOStreamWriter.channel_wrap_unwrap (serialize a))\n :\n from_channel deserialize\n   (IOStreamWriter.channel_send (to_channel (serialize a))) = \n Some a)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cheerios/core/BasicSerializers.v", "name": "strongind_pos", "text": "Theorem strongind_pos :\n    P xH ->\n    (forall q, ((forall p, le_pos p q -> P p) -> P (xI q)) /\\\n               ((forall p, le_pos p q -> P p) -> P (xO q))) ->\n    forall p, P p.\n  Proof using.\n    intros.\n    apply weaken_pos.\n    now apply strongind_pos_aux.\n  Qed.\n", "definition": "\n    P xH ->\n    (forall q, ((forall p, le_pos p q -> P p) -> P (xI q)) /\\\n               ((forall p, le_pos p q -> P p) -> P (xO q))) ->\n    forall p, P p.", "proof": "\n  Proof using.\n    intros.\n    apply weaken_pos.\n    now apply strongind_pos_aux.\n  ", "def_ranges": [125, 0, 129, 18], "proof_ranges": [130, 0, 134, 6], "proof_steps": [{"text": "Proof using.", "goal_before": ["P 1 ->\n(forall q : positive,\n ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n ((forall p : positive, le_pos p q -> P p) -> P q~0)) ->\nforall p : positive, P p"], "goal_after": ["P 1 ->\n(forall q : positive,\n ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n ((forall p : positive, le_pos p q -> P p) -> P q~0)) ->\nforall p : positive, P p"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros.", "goal_before": ["P 1 ->\n(forall q : positive,\n ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n ((forall p : positive, le_pos p q -> P p) -> P q~0)) ->\nforall p : positive, P p"], "goal_after": ["P p"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (H : P 1)\n   (H0 : forall q : positive,\n         ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n         ((forall p : positive, le_pos p q -> P p) -> P q~0)) \n   (p : positive) => ?Goal)"]}, {"text": "apply weaken_pos.", "goal_before": ["P p"], "goal_after": ["forall q p0 : positive, le_pos p0 q -> P p0"], "proof_term_before": ["(fun (H : P 1)\n   (H0 : forall q : positive,\n         ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n         ((forall p : positive, le_pos p q -> P p) -> P q~0)) \n   (p : positive) => ?Goal)"], "proof_term_after": ["(fun (H : P 1)\n   (H0 : forall q : positive,\n         ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n         ((forall p : positive, le_pos p q -> P p) -> P q~0)) \n   (p : positive) => weaken_pos ?Goal p)"]}, {"text": "now apply strongind_pos_aux.", "goal_before": ["forall q p0 : positive, le_pos p0 q -> P p0"], "goal_after": [], "proof_term_before": ["(fun (H : P 1)\n   (H0 : forall q : positive,\n         ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n         ((forall p : positive, le_pos p q -> P p) -> P q~0)) \n   (p : positive) => weaken_pos ?Goal p)"], "proof_term_after": ["(fun (H : P 1)\n   (H0 : forall q : positive,\n         ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n         ((forall p : positive, le_pos p q -> P p) -> P q~0)) \n   (p : positive) => weaken_pos (strongind_pos_aux H H0) p)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (H : P 1)\n   (H0 : forall q : positive,\n         ((forall p : positive, le_pos p q -> P p) -> P q~1) /\\\n         ((forall p : positive, le_pos p q -> P p) -> P q~0)) \n   (p : positive) => weaken_pos (strongind_pos_aux H H0) p)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cheerios/core/BasicSerializers.v", "name": "positive_serialize_deserialize_id", "text": "Theorem positive_serialize_deserialize_id :\n  serialize_deserialize_id_spec positive_serialize\n                                positive_deserialize.\nProof.\n  intros.\n  unfold positive_deserialize.\n  apply positive_step.\nQed.\n", "definition": "\n  serialize_deserialize_id_spec positive_serialize\n                                positive_deserialize.\n", "proof": "\n  intros.\n  unfold positive_deserialize.\n  apply positive_step.\n", "def_ranges": [218, 0, 220, 53], "proof_ranges": [221, 0, 225, 4], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold positive_deserialize.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply positive_step.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cheerios/core/Tree.v", "name": "rev'_spec", "text": "Theorem rev'_spec : forall {A : Type} (l : list A),\n    rev' l = rev l.\nProof.\n  intros. unfold rev'.\n  now rewrite rev_rec_spec, app_nil_r.\nQed.\n", "definition": " forall {A : Type} (l : list A),\n    rev' l = rev l.\n", "proof": "\n  intros. unfold rev'.\n  now rewrite rev_rec_spec, app_nil_r.\n", "def_ranges": [95, 0, 96, 19], "proof_ranges": [97, 0, 100, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall (A : Type) (l : list A), rev' l = rev l"], "goal_after": ["rev' l = rev l"], "proof_term_before": [], "proof_term_after": ["(fun (A : Type) (l : list A) => ?Goal)"]}, {"text": "unfold rev'.", "goal_before": ["rev' l = rev l"], "goal_after": ["rev_rec l [] = rev l"], "proof_term_before": ["(fun (A : Type) (l : list A) => ?Goal)"], "proof_term_after": ["(fun (A : Type) (l : list A) => ?Goal : rev' l = rev l)"]}, {"text": "now rewrite rev_rec_spec, app_nil_r.", "goal_before": ["rev_rec l [] = rev l"], "goal_after": [], "proof_term_before": ["(fun (A : Type) (l : list A) => ?Goal : rev' l = rev l)"], "proof_term_after": ["(fun (A : Type) (l : list A) =>\n eq_ind_r (fun l0 : list A => l0 = rev l)\n   (eq_ind_r (fun l0 : list A => l0 = rev l) eq_refl (app_nil_r (rev l)))\n   (rev_rec_spec l [])\n :\n rev' l = rev l)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A : Type) (l : list A) =>\n eq_ind_r (fun l0 : list A => l0 = rev l)\n   (eq_ind_r (fun l0 : list A => l0 = rev l) eq_refl (app_nil_r (rev l)))\n   (rev_rec_spec l [])\n :\n rev' l = rev l)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cheerios/core/Tree.v", "name": "map'_spec", "text": "Theorem map'_spec : forall {A B} (f : A -> B) (l : list A),\n    List.map f l = list_map' f l.\n  intros.\n  unfold list_map'.\n  now rewrite map_rec_spec.\nQed.\n", "definition": " forall {A B} (f : A -> B) (l : list A),\n    List.", "proof": "map f l = list_map' f l.\n  intros.\n  unfold list_map'.\n  now rewrite map_rec_spec.\n", "def_ranges": [129, 0, 130, 33], "proof_ranges": [131, 0, 134, 4], "proof_steps": [{"text": "map f l = list_map' f l.", "goal_before": ["forall (A B : Type) (f : A -> B) (l : list A), map f l = list_map' f l"], "goal_after": ["forall (A B : Type) (f : A -> B) (l : list A), map f l = list_map' f l"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": ["forall (A B : Type) (f : A -> B) (l : list A), map f l = list_map' f l"], "goal_after": ["forall (A B : Type) (f : A -> B) (l : list A), map f l = list_map' f l"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold list_map'.", "goal_before": ["map f l = list_map' f l"], "goal_after": ["map f l = list_map' f l"], "proof_term_before": [], "proof_term_after": []}, {"text": "now rewrite map_rec_spec.", "goal_before": ["map f l = map_rec f l []"], "goal_after": ["map f l = map_rec f l []"], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": ["map'_spec is defined"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/cheerios/core/Tree.v", "name": "tree_map'_spec", "text": "Theorem tree_map'_spec : forall {A B} (f : A -> B) (t : tree A),\n    tree_map' f t = map f t.\nProof.\n  intros.\n  destruct t.\n  - reflexivity.\n  - simpl.\n    now rewrite tree_map_loop_spec.\nQed.\n", "definition": " forall {A B} (f : A -> B) (t : tree A),\n    tree_map' f t = map f t.\n", "proof": "\n  intros.\n  destruct t.\n  - reflexivity.\n  - simpl.\n    now rewrite tree_map_loop_spec.\n", "def_ranges": [178, 0, 179, 28], "proof_ranges": [180, 0, 186, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall (A B : Type) (f : A -> B) (t : tree A), tree_map' f t = map f t"], "goal_after": ["tree_map' f t = map f t"], "proof_term_before": [], "proof_term_after": ["(fun (A B : Type) (f : A -> B) (t : tree A) => ?Goal)"]}, {"text": "destruct t.", "goal_before": ["tree_map' f t = map f t"], "goal_after": ["tree_map' f (atom a) = map f (atom a)", "tree_map' f (node l) = map f (node l)"], "proof_term_before": ["(fun (A B : Type) (f : A -> B) (t : tree A) => ?Goal)"], "proof_term_after": ["(fun (A B : Type) (f : A -> B) (t : tree A) =>\n match t as t0 return (tree_map' f t0 = map f t0) with\n | atom a => (fun a0 : A => ?Goal@{a:=a0}) a\n | node l => (fun l0 : list (tree A) => ?Goal0@{l:=l0}) l\n end)"]}, {"text": "reflexivity.", "goal_before": ["tree_map' f (atom a) = map f (atom a)", "tree_map' f (node l) = map f (node l)"], "goal_after": ["tree_map' f (node l) = map f (node l)"], "proof_term_before": ["(fun (A B : Type) (f : A -> B) (t : tree A) =>\n match t as t0 return (tree_map' f t0 = map f t0) with\n | atom a => (fun a0 : A => ?Goal@{a:=a0}) a\n | node l => (fun l0 : list (tree A) => ?Goal0@{l:=l0}) l\n end)"], "proof_term_after": ["(fun (A B : Type) (f : A -> B) (t : tree A) =>\n match t as t0 return (tree_map' f t0 = map f t0) with\n | atom a => (fun a0 : A => eq_refl) a\n | node l => (fun l0 : list (tree A) => ?Goal@{l:=l0}) l\n end)"]}, {"text": "simpl.", "goal_before": ["tree_map' f (node l) = map f (node l)"], "goal_after": ["node\n  ((fix tree_map_loop\n      (A0 B0 : Type) (f0 : A0 -> B0) (l0 : list (tree A0))\n      (acc : list (tree B0)) {struct l0} : list (tree B0) :=\n      match l0 with\n      | [] => rev_rec acc []\n      | a :: l1 => tree_map_loop A0 B0 f0 l1 (map f0 a :: acc)\n      end) A B f l []) = node (List.map (map f) l)"], "proof_term_before": ["(fun (A B : Type) (f : A -> B) (t : tree A) =>\n match t as t0 return (tree_map' f t0 = map f t0) with\n | atom a => (fun a0 : A => eq_refl) a\n | node l => (fun l0 : list (tree A) => ?Goal@{l:=l0}) l\n end)"], "proof_term_after": ["(fun (A B : Type) (f : A -> B) (t : tree A) =>\n match t as t0 return (tree_map' f t0 = map f t0) with\n | atom a => (fun a0 : A => eq_refl) a\n | node l =>\n     (fun l0 : list (tree A) =>\n      ?Goal@{l:=l0} : tree_map' f (node l0) = map f (node l0)) l\n end)"]}, {"text": "now rewrite tree_map_loop_spec.", "goal_before": ["node\n  ((fix tree_map_loop\n      (A0 B0 : Type) (f0 : A0 -> B0) (l0 : list (tree A0))\n      (acc : list (tree B0)) {struct l0} : list (tree B0) :=\n      match l0 with\n      | [] => rev_rec acc []\n      | a :: l1 => tree_map_loop A0 B0 f0 l1 (map f0 a :: acc)\n      end) A B f l []) = node (List.map (map f) l)"], "goal_after": [], "proof_term_before": ["(fun (A B : Type) (f : A -> B) (t : tree A) =>\n match t as t0 return (tree_map' f t0 = map f t0) with\n | atom a => (fun a0 : A => eq_refl) a\n | node l =>\n     (fun l0 : list (tree A) =>\n      ?Goal@{l:=l0} : tree_map' f (node l0) = map f (node l0)) l\n end)"], "proof_term_after": ["(fun (A B : Type) (f : A -> B) (t : tree A) =>\n match t as t0 return (tree_map' f t0 = map f t0) with\n | atom a => (fun a0 : A => eq_refl) a\n | node l =>\n     (fun l0 : list (tree A) =>\n      eq_ind_r\n        (fun l1 : list (tree B) => node l1 = node (List.map (map f) l0))\n        eq_refl (tree_map_loop_spec f l0 [])\n      :\n      tree_map' f (node l0) = map f (node l0)) l\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Type) (f : A -> B) (t : tree A) =>\n match t as t0 return (tree_map' f t0 = map f t0) with\n | atom a => (fun a0 : A => eq_refl) a\n | node l =>\n     (fun l0 : list (tree A) =>\n      eq_ind_r\n        (fun l1 : list (tree B) => node l1 = node (List.map (map f) l0))\n        eq_refl (tree_map_loop_spec f l0 [])\n      :\n      tree_map' f (node l0) = map f (node l0)) l\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/triple.v", "name": "Triples_are_enough_finite_case", "text": "Theorem Triples_are_enough_finite_case :\n (forall x y z : U,\n  Consistent U D (Triple U x y z) ->\n  ex (fun bsup : U => Lub U D (Triple U x y z) bsup)) ->\n forall X : Ensemble U,\n Finite U X ->\n Included U X (Carrier_of U D) ->\n Consistent U D X -> ex (fun bsup : U => Lub U D X bsup).\nProof.\nintro H'; try assumption.\nintros X H'0; try assumption.\nelim H'0 using Generalized_induction_on_finite_sets.\nclear H'0.\nclear X.\nintros X H'0; elim H'0.\nunfold D at 6 in |- *; auto with sets.\nclear H'0 X.\nintros A H'0; elim H'0.\nintros H'1 x H'2 H'3 H'4 H'5; try assumption.\nrewrite (Empty_set_zero' U x).\nexists x; auto with sets.\nclear H'0 A.\nintros A H'0; elim H'0.\nintros H'1 x H'2 H'3 x0 H'4 H'5 H'6 H'7; try assumption.\n2: clear H'0 A.\n2: intros A H'0 H'1 x H'2 H'3 x0 H'4 H'5 x1 H'6 H'7 H'8 H'9; try assumption.\nclear H'5 H'3 H'1.\nrewrite (Empty_set_zero' U x).\nunfold Add at 1 in |- *.\nrewrite (Couple_as_union U x x0).\nrewrite (Triple_as_Couple U x x0).\napply H'.\nrewrite <- (Triple_as_union U x x x0).\nrewrite (Union_idempotent U (Singleton U x)).\ngeneralize H'7.\nrewrite (Empty_set_zero' U x).\nunfold Add at 1 in |- *; auto with sets.\nclear H'5 H'3 H'1 H'0.\ncut\n (forall X : Ensemble U,\n  Included U X (Add U (Add U (Add U A x) x0) x1) ->\n  Included U X (Carrier_of U D)); auto with sets.\nintro L1.\ncut\n (forall X : Ensemble U,\n  Included U X (Add U (Add U (Add U A x) x0) x1) -> Consistent U D X);\n auto with sets.\n2: intros X H'0.\n2: apply\n    Consistent_downward_stable with (B := Add U (Add U (Add U A x) x0) x1);\n    auto with sets.\nintro L2.\ncut (Included U (Add U A x) (Add U (Add U (Add U A x) x0) x1)); auto with sets.\nintro F1.\ncut (Included U (Add U A x0) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\n2: apply (Inclusion_is_transitive U) with (Add U (Add U A x) x0);\n    auto with sets.\nintro F2.\ncut (Included U (Add U A x1) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\nintro F3.\ncut (Included U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\nintro F4.\ncut (Included U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\nintro F5.\ncut (Included U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\nintro F6.\ncut\n (Strict_Included U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1)).\n2: split; auto with sets.\n2: red in |- *; simpl in |- *; intro H'0.\n2: lapply\n    (Extension U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1));\n    [ intro H'10; elim H'10 | idtac ]; auto with sets.\nintro G1.\ncut\n (Strict_Included U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1)).\n2: split; auto with sets.\n2: red in |- *; simpl in |- *; intro H'0.\n2: lapply\n    (Extension U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1));\n    [ intro H'10; elim H'10 | idtac ]; auto with sets.\n2: intros H'1 H'3; try assumption.\n2: apply H'4.\n2: lapply (incl_add_x U (Add U (Add U A x) x0) (Add U A x) x1);\n    [ intro H'14; lapply H'14;\n       [ intro H'15; try exact H'15; clear H'14 | clear H'14 ]\n    | idtac ]; auto with sets.\nintro G2.\ncut\n (Strict_Included U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1)).\n2: split; auto with sets.\n2: red in |- *; simpl in |- *; intro H'0.\n2: lapply\n    (Extension U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1));\n    [ intro H'10; elim H'10 | idtac ]; auto with sets.\n2: intros H'1 H'3; try assumption.\n2: apply H'2.\n2: lapply (incl_add_x U (Add U (Add U A x) x0) (Add U A x0) x1);\n    [ intro H'14; lapply H'14;\n       [ intro H'15; try exact H'15; clear H'14 | clear H'14 ]\n    | idtac ]; auto with sets.\n2: lapply (incl_add_x U (Add U A x) A x0);\n    [ intro H'14; lapply H'14;\n       [ intro H'16; try exact H'16; clear H'14 | clear H'14 ]\n    | idtac ]; auto with sets.\nintro G3; try assumption.\ncut (Strict_Included U (Add U A x0) (Add U (Add U (Add U A x) x0) x1)).\n2: apply\n    Strict_inclusion_is_transitive_with_inclusion_left\n     with (y := Add U (Add U A x0) x1); auto with sets.\nintro G4; try assumption.\ncut (Strict_Included U (Add U A x1) (Add U (Add U (Add U A x) x0) x1)).\n2: apply\n    Strict_inclusion_is_transitive_with_inclusion_left\n     with (y := Add U (Add U A x) x1); auto with sets.\nintro G5; try assumption.\ncut (Strict_Included U (Add U A x) (Add U (Add U (Add U A x) x0) x1)).\n2: apply\n    Strict_inclusion_is_transitive_with_inclusion_left\n     with (y := Add U (Add U A x) x0); auto with sets.\nintro G6; try assumption.\nelim (H'7 (Add U A x));\n [ intros bsup E; try exact E | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U A x0));\n [ intros bsup0 E0; try exact E0 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U A x1));\n [ intros bsup1 E1; try exact E1 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U (Add U A x) x0));\n [ intros bsup2 E2; try exact E2 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U (Add U A x) x1));\n [ intros bsup3 E3; try exact E3 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U (Add U A x0) x1));\n [ intros bsup4 E4; try exact E4 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H' bsup bsup0 bsup1); [ intros bsup5 E5; try exact E5 | idtac ];\n auto with sets.\nexists bsup5; try assumption.\n2: apply Consistent_triple_intro.\n2: apply\n    Compatible_lubs\n     with\n       (A := Add U A x)\n       (B := Add U A x0)\n       (C := Add U (Add U A x) x0)\n       (c := bsup2); auto with sets.\n2: apply\n    Compatible_lubs\n     with\n       (A := Add U A x0)\n       (B := Add U A x1)\n       (C := Add U (Add U A x0) x1)\n       (c := bsup4); auto with sets.\n2: apply\n    Compatible_lubs\n     with\n       (A := Add U A x)\n       (B := Add U A x1)\n       (C := Add U (Add U A x) x1)\n       (c := bsup3); auto with sets.\ngeneralize E5.\nclear E5.\nrewrite (Triple_as_Couple_Singleton U bsup bsup0 bsup1). \nintro E5; try assumption.\nunfold Add at 1 in |- *.\ncut\n (Union U (Add U (Add U A x) x0) (Singleton U x1) =\n  Union U (Add U (Add U A x) x0) (Add U A x1)).\nintro H'0; rewrite H'0.\nclear H'0.\napply LUaux2 with (a := bsup2) (b := bsup1); auto with sets.\napply LUaux with (A := Couple U bsup bsup0) (B := Singleton U bsup1);\n auto with sets.\n3: apply Singleton_has_lub.\nclear E5 E4 E3 G6 G5 G4 G3 G2 G1 H'9 H'7 bsup5 bsup4 bsup3 H'6 H'4 H'2 H'.\nred in |- *; simpl in |- *.\nintros x2 H'; elim H'; auto with sets.\nintros x3 H'0; elim H'0; auto with sets.\napply Lub_is_in_Carrier with (X := Add U A x); auto with sets.\napply Lub_is_in_Carrier with (X := Add U A x0); auto with sets.\nintros x3 H'0; elim H'0; auto with sets.\napply Lub_is_in_Carrier with (X := Add U A x1); auto with sets.\n2: apply Lub_is_in_Carrier with (X := Add U A x1); auto with sets.\napply LUaux with (A := Add U A x) (B := Add U A x0); auto with sets.\ncut (Add U (Add U A x) x0 = Union U (Add U A x) (Add U A x0)).\nintro H'0; rewrite <- H'0; auto with sets.\ncut (Add U (Add U A x) x0 = Union U (Add U A x) (Add U A x0) :>Ensemble U).\nclear E5.\n(* Rewrite (Triple_as_Couple_Singleton U bsup bsup0 bsup1). *)\nintro E5; try assumption.\ncut (Lub U D (Couple U bsup bsup0) bsup2).\nintro H'1; try assumption.\napply Add_distributes; auto with sets.\napply LUaux with (A := Add U A x) (B := Add U A x0); auto with sets.\nrewrite <- (Add_distributes U A A x x0); auto with sets.\ncut\n (Union U (Add U (Add U A x) x0) (Singleton U x1) =\n  Add U (Add U (Add U A x) x0) x1 :>Ensemble U).\nintro H'0; rewrite H'0.\nrewrite (Add_distributes U (Add U A x) A x0 x1); auto with sets.\nunfold Add at 3 in |- *; auto with sets.\nQed.\n", "definition": "\n (forall x y z : U,\n  Consistent U D (Triple U x y z) ->\n  ex (fun bsup : U => Lub U D (Triple U x y z) bsup)) ->\n forall X : Ensemble U,\n Finite U X ->\n Included U X (Carrier_of U D) ->\n Consistent U D X -> ex (fun bsup : U => Lub U D X bsup).\n", "proof": "\nintro H'; try assumption.\nintros X H'0; try assumption.\nelim H'0 using Generalized_induction_on_finite_sets.\nclear H'0.\nclear X.\nintros X H'0; elim H'0.\nunfold D at 6 in |- *; auto with sets.\nclear H'0 X.\nintros A H'0; elim H'0.\nintros H'1 x H'2 H'3 H'4 H'5; try assumption.\nrewrite (Empty_set_zero' U x).\nexists x; auto with sets.\nclear H'0 A.\nintros A H'0; elim H'0.\nintros H'1 x H'2 H'3 x0 H'4 H'5 H'6 H'7; try assumption.\n2: clear H'0 A.\n2: intros A H'0 H'1 x H'2 H'3 x0 H'4 H'5 x1 H'6 H'7 H'8 H'9; try assumption.\nclear H'5 H'3 H'1.\nrewrite (Empty_set_zero' U x).\nunfold Add at 1 in |- *.\nrewrite (Couple_as_union U x x0).\nrewrite (Triple_as_Couple U x x0).\napply H'.\nrewrite <- (Triple_as_union U x x x0).\nrewrite (Union_idempotent U (Singleton U x)).\ngeneralize H'7.\nrewrite (Empty_set_zero' U x).\nunfold Add at 1 in |- *; auto with sets.\nclear H'5 H'3 H'1 H'0.\ncut\n (forall X : Ensemble U,\n  Included U X (Add U (Add U (Add U A x) x0) x1) ->\n  Included U X (Carrier_of U D)); auto with sets.\nintro L1.\ncut\n (forall X : Ensemble U,\n  Included U X (Add U (Add U (Add U A x) x0) x1) -> Consistent U D X);\n auto with sets.\n2: intros X H'0.\n2: apply\n    Consistent_downward_stable with (B := Add U (Add U (Add U A x) x0) x1);\n    auto with sets.\nintro L2.\ncut (Included U (Add U A x) (Add U (Add U (Add U A x) x0) x1)); auto with sets.\nintro F1.\ncut (Included U (Add U A x0) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\n2: apply (Inclusion_is_transitive U) with (Add U (Add U A x) x0);\n    auto with sets.\nintro F2.\ncut (Included U (Add U A x1) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\nintro F3.\ncut (Included U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\nintro F4.\ncut (Included U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\nintro F5.\ncut (Included U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1));\n auto with sets.\nintro F6.\ncut\n (Strict_Included U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1)).\n2: split; auto with sets.\n2: red in |- *; simpl in |- *; intro H'0.\n2: lapply\n    (Extension U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1));\n    [ intro H'10; elim H'10 | idtac ]; auto with sets.\nintro G1.\ncut\n (Strict_Included U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1)).\n2: split; auto with sets.\n2: red in |- *; simpl in |- *; intro H'0.\n2: lapply\n    (Extension U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1));\n    [ intro H'10; elim H'10 | idtac ]; auto with sets.\n2: intros H'1 H'3; try assumption.\n2: apply H'4.\n2: lapply (incl_add_x U (Add U (Add U A x) x0) (Add U A x) x1);\n    [ intro H'14; lapply H'14;\n       [ intro H'15; try exact H'15; clear H'14 | clear H'14 ]\n    | idtac ]; auto with sets.\nintro G2.\ncut\n (Strict_Included U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1)).\n2: split; auto with sets.\n2: red in |- *; simpl in |- *; intro H'0.\n2: lapply\n    (Extension U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1));\n    [ intro H'10; elim H'10 | idtac ]; auto with sets.\n2: intros H'1 H'3; try assumption.\n2: apply H'2.\n2: lapply (incl_add_x U (Add U (Add U A x) x0) (Add U A x0) x1);\n    [ intro H'14; lapply H'14;\n       [ intro H'15; try exact H'15; clear H'14 | clear H'14 ]\n    | idtac ]; auto with sets.\n2: lapply (incl_add_x U (Add U A x) A x0);\n    [ intro H'14; lapply H'14;\n       [ intro H'16; try exact H'16; clear H'14 | clear H'14 ]\n    | idtac ]; auto with sets.\nintro G3; try assumption.\ncut (Strict_Included U (Add U A x0) (Add U (Add U (Add U A x) x0) x1)).\n2: apply\n    Strict_inclusion_is_transitive_with_inclusion_left\n     with (y := Add U (Add U A x0) x1); auto with sets.\nintro G4; try assumption.\ncut (Strict_Included U (Add U A x1) (Add U (Add U (Add U A x) x0) x1)).\n2: apply\n    Strict_inclusion_is_transitive_with_inclusion_left\n     with (y := Add U (Add U A x) x1); auto with sets.\nintro G5; try assumption.\ncut (Strict_Included U (Add U A x) (Add U (Add U (Add U A x) x0) x1)).\n2: apply\n    Strict_inclusion_is_transitive_with_inclusion_left\n     with (y := Add U (Add U A x) x0); auto with sets.\nintro G6; try assumption.\nelim (H'7 (Add U A x));\n [ intros bsup E; try exact E | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U A x0));\n [ intros bsup0 E0; try exact E0 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U A x1));\n [ intros bsup1 E1; try exact E1 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U (Add U A x) x0));\n [ intros bsup2 E2; try exact E2 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U (Add U A x) x1));\n [ intros bsup3 E3; try exact E3 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H'7 (Add U (Add U A x0) x1));\n [ intros bsup4 E4; try exact E4 | idtac | idtac | idtac ]; \n auto with sets.\nelim (H' bsup bsup0 bsup1); [ intros bsup5 E5; try exact E5 | idtac ];\n auto with sets.\nexists bsup5; try assumption.\n2: apply Consistent_triple_intro.\n2: apply\n    Compatible_lubs\n     with\n       (A := Add U A x)\n       (B := Add U A x0)\n       (C := Add U (Add U A x) x0)\n       (c := bsup2); auto with sets.\n2: apply\n    Compatible_lubs\n     with\n       (A := Add U A x0)\n       (B := Add U A x1)\n       (C := Add U (Add U A x0) x1)\n       (c := bsup4); auto with sets.\n2: apply\n    Compatible_lubs\n     with\n       (A := Add U A x)\n       (B := Add U A x1)\n       (C := Add U (Add U A x) x1)\n       (c := bsup3); auto with sets.\ngeneralize E5.\nclear E5.\nrewrite (Triple_as_Couple_Singleton U bsup bsup0 bsup1). \nintro E5; try assumption.\nunfold Add at 1 in |- *.\ncut\n (Union U (Add U (Add U A x) x0) (Singleton U x1) =\n  Union U (Add U (Add U A x) x0) (Add U A x1)).\nintro H'0; rewrite H'0.\nclear H'0.\napply LUaux2 with (a := bsup2) (b := bsup1); auto with sets.\napply LUaux with (A := Couple U bsup bsup0) (B := Singleton U bsup1);\n auto with sets.\n3: apply Singleton_has_lub.\nclear E5 E4 E3 G6 G5 G4 G3 G2 G1 H'9 H'7 bsup5 bsup4 bsup3 H'6 H'4 H'2 H'.\nred in |- *; simpl in |- *.\nintros x2 H'; elim H'; auto with sets.\nintros x3 H'0; elim H'0; auto with sets.\napply Lub_is_in_Carrier with (X := Add U A x); auto with sets.\napply Lub_is_in_Carrier with (X := Add U A x0); auto with sets.\nintros x3 H'0; elim H'0; auto with sets.\napply Lub_is_in_Carrier with (X := Add U A x1); auto with sets.\n2: apply Lub_is_in_Carrier with (X := Add U A x1); auto with sets.\napply LUaux with (A := Add U A x) (B := Add U A x0); auto with sets.\ncut (Add U (Add U A x) x0 = Union U (Add U A x) (Add U A x0)).\nintro H'0; rewrite <- H'0; auto with sets.\ncut (Add U (Add U A x) x0 = Union U (Add U A x) (Add U A x0) :>Ensemble U).\nclear E5.\n(* Rewrite (Triple_as_Couple_Singleton U bsup bsup0 bsup1). *)\nintro E5; try assumption.\ncut (Lub U D (Couple U bsup bsup0) bsup2).\nintro H'1; try assumption.\napply Add_distributes; auto with sets.\napply LUaux with (A := Add U A x) (B := Add U A x0); auto with sets.\nrewrite <- (Add_distributes U A A x x0); auto with sets.\ncut\n (Union U (Add U (Add U A x) x0) (Singleton U x1) =\n  Add U (Add U (Add U A x) x0) x1 :>Ensemble U).\nintro H'0; rewrite H'0.\nrewrite (Add_distributes U (Add U A x) A x0 x1); auto with sets.\nunfold Add at 3 in |- *; auto with sets.\n", "def_ranges": [22, 0, 29, 57], "proof_ranges": [30, 0, 232, 4], "proof_steps": [{"text": "intro H'; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros X H'0; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0 using Generalized_induction_on_finite_sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear X.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros X H'0; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold D at 6 in |- *; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'0 X.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A H'0; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'1 x H'2 H'3 H'4 H'5; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (Empty_set_zero' U x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'0 A.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A H'0; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'1 x H'2 H'3 x0 H'4 H'5 H'6 H'7; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: clear H'0 A.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros A H'0 H'1 x H'2 H'3 x0 H'4 H'5 x1 H'6 H'7 H'8 H'9; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'5 H'3 H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (Empty_set_zero' U x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Add at 1 in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (Couple_as_union U x x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (Triple_as_Couple U x x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (Triple_as_union U x x x0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (Union_idempotent U (Singleton U x)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize H'7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (Empty_set_zero' U x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Add at 1 in |- *; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear H'5 H'3 H'1 H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(forall X : Ensemble U,", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Included U X (Add U (Add U (Add U A x) x0) x1) ->", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Included U X (Carrier_of U D)); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro L1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(forall X : Ensemble U,", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Included U X (Add U (Add U (Add U A x) x0) x1) -> Consistent U D X);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros X H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Consistent_downward_stable with (B := Add U (Add U (Add U A x) x0) x1);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro L2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Included U (Add U A x) (Add U (Add U (Add U A x) x0) x1)); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro F1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Included U (Add U A x0) (Add U (Add U (Add U A x) x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply (Inclusion_is_transitive U) with (Add U (Add U A x) x0);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro F2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Included U (Add U A x1) (Add U (Add U (Add U A x) x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro F3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Included U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro F4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Included U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro F5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Included U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro F6.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Strict_Included U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: split; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; simpl in |- *; intro H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: lapply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Extension U (Add U (Add U A x) x0) (Add U (Add U (Add U A x) x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'10; elim H'10 | idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro G1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Strict_Included U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: split; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; simpl in |- *; intro H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: lapply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Extension U (Add U (Add U A x) x1) (Add U (Add U (Add U A x) x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'10; elim H'10 | idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros H'1 H'3; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: lapply (incl_add_x U (Add U (Add U A x) x0) (Add U A x) x1);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'14; lapply H'14;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'15; try exact H'15; clear H'14 | clear H'14 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro G2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Strict_Included U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: split; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; simpl in |- *; intro H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: lapply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Extension U (Add U (Add U A x0) x1) (Add U (Add U (Add U A x) x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'10; elim H'10 | idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros H'1 H'3; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply H'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: lapply (incl_add_x U (Add U (Add U A x) x0) (Add U A x0) x1);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'14; lapply H'14;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'15; try exact H'15; clear H'14 | clear H'14 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: lapply (incl_add_x U (Add U A x) A x0);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'14; lapply H'14;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'16; try exact H'16; clear H'14 | clear H'14 ]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro G3; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Strict_Included U (Add U A x0) (Add U (Add U (Add U A x) x0) x1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Strict_inclusion_is_transitive_with_inclusion_left", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with (y := Add U (Add U A x0) x1); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro G4; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Strict_Included U (Add U A x1) (Add U (Add U (Add U A x) x0) x1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Strict_inclusion_is_transitive_with_inclusion_left", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with (y := Add U (Add U A x) x1); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro G5; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Strict_Included U (Add U A x) (Add U (Add U (Add U A x) x0) x1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Strict_inclusion_is_transitive_with_inclusion_left", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with (y := Add U (Add U A x) x0); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro G6; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H'7 (Add U A x));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intros bsup E; try exact E | idtac | idtac | idtac ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H'7 (Add U A x0));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intros bsup0 E0; try exact E0 | idtac | idtac | idtac ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H'7 (Add U A x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intros bsup1 E1; try exact E1 | idtac | idtac | idtac ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H'7 (Add U (Add U A x) x0));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intros bsup2 E2; try exact E2 | idtac | idtac | idtac ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H'7 (Add U (Add U A x) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intros bsup3 E3; try exact E3 | idtac | idtac | idtac ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H'7 (Add U (Add U A x0) x1));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intros bsup4 E4; try exact E4 | idtac | idtac | idtac ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H' bsup bsup0 bsup1); [ intros bsup5 E5; try exact E5 | idtac ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists bsup5; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply Consistent_triple_intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Compatible_lubs", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(A := Add U A x)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(B := Add U A x0)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(C := Add U (Add U A x) x0)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(c := bsup2); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Compatible_lubs", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(A := Add U A x0)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(B := Add U A x1)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(C := Add U (Add U A x0) x1)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(c := bsup4); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Compatible_lubs", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(A := Add U A x)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(B := Add U A x1)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(C := Add U (Add U A x) x1)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(c := bsup3); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "generalize E5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear E5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (Triple_as_Couple_Singleton U bsup bsup0 bsup1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro E5; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/triple.v", "name": "Triples_are_enough", "text": "Theorem Triples_are_enough :\n (forall x y z : U,\n  Consistent U D (Triple U x y z) ->\n  ex (fun bsup : U => Lub U D (Triple U x y z) bsup)) -> \n Coherent U D.\nintro H'; red in |- *; simpl in |- *.\nintros X H'0 K; try assumption.\ncut (Complete U D).\n2: exact (Cpo_cond U C).\nunfold D at 1 in |- *.\nintro H'3; elim H'3; intros H'6 H'7.\nelim (H'7 (Lubs_of_finite_parts U C X));\n [ intros bsup0 E0 | apply LFP_directed ]; auto with sets.\nexists bsup0; unfold D at 1 in |- *; auto with sets.\nintros Y H'1 H'2; try assumption.\nchange (ex (fun bsup : U => Lub U D Y bsup)) in |- *.\napply Triples_are_enough_finite_case; auto with sets.\napply Consistent_downward_stable with (B := X); auto with sets.\nQed.\n", "definition": "\n (forall x y z : U,\n  Consistent U D (Triple U x y z) ->\n  ex (fun bsup : U => Lub U D (Triple U x y z) bsup)) -> \n Coherent U D.", "proof": "\nintro H'; red in |- *; simpl in |- *.\nintros X H'0 K; try assumption.\ncut (Complete U D).\n2: exact (Cpo_cond U C).\nunfold D at 1 in |- *.\nintro H'3; elim H'3; intros H'6 H'7.\nelim (H'7 (Lubs_of_finite_parts U C X));\n [ intros bsup0 E0 | apply LFP_directed ]; auto with sets.\nexists bsup0; unfold D at 1 in |- *; auto with sets.\nintros Y H'1 H'2; try assumption.\nchange (ex (fun bsup : U => Lub U D Y bsup)) in |- *.\napply Triples_are_enough_finite_case; auto with sets.\napply Consistent_downward_stable with (B := X); auto with sets.\n", "def_ranges": [235, 0, 239, 14], "proof_ranges": [240, 0, 253, 4], "proof_steps": [{"text": "intro H'; red in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros X H'0 K; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (Complete U D).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: exact (Cpo_cond U C).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold D at 1 in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H'3; elim H'3; intros H'6 H'7.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H'7 (Lubs_of_finite_parts U C X));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intros bsup0 E0 | apply LFP_directed ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists bsup0; unfold D at 1 in |- *; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Y H'1 H'2; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (ex (fun bsup : U => Lub U D Y bsup)) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Triples_are_enough_finite_case; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Consistent_downward_stable with (B := X); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/newfil.v", "name": "Pairs_are_enough_finite_case", "text": "Theorem Pairs_are_enough_finite_case :\n (forall x y : U,\n  Compatible U D x y -> ex (fun bsup : U => Lub U D (Couple U x y) bsup)) ->\n forall X : Ensemble U,\n Finite U X ->\n Included U X (Carrier_of U D) ->\n ex (fun maj : U => Upper_Bound U D X maj) ->\n ex (fun bsup : U => Lub U D X bsup).\nProof.\nintros H' X H'0; elim H'0; auto with sets.\nunfold D at 3 in |- *; auto with sets.\nunfold Add in |- *.\nintros A H'1 H'2 x H'3 H'4 H'5.\nelim H'5; intros maj E; try exact E; clear H'5.\nelim H'2; [ intros bsupA E0; elim E0; clear H'2 | clear H'2 | clear H'2 ];\n auto with sets.\n2: exists maj;\n    apply Upper_downward_stable with (B := Union U A (Singleton U x));\n    auto with sets.\nintros H'2 H'6.\nelim (H' bsupA x); [ intros bsup E1; elim E1 | idtac ]; auto with sets.\n2: red in |- *; simpl in |- *.\n2: intros H'7 H'8; exists maj; elim E; auto 7 with sets.\nintros H'5 H'7; try assumption.\nexists bsup; try assumption.\napply LUaux2 with (a := bsupA) (b := x); auto with sets.\nQed.\n", "definition": "\n (forall x y : U,\n  Compatible U D x y -> ex (fun bsup : U => Lub U D (Couple U x y) bsup)) ->\n forall X : Ensemble U,\n Finite U X ->\n Included U X (Carrier_of U D) ->\n ex (fun maj : U => Upper_Bound U D X maj) ->\n ex (fun bsup : U => Lub U D X bsup).\n", "proof": "\nintros H' X H'0; elim H'0; auto with sets.\nunfold D at 3 in |- *; auto with sets.\nunfold Add in |- *.\nintros A H'1 H'2 x H'3 H'4 H'5.\nelim H'5; intros maj E; try exact E; clear H'5.\nelim H'2; [ intros bsupA E0; elim E0; clear H'2 | clear H'2 | clear H'2 ];\n auto with sets.\n2: exists maj;\n    apply Upper_downward_stable with (B := Union U A (Singleton U x));\n    auto with sets.\nintros H'2 H'6.\nelim (H' bsupA x); [ intros bsup E1; elim E1 | idtac ]; auto with sets.\n2: red in |- *; simpl in |- *.\n2: intros H'7 H'8; exists maj; elim E; auto 7 with sets.\nintros H'5 H'7; try assumption.\nexists bsup; try assumption.\napply LUaux2 with (a := bsupA) (b := x); auto with sets.\n", "def_ranges": [20, 0, 27, 37], "proof_ranges": [28, 0, 46, 4], "proof_steps": [{"text": "intros H' X H'0; elim H'0; auto with sets.", "goal_before": ["(forall x y : U,\n Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup) ->\nforall X : Ensemble U,\nFinite U X ->\nIncluded U X (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U D (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup) ?Goal ?Goal0 X H'0)"]}, {"text": "unfold D at 3 in |- *; auto with sets.", "goal_before": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U D (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup) ?Goal ?Goal0 X H'0)"], "proof_term_after": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup)\n   (?Goal0\n    :\n    Included U (Empty_set U) (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n    exists bsup : U, Lub U D (Empty_set U) bsup) ?Goal X H'0)"]}, {"text": "unfold Add in |- *.", "goal_before": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup)\n   (?Goal0\n    :\n    Included U (Empty_set U) (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n    exists bsup : U, Lub U D (Empty_set U) bsup) ?Goal X H'0)"], "proof_term_after": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup)\n   ((?Goal0\n     :\n     Included U (Empty_set U) (Carrier_of U D) ->\n     (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n     exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup)\n    :\n    Included U (Empty_set U) (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n    exists bsup : U, Lub U D (Empty_set U) bsup) ?Goal X H'0)"]}, {"text": "intros A H'1 H'2 x H'3 H'4 H'5.", "goal_before": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup)\n   ((?Goal0\n     :\n     Included U (Empty_set U) (Carrier_of U D) ->\n     (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n     exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup)\n    :\n    Included U (Empty_set U) (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n    exists bsup : U, Lub U D (Empty_set U) bsup) ?Goal X H'0)"], "proof_term_after": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup)\n   ((?Goal0\n     :\n     Included U (Empty_set U) (Carrier_of U D) ->\n     (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n     exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup)\n    :\n    Included U (Empty_set U) (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n    exists bsup : U, Lub U D (Empty_set U) bsup) ?Goal X H'0)"]}, {"text": "elim H'5; intros maj E; try exact E; clear H'5.", "goal_before": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup)\n   ((?Goal0\n     :\n     Included U (Empty_set U) (Carrier_of U D) ->\n     (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n     exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup)\n    :\n    Included U (Empty_set U) (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n    exists bsup : U, Lub U D (Empty_set U) bsup) ?Goal X H'0)"], "proof_term_after": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup)\n   ((?Goal0\n     :\n     Included U (Empty_set U) (Carrier_of U D) ->\n     (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n     exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup)\n    :\n    Included U (Empty_set U) (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n    exists bsup : U, Lub U D (Empty_set U) bsup) ?Goal X H'0)"]}, {"text": "elim H'2; [ intros bsupA E0; elim E0; clear H'2 | clear H'2 | clear H'2 ];", "goal_before": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": ["(fun\n   (H' : forall x y : U,\n         Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup)\n   (X : Ensemble U) (H'0 : Finite U X) =>\n Finite_ind U\n   (fun X0 : Ensemble U =>\n    Included U X0 (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D X0 maj) ->\n    exists bsup : U, Lub U D X0 bsup)\n   ((?Goal0\n     :\n     Included U (Empty_set U) (Carrier_of U D) ->\n     (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n     exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup)\n    :\n    Included U (Empty_set U) (Carrier_of U D) ->\n    (exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\n    exists bsup : U, Lub U D (Empty_set U) bsup) ?Goal X H'0)"], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "2: exists maj;", "goal_before": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_downward_stable with (B := Union U A (Singleton U x));", "goal_before": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["Included U (Empty_set U) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Empty_set U) maj) ->\nexists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'2 H'6.", "goal_before": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (H' bsupA x); [ intros bsup E1; elim E1 | idtac ]; auto with sets.", "goal_before": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "2: red in |- *; simpl in |- *.", "goal_before": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "2: intros H'7 H'8; exists maj; elim E; auto 7 with sets.", "goal_before": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'5 H'7; try assumption.", "goal_before": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists bsup; try assumption.", "goal_before": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "goal_after": ["exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup", "forall A : Ensemble U,\nFinite U A ->\n(Included U A (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D A maj) -> exists bsup : U, Lub U D A bsup) ->\nforall x : U,\n~ In U A x ->\nIncluded U (Add U A x) (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D (Add U A x) maj) ->\nexists bsup : U, Lub U D (Add U A x) bsup"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/newfil.v", "name": "LFP_directed", "text": "Theorem LFP_directed :\n forall X : Ensemble U,\n (forall Y : Ensemble U,\n  Included U Y X -> Finite U Y -> exists bsup : U, Lub U D Y bsup) ->\n Included U X (Carrier_of U D) ->\n Consistent U D X -> Directed U D (Lubs_of_finite_parts X).\nintros X K H' L; apply Definition_of_Directed.\nred in |- *; simpl in |- *; intros x H'0; elim H'0; auto with sets.\nintros bsup Y H'1 H'2 H'3; apply Lub_is_in_Carrier with (X := Y);\n auto with sets.\nelim (Empty_set_has_lub U C); intros bsup E.\napply Inhabited_intro with (x := bsup).\napply Lubs_of_finite_parts_def with (Y := Empty_set U); auto with sets.\nintros x1 x2 H'4; red in H'4.\nlapply (H'4 x1); [ intro H'1; elim H'1 | idtac ]; auto with sets.\nintros bsup Y H'0 H'2 H'3; try assumption.\nlapply (H'4 x2); [ intro H'6; elim H'6 | idtac ]; auto with sets.\nintros bsup0 Y0 H'5 H'7 H'8; try assumption.\nlapply (Union_preserves_Finite U Y Y0);\n [ intro H'12; lapply H'12; [ intro H'13; clear H'12 | clear H'12 ] | idtac ];\n auto with sets.\nelim (K (Union U Y Y0)); [ intros bsup1 E | idtac | idtac ]; auto with sets.\nexists bsup1; split.\napply Lubs_of_finite_parts_def with (Y := Union U Y Y0); auto with sets.\napply Upper_Bound_Couple_intro.\napply Lub_is_in_Carrier with (X := Y); auto with sets.\napply Lub_is_in_Carrier with (X := Y0); auto with sets.\napply Lub_is_in_Carrier with (X := Union U Y Y0); auto with sets.\nelim H'3.\nintros H'10 H'11; apply H'11.\nelim E; intros H'12 H'14;\n apply Upper_downward_stable with (B := Union U Y Y0); \n auto with sets.\nelim H'8.\nintros H'10 H'11; apply H'11.\nelim E; intros H'12 H'14;\n apply Upper_downward_stable with (B := Union U Y Y0); \n auto with sets.\nQed.\n", "definition": "\n forall X : Ensemble U,\n (forall Y : Ensemble U,\n  Included U Y X -> Finite U Y -> exists bsup : U, Lub U D Y bsup) ->\n Included U X (Carrier_of U D) ->\n Consistent U D X -> Directed U D (Lubs_of_finite_parts X).", "proof": "\nintros X K H' L; apply Definition_of_Directed.\nred in |- *; simpl in |- *; intros x H'0; elim H'0; auto with sets.\nintros bsup Y H'1 H'2 H'3; apply Lub_is_in_Carrier with (X := Y);\n auto with sets.\nelim (Empty_set_has_lub U C); intros bsup E.\napply Inhabited_intro with (x := bsup).\napply Lubs_of_finite_parts_def with (Y := Empty_set U); auto with sets.\nintros x1 x2 H'4; red in H'4.\nlapply (H'4 x1); [ intro H'1; elim H'1 | idtac ]; auto with sets.\nintros bsup Y H'0 H'2 H'3; try assumption.\nlapply (H'4 x2); [ intro H'6; elim H'6 | idtac ]; auto with sets.\nintros bsup0 Y0 H'5 H'7 H'8; try assumption.\nlapply (Union_preserves_Finite U Y Y0);\n [ intro H'12; lapply H'12; [ intro H'13; clear H'12 | clear H'12 ] | idtac ];\n auto with sets.\nelim (K (Union U Y Y0)); [ intros bsup1 E | idtac | idtac ]; auto with sets.\nexists bsup1; split.\napply Lubs_of_finite_parts_def with (Y := Union U Y Y0); auto with sets.\napply Upper_Bound_Couple_intro.\napply Lub_is_in_Carrier with (X := Y); auto with sets.\napply Lub_is_in_Carrier with (X := Y0); auto with sets.\napply Lub_is_in_Carrier with (X := Union U Y Y0); auto with sets.\nelim H'3.\nintros H'10 H'11; apply H'11.\nelim E; intros H'12 H'14;\n apply Upper_downward_stable with (B := Union U Y Y0); \n auto with sets.\nelim H'8.\nintros H'10 H'11; apply H'11.\nelim E; intros H'12 H'14;\n apply Upper_downward_stable with (B := Union U Y Y0); \n auto with sets.\n", "def_ranges": [54, 0, 59, 59], "proof_ranges": [60, 0, 92, 4], "proof_steps": [{"text": "intros X K H' L; apply Definition_of_Directed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; simpl in |- *; intros x H'0; elim H'0; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros bsup Y H'1 H'2 H'3; apply Lub_is_in_Carrier with (X := Y);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (Empty_set_has_lub U C); intros bsup E.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Inhabited_intro with (x := bsup).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lubs_of_finite_parts_def with (Y := Empty_set U); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 x2 H'4; red in H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (H'4 x1); [ intro H'1; elim H'1 | idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros bsup Y H'0 H'2 H'3; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (H'4 x2); [ intro H'6; elim H'6 | idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros bsup0 Y0 H'5 H'7 H'8; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (Union_preserves_Finite U Y Y0);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'12; lapply H'12; [ intro H'13; clear H'12 | clear H'12 ] | idtac ];", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (K (Union U Y Y0)); [ intros bsup1 E | idtac | idtac ]; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists bsup1; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lubs_of_finite_parts_def with (Y := Union U Y Y0); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_Couple_intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lub_is_in_Carrier with (X := Y); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lub_is_in_Carrier with (X := Y0); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Lub_is_in_Carrier with (X := Union U Y Y0); auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'10 H'11; apply H'11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; intros H'12 H'14;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_downward_stable with (B := Union U Y Y0);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'8.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'10 H'11; apply H'11.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/newfil.v", "name": "Lub_is_LFP", "text": "Theorem Lub_is_LFP :\n forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n forall bsup : U, Lub U D (Lubs_of_finite_parts X) bsup -> Lub U D X bsup.\nintros X K bsup E0; elim E0.\nintros H'4 H'5; apply Lub_definition; auto with sets.\napply Upper_Bound_definition; auto with sets.\napply Lub_is_in_Carrier with (X := Lubs_of_finite_parts X); auto with sets.\nred in |- *; simpl in |- *; intros x H'8; elim H'8.\nintros bsup0 Y H'9 H'10 H'11; apply Lub_is_in_Carrier with Y; auto with sets.\nintros y H'8; elim H'4.\nintros H'9 H'10; apply H'10.\napply Lubs_of_finite_parts_def with (Y := Singleton U y); auto with sets.\nred in |- *; simpl in |- *.\nintros x H'11; elim H'11; auto with sets.\napply Singleton_is_finite.\nintros y H'8; apply H'5.\napply Upper_Bound_definition.\nelim H'8; auto with sets.\nintros y0 H'9; elim H'9.\nintros bsup1 Y H'10 H'11 H'12; elim H'12.\nintros H'13 H'14; apply H'14.\napply Upper_downward_stable with (B := X); auto with sets.\nQed.\n", "definition": "\n forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n forall bsup : U, Lub U D (Lubs_of_finite_parts X) bsup -> Lub U D X bsup.", "proof": "\nintros X K bsup E0; elim E0.\nintros H'4 H'5; apply Lub_definition; auto with sets.\napply Upper_Bound_definition; auto with sets.\napply Lub_is_in_Carrier with (X := Lubs_of_finite_parts X); auto with sets.\nred in |- *; simpl in |- *; intros x H'8; elim H'8.\nintros bsup0 Y H'9 H'10 H'11; apply Lub_is_in_Carrier with Y; auto with sets.\nintros y H'8; elim H'4.\nintros H'9 H'10; apply H'10.\napply Lubs_of_finite_parts_def with (Y := Singleton U y); auto with sets.\nred in |- *; simpl in |- *.\nintros x H'11; elim H'11; auto with sets.\napply Singleton_is_finite.\nintros y H'8; apply H'5.\napply Upper_Bound_definition.\nelim H'8; auto with sets.\nintros y0 H'9; elim H'9.\nintros bsup1 Y H'10 H'11 H'12; elim H'12.\nintros H'13 H'14; apply H'14.\napply Upper_downward_stable with (B := X); auto with sets.\n", "def_ranges": [94, 0, 97, 74], "proof_ranges": [98, 0, 117, 4], "proof_steps": [{"text": "intros X K bsup E0; elim E0.", "goal_before": ["forall X : Ensemble U,\nIncluded U X (Carrier_of U D) ->\nforall bsup : U, Lub U D (Lubs_of_finite_parts X) bsup -> Lub U D X bsup"], "goal_after": ["Upper_Bound U D (Lubs_of_finite_parts X) bsup ->\n(forall y : U,\n Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y) ->\nLub U D X bsup"], "proof_term_before": [], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup) ?Goal E0)"]}, {"text": "intros H'4 H'5; apply Lub_definition; auto with sets.", "goal_before": ["Upper_Bound U D (Lubs_of_finite_parts X) bsup ->\n(forall y : U,\n Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y) ->\nLub U D X bsup"], "goal_after": ["Upper_Bound U D X bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup) ?Goal E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    => Lub_definition U D X bsup ?Goal ?Goal0) E0)"]}, {"text": "apply Upper_Bound_definition; auto with sets.", "goal_before": ["Upper_Bound U D X bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    => Lub_definition U D X bsup ?Goal ?Goal0) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"]}, {"text": "apply Lub_is_in_Carrier with (X := Lubs_of_finite_parts X); auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"]}, {"text": "red in |- *; simpl in |- *; intros x H'8; elim H'8.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"]}, {"text": "intros bsup0 Y H'9 H'10 H'11; apply Lub_is_in_Carrier with Y; auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"]}, {"text": "intros y H'8; elim H'4.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"]}, {"text": "intros H'9 H'10; apply H'10.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"]}, {"text": "apply Lubs_of_finite_parts_def with (Y := Singleton U y); auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"]}, {"text": "red in |- *; simpl in |- *.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup ?Goal0 ?Goal1) \n      ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "intros x H'11; elim H'11; auto with sets.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "apply Singleton_is_finite.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "intros y H'8; apply H'5.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "apply Upper_Bound_definition.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "elim H'8; auto with sets.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "intros y0 H'9; elim H'9.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "intros bsup1 Y H'10 H'11 H'12; elim H'12.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "intros H'13 H'14; apply H'14.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "apply Upper_downward_stable with (B := X); auto with sets.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"]}, {"text": "Qed.", "goal_before": ["Carrier_of U D bsup", "forall y : U, In U X y -> Rel_of U D y bsup", "forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y"], "goal_after": [], "proof_term_before": ["(fun (X : Ensemble U) (K : Included U X (Carrier_of U D)) \n   (bsup : U) (E0 : Lub U D (Lubs_of_finite_parts X) bsup) =>\n Lub_ind U D (Lubs_of_finite_parts X) bsup (Lub U D X bsup)\n   (fun (H'4 : Upper_Bound U D (Lubs_of_finite_parts X) bsup)\n      (H'5 : forall y : U,\n             Upper_Bound U D (Lubs_of_finite_parts X) y -> Rel_of U D bsup y)\n    =>\n    Lub_definition U D X bsup\n      (Upper_Bound_definition U D X bsup\n         ((?Goal1 : Carrier_of U D bsup) : In U (Carrier_of U D) bsup) \n         ?Goal0) ?Goal) E0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/newfil.v", "name": "Pairs_are_enough", "text": "Theorem Pairs_are_enough :\n (forall x y : U,\n  Compatible U D x y -> ex (fun bsup : U => Lub U D (Couple U x y) bsup)) ->\n Conditionally_complete U D.\nProof.\nintro H'; apply Definition_of_Conditionally_complete.\nintros X H'1 H'2.\ncut (Complete U D).\n2: exact (Cpo_cond U C).\nintro H'3; elim H'3; intros H'6 H'7.\nelim (H'7 (Lubs_of_finite_parts X)); [ intros bsup0 E0 | apply LFP_directed ];\n auto with sets.\nexists bsup0; auto with sets.\nauto with sets.\nintros Y H'4 H'5; apply Pairs_are_enough_finite_case; auto with sets.\nelim H'2; intros maj E; try exact E; clear H'2.\nexists maj.\napply Upper_downward_stable with (B := X); auto with sets.\nQed.\n", "definition": "\n (forall x y : U,\n  Compatible U D x y -> ex (fun bsup : U => Lub U D (Couple U x y) bsup)) ->\n Conditionally_complete U D.\n", "proof": "\nintro H'; apply Definition_of_Conditionally_complete.\nintros X H'1 H'2.\ncut (Complete U D).\n2: exact (Cpo_cond U C).\nintro H'3; elim H'3; intros H'6 H'7.\nelim (H'7 (Lubs_of_finite_parts X)); [ intros bsup0 E0 | apply LFP_directed ];\n auto with sets.\nexists bsup0; auto with sets.\nauto with sets.\nintros Y H'4 H'5; apply Pairs_are_enough_finite_case; auto with sets.\nelim H'2; intros maj E; try exact E; clear H'2.\nexists maj.\napply Upper_downward_stable with (B := X); auto with sets.\n", "def_ranges": [121, 0, 124, 28], "proof_ranges": [125, 0, 139, 4], "proof_steps": [{"text": "intro H'; apply Definition_of_Conditionally_complete.", "goal_before": ["(forall x y : U,\n Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup) ->\nConditionally_complete U D"], "goal_after": ["forall X : Ensemble U,\nIncluded U X (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup"], "proof_term_before": [], "proof_term_after": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D ?Goal)"]}, {"text": "intros X H'1 H'2.", "goal_before": ["forall X : Ensemble U,\nIncluded U X (Carrier_of U D) ->\n(exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup"], "goal_after": ["exists bsup : U, Lub U D X bsup"], "proof_term_before": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D ?Goal)"], "proof_term_after": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D\n   (fun (X : Ensemble U) (H'1 : Included U X (Carrier_of U D))\n      (H'2 : exists maj : U, Upper_Bound U D X maj) => \n    ?Goal))"]}, {"text": "cut (Complete U D).", "goal_before": ["exists bsup : U, Lub U D X bsup"], "goal_after": ["Complete U D -> exists bsup : U, Lub U D X bsup", "Complete U D"], "proof_term_before": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D\n   (fun (X : Ensemble U) (H'1 : Included U X (Carrier_of U D))\n      (H'2 : exists maj : U, Upper_Bound U D X maj) => \n    ?Goal))"], "proof_term_after": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D\n   (fun (X : Ensemble U) (H'1 : Included U X (Carrier_of U D))\n      (H'2 : exists maj : U, Upper_Bound U D X maj) =>\n    let H : Complete U D := ?Goal0 in ?Goal H))"]}, {"text": "2: exact (Cpo_cond U C).", "goal_before": ["Complete U D -> exists bsup : U, Lub U D X bsup", "Complete U D"], "goal_after": ["Complete U D -> exists bsup : U, Lub U D X bsup"], "proof_term_before": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D\n   (fun (X : Ensemble U) (H'1 : Included U X (Carrier_of U D))\n      (H'2 : exists maj : U, Upper_Bound U D X maj) =>\n    let H : Complete U D := ?Goal0 in ?Goal H))"], "proof_term_after": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D\n   (fun (X : Ensemble U) (H'1 : Included U X (Carrier_of U D))\n      (H'2 : exists maj : U, Upper_Bound U D X maj) =>\n    let H : Complete U D := Cpo_cond U C in ?Goal H))"]}, {"text": "intro H'3; elim H'3; intros H'6 H'7.", "goal_before": ["Complete U D -> exists bsup : U, Lub U D X bsup"], "goal_after": ["exists bsup : U, Lub U D X bsup"], "proof_term_before": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D\n   (fun (X : Ensemble U) (H'1 : Included U X (Carrier_of U D))\n      (H'2 : exists maj : U, Upper_Bound U D X maj) =>\n    let H : Complete U D := Cpo_cond U C in ?Goal H))"], "proof_term_after": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D\n   (fun (X : Ensemble U) (H'1 : Included U X (Carrier_of U D))\n      (H'2 : exists maj : U, Upper_Bound U D X maj) =>\n    let H : Complete U D := Cpo_cond U C in\n    (fun H'3 : Complete U D =>\n     Complete_ind U D (exists bsup : U, Lub U D X bsup)\n       (fun (H'6 : exists bot : U, Bottom U D bot)\n          (H'7 : forall X0 : Ensemble U,\n                 Directed U D X0 -> exists bsup : U, Lub U D X0 bsup) =>\n        ?Goal) H'3) H))"]}, {"text": "elim (H'7 (Lubs_of_finite_parts X)); [ intros bsup0 E0 | apply LFP_directed ];", "goal_before": ["exists bsup : U, Lub U D X bsup"], "goal_after": ["exists bsup : U, Lub U D X bsup"], "proof_term_before": ["(fun\n   H' : forall x y : U,\n        Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup =>\n Definition_of_Conditionally_complete U D\n   (fun (X : Ensemble U) (H'1 : Included U X (Carrier_of U D))\n      (H'2 : exists maj : U, Upper_Bound U D X maj) =>\n    let H : Complete U D := Cpo_cond U C in\n    (fun H'3 : Complete U D =>\n     Complete_ind U D (exists bsup : U, Lub U D X bsup)\n       (fun (H'6 : exists bot : U, Bottom U D bot)\n          (H'7 : forall X0 : Ensemble U,\n                 Directed U D X0 -> exists bsup : U, Lub U D X0 bsup) =>\n        ?Goal) H'3) H))"], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": ["exists bsup : U, Lub U D X bsup"], "goal_after": ["exists bsup : U, Lub U D X bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists bsup0; auto with sets.", "goal_before": ["exists bsup : U, Lub U D X bsup"], "goal_after": ["exists bsup : U, Lub U D X bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": ["exists bsup : U, Lub U D X bsup"], "goal_after": ["exists bsup : U, Lub U D X bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Y H'4 H'5; apply Pairs_are_enough_finite_case; auto with sets.", "goal_before": ["exists bsup : U, Lub U D X bsup"], "goal_after": ["exists bsup : U, Lub U D X bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'2; intros maj E; try exact E; clear H'2.", "goal_before": ["exists bsup : U, Lub U D X bsup"], "goal_after": ["exists bsup : U, Lub U D X bsup"], "proof_term_before": [], "proof_term_after": []}, {"text": "exists maj.", "goal_before": ["Lub U D X maj"], "goal_after": ["Lub U D X maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_downward_stable with (B := X); auto with sets.", "goal_before": ["Lub U D X maj"], "goal_after": ["Lub U D X maj"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Rel_of_reflexive", "text": "Theorem Rel_of_reflexive : forall x : U, Rel_of U D x x.\nProof.\nelim D.\nintros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.\nQed.\n", "definition": " forall x : U, Rel_of U D x x.\n", "proof": "\nelim D.\nintros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.\n", "def_ranges": [13, 0, 13, 56], "proof_ranges": [14, 0, 17, 4], "proof_steps": [{"text": "elim D.", "goal_before": ["forall x : U, Rel_of U D x x"], "goal_after": ["forall (Carrier_of : Ensemble U) (Rel_of : Relation U)\n  (PO_cond1 : Inhabited U Carrier_of) (PO_cond2 : Order U Rel_of) \n  (x : U),\nPartial_Order.Rel_of U\n  {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} x x"], "proof_term_before": [], "proof_term_after": ["match D as p return (forall x : U, Rel_of U p x x) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} => ?Goal Carrier_of Rel_of PO_cond1 PO_cond2\nend"]}, {"text": "intros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.", "goal_before": ["forall (Carrier_of : Ensemble U) (Rel_of : Relation U)\n  (PO_cond1 : Inhabited U Carrier_of) (PO_cond2 : Order U Rel_of) \n  (x : U),\nPartial_Order.Rel_of U\n  {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} x x"], "goal_after": [], "proof_term_before": ["match D as p return (forall x : U, Rel_of U p x x) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} => ?Goal Carrier_of Rel_of PO_cond1 PO_cond2\nend"], "proof_term_after": ["match D as p return (forall x : U, Rel_of U p x x) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of0;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (Carrier_of0 : Ensemble U) (Rel_of1 : Relation U)\n       (PO_cond3 : Inhabited U Carrier_of0) (PO_cond4 : Order U Rel_of1) =>\n     Order_ind U Rel_of1\n       (forall x : U,\n        Rel_of U\n          {|\n            Carrier_of := Carrier_of0;\n            Rel_of := Rel_of1;\n            PO_cond1 := PO_cond3;\n            PO_cond2 := PO_cond4\n          |} x x)\n       (fun (H : Reflexive U Rel_of1) (_ : Transitive U Rel_of1)\n          (_ : Antisymmetric U Rel_of1) => H) PO_cond4) Carrier_of Rel_of0\n      PO_cond1 PO_cond2\nend"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["match D as p return (forall x : U, Rel_of U p x x) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of0;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (Carrier_of0 : Ensemble U) (Rel_of1 : Relation U)\n       (PO_cond3 : Inhabited U Carrier_of0) (PO_cond4 : Order U Rel_of1) =>\n     Order_ind U Rel_of1\n       (forall x : U,\n        Rel_of U\n          {|\n            Carrier_of := Carrier_of0;\n            Rel_of := Rel_of1;\n            PO_cond1 := PO_cond3;\n            PO_cond2 := PO_cond4\n          |} x x)\n       (fun (H : Reflexive U Rel_of1) (_ : Transitive U Rel_of1)\n          (_ : Antisymmetric U Rel_of1) => H) PO_cond4) Carrier_of Rel_of0\n      PO_cond1 PO_cond2\nend"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Rel_of_antisymmetric", "text": "Theorem Rel_of_antisymmetric : Antisymmetric U (Rel_of U D).\nProof.\nelim D.\nintros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.\nQed.\n", "definition": " Antisymmetric U (Rel_of U D).\n", "proof": "\nelim D.\nintros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.\n", "def_ranges": [20, 0, 20, 60], "proof_ranges": [21, 0, 24, 4], "proof_steps": [{"text": "elim D.", "goal_before": ["Antisymmetric U (Rel_of U D)"], "goal_after": ["forall (Carrier_of : Ensemble U) (Rel_of : Relation U)\n  (PO_cond1 : Inhabited U Carrier_of) (PO_cond2 : Order U Rel_of),\nAntisymmetric U\n  (Partial_Order.Rel_of U\n     {|\n       Carrier_of := Carrier_of;\n       Rel_of := Rel_of;\n       PO_cond1 := PO_cond1;\n       PO_cond2 := PO_cond2\n     |})"], "proof_term_before": [], "proof_term_after": ["match D as p return (Antisymmetric U (Rel_of U p)) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} => ?Goal Carrier_of Rel_of PO_cond1 PO_cond2\nend"]}, {"text": "intros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.", "goal_before": ["forall (Carrier_of : Ensemble U) (Rel_of : Relation U)\n  (PO_cond1 : Inhabited U Carrier_of) (PO_cond2 : Order U Rel_of),\nAntisymmetric U\n  (Partial_Order.Rel_of U\n     {|\n       Carrier_of := Carrier_of;\n       Rel_of := Rel_of;\n       PO_cond1 := PO_cond1;\n       PO_cond2 := PO_cond2\n     |})"], "goal_after": [], "proof_term_before": ["match D as p return (Antisymmetric U (Rel_of U p)) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} => ?Goal Carrier_of Rel_of PO_cond1 PO_cond2\nend"], "proof_term_after": ["match D as p return (Antisymmetric U (Rel_of U p)) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of0;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (Carrier_of0 : Ensemble U) (Rel_of1 : Relation U)\n       (PO_cond3 : Inhabited U Carrier_of0) (PO_cond4 : Order U Rel_of1) =>\n     Order_ind U Rel_of1\n       (Antisymmetric U\n          (Rel_of U\n             {|\n               Carrier_of := Carrier_of0;\n               Rel_of := Rel_of1;\n               PO_cond1 := PO_cond3;\n               PO_cond2 := PO_cond4\n             |}))\n       (fun (_ : Reflexive U Rel_of1) (_ : Transitive U Rel_of1)\n          (H1 : Antisymmetric U Rel_of1) => H1) PO_cond4) Carrier_of Rel_of0\n      PO_cond1 PO_cond2\nend"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["match D as p return (Antisymmetric U (Rel_of U p)) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of0;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (Carrier_of0 : Ensemble U) (Rel_of1 : Relation U)\n       (PO_cond3 : Inhabited U Carrier_of0) (PO_cond4 : Order U Rel_of1) =>\n     Order_ind U Rel_of1\n       (Antisymmetric U\n          (Rel_of U\n             {|\n               Carrier_of := Carrier_of0;\n               Rel_of := Rel_of1;\n               PO_cond1 := PO_cond3;\n               PO_cond2 := PO_cond4\n             |}))\n       (fun (_ : Reflexive U Rel_of1) (_ : Transitive U Rel_of1)\n          (H1 : Antisymmetric U Rel_of1) => H1) PO_cond4) Carrier_of Rel_of0\n      PO_cond1 PO_cond2\nend"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Rel_of_transitive", "text": "Theorem Rel_of_transitive : Transitive U (Rel_of U D).\nProof.\nelim D.\nintros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.\nQed.\n", "definition": " Transitive U (Rel_of U D).\n", "proof": "\nelim D.\nintros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.\n", "def_ranges": [27, 0, 27, 54], "proof_ranges": [28, 0, 31, 4], "proof_steps": [{"text": "elim D.", "goal_before": ["Transitive U (Rel_of U D)"], "goal_after": ["forall (Carrier_of : Ensemble U) (Rel_of : Relation U)\n  (PO_cond1 : Inhabited U Carrier_of) (PO_cond2 : Order U Rel_of),\nTransitive U\n  (Partial_Order.Rel_of U\n     {|\n       Carrier_of := Carrier_of;\n       Rel_of := Rel_of;\n       PO_cond1 := PO_cond1;\n       PO_cond2 := PO_cond2\n     |})"], "proof_term_before": [], "proof_term_after": ["match D as p return (Transitive U (Rel_of U p)) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} => ?Goal Carrier_of Rel_of PO_cond1 PO_cond2\nend"]}, {"text": "intros Carrier_of Rel_of PO_cond1 PO_cond2; elim PO_cond2; auto with sets.", "goal_before": ["forall (Carrier_of : Ensemble U) (Rel_of : Relation U)\n  (PO_cond1 : Inhabited U Carrier_of) (PO_cond2 : Order U Rel_of),\nTransitive U\n  (Partial_Order.Rel_of U\n     {|\n       Carrier_of := Carrier_of;\n       Rel_of := Rel_of;\n       PO_cond1 := PO_cond1;\n       PO_cond2 := PO_cond2\n     |})"], "goal_after": [], "proof_term_before": ["match D as p return (Transitive U (Rel_of U p)) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} => ?Goal Carrier_of Rel_of PO_cond1 PO_cond2\nend"], "proof_term_after": ["match D as p return (Transitive U (Rel_of U p)) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of0;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (Carrier_of0 : Ensemble U) (Rel_of1 : Relation U)\n       (PO_cond3 : Inhabited U Carrier_of0) (PO_cond4 : Order U Rel_of1) =>\n     Order_ind U Rel_of1\n       (Transitive U\n          (Rel_of U\n             {|\n               Carrier_of := Carrier_of0;\n               Rel_of := Rel_of1;\n               PO_cond1 := PO_cond3;\n               PO_cond2 := PO_cond4\n             |}))\n       (fun (_ : Reflexive U Rel_of1) (H0 : Transitive U Rel_of1)\n          (_ : Antisymmetric U Rel_of1) => H0) PO_cond4) Carrier_of Rel_of0\n      PO_cond1 PO_cond2\nend"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["match D as p return (Transitive U (Rel_of U p)) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of0;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (Carrier_of0 : Ensemble U) (Rel_of1 : Relation U)\n       (PO_cond3 : Inhabited U Carrier_of0) (PO_cond4 : Order U Rel_of1) =>\n     Order_ind U Rel_of1\n       (Transitive U\n          (Rel_of U\n             {|\n               Carrier_of := Carrier_of0;\n               Rel_of := Rel_of1;\n               PO_cond1 := PO_cond3;\n               PO_cond2 := PO_cond4\n             |}))\n       (fun (_ : Reflexive U Rel_of1) (H0 : Transitive U Rel_of1)\n          (_ : Antisymmetric U Rel_of1) => H0) PO_cond4) Carrier_of Rel_of0\n      PO_cond1 PO_cond2\nend"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Couple_included_in_carrier", "text": "Theorem Couple_included_in_carrier :\n forall x y : U,\n In U (Carrier_of U D) x ->\n In U (Carrier_of U D) y -> Included U (Couple U x y) (Carrier_of U D).\nProof.\nintros x y H' H'0; red in |- *.\nintros x0 H'1; elim H'1; auto with sets.\nQed.\n", "definition": "\n forall x y : U,\n In U (Carrier_of U D) x ->\n In U (Carrier_of U D) y -> Included U (Couple U x y) (Carrier_of U D).\n", "proof": "\nintros x y H' H'0; red in |- *.\nintros x0 H'1; elim H'1; auto with sets.\n", "def_ranges": [34, 0, 37, 71], "proof_ranges": [38, 0, 41, 4], "proof_steps": [{"text": "intros x y H' H'0; red in |- *.", "goal_before": ["forall x y : U,\nIn U (Carrier_of U D) x ->\nIn U (Carrier_of U D) y -> Included U (Couple U x y) (Carrier_of U D)"], "goal_after": ["forall x0 : U, In U (Couple U x y) x0 -> In U (Carrier_of U D) x0"], "proof_term_before": [], "proof_term_after": ["(fun (x y : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) y)\n => ?Goal : Included U (Couple U x y) (Carrier_of U D))"]}, {"text": "intros x0 H'1; elim H'1; auto with sets.", "goal_before": ["forall x0 : U, In U (Couple U x y) x0 -> In U (Carrier_of U D) x0"], "goal_after": [], "proof_term_before": ["(fun (x y : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) y)\n => ?Goal : Included U (Couple U x y) (Carrier_of U D))"], "proof_term_after": ["(fun (x y : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) y)\n =>\n (fun (x0 : U) (H'1 : In U (Couple U x y) x0) =>\n  Couple_ind U x y (fun x1 : U => In U (Carrier_of U D) x1) H' H'0 x0 H'1)\n :\n Included U (Couple U x y) (Carrier_of U D))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) y)\n =>\n (fun (x0 : U) (H'1 : In U (Couple U x y) x0) =>\n  Couple_ind U x y (fun x1 : U => In U (Carrier_of U D) x1) H' H'0 x0 H'1)\n :\n Included U (Couple U x y) (Carrier_of U D))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Lub_is_in_Carrier", "text": "Theorem Lub_is_in_Carrier :\n forall (bsup : U) (X : Ensemble U),\n Included U X (Carrier_of U D) ->\n Lub U D X bsup -> In U (Carrier_of U D) bsup.\nProof.\nintros bsup X H' H'0; elim H'0.\nintro H'1; elim H'1; auto with sets.\nQed.\n", "definition": "\n forall (bsup : U) (X : Ensemble U),\n Included U X (Carrier_of U D) ->\n Lub U D X bsup -> In U (Carrier_of U D) bsup.\n", "proof": "\nintros bsup X H' H'0; elim H'0.\nintro H'1; elim H'1; auto with sets.\n", "def_ranges": [44, 0, 47, 46], "proof_ranges": [48, 0, 51, 4], "proof_steps": [{"text": "intros bsup X H' H'0; elim H'0.", "goal_before": ["forall (bsup : U) (X : Ensemble U),\nIncluded U X (Carrier_of U D) -> Lub U D X bsup -> In U (Carrier_of U D) bsup"], "goal_after": ["Upper_Bound U D X bsup ->\n(forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y) ->\nIn U (Carrier_of U D) bsup"], "proof_term_before": [], "proof_term_after": ["(fun (bsup : U) (X : Ensemble U) (H' : Included U X (Carrier_of U D))\n   (H'0 : Lub U D X bsup) =>\n Lub_ind U D X bsup (In U (Carrier_of U D) bsup) ?Goal H'0)"]}, {"text": "intro H'1; elim H'1; auto with sets.", "goal_before": ["Upper_Bound U D X bsup ->\n(forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y) ->\nIn U (Carrier_of U D) bsup"], "goal_after": [], "proof_term_before": ["(fun (bsup : U) (X : Ensemble U) (H' : Included U X (Carrier_of U D))\n   (H'0 : Lub U D X bsup) =>\n Lub_ind U D X bsup (In U (Carrier_of U D) bsup) ?Goal H'0)"], "proof_term_after": ["(fun (bsup : U) (X : Ensemble U) (_ : Included U X (Carrier_of U D))\n   (H'0 : Lub U D X bsup) =>\n Lub_ind U D X bsup (In U (Carrier_of U D) bsup)\n   (fun H'1 : Upper_Bound U D X bsup =>\n    Upper_Bound_ind U D X bsup\n      ((forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y) ->\n       In U (Carrier_of U D) bsup)\n      (fun (H : In U (Carrier_of U D) bsup)\n         (_ : forall y : U, In U X y -> Rel_of U D y bsup)\n         (_ : forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y) => H)\n      H'1) H'0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (bsup : U) (X : Ensemble U) (_ : Included U X (Carrier_of U D))\n   (H'0 : Lub U D X bsup) =>\n Lub_ind U D X bsup (In U (Carrier_of U D) bsup)\n   (fun H'1 : Upper_Bound U D X bsup =>\n    Upper_Bound_ind U D X bsup\n      ((forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y) ->\n       In U (Carrier_of U D) bsup)\n      (fun (H : In U (Carrier_of U D) bsup)\n         (_ : forall y : U, In U X y -> Rel_of U D y bsup)\n         (_ : forall y : U, Upper_Bound U D X y -> Rel_of U D bsup y) => H)\n      H'1) H'0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Singleton_has_lub", "text": "Theorem Singleton_has_lub :\n forall x : U, In U (Carrier_of U D) x -> Lub U D (Singleton U x) x.\nProof.\nintros x H'.\napply Lub_definition.\napply Upper_Bound_definition; auto with sets.\nintros y H'0; elim H'0; auto with sets.\nintros y H'0; elim H'0; auto with sets.\nQed.\n", "definition": "\n forall x : U, In U (Carrier_of U D) x -> Lub U D (Singleton U x) x.\n", "proof": "\nintros x H'.\napply Lub_definition.\napply Upper_Bound_definition; auto with sets.\nintros y H'0; elim H'0; auto with sets.\nintros y H'0; elim H'0; auto with sets.\n", "def_ranges": [53, 0, 54, 68], "proof_ranges": [55, 0, 61, 4], "proof_steps": [{"text": "intros x H'.", "goal_before": ["forall x : U, In U (Carrier_of U D) x -> Lub U D (Singleton U x) x"], "goal_after": ["Lub U D (Singleton U x) x"], "proof_term_before": [], "proof_term_after": ["(fun (x : U) (H' : In U (Carrier_of U D) x) => ?Goal)"]}, {"text": "apply Lub_definition.", "goal_before": ["Lub U D (Singleton U x) x"], "goal_after": ["Upper_Bound U D (Singleton U x) x", "forall y : U, Upper_Bound U D (Singleton U x) y -> Rel_of U D x y"], "proof_term_before": ["(fun (x : U) (H' : In U (Carrier_of U D) x) => ?Goal)"], "proof_term_after": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Lub_definition U D (Singleton U x) x ?Goal ?Goal0)"]}, {"text": "apply Upper_Bound_definition; auto with sets.", "goal_before": ["Upper_Bound U D (Singleton U x) x", "forall y : U, Upper_Bound U D (Singleton U x) y -> Rel_of U D x y"], "goal_after": ["forall y : U, In U (Singleton U x) y -> Rel_of U D y x", "forall y : U, Upper_Bound U D (Singleton U x) y -> Rel_of U D x y"], "proof_term_before": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Lub_definition U D (Singleton U x) x ?Goal ?Goal0)"], "proof_term_after": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Lub_definition U D (Singleton U x) x\n   (Upper_Bound_definition U D (Singleton U x) x H' ?Goal0) \n   ?Goal)"]}, {"text": "intros y H'0; elim H'0; auto with sets.", "goal_before": ["forall y : U, In U (Singleton U x) y -> Rel_of U D y x", "forall y : U, Upper_Bound U D (Singleton U x) y -> Rel_of U D x y"], "goal_after": ["Rel_of U D x x", "forall y : U, Upper_Bound U D (Singleton U x) y -> Rel_of U D x y"], "proof_term_before": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Lub_definition U D (Singleton U x) x\n   (Upper_Bound_definition U D (Singleton U x) x H' ?Goal0) \n   ?Goal)"], "proof_term_after": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Lub_definition U D (Singleton U x) x\n   (Upper_Bound_definition U D (Singleton U x) x H'\n      (fun (y : U) (H'0 : In U (Singleton U x) y) =>\n       Singleton_ind U x (fun y0 : U => Rel_of U D y0 x) ?Goal0 y H'0)) \n   ?Goal)"]}, {"text": "intros y H'0; elim H'0; auto with sets.", "goal_before": ["Rel_of U D x x", "forall y : U, Upper_Bound U D (Singleton U x) y -> Rel_of U D x y"], "goal_after": ["Rel_of U D x x", "forall y : U, Upper_Bound U D (Singleton U x) y -> Rel_of U D x y"], "proof_term_before": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Lub_definition U D (Singleton U x) x\n   (Upper_Bound_definition U D (Singleton U x) x H'\n      (fun (y : U) (H'0 : In U (Singleton U x) y) =>\n       Singleton_ind U x (fun y0 : U => Rel_of U D y0 x) ?Goal0 y H'0)) \n   ?Goal)"], "proof_term_after": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Lub_definition U D (Singleton U x) x\n   (Upper_Bound_definition U D (Singleton U x) x H'\n      (fun (y : U) (H'0 : In U (Singleton U x) y) =>\n       Singleton_ind U x (fun y0 : U => Rel_of U D y0 x) ?Goal0 y H'0)) \n   ?Goal)"]}, {"text": "Qed.", "goal_before": ["Rel_of U D x x", "forall y : U, Upper_Bound U D (Singleton U x) y -> Rel_of U D x y"], "goal_after": [], "proof_term_before": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Lub_definition U D (Singleton U x) x\n   (Upper_Bound_definition U D (Singleton U x) x H'\n      (fun (y : U) (H'0 : In U (Singleton U x) y) =>\n       Singleton_ind U x (fun y0 : U => Rel_of U D y0 x) ?Goal0 y H'0)) \n   ?Goal)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Empty_set_has_Upper_Bound", "text": "Theorem Empty_set_has_Upper_Bound :\n exists maj : U, Upper_Bound U D (Empty_set U) maj.\nProof.\nelim D.\nintros C R cond1 cond2.\nelim cond1.\nintros x H'; exists x.\napply Upper_Bound_definition; auto with sets.\nintros y H'0; elim H'0; auto with sets.\nQed.\n", "definition": "\n exists maj : U, Upper_Bound U D (Empty_set U) maj.\n", "proof": "\nelim D.\nintros C R cond1 cond2.\nelim cond1.\nintros x H'; exists x.\napply Upper_Bound_definition; auto with sets.\nintros y H'0; elim H'0; auto with sets.\n", "def_ranges": [64, 0, 65, 51], "proof_ranges": [66, 0, 73, 4], "proof_steps": [{"text": "elim D.", "goal_before": ["exists maj : U, Upper_Bound U D (Empty_set U) maj"], "goal_after": ["forall (Carrier_of : Ensemble U) (Rel_of : Relation U)\n  (PO_cond1 : Inhabited U Carrier_of) (PO_cond2 : Order U Rel_of),\nexists maj : U,\n  Upper_Bound U\n    {|\n      Carrier_of := Carrier_of;\n      Rel_of := Rel_of;\n      PO_cond1 := PO_cond1;\n      PO_cond2 := PO_cond2\n    |} (Empty_set U) maj"], "proof_term_before": [], "proof_term_after": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} => ?Goal Carrier_of Rel_of PO_cond1 PO_cond2\nend"]}, {"text": "intros C R cond1 cond2.", "goal_before": ["forall (Carrier_of : Ensemble U) (Rel_of : Relation U)\n  (PO_cond1 : Inhabited U Carrier_of) (PO_cond2 : Order U Rel_of),\nexists maj : U,\n  Upper_Bound U\n    {|\n      Carrier_of := Carrier_of;\n      Rel_of := Rel_of;\n      PO_cond1 := PO_cond1;\n      PO_cond2 := PO_cond2\n    |} (Empty_set U) maj"], "goal_after": ["exists maj : U,\n  Upper_Bound U\n    {| Carrier_of := C; Rel_of := R; PO_cond1 := cond1; PO_cond2 := cond2 |}\n    (Empty_set U) maj"], "proof_term_before": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} => ?Goal Carrier_of Rel_of PO_cond1 PO_cond2\nend"], "proof_term_after": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) => ?Goal) Carrier_of Rel_of PO_cond1 PO_cond2\nend"]}, {"text": "elim cond1.", "goal_before": ["exists maj : U,\n  Upper_Bound U\n    {| Carrier_of := C; Rel_of := R; PO_cond1 := cond1; PO_cond2 := cond2 |}\n    (Empty_set U) maj"], "goal_after": ["forall x : U,\nIn U C x ->\nexists maj : U,\n  Upper_Bound U\n    {| Carrier_of := C; Rel_of := R; PO_cond1 := cond1; PO_cond2 := cond2 |}\n    (Empty_set U) maj"], "proof_term_before": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) => ?Goal) Carrier_of Rel_of PO_cond1 PO_cond2\nend"], "proof_term_after": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) =>\n     Inhabited_ind U C\n       (exists maj : U,\n          Upper_Bound U\n            {|\n              Carrier_of := C;\n              Rel_of := R;\n              PO_cond1 := cond1;\n              PO_cond2 := cond2\n            |} (Empty_set U) maj) ?Goal cond1) Carrier_of Rel_of PO_cond1\n      PO_cond2\nend"]}, {"text": "intros x H'; exists x.", "goal_before": ["forall x : U,\nIn U C x ->\nexists maj : U,\n  Upper_Bound U\n    {| Carrier_of := C; Rel_of := R; PO_cond1 := cond1; PO_cond2 := cond2 |}\n    (Empty_set U) maj"], "goal_after": ["Upper_Bound U\n  {| Carrier_of := C; Rel_of := R; PO_cond1 := cond1; PO_cond2 := cond2 |}\n  (Empty_set U) x"], "proof_term_before": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) =>\n     Inhabited_ind U C\n       (exists maj : U,\n          Upper_Bound U\n            {|\n              Carrier_of := C;\n              Rel_of := R;\n              PO_cond1 := cond1;\n              PO_cond2 := cond2\n            |} (Empty_set U) maj) ?Goal cond1) Carrier_of Rel_of PO_cond1\n      PO_cond2\nend"], "proof_term_after": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) =>\n     Inhabited_ind U C\n       (exists maj : U,\n          Upper_Bound U\n            {|\n              Carrier_of := C;\n              Rel_of := R;\n              PO_cond1 := cond1;\n              PO_cond2 := cond2\n            |} (Empty_set U) maj)\n       (fun (x : U) (H' : In U C x) =>\n        ex_intro\n          (fun maj : U =>\n           Upper_Bound U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) maj) x ?Goal) cond1) Carrier_of Rel_of PO_cond1\n      PO_cond2\nend"]}, {"text": "apply Upper_Bound_definition; auto with sets.", "goal_before": ["Upper_Bound U\n  {| Carrier_of := C; Rel_of := R; PO_cond1 := cond1; PO_cond2 := cond2 |}\n  (Empty_set U) x"], "goal_after": ["forall y : U,\nIn U (Empty_set U) y ->\nRel_of U\n  {| Carrier_of := C; Rel_of := R; PO_cond1 := cond1; PO_cond2 := cond2 |} y\n  x"], "proof_term_before": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) =>\n     Inhabited_ind U C\n       (exists maj : U,\n          Upper_Bound U\n            {|\n              Carrier_of := C;\n              Rel_of := R;\n              PO_cond1 := cond1;\n              PO_cond2 := cond2\n            |} (Empty_set U) maj)\n       (fun (x : U) (H' : In U C x) =>\n        ex_intro\n          (fun maj : U =>\n           Upper_Bound U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) maj) x ?Goal) cond1) Carrier_of Rel_of PO_cond1\n      PO_cond2\nend"], "proof_term_after": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) =>\n     Inhabited_ind U C\n       (exists maj : U,\n          Upper_Bound U\n            {|\n              Carrier_of := C;\n              Rel_of := R;\n              PO_cond1 := cond1;\n              PO_cond2 := cond2\n            |} (Empty_set U) maj)\n       (fun (x : U) (H' : In U C x) =>\n        ex_intro\n          (fun maj : U =>\n           Upper_Bound U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) maj) x\n          (Upper_Bound_definition U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) x H' ?Goal)) cond1) Carrier_of Rel_of PO_cond1\n      PO_cond2\nend"]}, {"text": "intros y H'0; elim H'0; auto with sets.", "goal_before": ["forall y : U,\nIn U (Empty_set U) y ->\nRel_of U\n  {| Carrier_of := C; Rel_of := R; PO_cond1 := cond1; PO_cond2 := cond2 |} y\n  x"], "goal_after": [], "proof_term_before": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) =>\n     Inhabited_ind U C\n       (exists maj : U,\n          Upper_Bound U\n            {|\n              Carrier_of := C;\n              Rel_of := R;\n              PO_cond1 := cond1;\n              PO_cond2 := cond2\n            |} (Empty_set U) maj)\n       (fun (x : U) (H' : In U C x) =>\n        ex_intro\n          (fun maj : U =>\n           Upper_Bound U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) maj) x\n          (Upper_Bound_definition U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) x H' ?Goal)) cond1) Carrier_of Rel_of PO_cond1\n      PO_cond2\nend"], "proof_term_after": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of0;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) =>\n     Inhabited_ind U C\n       (exists maj : U,\n          Upper_Bound U\n            {|\n              Carrier_of := C;\n              Rel_of := R;\n              PO_cond1 := cond1;\n              PO_cond2 := cond2\n            |} (Empty_set U) maj)\n       (fun (x : U) (H' : In U C x) =>\n        ex_intro\n          (fun maj : U =>\n           Upper_Bound U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) maj) x\n          (Upper_Bound_definition U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) x H'\n             (fun (y : U) (H'0 : In U (Empty_set U) y) =>\n              Empty_set_ind U\n                (fun y0 : U =>\n                 Rel_of U\n                   {|\n                     Carrier_of := C;\n                     Rel_of := R;\n                     PO_cond1 := cond1;\n                     PO_cond2 := cond2\n                   |} y0 x) y H'0))) cond1) Carrier_of Rel_of0 PO_cond1\n      PO_cond2\nend"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["match D as p return (exists maj : U, Upper_Bound U p (Empty_set U) maj) with\n| {|\n    Carrier_of := Carrier_of;\n    Rel_of := Rel_of0;\n    PO_cond1 := PO_cond1;\n    PO_cond2 := PO_cond2\n  |} =>\n    (fun (C : Ensemble U) (R : Relation U) (cond1 : Inhabited U C)\n       (cond2 : Order U R) =>\n     Inhabited_ind U C\n       (exists maj : U,\n          Upper_Bound U\n            {|\n              Carrier_of := C;\n              Rel_of := R;\n              PO_cond1 := cond1;\n              PO_cond2 := cond2\n            |} (Empty_set U) maj)\n       (fun (x : U) (H' : In U C x) =>\n        ex_intro\n          (fun maj : U =>\n           Upper_Bound U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) maj) x\n          (Upper_Bound_definition U\n             {|\n               Carrier_of := C;\n               Rel_of := R;\n               PO_cond1 := cond1;\n               PO_cond2 := cond2\n             |} (Empty_set U) x H'\n             (fun (y : U) (H'0 : In U (Empty_set U) y) =>\n              Empty_set_ind U\n                (fun y0 : U =>\n                 Rel_of U\n                   {|\n                     Carrier_of := C;\n                     Rel_of := R;\n                     PO_cond1 := cond1;\n                     PO_cond2 := cond2\n                   |} y0 x) y H'0))) cond1) Carrier_of Rel_of0 PO_cond1\n      PO_cond2\nend"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Anyone_is_Upper_Bound_of_Empty_set", "text": "Theorem Anyone_is_Upper_Bound_of_Empty_set :\n forall x : U, In U (Carrier_of U D) x -> Upper_Bound U D (Empty_set U) x.\nintros x H'; apply Upper_Bound_definition; auto with sets.\nintros y H'0; elim H'0; auto with sets.\nQed.\n", "definition": "\n forall x : U, In U (Carrier_of U D) x -> Upper_Bound U D (Empty_set U) x.", "proof": "\nintros x H'; apply Upper_Bound_definition; auto with sets.\nintros y H'0; elim H'0; auto with sets.\n", "def_ranges": [76, 0, 77, 74], "proof_ranges": [78, 0, 80, 4], "proof_steps": [{"text": "intros x H'; apply Upper_Bound_definition; auto with sets.", "goal_before": ["forall x : U, In U (Carrier_of U D) x -> Upper_Bound U D (Empty_set U) x"], "goal_after": ["forall y : U, In U (Empty_set U) y -> Rel_of U D y x"], "proof_term_before": [], "proof_term_after": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Upper_Bound_definition U D (Empty_set U) x H' ?Goal)"]}, {"text": "intros y H'0; elim H'0; auto with sets.", "goal_before": ["forall y : U, In U (Empty_set U) y -> Rel_of U D y x"], "goal_after": [], "proof_term_before": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Upper_Bound_definition U D (Empty_set U) x H' ?Goal)"], "proof_term_after": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Upper_Bound_definition U D (Empty_set U) x H'\n   (fun (y : U) (H'0 : In U (Empty_set U) y) =>\n    Empty_set_ind U (fun y0 : U => Rel_of U D y0 x) y H'0))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : U) (H' : In U (Carrier_of U D) x) =>\n Upper_Bound_definition U D (Empty_set U) x H'\n   (fun (y : U) (H'0 : In U (Empty_set U) y) =>\n    Empty_set_ind U (fun y0 : U => Rel_of U D y0 x) y H'0))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Empty_set_has_lub", "text": "Theorem Empty_set_has_lub :\n forall C : Cpo U, exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup.\nProof.\nintro C; elim C; simpl in |- *.\nintros PO_of_cpo Cpo_cond; elim Cpo_cond; clear Cpo_cond.\nintro H'; elim H'; clear H'.\nintros bot is_bot H'0; exists bot; simpl in |- *.\nelim is_bot; intros H' H'1.\napply Lub_definition.\napply Upper_Bound_definition; auto with sets.\nintros y H'2; elim H'2; auto with sets.\nintros y H'2; elim H'2; auto with sets.\nQed.\n", "definition": "\n forall C : Cpo U, exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup.\n", "proof": "\nintro C; elim C; simpl in |- *.\nintros PO_of_cpo Cpo_cond; elim Cpo_cond; clear Cpo_cond.\nintro H'; elim H'; clear H'.\nintros bot is_bot H'0; exists bot; simpl in |- *.\nelim is_bot; intros H' H'1.\napply Lub_definition.\napply Upper_Bound_definition; auto with sets.\nintros y H'2; elim H'2; auto with sets.\nintros y H'2; elim H'2; auto with sets.\n", "def_ranges": [83, 0, 84, 77], "proof_ranges": [85, 0, 95, 4], "proof_steps": [{"text": "intro C; elim C; simpl in |- *.", "goal_before": ["forall C : Cpo U, exists bsup : U, Lub U (PO_of_cpo U C) (Empty_set U) bsup"], "goal_after": ["forall PO_of_cpo : PO U,\nComplete U PO_of_cpo -> exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup"], "proof_term_before": [], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     (?Goal\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "intros PO_of_cpo Cpo_cond; elim Cpo_cond; clear Cpo_cond.", "goal_before": ["forall PO_of_cpo : PO U,\nComplete U PO_of_cpo -> exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup"], "goal_after": ["(exists bot : U, Bottom U PO_of_cpo bot) ->\n(forall X : Ensemble U,\n Directed U PO_of_cpo X -> exists bsup : U, Lub U PO_of_cpo X bsup) ->\nexists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup"], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     (?Goal\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup) \n         ?Goal Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "intro H'; elim H'; clear H'.", "goal_before": ["(exists bot : U, Bottom U PO_of_cpo bot) ->\n(forall X : Ensemble U,\n Directed U PO_of_cpo X -> exists bsup : U, Lub U PO_of_cpo X bsup) ->\nexists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup"], "goal_after": ["forall x : U,\nBottom U PO_of_cpo x ->\n(forall X : Ensemble U,\n Directed U PO_of_cpo X -> exists bsup : U, Lub U PO_of_cpo X bsup) ->\nexists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup"], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup) \n         ?Goal Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot => ex_ind ?Goal H')\n         Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "intros bot is_bot H'0; exists bot; simpl in |- *.", "goal_before": ["forall x : U,\nBottom U PO_of_cpo x ->\n(forall X : Ensemble U,\n Directed U PO_of_cpo X -> exists bsup : U, Lub U PO_of_cpo X bsup) ->\nexists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup"], "goal_after": ["Lub U PO_of_cpo (Empty_set U) bot"], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot => ex_ind ?Goal H')\n         Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot (?Goal : Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "elim is_bot; intros H' H'1.", "goal_before": ["Lub U PO_of_cpo (Empty_set U) bot"], "goal_after": ["Lub U PO_of_cpo (Empty_set U) bot"], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot (?Goal : Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   ?Goal@{H':=H'1; H'1:=H'2}) is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "apply Lub_definition.", "goal_before": ["Lub U PO_of_cpo (Empty_set U) bot"], "goal_after": ["Upper_Bound U PO_of_cpo (Empty_set U) bot", "forall y : U,\nUpper_Bound U PO_of_cpo (Empty_set U) y -> Rel_of U PO_of_cpo bot y"], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   ?Goal@{H':=H'1; H'1:=H'2}) is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   Lub_definition U PO_of_cpo (Empty_set U) bot\n                     ?Goal@{H':=H'1; H'1:=H'2} ?Goal0@{H':=H'1; H'1:=H'2})\n                  is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "apply Upper_Bound_definition; auto with sets.", "goal_before": ["Upper_Bound U PO_of_cpo (Empty_set U) bot", "forall y : U,\nUpper_Bound U PO_of_cpo (Empty_set U) y -> Rel_of U PO_of_cpo bot y"], "goal_after": ["forall y : U, In U (Empty_set U) y -> Rel_of U PO_of_cpo y bot", "forall y : U,\nUpper_Bound U PO_of_cpo (Empty_set U) y -> Rel_of U PO_of_cpo bot y"], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   Lub_definition U PO_of_cpo (Empty_set U) bot\n                     ?Goal@{H':=H'1; H'1:=H'2} ?Goal0@{H':=H'1; H'1:=H'2})\n                  is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   Lub_definition U PO_of_cpo (Empty_set U) bot\n                     (Upper_Bound_definition U PO_of_cpo \n                        (Empty_set U) bot H'1 ?Goal0@{H':=H'1; H'1:=H'2})\n                     ?Goal@{H':=H'1; H'1:=H'2}) is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "intros y H'2; elim H'2; auto with sets.", "goal_before": ["forall y : U, In U (Empty_set U) y -> Rel_of U PO_of_cpo y bot", "forall y : U,\nUpper_Bound U PO_of_cpo (Empty_set U) y -> Rel_of U PO_of_cpo bot y"], "goal_after": ["forall y : U,\nUpper_Bound U PO_of_cpo (Empty_set U) y -> Rel_of U PO_of_cpo bot y"], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   Lub_definition U PO_of_cpo (Empty_set U) bot\n                     (Upper_Bound_definition U PO_of_cpo \n                        (Empty_set U) bot H'1 ?Goal0@{H':=H'1; H'1:=H'2})\n                     ?Goal@{H':=H'1; H'1:=H'2}) is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   Lub_definition U PO_of_cpo (Empty_set U) bot\n                     (Upper_Bound_definition U PO_of_cpo \n                        (Empty_set U) bot H'1\n                        (fun (y : U) (H'3 : In U (Empty_set U) y) =>\n                         Empty_set_ind U\n                           (fun y0 : U => Rel_of U PO_of_cpo y0 bot) y H'3))\n                     ?Goal@{H':=H'1; H'1:=H'2}) is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "intros y H'2; elim H'2; auto with sets.", "goal_before": ["forall y : U,\nUpper_Bound U PO_of_cpo (Empty_set U) y -> Rel_of U PO_of_cpo bot y"], "goal_after": [], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (H'0 : forall X : Ensemble U,\n                      Directed U PO_of_cpo X ->\n                      exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   Lub_definition U PO_of_cpo (Empty_set U) bot\n                     (Upper_Bound_definition U PO_of_cpo \n                        (Empty_set U) bot H'1\n                        (fun (y : U) (H'3 : In U (Empty_set U) y) =>\n                         Empty_set_ind U\n                           (fun y0 : U => Rel_of U PO_of_cpo y0 bot) y H'3))\n                     ?Goal@{H':=H'1; H'1:=H'2}) is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (_ : forall X : Ensemble U,\n                    Directed U PO_of_cpo X ->\n                    exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   Lub_definition U PO_of_cpo (Empty_set U) bot\n                     (Upper_Bound_definition U PO_of_cpo \n                        (Empty_set U) bot H'1\n                        (fun (y : U) (H'3 : In U (Empty_set U) y) =>\n                         Empty_set_ind U\n                           (fun y0 : U => Rel_of U PO_of_cpo y0 bot) y H'3))\n                     (fun (y : U)\n                        (H'3 : Upper_Bound U PO_of_cpo (Empty_set U) y) =>\n                      Upper_Bound_ind U PO_of_cpo \n                        (Empty_set U) y (Rel_of U PO_of_cpo bot y)\n                        (fun (H : In U (Carrier_of U PO_of_cpo) y)\n                           (_ : forall y0 : U,\n                                In U (Empty_set U) y0 ->\n                                Rel_of U PO_of_cpo y0 y) => \n                         H'2 y H) H'3)) is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun C : Cpo U =>\n match\n   C as c return (exists bsup : U, Lub U (PO_of_cpo U c) (Empty_set U) bsup)\n with\n | {| PO_of_cpo := PO_of_cpo0; Cpo_cond := Cpo_cond |} =>\n     ((fun (PO_of_cpo : PO U) (Cpo_cond0 : Complete U PO_of_cpo) =>\n       Complete_ind U PO_of_cpo\n         (exists bsup : U, Lub U PO_of_cpo (Empty_set U) bsup)\n         (fun H' : exists bot : U, Bottom U PO_of_cpo bot =>\n          ex_ind\n            (fun (bot : U) (is_bot : Bottom U PO_of_cpo bot)\n               (_ : forall X : Ensemble U,\n                    Directed U PO_of_cpo X ->\n                    exists bsup : U, Lub U PO_of_cpo X bsup) =>\n             ex_intro (fun bsup : U => Lub U PO_of_cpo (Empty_set U) bsup)\n               bot\n               (Bottom_ind U PO_of_cpo bot\n                  (Lub U PO_of_cpo (Empty_set U) bot)\n                  (fun (H'1 : In U (Carrier_of U PO_of_cpo) bot)\n                     (H'2 : forall y : U,\n                            In U (Carrier_of U PO_of_cpo) y ->\n                            Rel_of U PO_of_cpo bot y) =>\n                   Lub_definition U PO_of_cpo (Empty_set U) bot\n                     (Upper_Bound_definition U PO_of_cpo \n                        (Empty_set U) bot H'1\n                        (fun (y : U) (H'3 : In U (Empty_set U) y) =>\n                         Empty_set_ind U\n                           (fun y0 : U => Rel_of U PO_of_cpo y0 bot) y H'3))\n                     (fun (y : U)\n                        (H'3 : Upper_Bound U PO_of_cpo (Empty_set U) y) =>\n                      Upper_Bound_ind U PO_of_cpo \n                        (Empty_set U) y (Rel_of U PO_of_cpo bot y)\n                        (fun (H : In U (Carrier_of U PO_of_cpo) y)\n                           (_ : forall y0 : U,\n                                In U (Empty_set U) y0 ->\n                                Rel_of U PO_of_cpo y0 y) => \n                         H'2 y H) H'3)) is_bot\n                :\n                Lub U PO_of_cpo (Empty_set U) bot)) H') Cpo_cond0)\n      :\n      forall (PO_of_cpo1 : PO U) (Cpo_cond0 : Complete U PO_of_cpo1),\n      exists bsup : U,\n        Lub U\n          (PO_of_cpo U {| PO_of_cpo := PO_of_cpo1; Cpo_cond := Cpo_cond0 |})\n          (Empty_set U) bsup) PO_of_cpo0 Cpo_cond\n end)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Upper_downward_stable", "text": "Theorem Upper_downward_stable :\n forall (A B : Ensemble U) (maj : U),\n Included U A (Carrier_of U D) ->\n Included U B (Carrier_of U D) ->\n Included U A B -> Upper_Bound U D B maj -> Upper_Bound U D A maj.\nProof.\nintros A B0 maj H' H'0 H'1 H'2; elim H'2; auto with sets.\nQed.\n", "definition": "\n forall (A B : Ensemble U) (maj : U),\n Included U A (Carrier_of U D) ->\n Included U B (Carrier_of U D) ->\n Included U A B -> Upper_Bound U D B maj -> Upper_Bound U D A maj.\n", "proof": "\nintros A B0 maj H' H'0 H'1 H'2; elim H'2; auto with sets.\n", "def_ranges": [98, 0, 102, 66], "proof_ranges": [103, 0, 105, 4], "proof_steps": [{"text": "intros A B0 maj H' H'0 H'1 H'2; elim H'2; auto with sets.", "goal_before": ["forall (A B0 : Ensemble U) (maj : U),\nIncluded U A (Carrier_of U D) ->\nIncluded U B0 (Carrier_of U D) ->\nIncluded U A B0 -> Upper_Bound U D B0 maj -> Upper_Bound U D A maj"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (A B0 : Ensemble U) (maj : U) (_ : Included U A (Carrier_of U D))\n   (_ : Included U B0 (Carrier_of U D)) (H'1 : Included U A B0)\n   (H'2 : Upper_Bound U D B0 maj) =>\n Upper_Bound_ind U D B0 maj (Upper_Bound U D A maj)\n   (fun (H : In U (Carrier_of U D) maj)\n      (H0 : forall y : U, In U B0 y -> Rel_of U D y maj) =>\n    Upper_Bound_definition U D A maj H\n      (fun (y : U) (H1 : In U A y) => H0 y (H'1 y H1))) H'2)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B0 : Ensemble U) (maj : U) (_ : Included U A (Carrier_of U D))\n   (_ : Included U B0 (Carrier_of U D)) (H'1 : Included U A B0)\n   (H'2 : Upper_Bound U D B0 maj) =>\n Upper_Bound_ind U D B0 maj (Upper_Bound U D A maj)\n   (fun (H : In U (Carrier_of U D) maj)\n      (H0 : forall y : U, In U B0 y -> Rel_of U D y maj) =>\n    Upper_Bound_definition U D A maj H\n      (fun (y : U) (H1 : In U A y) => H0 y (H'1 y H1))) H'2)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Conditionally_complete_has_a_bottom", "text": "Theorem Conditionally_complete_has_a_bottom :\n Conditionally_complete U D -> exists bot : U, Bottom U D bot.\nProof.\nintro H'; elim H'.\nintro H'0; elim (H'0 (Empty_set U));\n [ intros bsup E; elim E | idtac | idtac ]; auto with sets.\nintros H'1 H'2; exists bsup.\nelim H'1; auto with sets.\nQed.\n", "definition": "\n Conditionally_complete U D -> exists bot : U, Bottom U D bot.\n", "proof": "\nintro H'; elim H'.\nintro H'0; elim (H'0 (Empty_set U));\n [ intros bsup E; elim E | idtac | idtac ]; auto with sets.\nintros H'1 H'2; exists bsup.\nelim H'1; auto with sets.\n", "def_ranges": [107, 0, 108, 62], "proof_ranges": [109, 0, 115, 4], "proof_steps": [{"text": "intro H'; elim H'.", "goal_before": ["Conditionally_complete U D -> exists bot : U, Bottom U D bot"], "goal_after": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "proof_term_before": [], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D (exists bot : U, Bottom U D bot) ?Goal H')"]}, {"text": "intro H'0; elim (H'0 (Empty_set U));", "goal_before": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "goal_after": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D (exists bot : U, Bottom U D bot) ?Goal H')"], "proof_term_after": []}, {"text": "[ intros bsup E; elim E | idtac | idtac ]; auto with sets.", "goal_before": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "goal_after": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'1 H'2; exists bsup.", "goal_before": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "goal_after": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'1; auto with sets.", "goal_before": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "goal_after": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nexists bot : U, Bottom U D bot"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Bottom_is_compact", "text": "Theorem Bottom_is_compact :\n Conditionally_complete U D ->\n exists bot : U, Bottom U D bot /\\ Compact U D bot.\nProof.\nintro H'; lapply Conditionally_complete_has_a_bottom;\n [ intro H'0 | try assumption ].\nelim H'0; intros bot E; clear H'0.\nexists bot; split; auto with sets.\napply Definition_of_compact; auto with sets.\nelim E; auto with sets.\nintros X H'0; elim H'0.\nintros H'1 H'2; elim H'2.\nintros x H'3 H'4 H'5; try assumption.\nexists x; auto with sets.\nelim E; auto with sets.\nQed.\n", "definition": "\n Conditionally_complete U D ->\n exists bot : U, Bottom U D bot /\\ Compact U D bot.\n", "proof": "\nintro H'; lapply Conditionally_complete_has_a_bottom;\n [ intro H'0 | try assumption ].\nelim H'0; intros bot E; clear H'0.\nexists bot; split; auto with sets.\napply Definition_of_compact; auto with sets.\nelim E; auto with sets.\nintros X H'0; elim H'0.\nintros H'1 H'2; elim H'2.\nintros x H'3 H'4 H'5; try assumption.\nexists x; auto with sets.\nelim E; auto with sets.\n", "def_ranges": [118, 0, 120, 51], "proof_ranges": [121, 0, 133, 4], "proof_steps": [{"text": "intro H'; lapply Conditionally_complete_has_a_bottom;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[ intro H'0 | try assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0; intros bot E; clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists bot; split; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_compact; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros X H'0; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'1 H'2; elim H'2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H'3 H'4 H'5; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Compact_is_in_Carrier", "text": "Theorem Compact_is_in_Carrier :\n forall x : U, Compact U D x -> In U (Carrier_of U D) x.\nProof.\nintros x H'; elim H'; auto with sets.\nQed.\n", "definition": "\n forall x : U, Compact U D x -> In U (Carrier_of U D) x.\n", "proof": "\nintros x H'; elim H'; auto with sets.\n", "def_ranges": [136, 0, 137, 56], "proof_ranges": [138, 0, 140, 4], "proof_steps": [{"text": "intros x H'; elim H'; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Compatible_is_reflexive", "text": "Theorem Compatible_is_reflexive : forall x : U, Compatible U D x x.\nProof.\nintro x; red in |- *; simpl in |- *.\nintros H'2 H'3; exists x.\nsplit; [ assumption | apply Upper_Bound_definition ]; auto with sets.\nintros y H'; elim H'; auto with sets.\nQed.\n", "definition": " forall x : U, Compatible U D x x.\n", "proof": "\nintro x; red in |- *; simpl in |- *.\nintros H'2 H'3; exists x.\nsplit; [ assumption | apply Upper_Bound_definition ]; auto with sets.\nintros y H'; elim H'; auto with sets.\n", "def_ranges": [143, 0, 143, 67], "proof_ranges": [144, 0, 149, 4], "proof_steps": [{"text": "intro x; red in |- *; simpl in |- *.", "goal_before": ["forall x : U, Compatible U D x x"], "goal_after": ["In U (Carrier_of U D) x ->\nIn U (Carrier_of U D) x ->\nexists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z"], "proof_term_before": [], "proof_term_after": ["(fun x : U =>\n (?Goal\n  :\n  In U (Carrier_of U D) x ->\n  In U (Carrier_of U D) x ->\n  exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z)\n :\n Compatible U D x x)"]}, {"text": "intros H'2 H'3; exists x.", "goal_before": ["In U (Carrier_of U D) x ->\nIn U (Carrier_of U D) x ->\nexists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z"], "goal_after": ["In U (Carrier_of U D) x /\\ Upper_Bound U D (Couple U x x) x"], "proof_term_before": ["(fun x : U =>\n (?Goal\n  :\n  In U (Carrier_of U D) x ->\n  In U (Carrier_of U D) x ->\n  exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z)\n :\n Compatible U D x x)"], "proof_term_after": ["(fun x : U =>\n ((fun H'2 H'3 : In U (Carrier_of U D) x =>\n   ex_intro\n     (fun z : U =>\n      In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z) x \n     ?Goal)\n  :\n  In U (Carrier_of U D) x ->\n  In U (Carrier_of U D) x ->\n  exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z)\n :\n Compatible U D x x)"]}, {"text": "split; [ assumption | apply Upper_Bound_definition ]; auto with sets.", "goal_before": ["In U (Carrier_of U D) x /\\ Upper_Bound U D (Couple U x x) x"], "goal_after": ["forall y : U, In U (Couple U x x) y -> Rel_of U D y x"], "proof_term_before": ["(fun x : U =>\n ((fun H'2 H'3 : In U (Carrier_of U D) x =>\n   ex_intro\n     (fun z : U =>\n      In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z) x \n     ?Goal)\n  :\n  In U (Carrier_of U D) x ->\n  In U (Carrier_of U D) x ->\n  exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z)\n :\n Compatible U D x x)"], "proof_term_after": ["(fun x : U =>\n ((fun H'2 H'3 : In U (Carrier_of U D) x =>\n   ex_intro\n     (fun z : U =>\n      In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z) x\n     (conj H'3 (Upper_Bound_definition U D (Couple U x x) x H'3 ?Goal)))\n  :\n  In U (Carrier_of U D) x ->\n  In U (Carrier_of U D) x ->\n  exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z)\n :\n Compatible U D x x)"]}, {"text": "intros y H'; elim H'; auto with sets.", "goal_before": ["forall y : U, In U (Couple U x x) y -> Rel_of U D y x"], "goal_after": ["Rel_of U D x x", "Rel_of U D x x"], "proof_term_before": ["(fun x : U =>\n ((fun H'2 H'3 : In U (Carrier_of U D) x =>\n   ex_intro\n     (fun z : U =>\n      In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z) x\n     (conj H'3 (Upper_Bound_definition U D (Couple U x x) x H'3 ?Goal)))\n  :\n  In U (Carrier_of U D) x ->\n  In U (Carrier_of U D) x ->\n  exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z)\n :\n Compatible U D x x)"], "proof_term_after": ["(fun x : U =>\n ((fun H'2 H'3 : In U (Carrier_of U D) x =>\n   ex_intro\n     (fun z : U =>\n      In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z) x\n     (conj H'3\n        (Upper_Bound_definition U D (Couple U x x) x H'3\n           (fun (y : U) (H' : In U (Couple U x x) y) =>\n            Couple_ind U x x (fun y0 : U => Rel_of U D y0 x) \n              ?Goal ?Goal0 y H'))))\n  :\n  In U (Carrier_of U D) x ->\n  In U (Carrier_of U D) x ->\n  exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z)\n :\n Compatible U D x x)"]}, {"text": "Qed.", "goal_before": ["Rel_of U D x x", "Rel_of U D x x"], "goal_after": [], "proof_term_before": ["(fun x : U =>\n ((fun H'2 H'3 : In U (Carrier_of U D) x =>\n   ex_intro\n     (fun z : U =>\n      In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z) x\n     (conj H'3\n        (Upper_Bound_definition U D (Couple U x x) x H'3\n           (fun (y : U) (H' : In U (Couple U x x) y) =>\n            Couple_ind U x x (fun y0 : U => Rel_of U D y0 x) \n              ?Goal ?Goal0 y H'))))\n  :\n  In U (Carrier_of U D) x ->\n  In U (Carrier_of U D) x ->\n  exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x x) z)\n :\n Compatible U D x x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Couple_is_symmetric", "text": "Theorem Couple_is_symmetric :\n forall x y : U, Couple U x y = Couple U y x :>Ensemble U.\nProof.\nintros x y; apply Extensionality_Ensembles; red in |- *.\nsplit; red in |- *; (intros x0 H'; elim H'); auto with sets.\nQed.\n", "definition": "\n forall x y : U, Couple U x y = Couple U y x :>Ensemble U.\n", "proof": "\nintros x y; apply Extensionality_Ensembles; red in |- *.\nsplit; red in |- *; (intros x0 H'; elim H'); auto with sets.\n", "def_ranges": [152, 0, 153, 58], "proof_ranges": [154, 0, 157, 4], "proof_steps": [{"text": "intros x y; apply Extensionality_Ensembles; red in |- *.", "goal_before": ["forall x y : U, Couple U x y = Couple U y x"], "goal_after": ["Included U (Couple U x y) (Couple U y x) /\\\nIncluded U (Couple U y x) (Couple U x y)"], "proof_term_before": [], "proof_term_after": ["(fun x y : U =>\n Extensionality_Ensembles U (Couple U x y) (Couple U y x)\n   (?Goal : Same_set U (Couple U x y) (Couple U y x)))"]}, {"text": "split; red in |- *; (intros x0 H'; elim H'); auto with sets.", "goal_before": ["Included U (Couple U x y) (Couple U y x) /\\\nIncluded U (Couple U y x) (Couple U x y)"], "goal_after": [], "proof_term_before": ["(fun x y : U =>\n Extensionality_Ensembles U (Couple U x y) (Couple U y x)\n   (?Goal : Same_set U (Couple U x y) (Couple U y x)))"], "proof_term_after": ["(fun x y : U =>\n Extensionality_Ensembles U (Couple U x y) (Couple U y x)\n   (conj\n      ((fun (x0 : U) (H' : In U (Couple U x y) x0) =>\n        Couple_ind U x y (fun x1 : U => In U (Couple U y x) x1)\n          (Couple_r U y x) (Couple_l U y x) x0 H')\n       :\n       Included U (Couple U x y) (Couple U y x))\n      ((fun (x0 : U) (H' : In U (Couple U y x) x0) =>\n        Couple_ind U y x (fun x1 : U => In U (Couple U x y) x1)\n          (Couple_r U x y) (Couple_l U x y) x0 H')\n       :\n       Included U (Couple U y x) (Couple U x y))\n    :\n    Same_set U (Couple U x y) (Couple U y x)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x y : U =>\n Extensionality_Ensembles U (Couple U x y) (Couple U y x)\n   (conj\n      ((fun (x0 : U) (H' : In U (Couple U x y) x0) =>\n        Couple_ind U x y (fun x1 : U => In U (Couple U y x) x1)\n          (Couple_r U y x) (Couple_l U y x) x0 H')\n       :\n       Included U (Couple U x y) (Couple U y x))\n      ((fun (x0 : U) (H' : In U (Couple U y x) x0) =>\n        Couple_ind U y x (fun x1 : U => In U (Couple U x y) x1)\n          (Couple_r U x y) (Couple_l U x y) x0 H')\n       :\n       Included U (Couple U y x) (Couple U x y))\n    :\n    Same_set U (Couple U x y) (Couple U y x)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Compatible_is_symmetric", "text": "Theorem Compatible_is_symmetric :\n forall x y : U, Compatible U D x y -> Compatible U D y x.\nProof.\nunfold Compatible in |- *.\nintros x y H' H'0 H'1.\nrewrite <- (Couple_is_symmetric x y); auto with sets.\nQed.\n", "definition": "\n forall x y : U, Compatible U D x y -> Compatible U D y x.\n", "proof": "\nunfold Compatible in |- *.\nintros x y H' H'0 H'1.\nrewrite <- (Couple_is_symmetric x y); auto with sets.\n", "def_ranges": [159, 0, 160, 58], "proof_ranges": [161, 0, 165, 4], "proof_steps": [{"text": "unfold Compatible in |- *.", "goal_before": ["forall x y : U, Compatible U D x y -> Compatible U D y x"], "goal_after": ["forall x y : U,\n(In U (Carrier_of U D) x ->\n In U (Carrier_of U D) y ->\n exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x y) z) ->\nIn U (Carrier_of U D) y ->\nIn U (Carrier_of U D) x ->\nexists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U y x) z"], "proof_term_before": [], "proof_term_after": ["(?Goal : forall x y : U, Compatible U D x y -> Compatible U D y x)"]}, {"text": "intros x y H' H'0 H'1.", "goal_before": ["forall x y : U,\n(In U (Carrier_of U D) x ->\n In U (Carrier_of U D) y ->\n exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x y) z) ->\nIn U (Carrier_of U D) y ->\nIn U (Carrier_of U D) x ->\nexists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U y x) z"], "goal_after": ["exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U y x) z"], "proof_term_before": ["(?Goal : forall x y : U, Compatible U D x y -> Compatible U D y x)"], "proof_term_after": ["((fun (x y : U)\n    (H' : In U (Carrier_of U D) x ->\n          In U (Carrier_of U D) y ->\n          exists z : U,\n            In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x y) z)\n    (H'0 : In U (Carrier_of U D) y) (H'1 : In U (Carrier_of U D) x) => \n  ?Goal)\n :\n forall x y : U, Compatible U D x y -> Compatible U D y x)"]}, {"text": "rewrite <- (Couple_is_symmetric x y); auto with sets.", "goal_before": ["exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U y x) z"], "goal_after": [], "proof_term_before": ["((fun (x y : U)\n    (H' : In U (Carrier_of U D) x ->\n          In U (Carrier_of U D) y ->\n          exists z : U,\n            In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x y) z)\n    (H'0 : In U (Carrier_of U D) y) (H'1 : In U (Carrier_of U D) x) => \n  ?Goal)\n :\n forall x y : U, Compatible U D x y -> Compatible U D y x)"], "proof_term_after": ["((fun (x y : U)\n    (H' : In U (Carrier_of U D) x ->\n          In U (Carrier_of U D) y ->\n          exists z : U,\n            In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x y) z)\n    (H'0 : In U (Carrier_of U D) y) (H'1 : In U (Carrier_of U D) x) =>\n  eq_ind (Couple U x y)\n    (fun e : Ensemble U =>\n     exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D e z)\n    (H' H'1 H'0) (Couple U y x) (Couple_is_symmetric x y))\n :\n forall x y : U, Compatible U D x y -> Compatible U D y x)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["((fun (x y : U)\n    (H' : In U (Carrier_of U D) x ->\n          In U (Carrier_of U D) y ->\n          exists z : U,\n            In U (Carrier_of U D) z /\\ Upper_Bound U D (Couple U x y) z)\n    (H'0 : In U (Carrier_of U D) y) (H'1 : In U (Carrier_of U D) x) =>\n  eq_ind (Couple U x y)\n    (fun e : Ensemble U =>\n     exists z : U, In U (Carrier_of U D) z /\\ Upper_Bound U D e z)\n    (H' H'1 H'0) (Couple U y x) (Couple_is_symmetric x y))\n :\n forall x y : U, Compatible U D x y -> Compatible U D y x)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Compatible_imp_consistent", "text": "Theorem Compatible_imp_consistent :\n forall x y : U, Compatible U D x y -> Consistent U D (Couple U x y).\nintros x y H'; red in |- *; simpl in |- *.\nintros H'0 x0 y0 H'1; try assumption.\nred in H'1.\nlapply (H'1 x0); [ intro H'3 | auto with sets ].\nlapply (H'1 y0); [ intro H'4 | auto with sets ].\nelim H'4.\nelim H'3; auto with sets.\nelim H'3; auto with sets.\nQed.\n", "definition": "\n forall x y : U, Compatible U D x y -> Consistent U D (Couple U x y).", "proof": "\nintros x y H'; red in |- *; simpl in |- *.\nintros H'0 x0 y0 H'1; try assumption.\nred in H'1.\nlapply (H'1 x0); [ intro H'3 | auto with sets ].\nlapply (H'1 y0); [ intro H'4 | auto with sets ].\nelim H'4.\nelim H'3; auto with sets.\nelim H'3; auto with sets.\n", "def_ranges": [168, 0, 169, 69], "proof_ranges": [170, 0, 178, 4], "proof_steps": [{"text": "intros x y H'; red in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'0 x0 y0 H'1; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (H'1 x0); [ intro H'3 | auto with sets ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "lapply (H'1 y0); [ intro H'4 | auto with sets ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'3; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'3; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Consistent_imp_compatible", "text": "Theorem Consistent_imp_compatible :\n forall x y : U,\n In U (Carrier_of U D) x ->\n In U (Carrier_of U D) y ->\n Consistent U D (Couple U x y) -> Compatible U D x y.\nProof.\nintros x y H' H'0 H'1; red in H'1; simpl in H'1; auto with sets.\nQed.\n", "definition": "\n forall x y : U,\n In U (Carrier_of U D) x ->\n In U (Carrier_of U D) y ->\n Consistent U D (Couple U x y) -> Compatible U D x y.\n", "proof": "\nintros x y H' H'0 H'1; red in H'1; simpl in H'1; auto with sets.\n", "def_ranges": [180, 0, 184, 53], "proof_ranges": [185, 0, 187, 4], "proof_steps": [{"text": "intros x y H' H'0 H'1; red in H'1; simpl in H'1; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Coherent_implies_Conditionally_Complete", "text": "Theorem Coherent_implies_Conditionally_Complete :\n Coherent U D -> Conditionally_complete U D.\nProof.\nintro H'; red in H'.\napply Definition_of_Conditionally_complete.\nintros X H'0 H'1.\napply H'; auto with sets.\nred in |- *; simpl in |- *.\nintros H'2 x y H'3; red in |- *; simpl in |- *.\nintros H'4 H'5.\nelim H'1; intros maj E; try exact E; clear H'1.\nexists maj; elim E; auto with sets.\nQed.\n", "definition": "\n Coherent U D -> Conditionally_complete U D.\n", "proof": "\nintro H'; red in H'.\napply Definition_of_Conditionally_complete.\nintros X H'0 H'1.\napply H'; auto with sets.\nred in |- *; simpl in |- *.\nintros H'2 x y H'3; red in |- *; simpl in |- *.\nintros H'4 H'5.\nelim H'1; intros maj E; try exact E; clear H'1.\nexists maj; elim E; auto with sets.\n", "def_ranges": [189, 0, 190, 44], "proof_ranges": [191, 0, 201, 4], "proof_steps": [{"text": "intro H'; red in H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Conditionally_complete.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros X H'0 H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H'; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'2 x y H'3; red in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'4 H'5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'1; intros maj E; try exact E; clear H'1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists maj; elim E; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Coherent_has_a_bottom", "text": "Theorem Coherent_has_a_bottom :\n Coherent U D -> exists bot : U, Bottom U D bot.\nProof.\nauto with sets.\nQed.\n", "definition": "\n Coherent U D -> exists bot : U, Bottom U D bot.\n", "proof": "\nauto with sets.\n", "def_ranges": [204, 0, 205, 48], "proof_ranges": [206, 0, 208, 4], "proof_steps": [{"text": "auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo.v", "name": "Coherent_implies_Complete", "text": "Theorem Coherent_implies_Complete : Coherent U D -> Complete U D.\nProof.\nintro H'.\napply Definition_of_Complete; auto with sets.\nintros X H'0; apply H'.\nelim H'0; auto with sets.\nred in |- *; simpl in |- *.\nintros H'1 x y H'2; elim H'0.\nintros H'3 H'4 H'5; lapply (H'5 x y); [ intro H'8; elim H'8 | auto with sets ].\nintros x0 H'6; red in |- *; simpl in |- *.\nintros H'7 H'9; exists x0.\nintuition.\nQed.\n", "definition": " Coherent U D -> Complete U D.\n", "proof": "\nintro H'.\napply Definition_of_Complete; auto with sets.\nintros X H'0; apply H'.\nelim H'0; auto with sets.\nred in |- *; simpl in |- *.\nintros H'1 x y H'2; elim H'0.\nintros H'3 H'4 H'5; lapply (H'5 x y); [ intro H'8; elim H'8 | auto with sets ].\nintros x0 H'6; red in |- *; simpl in |- *.\nintros H'7 H'9; exists x0.\nintuition.\n", "def_ranges": [211, 0, 211, 65], "proof_ranges": [212, 0, 223, 4], "proof_steps": [{"text": "intro H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Definition_of_Complete; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros X H'0; apply H'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'0; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'1 x y H'2; elim H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'3 H'4 H'5; lapply (H'5 x y); [ intro H'8; elim H'8 | auto with sets ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H'6; red in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'7 H'9; exists x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intuition.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Upper_Bound_is_in_Carrier", "text": "Theorem Upper_Bound_is_in_Carrier :\n forall (X : Ensemble U) (bound : U),\n Included U X (Carrier_of U D) ->\n Upper_Bound U D X bound -> In U (Carrier_of U D) bound.\nintros X bound H' H'0; elim H'0; auto with sets.\nQed.\n", "definition": "\n forall (X : Ensemble U) (bound : U),\n Included U X (Carrier_of U D) ->\n Upper_Bound U D X bound -> In U (Carrier_of U D) bound.", "proof": "\nintros X bound H' H'0; elim H'0; auto with sets.\n", "def_ranges": [16, 0, 19, 56], "proof_ranges": [20, 0, 21, 4], "proof_steps": [{"text": "intros X bound H' H'0; elim H'0; auto with sets.", "goal_before": ["forall (X : Ensemble U) (bound : U),\nIncluded U X (Carrier_of U D) ->\nUpper_Bound U D X bound -> In U (Carrier_of U D) bound"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (X : Ensemble U) (bound : U) (_ : Included U X (Carrier_of U D))\n   (H'0 : Upper_Bound U D X bound) =>\n Upper_Bound_ind U D X bound (In U (Carrier_of U D) bound)\n   (fun (H : In U (Carrier_of U D) bound)\n      (_ : forall y : U, In U X y -> Rel_of U D y bound) => H) H'0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (X : Ensemble U) (bound : U) (_ : Included U X (Carrier_of U D))\n   (H'0 : Upper_Bound U D X bound) =>\n Upper_Bound_ind U D X bound (In U (Carrier_of U D) bound)\n   (fun (H : In U (Carrier_of U D) bound)\n      (_ : forall y : U, In U X y -> Rel_of U D y bound) => H) H'0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Lower_Bound_is_in_Carrier", "text": "Theorem Lower_Bound_is_in_Carrier :\n forall (X : Ensemble U) (bound : U),\n Included U X (Carrier_of U D) ->\n Lower_Bound U D X bound -> In U (Carrier_of U D) bound.\nintros X bound H' H'0; elim H'0; auto with sets.\nQed.\n", "definition": "\n forall (X : Ensemble U) (bound : U),\n Included U X (Carrier_of U D) ->\n Lower_Bound U D X bound -> In U (Carrier_of U D) bound.", "proof": "\nintros X bound H' H'0; elim H'0; auto with sets.\n", "def_ranges": [23, 0, 26, 56], "proof_ranges": [27, 0, 28, 4], "proof_steps": [{"text": "intros X bound H' H'0; elim H'0; auto with sets.", "goal_before": ["forall (X : Ensemble U) (bound : U),\nIncluded U X (Carrier_of U D) ->\nLower_Bound U D X bound -> In U (Carrier_of U D) bound"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (X : Ensemble U) (bound : U) (_ : Included U X (Carrier_of U D))\n   (H'0 : Lower_Bound U D X bound) =>\n Lower_Bound_ind U D X bound (In U (Carrier_of U D) bound)\n   (fun (H : In U (Carrier_of U D) bound)\n      (_ : forall y : U, In U X y -> Rel_of U D bound y) => H) H'0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (X : Ensemble U) (bound : U) (_ : Included U X (Carrier_of U D))\n   (H'0 : Lower_Bound U D X bound) =>\n Lower_Bound_ind U D X bound (In U (Carrier_of U D) bound)\n   (fun (H : In U (Carrier_of U D) bound)\n      (_ : forall y : U, In U X y -> Rel_of U D bound y) => H) H'0)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Lub_is_unique", "text": "Theorem Lub_is_unique :\n Conditionally_complete U D ->\n forall (C : Ensemble U) (bsup1 bsup2 : U),\n Lub U D C bsup1 -> Lub U D C bsup2 -> bsup1 = bsup2.\nintros H' C bsup1 bsup2 H'0 H'1.\napply (Rel_of_antisymmetric U D); (elim H'1; elim H'0; auto with sets).\nQed.\n", "definition": "\n Conditionally_complete U D ->\n forall (C : Ensemble U) (bsup1 bsup2 : U),\n Lub U D C bsup1 -> Lub U D C bsup2 -> bsup1 = bsup2.", "proof": "\nintros H' C bsup1 bsup2 H'0 H'1.\napply (Rel_of_antisymmetric U D); (elim H'1; elim H'0; auto with sets).\n", "def_ranges": [30, 0, 33, 53], "proof_ranges": [34, 0, 36, 4], "proof_steps": [{"text": "intros H' C bsup1 bsup2 H'0 H'1.", "goal_before": ["Conditionally_complete U D ->\nforall (C : Ensemble U) (bsup1 bsup2 : U),\nLub U D C bsup1 -> Lub U D C bsup2 -> bsup1 = bsup2"], "goal_after": ["bsup1 = bsup2"], "proof_term_before": [], "proof_term_after": ["(fun (H' : Conditionally_complete U D) (C : Ensemble U) \n   (bsup1 bsup2 : U) (H'0 : Lub U D C bsup1) (H'1 : Lub U D C bsup2) => \n ?Goal)"]}, {"text": "apply (Rel_of_antisymmetric U D); (elim H'1; elim H'0; auto with sets).", "goal_before": ["bsup1 = bsup2"], "goal_after": ["bsup1 = bsup2"], "proof_term_before": ["(fun (H' : Conditionally_complete U D) (C : Ensemble U) \n   (bsup1 bsup2 : U) (H'0 : Lub U D C bsup1) (H'1 : Lub U D C bsup2) => \n ?Goal)"], "proof_term_after": ["(fun (H' : Conditionally_complete U D) (C : Ensemble U) \n   (bsup1 bsup2 : U) (H'0 : Lub U D C bsup1) (H'1 : Lub U D C bsup2) => \n ?Goal)"]}, {"text": "Qed.", "goal_before": ["bsup1 = bsup2"], "goal_after": [], "proof_term_before": ["(fun (H' : Conditionally_complete U D) (C : Ensemble U) \n   (bsup1 bsup2 : U) (H'0 : Lub U D C bsup1) (H'1 : Lub U D C bsup2) => \n ?Goal)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Upper_Bound_Couple_intro", "text": "Theorem Upper_Bound_Couple_intro :\n forall x y z : U,\n In U (Carrier_of U D) x ->\n In U (Carrier_of U D) y ->\n In U (Carrier_of U D) z ->\n Rel_of U D x z -> Rel_of U D y z -> Upper_Bound U D (Couple U x y) z.\nintros x y z H' H'0 H'1 H'2 H'3.\napply Upper_Bound_definition; auto with sets.\nintros y0 H'4; elim H'4; auto with sets.\nQed.\n", "definition": "\n forall x y z : U,\n In U (Carrier_of U D) x ->\n In U (Carrier_of U D) y ->\n In U (Carrier_of U D) z ->\n Rel_of U D x z -> Rel_of U D y z -> Upper_Bound U D (Couple U x y) z.", "proof": "\nintros x y z H' H'0 H'1 H'2 H'3.\napply Upper_Bound_definition; auto with sets.\nintros y0 H'4; elim H'4; auto with sets.\n", "def_ranges": [38, 0, 43, 70], "proof_ranges": [44, 0, 47, 4], "proof_steps": [{"text": "intros x y z H' H'0 H'1 H'2 H'3.", "goal_before": ["forall x y z : U,\nIn U (Carrier_of U D) x ->\nIn U (Carrier_of U D) y ->\nIn U (Carrier_of U D) z ->\nRel_of U D x z -> Rel_of U D y z -> Upper_Bound U D (Couple U x y) z"], "goal_after": ["Upper_Bound U D (Couple U x y) z"], "proof_term_before": [], "proof_term_after": ["(fun (x y z : U) (H' : In U (Carrier_of U D) x)\n   (H'0 : In U (Carrier_of U D) y) (H'1 : In U (Carrier_of U D) z)\n   (H'2 : Rel_of U D x z) (H'3 : Rel_of U D y z) => \n ?Goal)"]}, {"text": "apply Upper_Bound_definition; auto with sets.", "goal_before": ["Upper_Bound U D (Couple U x y) z"], "goal_after": ["forall y0 : U, In U (Couple U x y) y0 -> Rel_of U D y0 z"], "proof_term_before": ["(fun (x y z : U) (H' : In U (Carrier_of U D) x)\n   (H'0 : In U (Carrier_of U D) y) (H'1 : In U (Carrier_of U D) z)\n   (H'2 : Rel_of U D x z) (H'3 : Rel_of U D y z) => \n ?Goal)"], "proof_term_after": ["(fun (x y z : U) (H' : In U (Carrier_of U D) x)\n   (H'0 : In U (Carrier_of U D) y) (H'1 : In U (Carrier_of U D) z)\n   (H'2 : Rel_of U D x z) (H'3 : Rel_of U D y z) =>\n Upper_Bound_definition U D (Couple U x y) z H'1 ?Goal)"]}, {"text": "intros y0 H'4; elim H'4; auto with sets.", "goal_before": ["forall y0 : U, In U (Couple U x y) y0 -> Rel_of U D y0 z"], "goal_after": [], "proof_term_before": ["(fun (x y z : U) (H' : In U (Carrier_of U D) x)\n   (H'0 : In U (Carrier_of U D) y) (H'1 : In U (Carrier_of U D) z)\n   (H'2 : Rel_of U D x z) (H'3 : Rel_of U D y z) =>\n Upper_Bound_definition U D (Couple U x y) z H'1 ?Goal)"], "proof_term_after": ["(fun (x y z : U) (_ : In U (Carrier_of U D) x) (_ : In U (Carrier_of U D) y)\n   (H'1 : In U (Carrier_of U D) z) (H'2 : Rel_of U D x z)\n   (H'3 : Rel_of U D y z) =>\n Upper_Bound_definition U D (Couple U x y) z H'1\n   (fun (y0 : U) (H'4 : In U (Couple U x y) y0) =>\n    Couple_ind U x y (fun y1 : U => Rel_of U D y1 z) H'2 H'3 y0 H'4))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y z : U) (_ : In U (Carrier_of U D) x) (_ : In U (Carrier_of U D) y)\n   (H'1 : In U (Carrier_of U D) z) (H'2 : Rel_of U D x z)\n   (H'3 : Rel_of U D y z) =>\n Upper_Bound_definition U D (Couple U x y) z H'1\n   (fun (y0 : U) (H'4 : In U (Couple U x y) y0) =>\n    Couple_ind U x y (fun y1 : U => Rel_of U D y1 z) H'2 H'3 y0 H'4))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Upper_Bound_Couple_inv", "text": "Theorem Upper_Bound_Couple_inv :\n forall x y z : U,\n Upper_Bound U D (Couple U x y) z ->\n Rel_of U D x z /\\ Rel_of U D y z /\\ In U (Carrier_of U D) z.\nintros x y z H'; elim H'; auto with sets.\nQed.\n", "definition": "\n forall x y z : U,\n Upper_Bound U D (Couple U x y) z ->\n Rel_of U D x z /\\ Rel_of U D y z /\\ In U (Carrier_of U D) z.", "proof": "\nintros x y z H'; elim H'; auto with sets.\n", "def_ranges": [50, 0, 53, 61], "proof_ranges": [54, 0, 55, 4], "proof_steps": [{"text": "intros x y z H'; elim H'; auto with sets.", "goal_before": ["forall x y z : U,\nUpper_Bound U D (Couple U x y) z ->\nRel_of U D x z /\\ Rel_of U D y z /\\ In U (Carrier_of U D) z"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x y z : U) (H' : Upper_Bound U D (Couple U x y) z) =>\n Upper_Bound_ind U D (Couple U x y) z\n   (Rel_of U D x z /\\ Rel_of U D y z /\\ In U (Carrier_of U D) z)\n   (fun (H : In U (Carrier_of U D) z)\n      (H0 : forall y0 : U, In U (Couple U x y) y0 -> Rel_of U D y0 z) =>\n    conj (H0 x (Couple_l U x y)) (conj (H0 y (Couple_r U x y)) H)) H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y z : U) (H' : Upper_Bound U D (Couple U x y) z) =>\n Upper_Bound_ind U D (Couple U x y) z\n   (Rel_of U D x z /\\ Rel_of U D y z /\\ In U (Carrier_of U D) z)\n   (fun (H : In U (Carrier_of U D) z)\n      (H0 : forall y0 : U, In U (Couple U x y) y0 -> Rel_of U D y0 z) =>\n    conj (H0 x (Couple_l U x y)) (conj (H0 y (Couple_r U x y)) H)) H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Upper_Bound_Singleton_intro", "text": "Theorem Upper_Bound_Singleton_intro :\n forall x z : U,\n In U (Carrier_of U D) x ->\n In U (Carrier_of U D) z -> x = z -> Upper_Bound U D (Singleton U x) z.\nintros x z H' H'0 H'1; rewrite <- H'1.\napply Upper_Bound_definition; auto with sets.\nintros y H'2; elim H'2; auto with sets.\nQed.\n", "definition": "\n forall x z : U,\n In U (Carrier_of U D) x ->\n In U (Carrier_of U D) z -> x = z -> Upper_Bound U D (Singleton U x) z.", "proof": "\nintros x z H' H'0 H'1; rewrite <- H'1.\napply Upper_Bound_definition; auto with sets.\nintros y H'2; elim H'2; auto with sets.\n", "def_ranges": [57, 0, 60, 71], "proof_ranges": [61, 0, 64, 4], "proof_steps": [{"text": "intros x z H' H'0 H'1; rewrite <- H'1.", "goal_before": ["forall x z : U,\nIn U (Carrier_of U D) x ->\nIn U (Carrier_of U D) z -> x = z -> Upper_Bound U D (Singleton U x) z"], "goal_after": ["Upper_Bound U D (Singleton U x) x"], "proof_term_before": [], "proof_term_after": ["(fun (x z : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) z)\n   (H'1 : x = z) =>\n eq_ind x (fun z0 : U => Upper_Bound U D (Singleton U x) z0) ?Goal z H'1)"]}, {"text": "apply Upper_Bound_definition; auto with sets.", "goal_before": ["Upper_Bound U D (Singleton U x) x"], "goal_after": ["forall y : U, In U (Singleton U x) y -> Rel_of U D y x"], "proof_term_before": ["(fun (x z : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) z)\n   (H'1 : x = z) =>\n eq_ind x (fun z0 : U => Upper_Bound U D (Singleton U x) z0) ?Goal z H'1)"], "proof_term_after": ["(fun (x z : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) z)\n   (H'1 : x = z) =>\n eq_ind x (fun z0 : U => Upper_Bound U D (Singleton U x) z0)\n   (Upper_Bound_definition U D (Singleton U x) x H' ?Goal) z H'1)"]}, {"text": "intros y H'2; elim H'2; auto with sets.", "goal_before": ["forall y : U, In U (Singleton U x) y -> Rel_of U D y x"], "goal_after": ["Rel_of U D x x"], "proof_term_before": ["(fun (x z : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) z)\n   (H'1 : x = z) =>\n eq_ind x (fun z0 : U => Upper_Bound U D (Singleton U x) z0)\n   (Upper_Bound_definition U D (Singleton U x) x H' ?Goal) z H'1)"], "proof_term_after": ["(fun (x z : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) z)\n   (H'1 : x = z) =>\n eq_ind x (fun z0 : U => Upper_Bound U D (Singleton U x) z0)\n   (Upper_Bound_definition U D (Singleton U x) x H'\n      (fun (y : U) (H'2 : In U (Singleton U x) y) =>\n       Singleton_ind U x (fun y0 : U => Rel_of U D y0 x) ?Goal y H'2)) z H'1)"]}, {"text": "Qed.", "goal_before": ["Rel_of U D x x"], "goal_after": [], "proof_term_before": ["(fun (x z : U) (H' : In U (Carrier_of U D) x) (H'0 : In U (Carrier_of U D) z)\n   (H'1 : x = z) =>\n eq_ind x (fun z0 : U => Upper_Bound U D (Singleton U x) z0)\n   (Upper_Bound_definition U D (Singleton U x) x H'\n      (fun (y : U) (H'2 : In U (Singleton U x) y) =>\n       Singleton_ind U x (fun y0 : U => Rel_of U D y0 x) ?Goal y H'2)) z H'1)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Upper_Bound_Singleton_inv", "text": "Theorem Upper_Bound_Singleton_inv :\n forall x z : U, Upper_Bound U D (Singleton U x) z -> Rel_of U D x z.\nintros x z H'; elim H'; auto with sets.\nQed.\n", "definition": "\n forall x z : U, Upper_Bound U D (Singleton U x) z -> Rel_of U D x z.", "proof": "\nintros x z H'; elim H'; auto with sets.\n", "def_ranges": [67, 0, 68, 69], "proof_ranges": [69, 0, 70, 4], "proof_steps": [{"text": "intros x z H'; elim H'; auto with sets.", "goal_before": ["forall x z : U, Upper_Bound U D (Singleton U x) z -> Rel_of U D x z"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun (x z : U) (H' : Upper_Bound U D (Singleton U x) z) =>\n Upper_Bound_ind U D (Singleton U x) z (Rel_of U D x z)\n   (fun (_ : In U (Carrier_of U D) z)\n      (H0 : forall y : U, In U (Singleton U x) y -> Rel_of U D y z) =>\n    H0 x (In_singleton U x)) H')"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x z : U) (H' : Upper_Bound U D (Singleton U x) z) =>\n Upper_Bound_ind U D (Singleton U x) z (Rel_of U D x z)\n   (fun (_ : In U (Carrier_of U D) z)\n      (H0 : forall y : U, In U (Singleton U x) y -> Rel_of U D y z) =>\n    H0 x (In_singleton U x)) H')"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Non_empty_has_glb", "text": "Theorem Non_empty_has_glb :\n Conditionally_complete U D ->\n forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n Inhabited U X -> exists binf : U, Glb U D X binf.\nProof.\nintro H'; elim H'; clear H'.\nintros H'0 X H'1 H'2.\ngeneralize (Lower_Bound_is_in_Carrier X); intro L.\nelim (H'0 (fun z : U => Lower_Bound U D X z)); auto with sets.\nintros bsup H'3; elim H'3; intros H'4 H'6.\nexists bsup; auto with sets.\napply Glb_definition; auto with sets.\napply Lower_Bound_definition; auto with sets.\napply Lub_is_in_Carrier with (X := fun z : U => Lower_Bound U D X z);\n auto with sets.\nintros y H'7; apply H'6.\napply Upper_Bound_definition; auto with sets.\nintros y0 H'8; elim H'8; auto with sets.\nintros y H'7; elim H'7; auto with sets.\nintros H'8 H'9; elim H'4; auto with sets.\nelim H'2; intros x0 H'3; exists x0.\napply Upper_Bound_definition; auto with sets.\nintros y H'4; elim H'4; auto with sets.\nQed.\n", "definition": "\n Conditionally_complete U D ->\n forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n Inhabited U X -> exists binf : U, Glb U D X binf.\n", "proof": "\nintro H'; elim H'; clear H'.\nintros H'0 X H'1 H'2.\ngeneralize (Lower_Bound_is_in_Carrier X); intro L.\nelim (H'0 (fun z : U => Lower_Bound U D X z)); auto with sets.\nintros bsup H'3; elim H'3; intros H'4 H'6.\nexists bsup; auto with sets.\napply Glb_definition; auto with sets.\napply Lower_Bound_definition; auto with sets.\napply Lub_is_in_Carrier with (X := fun z : U => Lower_Bound U D X z);\n auto with sets.\nintros y H'7; apply H'6.\napply Upper_Bound_definition; auto with sets.\nintros y0 H'8; elim H'8; auto with sets.\nintros y H'7; elim H'7; auto with sets.\nintros H'8 H'9; elim H'4; auto with sets.\nelim H'2; intros x0 H'3; exists x0.\napply Upper_Bound_definition; auto with sets.\nintros y H'4; elim H'4; auto with sets.\n", "def_ranges": [73, 0, 77, 50], "proof_ranges": [78, 0, 97, 4], "proof_steps": [{"text": "intro H'; elim H'; clear H'.", "goal_before": ["Conditionally_complete U D ->\nforall X : Ensemble U,\nIncluded U X (Carrier_of U D) ->\nInhabited U X -> exists binf : U, Glb U D X binf"], "goal_after": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nforall X : Ensemble U,\nIncluded U X (Carrier_of U D) ->\nInhabited U X -> exists binf : U, Glb U D X binf"], "proof_term_before": [], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf) \n   ?Goal H')"]}, {"text": "intros H'0 X H'1 H'2.", "goal_before": ["(forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n (exists maj : U, Upper_Bound U D X maj) -> exists bsup : U, Lub U D X bsup) ->\nforall X : Ensemble U,\nIncluded U X (Carrier_of U D) ->\nInhabited U X -> exists binf : U, Glb U D X binf"], "goal_after": ["exists binf : U, Glb U D X binf"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf) \n   ?Goal H')"], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) => \n    ?Goal) H')"]}, {"text": "generalize (Lower_Bound_is_in_Carrier X); intro L.", "goal_before": ["exists binf : U, Glb U D X binf"], "goal_after": ["exists binf : U, Glb U D X binf"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) => \n    ?Goal) H')"], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound => \n     ?Goal) (Lower_Bound_is_in_Carrier X)) H')"]}, {"text": "elim (H'0 (fun z : U => Lower_Bound U D X z)); auto with sets.", "goal_before": ["exists binf : U, Glb U D X binf"], "goal_after": ["forall x : U,\nLub U D (fun z : U => Lower_Bound U D X z) x ->\nexists binf : U, Glb U D X binf", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound => \n     ?Goal) (Lower_Bound_is_in_Carrier X)) H')"], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind ?Goal\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal0)) (Lower_Bound_is_in_Carrier X)) H')"]}, {"text": "intros bsup H'3; elim H'3; intros H'4 H'6.", "goal_before": ["forall x : U,\nLub U D (fun z : U => Lower_Bound U D X z) x ->\nexists binf : U, Glb U D X binf", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["exists binf : U, Glb U D X binf", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind ?Goal\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal0)) (Lower_Bound_is_in_Carrier X)) H')"], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind\n       (fun (bsup : U)\n          (H'3 : Lub U D (fun z : U => Lower_Bound U D X z) bsup) =>\n        Lub_ind U D (fun z : U => Lower_Bound U D X z) bsup\n          (exists binf : U, Glb U D X binf)\n          (fun\n             (H'4 : Upper_Bound U D (fun z : U => Lower_Bound U D X z) bsup)\n             (H'6 : forall y : U,\n                    Upper_Bound U D (fun z : U => Lower_Bound U D X z) y ->\n                    Rel_of U D bsup y) => ?Goal0) H'3)\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal)) (Lower_Bound_is_in_Carrier X)) H')"]}, {"text": "exists bsup; auto with sets.", "goal_before": ["exists binf : U, Glb U D X binf", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["Glb U D X bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind\n       (fun (bsup : U)\n          (H'3 : Lub U D (fun z : U => Lower_Bound U D X z) bsup) =>\n        Lub_ind U D (fun z : U => Lower_Bound U D X z) bsup\n          (exists binf : U, Glb U D X binf)\n          (fun\n             (H'4 : Upper_Bound U D (fun z : U => Lower_Bound U D X z) bsup)\n             (H'6 : forall y : U,\n                    Upper_Bound U D (fun z : U => Lower_Bound U D X z) y ->\n                    Rel_of U D bsup y) => ?Goal0) H'3)\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal)) (Lower_Bound_is_in_Carrier X)) H')"], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind\n       (fun (bsup : U)\n          (H'3 : Lub U D (fun z : U => Lower_Bound U D X z) bsup) =>\n        Lub_ind U D (fun z : U => Lower_Bound U D X z) bsup\n          (exists binf : U, Glb U D X binf)\n          (fun\n             (H'4 : Upper_Bound U D (fun z : U => Lower_Bound U D X z) bsup)\n             (H'6 : forall y : U,\n                    Upper_Bound U D (fun z : U => Lower_Bound U D X z) y ->\n                    Rel_of U D bsup y) =>\n           ex_intro (fun binf : U => Glb U D X binf) bsup ?Goal0) H'3)\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal)) (Lower_Bound_is_in_Carrier X)) H')"]}, {"text": "apply Glb_definition; auto with sets.", "goal_before": ["Glb U D X bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["Lower_Bound U D X bsup", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind\n       (fun (bsup : U)\n          (H'3 : Lub U D (fun z : U => Lower_Bound U D X z) bsup) =>\n        Lub_ind U D (fun z : U => Lower_Bound U D X z) bsup\n          (exists binf : U, Glb U D X binf)\n          (fun\n             (H'4 : Upper_Bound U D (fun z : U => Lower_Bound U D X z) bsup)\n             (H'6 : forall y : U,\n                    Upper_Bound U D (fun z : U => Lower_Bound U D X z) y ->\n                    Rel_of U D bsup y) =>\n           ex_intro (fun binf : U => Glb U D X binf) bsup ?Goal0) H'3)\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal)) (Lower_Bound_is_in_Carrier X)) H')"], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind\n       (fun (bsup : U)\n          (H'3 : Lub U D (fun z : U => Lower_Bound U D X z) bsup) =>\n        Lub_ind U D (fun z : U => Lower_Bound U D X z) bsup\n          (exists binf : U, Glb U D X binf)\n          (fun\n             (H'4 : Upper_Bound U D (fun z : U => Lower_Bound U D X z) bsup)\n             (H'6 : forall y : U,\n                    Upper_Bound U D (fun z : U => Lower_Bound U D X z) y ->\n                    Rel_of U D bsup y) =>\n           ex_intro (fun binf : U => Glb U D X binf) bsup\n             (Glb_definition U D X bsup ?Goal0 ?Goal1)) H'3)\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal)) (Lower_Bound_is_in_Carrier X)) H')"]}, {"text": "apply Lower_Bound_definition; auto with sets.", "goal_before": ["Lower_Bound U D X bsup", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind\n       (fun (bsup : U)\n          (H'3 : Lub U D (fun z : U => Lower_Bound U D X z) bsup) =>\n        Lub_ind U D (fun z : U => Lower_Bound U D X z) bsup\n          (exists binf : U, Glb U D X binf)\n          (fun\n             (H'4 : Upper_Bound U D (fun z : U => Lower_Bound U D X z) bsup)\n             (H'6 : forall y : U,\n                    Upper_Bound U D (fun z : U => Lower_Bound U D X z) y ->\n                    Rel_of U D bsup y) =>\n           ex_intro (fun binf : U => Glb U D X binf) bsup\n             (Glb_definition U D X bsup ?Goal0 ?Goal1)) H'3)\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal)) (Lower_Bound_is_in_Carrier X)) H')"], "proof_term_after": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind\n       (fun (bsup : U)\n          (H'3 : Lub U D (fun z : U => Lower_Bound U D X z) bsup) =>\n        Lub_ind U D (fun z : U => Lower_Bound U D X z) bsup\n          (exists binf : U, Glb U D X binf)\n          (fun\n             (H'4 : Upper_Bound U D (fun z : U => Lower_Bound U D X z) bsup)\n             (H'6 : forall y : U,\n                    Upper_Bound U D (fun z : U => Lower_Bound U D X z) y ->\n                    Rel_of U D bsup y) =>\n           ex_intro (fun binf : U => Glb U D X binf) bsup\n             (Glb_definition U D X bsup\n                (Lower_Bound_definition U D X bsup ?Goal1 ?Goal2) \n                ?Goal0)) H'3)\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal)) (Lower_Bound_is_in_Carrier X)) H')"]}, {"text": "apply Lub_is_in_Carrier with (X := fun z : U => Lower_Bound U D X z);", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": ["(fun H' : Conditionally_complete U D =>\n Conditionally_complete_ind U D\n   (forall X : Ensemble U,\n    Included U X (Carrier_of U D) ->\n    Inhabited U X -> exists binf : U, Glb U D X binf)\n   (fun\n      (H'0 : forall X : Ensemble U,\n             Included U X (Carrier_of U D) ->\n             (exists maj : U, Upper_Bound U D X maj) ->\n             exists bsup : U, Lub U D X bsup) (X : Ensemble U)\n      (H'1 : Included U X (Carrier_of U D)) (H'2 : Inhabited U X) =>\n    (fun\n       L : forall bound : U,\n           Included U X (Carrier_of U D) ->\n           Lower_Bound U D X bound -> In U (Carrier_of U D) bound =>\n     ex_ind\n       (fun (bsup : U)\n          (H'3 : Lub U D (fun z : U => Lower_Bound U D X z) bsup) =>\n        Lub_ind U D (fun z : U => Lower_Bound U D X z) bsup\n          (exists binf : U, Glb U D X binf)\n          (fun\n             (H'4 : Upper_Bound U D (fun z : U => Lower_Bound U D X z) bsup)\n             (H'6 : forall y : U,\n                    Upper_Bound U D (fun z : U => Lower_Bound U D X z) y ->\n                    Rel_of U D bsup y) =>\n           ex_intro (fun binf : U => Glb U D X binf) bsup\n             (Glb_definition U D X bsup\n                (Lower_Bound_definition U D X bsup ?Goal1 ?Goal2) \n                ?Goal0)) H'3)\n       (H'0 (fun z : U => Lower_Bound U D X z)\n          ((fun (x : U) (H : In U (fun z : U => Lower_Bound U D X z) x) =>\n            L x H'1 H)\n           :\n           Included U (fun z : U => Lower_Bound U D X z) (Carrier_of U D))\n          ?Goal)) (Lower_Bound_is_in_Carrier X)) H')"], "proof_term_after": []}, {"text": "auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'7; apply H'6.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y0 H'8; elim H'8; auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'7; elim H'7; auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'8 H'9; elim H'4; auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H'2; intros x0 H'3; exists x0.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Upper_Bound_definition; auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y H'4; elim H'4; auto with sets.", "goal_before": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "goal_after": ["In U (Carrier_of U D) bsup", "forall y : U, In U X y -> Rel_of U D bsup y", "forall y : U, Lower_Bound U D X y -> Rel_of U D y bsup", "exists maj : U, Upper_Bound U D (fun z : U => Lower_Bound U D X z) maj"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Bounded_implies_consistent", "text": "Theorem Bounded_implies_consistent :\n forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n ex (fun maj : U => Upper_Bound U D X maj) -> Consistent U D X.\nintros X H' H'0; elim H'0; intros maj E; try exact E; clear H'0.\nred in |- *; simpl in |- *.\nintros H'0 x y H'1; red in |- *; simpl in |- *.\nintros H'2 H'3; exists maj; split.\nelim E; auto with sets.\nelim E; auto with sets.\nQed.\n", "definition": "\n forall X : Ensemble U,\n Included U X (Carrier_of U D) ->\n ex (fun maj : U => Upper_Bound U D X maj) -> Consistent U D X.", "proof": "\nintros X H' H'0; elim H'0; intros maj E; try exact E; clear H'0.\nred in |- *; simpl in |- *.\nintros H'0 x y H'1; red in |- *; simpl in |- *.\nintros H'2 H'3; exists maj; split.\nelim E; auto with sets.\nelim E; auto with sets.\n", "def_ranges": [99, 0, 102, 63], "proof_ranges": [103, 0, 109, 4], "proof_steps": [{"text": "intros X H' H'0; elim H'0; intros maj E; try exact E; clear H'0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'0 x y H'1; red in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H'2 H'3; exists maj; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim E; auto with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/domain-theory/lpo1.v", "name": "Consistent_downward_stable", "text": "Theorem Consistent_downward_stable :\n forall B : Ensemble U,\n Included U B (Carrier_of U D) ->\n Consistent U D B ->\n forall A : Ensemble U, Included U A B -> Consistent U D A.\nProof.\nauto 6 with sets.\nQed.\n", "definition": "\n forall B : Ensemble U,\n Included U B (Carrier_of U D) ->\n Consistent U D B ->\n forall A : Ensemble U, Included U A B -> Consistent U D A.\n", "proof": "\nauto 6 with sets.\n", "def_ranges": [111, 0, 115, 59], "proof_ranges": [116, 0, 118, 4], "proof_steps": [{"text": "auto 6 with sets.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}]