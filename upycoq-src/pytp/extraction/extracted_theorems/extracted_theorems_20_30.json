[{"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inter.v", "name": "union_inter", "text": "Lemma union_inter :\n forall a b c : Ensf,\n inter a b empty -> inter a c empty -> inter a (union b c) empty.\nunfold inter in |- *.\nintros.\nelim H0; clear H0.\nintros H0 H1; elim H1; clear H1; intros H1 H2.\nelim H; clear H.\nintros H3 H4; elim H4; clear H4; intros H4 H5.\nsplit; auto.\nsplit.\napply empty_inclus.\nintros.\ncut (dans x b \\/ dans x c); auto.\nintro H7; elim H7; auto.\nQed.\n", "definition": "\n forall a b c : Ensf,\n inter a b empty -> inter a c empty -> inter a (union b c) empty.", "proof": "\nunfold inter in |- *.\nintros.\nelim H0; clear H0.\nintros H0 H1; elim H1; clear H1; intros H1 H2.\nelim H; clear H.\nintros H3 H4; elim H4; clear H4; intros H4 H5.\nsplit; auto.\nsplit.\napply empty_inclus.\nintros.\ncut (dans x b \\/ dans x c); auto.\nintro H7; elim H7; auto.\nQed.", "proof_term": [], "def_ranges": [58, 0, 60, 65], "proof_ranges": [61, 0, 73, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inter in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H0; clear H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H0 H1; elim H1; clear H1; intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H; clear H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H3 H4; elim H4; clear H4; intros H4 H5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply empty_inclus.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x b \\/ dans x c); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H7; elim H7; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inter in |- *. Show Proof.", "intros. Show Proof.", "elim H0; clear H0. Show Proof.", "intros H0 H1; elim H1; clear H1; intros H1 H2. Show Proof.", "elim H; clear H. Show Proof.", "intros H3 H4; elim H4; clear H4; intros H4 H5. Show Proof.", "split; auto. Show Proof.", "split. Show Proof.", "apply empty_inclus. Show Proof.", "intros. Show Proof.", "cut (dans x b \\/ dans x c); auto. Show Proof.", "intro H7; elim H7; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inter.v", "name": "inter_union", "text": "Lemma inter_union :\n forall A B C : Ensf,\n inter A C empty -> inter B C empty -> inter (union A B) C empty.\nunfold inter in |- *.\nintros.\nelim H0; clear H0.\nintros H0 H1; elim H1; clear H1; intros H1 H2.\nelim H; clear H.\nintros H3 H4; elim H4; clear H4; intros H4 H5.\nsplit; auto.\nsplit; auto.\nintros.\ncut (dans x A \\/ dans x B); auto.\nintro H7; elim H7; auto.\nQed.\n", "definition": "\n forall A B C : Ensf,\n inter A C empty -> inter B C empty -> inter (union A B) C empty.", "proof": "\nunfold inter in |- *.\nintros.\nelim H0; clear H0.\nintros H0 H1; elim H1; clear H1; intros H1 H2.\nelim H; clear H.\nintros H3 H4; elim H4; clear H4; intros H4 H5.\nsplit; auto.\nsplit; auto.\nintros.\ncut (dans x A \\/ dans x B); auto.\nintro H7; elim H7; auto.\nQed.", "proof_term": [], "def_ranges": [75, 0, 77, 65], "proof_ranges": [78, 0, 89, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inter in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H0; clear H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H0 H1; elim H1; clear H1; intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H; clear H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H3 H4; elim H4; clear H4; intros H4 H5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x A \\/ dans x B); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H7; elim H7; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inter in |- *. Show Proof.", "intros. Show Proof.", "elim H0; clear H0. Show Proof.", "intros H0 H1; elim H1; clear H1; intros H1 H2. Show Proof.", "elim H; clear H. Show Proof.", "intros H3 H4; elim H4; clear H4; intros H4 H5. Show Proof.", "split; auto. Show Proof.", "split; auto. Show Proof.", "intros. Show Proof.", "cut (dans x A \\/ dans x B); auto. Show Proof.", "intro H7; elim H7; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inter.v", "name": "inter_dans", "text": "Lemma inter_dans :\n forall (A B : Ensf) (x : Elt), inter A B empty -> dans x A -> ~ dans x B.\nunfold inter in |- *.\nintros.\nelim H; clear H; intros H Ht; elim Ht; clear Ht; intros H1 H2.\nred in |- *; intro.\ncut (dans x empty); auto.\nintro.\napply dans_empty_imp_P with x; auto.\nQed.\n", "definition": "\n forall (A B : Ensf) (x : Elt), inter A B empty -> dans x A -> ~ dans x B.", "proof": "\nunfold inter in |- *.\nintros.\nelim H; clear H; intros H Ht; elim Ht; clear Ht; intros H1 H2.\nred in |- *; intro.\ncut (dans x empty); auto.\nintro.\napply dans_empty_imp_P with x; auto.\nQed.", "proof_term": [], "def_ranges": [91, 0, 92, 74], "proof_ranges": [93, 0, 100, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inter in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H; clear H; intros H Ht; elim Ht; clear Ht; intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *; intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x empty); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_empty_imp_P with x; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inter in |- *. Show Proof.", "intros. Show Proof.", "elim H; clear H; intros H Ht; elim Ht; clear Ht; intros H1 H2. Show Proof.", "red in |- *; intro. Show Proof.", "cut (dans x empty); auto. Show Proof.", "intro. Show Proof.", "apply dans_empty_imp_P with x; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inter.v", "name": "sym_inter", "text": "Lemma sym_inter : forall A B C : Ensf, inter A B C -> inter B A C.\nunfold inter in |- *.\nintros.\nelim H; clear H; intros H Ht; elim Ht; clear Ht; intros H0 H1.\nauto.\nQed.", "definition": " forall A B C : Ensf, inter A B C -> inter B A C.", "proof": "\nunfold inter in |- *.\nintros.\nelim H; clear H; intros H Ht; elim Ht; clear Ht; intros H0 H1.\nauto.\nQed", "proof_term": [], "def_ranges": [102, 0, 102, 66], "proof_ranges": [103, 0, 107, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inter in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H; clear H; intros H Ht; elim Ht; clear Ht; intros H0 H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inter in |- *. Show Proof.", "intros. Show Proof.", "elim H; clear H; intros H Ht; elim Ht; clear Ht; intros H0 H1. Show Proof.", "auto. Show Proof.", "Qed Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "empty_inclus", "text": "Lemma empty_inclus : forall x : Ensf, inclus empty x.\nunfold inclus in |- *; intros.\nabsurd (dans x0 empty); auto.\nQed.\n", "definition": " forall x : Ensf, inclus empty x.", "proof": "\nunfold inclus in |- *; intros.\nabsurd (dans x0 empty); auto.\nQed.", "proof_term": [], "def_ranges": [61, 0, 61, 53], "proof_ranges": [62, 0, 64, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inclus in |- *; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "absurd (dans x0 empty); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inclus in |- *; intros. Show Proof.", "absurd (dans x0 empty); auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "refl_inclus", "text": "Lemma refl_inclus : forall x : Ensf, inclus x x.\nauto.\nQed.\n", "definition": " forall x : Ensf, inclus x x.", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [67, 0, 67, 48], "proof_ranges": [68, 0, 69, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "inclus_trans", "text": "Lemma inclus_trans :\n forall a b c : Ensf, inclus a b -> inclus b c -> inclus a c.\nauto.\nQed.\n", "definition": "\n forall a b c : Ensf, inclus a b -> inclus b c -> inclus a c.", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [72, 0, 73, 61], "proof_ranges": [74, 0, 75, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "cart_inclus", "text": "Lemma cart_inclus :\n forall a b c d : Ensf,\n inclus a b -> inclus c d -> inclus (prodcart a c) (prodcart b d).\nunfold inclus in |- *.\nintros.\ncut\n (exists x1 : Elt,\n    (exists x2 : Elt, dans x1 a /\\ dans x2 c /\\ x = couple x1 x2)).\n2: apply coupl3; auto.\nintro H2; elim H2; clear H2.\nintros x1 H2; elim H2; clear H2.\nintros x2 H2; elim H2; clear H2.\nintros H2 H3; elim H3; clear H3.\nintros H3 H4.\nrewrite H4.\nauto.\nQed.\n", "definition": "\n forall a b c d : Ensf,\n inclus a b -> inclus c d -> inclus (prodcart a c) (prodcart b d).", "proof": "\nunfold inclus in |- *.\nintros.\ncut\n (exists x1 : Elt,\n    (exists x2 : Elt, dans x1 a /\\ dans x2 c /\\ x = couple x1 x2)).\n2: apply coupl3; auto.\nintro H2; elim H2; clear H2.\nintros x1 H2; elim H2; clear H2.\nintros x2 H2; elim H2; clear H2.\nintros H2 H3; elim H3; clear H3.\nintros H3 H4.\nrewrite H4.\nauto.\nQed.", "proof_term": [], "def_ranges": [77, 0, 79, 66], "proof_ranges": [80, 0, 93, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(exists x1 : Elt,", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(exists x2 : Elt, dans x1 a /\\ dans x2 c /\\ x = couple x1 x2)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply coupl3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x2 H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H2 H3; elim H3; clear H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H3 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inclus in |- *. Show Proof.", "intros. Show Proof.", "cut Show Proof.", "(exists x1 : Elt, Show Proof.", "(exists x2 : Elt, dans x1 a /\\ dans x2 c /\\ x = couple x1 x2)). Show Proof.", "2: apply coupl3; auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intros x1 H2; elim H2; clear H2. Show Proof.", "intros x2 H2; elim H2; clear H2. Show Proof.", "intros H2 H3; elim H3; clear H3. Show Proof.", "intros H3 H4. Show Proof.", "rewrite H4. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "inclus_add", "text": "Lemma inclus_add :\n forall (a b : Ensf) (y : Elt), inclus a b -> inclus a (add y b).\nauto.\nQed.\n", "definition": "\n forall (a b : Ensf) (y : Elt), inclus a b -> inclus a (add y b).", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [96, 0, 97, 65], "proof_ranges": [98, 0, 99, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "singl_inclus_add", "text": "Lemma singl_inclus_add :\n forall (e : Elt) (a : Ensf), inclus (singleton e) (add e a).\nunfold inclus in |- *.\nintros e a x H.\ncut (x = e); auto.\nintro H0.\nrewrite H0; auto.\nQed.\n", "definition": "\n forall (e : Elt) (a : Ensf), inclus (singleton e) (add e a).", "proof": "\nunfold inclus in |- *.\nintros e a x H.\ncut (x = e); auto.\nintro H0.\nrewrite H0; auto.\nQed.", "proof_term": [], "def_ranges": [102, 0, 103, 61], "proof_ranges": [104, 0, 109, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros e a x H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (x = e); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inclus in |- *. Show Proof.", "intros e a x H. Show Proof.", "cut (x = e); auto. Show Proof.", "intro H0. Show Proof.", "rewrite H0; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "inclus_singl", "text": "Lemma inclus_singl :\n forall (e : Elt) (a : Ensf), inclus (singleton e) a -> dans e a.\nauto.\nQed.\n", "definition": "\n forall (e : Elt) (a : Ensf), inclus (singleton e) a -> dans e a.", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [112, 0, 113, 65], "proof_ranges": [114, 0, 115, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "add_inclus", "text": "Lemma add_inclus :\n forall (x : Elt) (a b : Ensf), dans x b -> inclus a b -> inclus (add x a) b.\nunfold inclus in |- *.\nintros.\ncut (x = x0 \\/ dans x0 a).\n2: apply dans_add; auto.\nintro H2; elim H2; clear H2.\nintro H2; rewrite <- H2; auto.\nauto.\nQed.\n", "definition": "\n forall (x : Elt) (a b : Ensf), dans x b -> inclus a b -> inclus (add x a) b.", "proof": "\nunfold inclus in |- *.\nintros.\ncut (x = x0 \\/ dans x0 a).\n2: apply dans_add; auto.\nintro H2; elim H2; clear H2.\nintro H2; rewrite <- H2; auto.\nauto.\nQed.", "proof_term": [], "def_ranges": [118, 0, 119, 77], "proof_ranges": [120, 0, 127, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (x = x0 \\/ dans x0 a).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; rewrite <- H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inclus in |- *. Show Proof.", "intros. Show Proof.", "cut (x = x0 \\/ dans x0 a). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intro H2; rewrite <- H2; auto. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "dans_trans", "text": "Lemma dans_trans :\n forall (x : Elt) (a b : Ensf), dans x a -> inclus a b -> dans x b.\nauto.\nQed.\n", "definition": "\n forall (x : Elt) (a b : Ensf), dans x a -> inclus a b -> dans x b.", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [130, 0, 131, 67], "proof_ranges": [132, 0, 133, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "union_inclus", "text": "Lemma union_inclus :\n forall a b c : Ensf, inclus a c -> inclus b c -> inclus (union a b) c.\nunfold inclus in |- *.\nintros.\ncut (dans x a \\/ dans x b); auto.\nintro H2; elim H2; auto.\nQed.\n", "definition": "\n forall a b c : Ensf, inclus a c -> inclus b c -> inclus (union a b) c.", "proof": "\nunfold inclus in |- *.\nintros.\ncut (dans x a \\/ dans x b); auto.\nintro H2; elim H2; auto.\nQed.", "proof_term": [], "def_ranges": [135, 0, 136, 71], "proof_ranges": [137, 0, 141, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x a \\/ dans x b); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inclus in |- *. Show Proof.", "intros. Show Proof.", "cut (dans x a \\/ dans x b); auto. Show Proof.", "intro H2; elim H2; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "inclus_g", "text": "Lemma inclus_g : forall a b : Ensf, inclus a (union a b).\nauto.\nQed.\n", "definition": " forall a b : Ensf, inclus a (union a b).", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [144, 0, 144, 57], "proof_ranges": [145, 0, 146, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "inclus_d", "text": "Lemma inclus_d : forall a b : Ensf, inclus b (union a b).\nauto.\nQed.\n", "definition": " forall a b : Ensf, inclus b (union a b).", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [148, 0, 148, 57], "proof_ranges": [149, 0, 150, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "inclus_g2", "text": "Lemma inclus_g2 : forall A B C : Ensf, inclus A B -> inclus A (union B C).\nauto.\nQed.\n", "definition": " forall A B C : Ensf, inclus A B -> inclus A (union B C).", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [152, 0, 152, 74], "proof_ranges": [153, 0, 154, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_inclus.v", "name": "inclus_d2", "text": "Lemma inclus_d2 : forall A B C : Ensf, inclus A C -> inclus A (union B C).\nauto.\nQed.\n", "definition": " forall A B C : Ensf, inclus A C -> inclus A (union B C).", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [157, 0, 157, 74], "proof_ranges": [158, 0, 159, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_produit.v", "name": "dans_singleprod", "text": "Lemma dans_singleprod :\n forall (x y x0 : Elt) (b : Ensf),\n dans (couple x y) (singleprod x0 b) -> x = x0 :>Elt /\\ dans y b.\nintros x y x0.\nsimple induction b.\nsimpl in |- *.\nintro.\napply (dans_empty_imp_P (couple x y)); auto.\n\nintros a b0 H.\nsimpl in |- *.\nintro.\ncut (couple x0 a = couple x y :>Elt \\/ dans (couple x y) (singleprod x0 b0)).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro H1.\ninjection H1; intros.\nsplit; auto.\nrewrite H2; auto.\n\nintro.\ncut (x = x0 :>Elt /\\ dans y b0); auto.\nintro H2; elim H2; clear H2.\nintros.\nsplit; auto.\nQed.\n", "definition": "\n forall (x y x0 : Elt) (b : Ensf),\n dans (couple x y) (singleprod x0 b) -> x = x0 :>Elt /\\ dans y b.", "proof": "\nintros x y x0.\nsimple induction b.\nsimpl in |- *.\nintro.\napply (dans_empty_imp_P (couple x y)); auto.\n\nintros a b0 H.\nsimpl in |- *.\nintro.\ncut (couple x0 a = couple x y :>Elt \\/ dans (couple x y) (singleprod x0 b0)).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro H1.\ninjection H1; intros.\nsplit; auto.\nrewrite H2; auto.\n\nintro.\ncut (x = x0 :>Elt /\\ dans y b0); auto.\nintro H2; elim H2; clear H2.\nintros.\nsplit; auto.\nQed.", "proof_term": [], "def_ranges": [85, 0, 87, 65], "proof_ranges": [88, 0, 110, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x y x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P (couple x y)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b0 H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (couple x0 a = couple x y :>Elt \\/ dans (couple x y) (singleprod x0 b0)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (x = x0 :>Elt /\\ dans y b0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x y x0. Show Proof.", "simple induction b. Show Proof.", "simpl in |- *. Show Proof.", "intro. Show Proof.", "apply (dans_empty_imp_P (couple x y)); auto. Show Proof.", "intros a b0 H. Show Proof.", "simpl in |- *. Show Proof.", "intro. Show Proof.", "cut (couple x0 a = couple x y :>Elt \\/ dans (couple x y) (singleprod x0 b0)). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro H1. Show Proof.", "injection H1; intros. Show Proof.", "split; auto. Show Proof.", "rewrite H2; auto. Show Proof.", "intro. Show Proof.", "cut (x = x0 :>Elt /\\ dans y b0); auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intros. Show Proof.", "split; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_produit.v", "name": "coupl2", "text": "Lemma coupl2 :\n forall (x y : Elt) (a b : Ensf),\n dans (couple x y) (prodcart a b) -> dans x a /\\ dans y b.\nintros x y.\nsimple induction a.\nintro b.\nsimpl in |- *.\nintro.\napply (dans_empty_imp_P (couple x y)); auto.\n\nintros a0 b H b0.\nsimpl in |- *.\nintro.\ncut\n (dans (couple x y) (singleprod a0 b0) \\/ dans (couple x y) (prodcart b b0)).\n2: apply dans_union; auto.\nintro H1; elim H1; clear H1.\nintro H1.\ncut (x = a0 :>Elt /\\ dans y b0).\n2: apply dans_singleprod; auto.\nintro H2; elim H2; clear H2.\nintros.\nrewrite H2.\nsplit; auto.\nintro.\ncut (dans x b /\\ dans y b0); auto.\nintro H2; elim H2; clear H2.\nintros.\nsplit; auto.\nQed.\n", "definition": "\n forall (x y : Elt) (a b : Ensf),\n dans (couple x y) (prodcart a b) -> dans x a /\\ dans y b.", "proof": "\nintros x y.\nsimple induction a.\nintro b.\nsimpl in |- *.\nintro.\napply (dans_empty_imp_P (couple x y)); auto.\n\nintros a0 b H b0.\nsimpl in |- *.\nintro.\ncut\n (dans (couple x y) (singleprod a0 b0) \\/ dans (couple x y) (prodcart b b0)).\n2: apply dans_union; auto.\nintro H1; elim H1; clear H1.\nintro H1.\ncut (x = a0 :>Elt /\\ dans y b0).\n2: apply dans_singleprod; auto.\nintro H2; elim H2; clear H2.\nintros.\nrewrite H2.\nsplit; auto.\nintro.\ncut (dans x b /\\ dans y b0); auto.\nintro H2; elim H2; clear H2.\nintros.\nsplit; auto.\nQed.", "proof_term": [], "def_ranges": [115, 0, 117, 58], "proof_ranges": [118, 0, 144, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P (couple x y)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H b0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(dans (couple x y) (singleprod a0 b0) \\/ dans (couple x y) (prodcart b b0)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_union; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (x = a0 :>Elt /\\ dans y b0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_singleprod; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x b /\\ dans y b0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x y. Show Proof.", "simple induction a. Show Proof.", "intro b. Show Proof.", "simpl in |- *. Show Proof.", "intro. Show Proof.", "apply (dans_empty_imp_P (couple x y)); auto. Show Proof.", "intros a0 b H b0. Show Proof.", "simpl in |- *. Show Proof.", "intro. Show Proof.", "cut Show Proof.", "(dans (couple x y) (singleprod a0 b0) \\/ dans (couple x y) (prodcart b b0)). Show Proof.", "2: apply dans_union; auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro H1. Show Proof.", "cut (x = a0 :>Elt /\\ dans y b0). Show Proof.", "2: apply dans_singleprod; auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intros. Show Proof.", "rewrite H2. Show Proof.", "split; auto. Show Proof.", "intro. Show Proof.", "cut (dans x b /\\ dans y b0); auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intros. Show Proof.", "split; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_produit.v", "name": "dans_single", "text": "Lemma dans_single :\n forall (x y : Elt) (a : Ensf),\n dans y a -> dans (couple x y) (singleprod x a).\nintros x y.\nsimple induction a.\nintro.\napply (dans_empty_imp_P y); auto.\nintros a0 b H H1.\ncut (a0 = y :>Elt \\/ dans y b).\n2: apply dans_add; auto.\nintro H2; elim H2; clear H2.\nintro.\nsimpl in |- *.\nrewrite H0; auto.\nsimpl in |- *; auto.\nQed.\n", "definition": "\n forall (x y : Elt) (a : Ensf),\n dans y a -> dans (couple x y) (singleprod x a).", "proof": "\nintros x y.\nsimple induction a.\nintro.\napply (dans_empty_imp_P y); auto.\nintros a0 b H H1.\ncut (a0 = y :>Elt \\/ dans y b).\n2: apply dans_add; auto.\nintro H2; elim H2; clear H2.\nintro.\nsimpl in |- *.\nrewrite H0; auto.\nsimpl in |- *; auto.\nQed.", "proof_term": [], "def_ranges": [148, 0, 150, 48], "proof_ranges": [151, 0, 163, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P y); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a0 = y :>Elt \\/ dans y b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x y. Show Proof.", "simple induction a. Show Proof.", "intro. Show Proof.", "apply (dans_empty_imp_P y); auto. Show Proof.", "intros a0 b H H1. Show Proof.", "cut (a0 = y :>Elt \\/ dans y b). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intro. Show Proof.", "simpl in |- *. Show Proof.", "rewrite H0; auto. Show Proof.", "simpl in |- *; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_produit.v", "name": "coupl2_inv", "text": "Lemma coupl2_inv :\n forall (x y : Elt) (a b : Ensf),\n dans x a -> dans y b -> dans (couple x y) (prodcart a b).\nintros x y.\nsimple induction a.\nintros b H.\napply (dans_empty_imp_P x); auto.\n\nintros a0 b H b0 H0.\ncut (a0 = x :>Elt \\/ dans x b).\n2: apply dans_add; auto.\nsimpl in |- *.\nintro H1; elim H1; clear H1.\nintros H1 H2.\napply dans_union_inv.\nleft.\nrewrite H1.\napply dans_single; auto.\nintros H1 H2.\napply dans_union_inv.\nright.\nauto.\nQed.\n", "definition": "\n forall (x y : Elt) (a b : Ensf),\n dans x a -> dans y b -> dans (couple x y) (prodcart a b).", "proof": "\nintros x y.\nsimple induction a.\nintros b H.\napply (dans_empty_imp_P x); auto.\n\nintros a0 b H b0 H0.\ncut (a0 = x :>Elt \\/ dans x b).\n2: apply dans_add; auto.\nsimpl in |- *.\nintro H1; elim H1; clear H1.\nintros H1 H2.\napply dans_union_inv.\nleft.\nrewrite H1.\napply dans_single; auto.\nintros H1 H2.\napply dans_union_inv.\nright.\nauto.\nQed.", "proof_term": [], "def_ranges": [165, 0, 167, 58], "proof_ranges": [168, 0, 187, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros b H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H b0 H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a0 = x :>Elt \\/ dans x b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_union_inv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_single; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_union_inv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "right.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x y. Show Proof.", "simple induction a. Show Proof.", "intros b H. Show Proof.", "apply (dans_empty_imp_P x); auto. Show Proof.", "intros a0 b H b0 H0. Show Proof.", "cut (a0 = x :>Elt \\/ dans x b). Show Proof.", "2: apply dans_add; auto. Show Proof.", "simpl in |- *. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intros H1 H2. Show Proof.", "apply dans_union_inv. Show Proof.", "left. Show Proof.", "rewrite H1. Show Proof.", "apply dans_single; auto. Show Proof.", "intros H1 H2. Show Proof.", "apply dans_union_inv. Show Proof.", "right. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_produit.v", "name": "dans_singleprod2", "text": "Lemma dans_singleprod2 :\n forall (x x0 : Elt) (b : Ensf),\n dans x (singleprod x0 b) -> exists y : Elt, x = couple x0 y /\\ dans y b.\nintros x x0.\nsimple induction b.\nintro.\napply (dans_empty_imp_P x); auto.\nintros a b0 H.\nsimpl in |- *.\nintro.\ncut (couple x0 a = x :>Elt \\/ dans x (singleprod x0 b0)).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro.\nexists a; auto.\nintro.\ncut (exists y : Elt, x = couple x0 y /\\ dans y b0); auto.\nintro H2; elim H2; clear H2.\nintros.\nexists x1.\nelim H2; clear H2.\nintros.\nsplit; auto.\nQed.\n", "definition": "\n forall (x x0 : Elt) (b : Ensf),\n dans x (singleprod x0 b) -> exists y : Elt, x = couple x0 y /\\ dans y b.", "proof": "\nintros x x0.\nsimple induction b.\nintro.\napply (dans_empty_imp_P x); auto.\nintros a b0 H.\nsimpl in |- *.\nintro.\ncut (couple x0 a = x :>Elt \\/ dans x (singleprod x0 b0)).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro.\nexists a; auto.\nintro.\ncut (exists y : Elt, x = couple x0 y /\\ dans y b0); auto.\nintro H2; elim H2; clear H2.\nintros.\nexists x1.\nelim H2; clear H2.\nintros.\nsplit; auto.\nQed.", "proof_term": [], "def_ranges": [193, 0, 195, 73], "proof_ranges": [196, 0, 216, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b0 H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (couple x0 a = x :>Elt \\/ dans x (singleprod x0 b0)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists a; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, x = couple x0 y /\\ dans y b0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x x0. Show Proof.", "simple induction b. Show Proof.", "intro. Show Proof.", "apply (dans_empty_imp_P x); auto. Show Proof.", "intros a b0 H. Show Proof.", "simpl in |- *. Show Proof.", "intro. Show Proof.", "cut (couple x0 a = x :>Elt \\/ dans x (singleprod x0 b0)). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro. Show Proof.", "exists a; auto. Show Proof.", "intro. Show Proof.", "cut (exists y : Elt, x = couple x0 y /\\ dans y b0); auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intros. Show Proof.", "exists x1. Show Proof.", "elim H2; clear H2. Show Proof.", "intros. Show Proof.", "split; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_produit.v", "name": "coupl3", "text": "Lemma coupl3 :\n forall (a b : Ensf) (x : Elt),\n dans x (prodcart a b) ->\n exists x1 : Elt,\n   (exists x2 : Elt, dans x1 a /\\ dans x2 b /\\ x = couple x1 x2).\nsimple induction a.\nintro b.\nsimpl in |- *.\nintros x H.\napply (dans_empty_imp_P x); auto.\n\nintros a0 b H b0 x.\nsimpl in |- *.\nintro.\ncut (dans x (singleprod a0 b0) \\/ dans x (prodcart b b0)); auto.\nintro H1; elim H1; clear H1.\nintro.\ncut (exists y : Elt, x = couple a0 y /\\ dans y b0).\n2: apply dans_singleprod2; auto.\nintro H2; elim H2; clear H2.\nintros x0 H2.\nexists a0.\nexists x0.\nelim H2; clear H2.\nintros.\nsplit; auto.\nintro.\ncut\n (exists x1 : Elt,\n    (exists x2 : Elt, dans x1 b /\\ dans x2 b0 /\\ x = couple x1 x2));\n auto.\nintro H2; elim H2; clear H2.\nintros x0 H2; elim H2; clear H2.\nintros x1 H2; elim H2; clear H2.\nintros H2 H3; elim H3; clear H3.\nintros H4 H5.\nexists x0.\nexists x1.\nsplit; auto.\nQed.", "definition": "\n forall (a b : Ensf) (x : Elt),\n dans x (prodcart a b) ->\n exists x1 : Elt,\n   (exists x2 : Elt, dans x1 a /\\ dans x2 b /\\ x = couple x1 x2).", "proof": "\nsimple induction a.\nintro b.\nsimpl in |- *.\nintros x H.\napply (dans_empty_imp_P x); auto.\n\nintros a0 b H b0 x.\nsimpl in |- *.\nintro.\ncut (dans x (singleprod a0 b0) \\/ dans x (prodcart b b0)); auto.\nintro H1; elim H1; clear H1.\nintro.\ncut (exists y : Elt, x = couple a0 y /\\ dans y b0).\n2: apply dans_singleprod2; auto.\nintro H2; elim H2; clear H2.\nintros x0 H2.\nexists a0.\nexists x0.\nelim H2; clear H2.\nintros.\nsplit; auto.\nintro.\ncut\n (exists x1 : Elt,\n    (exists x2 : Elt, dans x1 b /\\ dans x2 b0 /\\ x = couple x1 x2));\n auto.\nintro H2; elim H2; clear H2.\nintros x0 H2; elim H2; clear H2.\nintros x1 H2; elim H2; clear H2.\nintros H2 H3; elim H3; clear H3.\nintros H4 H5.\nexists x0.\nexists x1.\nsplit; auto.\nQed", "proof_term": [], "def_ranges": [221, 0, 225, 65], "proof_ranges": [226, 0, 260, 4], "only_proof_term": false, "proof_steps": [{"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H b0 x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x (singleprod a0 b0) \\/ dans x (prodcart b b0)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, x = couple a0 y /\\ dans y b0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_singleprod2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists a0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(exists x1 : Elt,", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(exists x2 : Elt, dans x1 b /\\ dans x2 b0 /\\ x = couple x1 x2));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x1 H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H2 H3; elim H3; clear H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H4 H5.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["simple induction a. Show Proof.", "intro b. Show Proof.", "simpl in |- *. Show Proof.", "intros x H. Show Proof.", "apply (dans_empty_imp_P x); auto. Show Proof.", "intros a0 b H b0 x. Show Proof.", "simpl in |- *. Show Proof.", "intro. Show Proof.", "cut (dans x (singleprod a0 b0) \\/ dans x (prodcart b b0)); auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro. Show Proof.", "cut (exists y : Elt, x = couple a0 y /\\ dans y b0). Show Proof.", "2: apply dans_singleprod2; auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intros x0 H2. Show Proof.", "exists a0. Show Proof.", "exists x0. Show Proof.", "elim H2; clear H2. Show Proof.", "intros. Show Proof.", "split; auto. Show Proof.", "intro. Show Proof.", "cut Show Proof.", "(exists x1 : Elt, Show Proof.", "(exists x2 : Elt, dans x1 b /\\ dans x2 b0 /\\ x = couple x1 x2)); Show Proof.", "auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intros x0 H2; elim H2; clear H2. Show Proof.", "intros x1 H2; elim H2; clear H2. Show Proof.", "intros H2 H3; elim H3; clear H3. Show Proof.", "intros H4 H5. Show Proof.", "exists x0. Show Proof.", "exists x1. Show Proof.", "split; auto. Show Proof.", "Qed Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Rat.v", "name": "induction_star", "text": "Lemma induction_star :\n forall (P : Word -> Prop) (l : wordset),\n (forall (n : nat) (w : Word), lpuiss n l w -> P w) ->\n forall w : Word, lstar l w -> P w.\nunfold lstar in |- *.\nintros.\nelim H0; clear H0.\nintros x H0.\napply (H x w); auto.\nQed.\n", "definition": "\n forall (P : Word -> Prop) (l : wordset),\n (forall (n : nat) (w : Word), lpuiss n l w -> P w) ->\n forall w : Word, lstar l w -> P w.", "proof": "\nunfold lstar in |- *.\nintros.\nelim H0; clear H0.\nintros x H0.\napply (H x w); auto.\nQed.", "proof_term": [], "def_ranges": [72, 0, 75, 35], "proof_ranges": [76, 0, 81, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold lstar in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H0; clear H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (H x w); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold lstar in |- *. Show Proof.", "intros. Show Proof.", "elim H0; clear H0. Show Proof.", "intros x H0. Show Proof.", "apply (H x w); auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Rat.v", "name": "lw_imp_lstarlw", "text": "Lemma lw_imp_lstarlw : forall (l : wordset) (w : Word), l w -> lstar l w.\nintros.\nunfold lstar in |- *.\nexists 1.\nchange (lconc l (lpuiss 0 l) w) in |- *.\nunfold lconc in |- *.\nexists w.\nexists nil.\nsplit; [ assumption | split ]. \nunfold lpuiss in |- *.\nunfold lword in |- *; auto.\nsymmetry  in |- *.\napply Append_w_nil.\nQed.\n", "definition": " forall (l : wordset) (w : Word), l w -> lstar l w.", "proof": "\nintros.\nunfold lstar in |- *.\nexists 1.\nchange (lconc l (lpuiss 0 l) w) in |- *.\nunfold lconc in |- *.\nexists w.\nexists nil.\nsplit; [ assumption | split ]. \nunfold lpuiss in |- *.\nunfold lword in |- *; auto.\nsymmetry  in |- *.\napply Append_w_nil.\nQed.", "proof_term": [], "def_ranges": [87, 0, 87, 73], "proof_ranges": [88, 0, 100, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold lstar in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists 1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (lconc l (lpuiss 0 l) w) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold lconc in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists w.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists nil.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; [ assumption | split ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold lpuiss in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold lword in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "symmetry  in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Append_w_nil.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "unfold lstar in |- *. Show Proof.", "exists 1. Show Proof.", "change (lconc l (lpuiss 0 l) w) in |- *. Show Proof.", "unfold lconc in |- *. Show Proof.", "exists w. Show Proof.", "exists nil. Show Proof.", "split; [ assumption | split ]. Show Proof.", "unfold lpuiss in |- *. Show Proof.", "unfold lword in |- *; auto. Show Proof.", "symmetry  in |- *. Show Proof.", "apply Append_w_nil. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_types.v", "name": "nat_invol", "text": "Lemma nat_invol : forall n : nat, natural_inv (natural n) = n.\nauto.\nQed.\n", "definition": " forall n : nat, natural_inv (natural n) = n.", "proof": "\nauto.\nQed.", "proof_term": ["(fun n : nat => eq_refl)"], "def_ranges": [77, 0, 77, 62], "proof_ranges": [78, 0, 79, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": ["forall n : nat, natural_inv (natural n) = n"], "goal_after": [], "proof_term_before": [], "proof_term_after": ["(fun n : nat => eq_refl)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun n : nat => eq_refl)"], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_types.v", "name": "add_add", "text": "Lemma add_add :\n forall (a b : Elt) (c d : Ensf), a = b -> c = d -> add a c = add b d.\nintros.\nrewrite H.\nrewrite H0.\ntrivial.\nQed.\n", "definition": "\n forall (a b : Elt) (c d : Ensf), a = b -> c = d -> add a c = add b d.", "proof": "\nintros.\nrewrite H.\nrewrite H0.\ntrivial.\nQed.", "proof_term": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => add a0 c = add b d)\n   (eq_ind_r (fun c0 : Ensf => add b c0 = add b d) eq_refl H0) H)"], "def_ranges": [99, 0, 100, 70], "proof_ranges": [101, 0, 105, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": ["forall (a b : Elt) (c d : Ensf), a = b -> c = d -> add a c = add b d"], "goal_after": ["add a c = add b d"], "proof_term_before": [], "proof_term_after": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) => ?Goal)"]}, {"text": "rewrite H.", "goal_before": ["add a c = add b d"], "goal_after": ["add b c = add b d"], "proof_term_before": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) => ?Goal)"], "proof_term_after": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => add a0 c = add b d) ?Goal H)"]}, {"text": "rewrite H0.", "goal_before": ["add b c = add b d"], "goal_after": ["add b d = add b d"], "proof_term_before": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => add a0 c = add b d) ?Goal H)"], "proof_term_after": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => add a0 c = add b d)\n   (eq_ind_r (fun c0 : Ensf => add b c0 = add b d) ?Goal H0) H)"]}, {"text": "trivial.", "goal_before": ["add b d = add b d"], "goal_after": [], "proof_term_before": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => add a0 c = add b d)\n   (eq_ind_r (fun c0 : Ensf => add b c0 = add b d) ?Goal H0) H)"], "proof_term_after": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => add a0 c = add b d)\n   (eq_ind_r (fun c0 : Ensf => add b c0 = add b d) eq_refl H0) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : Elt) (c d : Ensf) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => add a0 c = add b d)\n   (eq_ind_r (fun c0 : Ensf => add b c0 = add b d) eq_refl H0) H)"], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "rewrite H. Show Proof.", "rewrite H0. Show Proof.", "trivial. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_types.v", "name": "couple_couple", "text": "Lemma couple_couple :\n forall a b c d : Elt, a = b -> c = d -> couple a c = couple b d.\nintros.\nrewrite H.\nrewrite H0.\ntrivial.\nQed.\n", "definition": "\n forall a b c d : Elt, a = b -> c = d -> couple a c = couple b d.", "proof": "\nintros.\nrewrite H.\nrewrite H0.\ntrivial.\nQed.", "proof_term": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => couple a0 c = couple b d)\n   (eq_ind_r (fun c0 : Elt => couple b c0 = couple b d) eq_refl H0) H)"], "def_ranges": [109, 0, 110, 65], "proof_ranges": [111, 0, 115, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": ["forall a b c d : Elt, a = b -> c = d -> couple a c = couple b d"], "goal_after": ["couple a c = couple b d"], "proof_term_before": [], "proof_term_after": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) => ?Goal)"]}, {"text": "rewrite H.", "goal_before": ["couple a c = couple b d"], "goal_after": ["couple b c = couple b d"], "proof_term_before": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) => ?Goal)"], "proof_term_after": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => couple a0 c = couple b d) ?Goal H)"]}, {"text": "rewrite H0.", "goal_before": ["couple b c = couple b d"], "goal_after": ["couple b d = couple b d"], "proof_term_before": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => couple a0 c = couple b d) ?Goal H)"], "proof_term_after": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => couple a0 c = couple b d)\n   (eq_ind_r (fun c0 : Elt => couple b c0 = couple b d) ?Goal H0) H)"]}, {"text": "trivial.", "goal_before": ["couple b d = couple b d"], "goal_after": [], "proof_term_before": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => couple a0 c = couple b d)\n   (eq_ind_r (fun c0 : Elt => couple b c0 = couple b d) ?Goal H0) H)"], "proof_term_after": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => couple a0 c = couple b d)\n   (eq_ind_r (fun c0 : Elt => couple b c0 = couple b d) eq_refl H0) H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b c d : Elt) (H : a = b) (H0 : c = d) =>\n eq_ind_r (fun a0 : Elt => couple a0 c = couple b d)\n   (eq_ind_r (fun c0 : Elt => couple b c0 = couple b d) eq_refl H0) H)"], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "rewrite H. Show Proof.", "rewrite H0. Show Proof.", "trivial. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_types.v", "name": "word_word", "text": "Lemma word_word : forall a b : Word, a = b -> word a = word b.\nintros.\napply (f_equal (A:=Word) (B:=Elt)); auto.\nQed.\n", "definition": " forall a b : Word, a = b -> word a = word b.", "proof": "\nintros.\napply (f_equal (A:=Word) (B:=Elt)); auto.\nQed.", "proof_term": ["(fun (a b : Word) (H : a = b) => f_equal word H)"], "def_ranges": [117, 0, 117, 62], "proof_ranges": [118, 0, 120, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": ["forall a b : Word, a = b -> word a = word b"], "goal_after": ["word a = word b"], "proof_term_before": [], "proof_term_after": ["(fun (a b : Word) (H : a = b) => ?Goal)"]}, {"text": "apply (f_equal (A:=Word) (B:=Elt)); auto.", "goal_before": ["word a = word b"], "goal_after": [], "proof_term_before": ["(fun (a b : Word) (H : a = b) => ?Goal)"], "proof_term_after": ["(fun (a b : Word) (H : a = b) => f_equal word H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : Word) (H : a = b) => f_equal word H)"], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "apply (f_equal (A:=Word) (B:=Elt)); auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_types.v", "name": "word_word_inv", "text": "Lemma word_word_inv : forall a b : Word, word a = word b -> a = b.\nintros a b H.\ninjection H.\ntrivial.\nQed.\n", "definition": " forall a b : Word, word a = word b -> a = b.", "proof": "\nintros a b H.\ninjection H.\ntrivial.\nQed.", "proof_term": ["(fun (a b : Word) (H : word a = word b) =>\n let H0 : a = b :=\n   f_equal (fun e : Elt => match e with\n                           | word w => w\n                           | _ => a\n                           end) H in\n (fun H1 : a = b => H1) H0)"], "def_ranges": [123, 0, 123, 66], "proof_ranges": [124, 0, 127, 4], "only_proof_term": false, "proof_steps": [{"text": "intros a b H.", "goal_before": ["forall a b : Word, word a = word b -> a = b"], "goal_after": ["a = b"], "proof_term_before": [], "proof_term_after": ["(fun (a b : Word) (H : word a = word b) => ?Goal)"]}, {"text": "injection H.", "goal_before": ["a = b"], "goal_after": ["a = b -> a = b"], "proof_term_before": ["(fun (a b : Word) (H : word a = word b) => ?Goal)"], "proof_term_after": ["(fun (a b : Word) (H : word a = word b) =>\n let H0 : a = b :=\n   f_equal (fun e : Elt => match e with\n                           | word w => w\n                           | _ => a\n                           end) H in\n ?Goal H0)"]}, {"text": "trivial.", "goal_before": ["a = b -> a = b"], "goal_after": [], "proof_term_before": ["(fun (a b : Word) (H : word a = word b) =>\n let H0 : a = b :=\n   f_equal (fun e : Elt => match e with\n                           | word w => w\n                           | _ => a\n                           end) H in\n ?Goal H0)"], "proof_term_after": ["(fun (a b : Word) (H : word a = word b) =>\n let H0 : a = b :=\n   f_equal (fun e : Elt => match e with\n                           | word w => w\n                           | _ => a\n                           end) H in\n (fun H1 : a = b => H1) H0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (a b : Word) (H : word a = word b) =>\n let H0 : a = b :=\n   f_equal (fun e : Elt => match e with\n                           | word w => w\n                           | _ => a\n                           end) H in\n (fun H1 : a = b => H1) H0)"], "proof_term_after": []}], "augmented_proof": ["intros a b H. Show Proof.", "injection H. Show Proof.", "trivial. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_types.v", "name": "False_imp_P", "text": "Lemma False_imp_P : forall P : Prop, False -> P.\nintros.\nelimtype False.\nassumption.\nQed.\n", "definition": " forall P : Prop, False -> P.", "proof": "\nintros.\nelimtype False.\nassumption.\nQed.", "proof_term": ["(fun (P : Prop) (H : False) => False_ind P H)"], "def_ranges": [137, 0, 137, 48], "proof_ranges": [138, 0, 141, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": ["forall P : Prop, False -> P"], "goal_after": ["P"], "proof_term_before": [], "proof_term_after": ["(fun (P : Prop) (H : False) => ?Goal)"]}, {"text": "elimtype False.", "goal_before": ["P"], "goal_after": ["False"], "proof_term_before": ["(fun (P : Prop) (H : False) => ?Goal)"], "proof_term_after": ["(fun (P : Prop) (H : False) => False_ind P ?Goal)"]}, {"text": "assumption.", "goal_before": ["False"], "goal_after": [], "proof_term_before": ["(fun (P : Prop) (H : False) => False_ind P ?Goal)"], "proof_term_after": ["(fun (P : Prop) (H : False) => False_ind P H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (P : Prop) (H : False) => False_ind P H)"], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "elimtype False. Show Proof.", "assumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_types.v", "name": "equal_add", "text": "Lemma equal_add : forall (a b : Ensf) (e : Elt), a = b -> add e a = add e b.\nintros.\napply (f_equal (A:=Ensf) (B:=Ensf)); auto.\nQed.", "definition": " forall (a b : Ensf) (e : Elt), a = b -> add e a = add e b.", "proof": "\nintros.\napply (f_equal (A:=Ensf) (B:=Ensf)); auto.\nQed", "proof_term": ["(fun (a b : Ensf) (e : Elt) (H : a = b) => f_equal (add e) H)"], "def_ranges": [143, 0, 143, 76], "proof_ranges": [144, 0, 146, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": ["forall (a b : Ensf) (e : Elt), a = b -> add e a = add e b"], "goal_after": ["add e a = add e b"], "proof_term_before": [], "proof_term_after": ["(fun (a b : Ensf) (e : Elt) (H : a = b) => ?Goal)"]}, {"text": "apply (f_equal (A:=Ensf) (B:=Ensf)); auto.", "goal_before": ["add e a = add e b"], "goal_after": [], "proof_term_before": ["(fun (a b : Ensf) (e : Elt) (H : a = b) => ?Goal)"], "proof_term_after": ["(fun (a b : Ensf) (e : Elt) (H : a = b) => f_equal (add e) H)"]}], "augmented_proof": ["intros. Show Proof.", "apply (f_equal (A:=Ensf) (B:=Ensf)); auto. Show Proof.", "Qed Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Max.v", "name": "sup_add", "text": "Lemma sup_add :\n forall (x : Elt) (e : Ensf), sup (add x e) = max (Z x) (sup e) :>nat.\nintros x.\nsimple induction e; auto.\nQed.\n", "definition": "\n forall (x : Elt) (e : Ensf), sup (add x e) = max (Z x) (sup e) :>nat.", "proof": "\nintros x.\nsimple induction e; auto.\nQed.", "proof_term": [], "def_ranges": [83, 0, 84, 70], "proof_ranges": [85, 0, 87, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction e; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x. Show Proof.", "simple induction e; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Max.v", "name": "elt_not_sym", "text": "Lemma elt_not_sym : forall a b : Elt, a <> b :>Elt -> b <> a :>Elt.\nauto.\nQed.\n", "definition": " forall a b : Elt, a <> b :>Elt -> b <> a :>Elt.", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [118, 0, 118, 67], "proof_ranges": [119, 0, 120, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Max.v", "name": "lt_n_Z", "text": "Lemma lt_n_Z : forall n : nat, n < Z (natural n).\nintro.\nreplace (Z (natural n)) with (S n); auto.\nQed.\n", "definition": " forall n : nat, n < Z (natural n).", "proof": "\nintro.\nreplace (Z (natural n)) with (S n); auto.\nQed.", "proof_term": [], "def_ranges": [124, 0, 124, 49], "proof_ranges": [125, 0, 127, 4], "only_proof_term": false, "proof_steps": [{"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (Z (natural n)) with (S n); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intro. Show Proof.", "replace (Z (natural n)) with (S n); auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Max.v", "name": "lt_n_sup", "text": "Lemma lt_n_sup : forall (x : Ensf) (n : nat), dans (natural n) x -> n < sup x.\nsimple induction x.\nintros.\nabsurd (dans (natural n) empty); auto.\nintros a b H n H0.\nreplace (sup (add a b)) with (max (Z a) (sup b)).\n2: auto.\ncut (n < Z a \\/ n < sup b).\nintro.\nelim H1; auto.\nintros; apply lt_le_trans with (Z a); auto with arith.\nintros; apply lt_le_trans with (sup b); auto with arith.\ncut (a = natural n :>Elt \\/ dans (natural n) b).\n2: apply dans_add; auto.\nintro.\nelim H1.\nintro; left.\nrewrite H2; apply lt_n_Z.\nintro; right.\napply H; assumption.\nQed.\n", "definition": " forall (x : Ensf) (n : nat), dans (natural n) x -> n < sup x.", "proof": "\nsimple induction x.\nintros.\nabsurd (dans (natural n) empty); auto.\nintros a b H n H0.\nreplace (sup (add a b)) with (max (Z a) (sup b)).\n2: auto.\ncut (n < Z a \\/ n < sup b).\nintro.\nelim H1; auto.\nintros; apply lt_le_trans with (Z a); auto with arith.\nintros; apply lt_le_trans with (sup b); auto with arith.\ncut (a = natural n :>Elt \\/ dans (natural n) b).\n2: apply dans_add; auto.\nintro.\nelim H1.\nintro; left.\nrewrite H2; apply lt_n_Z.\nintro; right.\napply H; assumption.\nQed.", "proof_term": [], "def_ranges": [134, 0, 134, 78], "proof_ranges": [135, 0, 154, 4], "only_proof_term": false, "proof_steps": [{"text": "simple induction x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "absurd (dans (natural n) empty); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b H n H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (sup (add a b)) with (max (Z a) (sup b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (n < Z a \\/ n < sup b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; apply lt_le_trans with (Z a); auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros; apply lt_le_trans with (sup b); auto with arith.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a = natural n :>Elt \\/ dans (natural n) b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; left.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H2; apply lt_n_Z.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; right.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["simple induction x. Show Proof.", "intros. Show Proof.", "absurd (dans (natural n) empty); auto. Show Proof.", "intros a b H n H0. Show Proof.", "replace (sup (add a b)) with (max (Z a) (sup b)). Show Proof.", "2: auto. Show Proof.", "cut (n < Z a \\/ n < sup b). Show Proof.", "intro. Show Proof.", "elim H1; auto. Show Proof.", "intros; apply lt_le_trans with (Z a); auto with arith. Show Proof.", "intros; apply lt_le_trans with (sup b); auto with arith. Show Proof.", "cut (a = natural n :>Elt \\/ dans (natural n) b). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro. Show Proof.", "elim H1. Show Proof.", "intro; left. Show Proof.", "rewrite H2; apply lt_n_Z. Show Proof.", "intro; right. Show Proof.", "apply H; assumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Max.v", "name": "sup_out", "text": "Lemma sup_out : forall x : Ensf, ~ dans (natural (sup x)) x.\nintro.\nred in |- *.\nintro.\ncut (sup x < sup x).\nchange (~ sup x < sup x) in |- *.\napply lt_irrefl.\napply lt_n_sup.\nassumption.\nQed.\n", "definition": " forall x : Ensf, ~ dans (natural (sup x)) x.", "proof": "\nintro.\nred in |- *.\nintro.\ncut (sup x < sup x).\nchange (~ sup x < sup x) in |- *.\napply lt_irrefl.\napply lt_n_sup.\nassumption.\nQed.", "proof_term": [], "def_ranges": [160, 0, 160, 60], "proof_ranges": [161, 0, 169, 4], "only_proof_term": false, "proof_steps": [{"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (sup x < sup x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (~ sup x < sup x) in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply lt_irrefl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply lt_n_sup.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intro. Show Proof.", "red in |- *. Show Proof.", "intro. Show Proof.", "cut (sup x < sup x). Show Proof.", "change (~ sup x < sup x) in |- *. Show Proof.", "apply lt_irrefl. Show Proof.", "apply lt_n_sup. Show Proof.", "assumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Max.v", "name": "exist_other", "text": "Lemma exist_other : forall e : Ensf, exists x : Elt, ~ dans x e.\nintro.\nexists (natural (sup e)).\napply sup_out.\nQed.", "definition": " forall e : Ensf, exists x : Elt, ~ dans x e.", "proof": "\nintro.\nexists (natural (sup e)).\napply sup_out.\nQed", "proof_term": [], "def_ranges": [177, 0, 177, 64], "proof_ranges": [178, 0, 181, 4], "only_proof_term": false, "proof_steps": [{"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (natural (sup e)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sup_out.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intro. Show Proof.", "exists (natural (sup e)). Show Proof.", "apply sup_out. Show Proof.", "Qed Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_disj.v", "name": "dans_map_injg", "text": "Lemma dans_map_injg :\n forall (e : Ensf) (x : Elt), dans x (map injgauche e) -> dans (first x) e.\nintros.\ncut (exists y : Elt, dans y e /\\ x = injgauche y).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht.\nintros.  \nunfold injgauche in H1.\nreplace (first x) with y; auto.\nsymmetry  in |- *.\nreplace y with (first (couple y zero)); auto.\napply (f_equal (A:=Elt) (B:=Elt)); auto.\nQed.\n", "definition": "\n forall (e : Ensf) (x : Elt), dans x (map injgauche e) -> dans (first x) e.", "proof": "\nintros.\ncut (exists y : Elt, dans y e /\\ x = injgauche y).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht.\nintros.  \nunfold injgauche in H1.\nreplace (first x) with y; auto.\nsymmetry  in |- *.\nreplace y with (first (couple y zero)); auto.\napply (f_equal (A:=Elt) (B:=Elt)); auto.\nQed.", "proof_term": [], "def_ranges": [65, 0, 66, 75], "proof_ranges": [67, 0, 78, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, dans y e /\\ x = injgauche y).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold injgauche in H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (first x) with y; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "symmetry  in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace y with (first (couple y zero)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (f_equal (A:=Elt) (B:=Elt)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "cut (exists y : Elt, dans y e /\\ x = injgauche y). Show Proof.", "2: apply dans_map; auto. Show Proof.", "intro Ht; elim Ht; clear Ht. Show Proof.", "intros y Ht; elim Ht; clear Ht. Show Proof.", "intros. Show Proof.", "unfold injgauche in H1. Show Proof.", "replace (first x) with y; auto. Show Proof.", "symmetry  in |- *. Show Proof.", "replace y with (first (couple y zero)); auto. Show Proof.", "apply (f_equal (A:=Elt) (B:=Elt)); auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_disj.v", "name": "dans_map_injd", "text": "Lemma dans_map_injd :\n forall (e : Ensf) (x : Elt), dans x (map injdroite e) -> dans (first x) e.\nintros.\ncut (exists y : Elt, dans y e /\\ x = injdroite y).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht.\nintros.  \nunfold injdroite in H1.\nreplace (first x) with y; auto.\nsymmetry  in |- *.\nreplace y with (first (couple y un)); auto.\napply (f_equal (A:=Elt) (B:=Elt)); auto.\nQed.\n", "definition": "\n forall (e : Ensf) (x : Elt), dans x (map injdroite e) -> dans (first x) e.", "proof": "\nintros.\ncut (exists y : Elt, dans y e /\\ x = injdroite y).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht.\nintros.  \nunfold injdroite in H1.\nreplace (first x) with y; auto.\nsymmetry  in |- *.\nreplace y with (first (couple y un)); auto.\napply (f_equal (A:=Elt) (B:=Elt)); auto.\nQed.", "proof_term": [], "def_ranges": [80, 0, 81, 75], "proof_ranges": [82, 0, 93, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, dans y e /\\ x = injdroite y).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold injdroite in H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (first x) with y; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "symmetry  in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace y with (first (couple y un)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (f_equal (A:=Elt) (B:=Elt)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "cut (exists y : Elt, dans y e /\\ x = injdroite y). Show Proof.", "2: apply dans_map; auto. Show Proof.", "intro Ht; elim Ht; clear Ht. Show Proof.", "intros y Ht; elim Ht; clear Ht. Show Proof.", "intros. Show Proof.", "unfold injdroite in H1. Show Proof.", "replace (first x) with y; auto. Show Proof.", "symmetry  in |- *. Show Proof.", "replace y with (first (couple y un)); auto. Show Proof.", "apply (f_equal (A:=Elt) (B:=Elt)); auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_disj.v", "name": "absurd_injg_injd", "text": "Lemma absurd_injg_injd :\n forall (x : Elt) (e f : Ensf),\n dans x (map injgauche e) -> ~ dans x (map injdroite f).\nintros.\ncut (exists y : Elt, dans y e /\\ x = injgauche y).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht.\nintros.  \nred in |- *.\nintro.\ncut (exists y' : Elt, dans y' f /\\ x = injdroite y' :>Elt).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y' Ht; elim Ht; clear Ht.\nintros.  \nabsurd (zero = un :>Elt).\nunfold zero in |- *.\nunfold un in |- *.\ndiscriminate.\n\nunfold injdroite in H4.\nunfold injgauche in H1.\nreplace zero with (second (couple y zero)); auto.\nreplace un with (second (couple y' un)); auto.\nrewrite <- H4.\nrewrite <- H1.\nauto.\nQed.\n", "definition": "\n forall (x : Elt) (e f : Ensf),\n dans x (map injgauche e) -> ~ dans x (map injdroite f).", "proof": "\nintros.\ncut (exists y : Elt, dans y e /\\ x = injgauche y).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht.\nintros.  \nred in |- *.\nintro.\ncut (exists y' : Elt, dans y' f /\\ x = injdroite y' :>Elt).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y' Ht; elim Ht; clear Ht.\nintros.  \nabsurd (zero = un :>Elt).\nunfold zero in |- *.\nunfold un in |- *.\ndiscriminate.\n\nunfold injdroite in H4.\nunfold injgauche in H1.\nreplace zero with (second (couple y zero)); auto.\nreplace un with (second (couple y' un)); auto.\nrewrite <- H4.\nrewrite <- H1.\nauto.\nQed.", "proof_term": [], "def_ranges": [95, 0, 97, 56], "proof_ranges": [98, 0, 123, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, dans y e /\\ x = injgauche y).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y' : Elt, dans y' f /\\ x = injdroite y' :>Elt).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y' Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "absurd (zero = un :>Elt).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold zero in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold un in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "discriminate.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold injdroite in H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold injgauche in H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace zero with (second (couple y zero)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace un with (second (couple y' un)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "cut (exists y : Elt, dans y e /\\ x = injgauche y). Show Proof.", "2: apply dans_map; auto. Show Proof.", "intro Ht; elim Ht; clear Ht. Show Proof.", "intros y Ht; elim Ht; clear Ht. Show Proof.", "intros. Show Proof.", "red in |- *. Show Proof.", "intro. Show Proof.", "cut (exists y' : Elt, dans y' f /\\ x = injdroite y' :>Elt). Show Proof.", "2: apply dans_map; auto. Show Proof.", "intro Ht; elim Ht; clear Ht. Show Proof.", "intros y' Ht; elim Ht; clear Ht. Show Proof.", "intros. Show Proof.", "absurd (zero = un :>Elt). Show Proof.", "unfold zero in |- *. Show Proof.", "unfold un in |- *. Show Proof.", "discriminate. Show Proof.", "unfold injdroite in H4. Show Proof.", "unfold injgauche in H1. Show Proof.", "replace zero with (second (couple y zero)); auto. Show Proof.", "replace un with (second (couple y' un)); auto. Show Proof.", "rewrite <- H4. Show Proof.", "rewrite <- H1. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_disj.v", "name": "union_disj1", "text": "Lemma union_disj1 :\n forall (x : Elt) (a b : Ensf),\n dans x (union_disj a b) ->\n (exists y : Elt, dans y a /\\ x = injgauche y :>Elt) \\/\n (exists y : Elt, dans y b /\\ x = injdroite y :>Elt).\nunfold union_disj in |- *.\nintros.\ncut (dans x (map injgauche a) \\/ dans x (map injdroite b)).\n2: auto.\nintro H0; elim H0; clear H0.\nintro; left.\napply dans_map; auto.\nintro; right.\napply dans_map; auto.\nQed.\n", "definition": "\n forall (x : Elt) (a b : Ensf),\n dans x (union_disj a b) ->\n (exists y : Elt, dans y a /\\ x = injgauche y :>Elt) \\/\n (exists y : Elt, dans y b /\\ x = injdroite y :>Elt).", "proof": "\nunfold union_disj in |- *.\nintros.\ncut (dans x (map injgauche a) \\/ dans x (map injdroite b)).\n2: auto.\nintro H0; elim H0; clear H0.\nintro; left.\napply dans_map; auto.\nintro; right.\napply dans_map; auto.\nQed.", "proof_term": [], "def_ranges": [131, 0, 135, 53], "proof_ranges": [136, 0, 145, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold union_disj in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x (map injgauche a) \\/ dans x (map injdroite b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H0; elim H0; clear H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; left.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; right.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold union_disj in |- *. Show Proof.", "intros. Show Proof.", "cut (dans x (map injgauche a) \\/ dans x (map injdroite b)). Show Proof.", "2: auto. Show Proof.", "intro H0; elim H0; clear H0. Show Proof.", "intro; left. Show Proof.", "apply dans_map; auto. Show Proof.", "intro; right. Show Proof.", "apply dans_map; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_disj.v", "name": "union_disj_d", "text": "Lemma union_disj_d :\n forall (x : Elt) (a b : Ensf),\n dans x b -> dans (injdroite x) (union_disj a b).\nintros.\nunfold union_disj in |- *.\napply union_d.\napply dans_map_inv.\nauto.\nQed.\n", "definition": "\n forall (x : Elt) (a b : Ensf),\n dans x b -> dans (injdroite x) (union_disj a b).", "proof": "\nintros.\nunfold union_disj in |- *.\napply union_d.\napply dans_map_inv.\nauto.\nQed.", "proof_term": [], "def_ranges": [147, 0, 149, 49], "proof_ranges": [150, 0, 155, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold union_disj in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply union_d.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_map_inv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "unfold union_disj in |- *. Show Proof.", "apply union_d. Show Proof.", "apply dans_map_inv. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_disj.v", "name": "union_disj_g", "text": "Lemma union_disj_g :\n forall (x : Elt) (a b : Ensf),\n dans x a -> dans (injgauche x) (union_disj a b).\nintros.\nunfold union_disj in |- *.\napply union_g.\napply dans_map_inv.\nauto.\nQed.\n", "definition": "\n forall (x : Elt) (a b : Ensf),\n dans x a -> dans (injgauche x) (union_disj a b).", "proof": "\nintros.\nunfold union_disj in |- *.\napply union_g.\napply dans_map_inv.\nauto.\nQed.", "proof_term": [], "def_ranges": [157, 0, 159, 49], "proof_ranges": [160, 0, 165, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold union_disj in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply union_g.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_map_inv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "unfold union_disj in |- *. Show Proof.", "apply union_g. Show Proof.", "apply dans_map_inv. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_disj.v", "name": "inclus_union_disj", "text": "Lemma inclus_union_disj :\n forall a b c d : Ensf,\n inclus a c -> inclus b d -> inclus (union_disj a b) (union_disj c d).\nunfold inclus in |- *.\nintros.\nunfold union_disj in H1.\ncut (dans x (map injgauche a) \\/ dans x (map injdroite b)); auto.\nintro Ht; elim Ht; clear Ht.\n\nintro.\ncut (exists y : Elt, dans y a /\\ x = injgauche y).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht; intros H3 H4.\ncut (dans y c); auto.\nintro.\nunfold union_disj in |- *.\napply union_g.\nrewrite H4.\napply dans_map_inv; auto.\n\nintro.\ncut (exists y : Elt, dans y b /\\ x = injdroite y :>Elt).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht; intros H3 H4.\ncut (dans y d); auto.\nintro.\nunfold union_disj in |- *.\napply union_d.\nrewrite H4.\napply dans_map_inv; auto.\nQed.\n", "definition": "\n forall a b c d : Ensf,\n inclus a c -> inclus b d -> inclus (union_disj a b) (union_disj c d).", "proof": "\nunfold inclus in |- *.\nintros.\nunfold union_disj in H1.\ncut (dans x (map injgauche a) \\/ dans x (map injdroite b)); auto.\nintro Ht; elim Ht; clear Ht.\n\nintro.\ncut (exists y : Elt, dans y a /\\ x = injgauche y).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht; intros H3 H4.\ncut (dans y c); auto.\nintro.\nunfold union_disj in |- *.\napply union_g.\nrewrite H4.\napply dans_map_inv; auto.\n\nintro.\ncut (exists y : Elt, dans y b /\\ x = injdroite y :>Elt).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht; intros H3 H4.\ncut (dans y d); auto.\nintro.\nunfold union_disj in |- *.\napply union_d.\nrewrite H4.\napply dans_map_inv; auto.\nQed.", "proof_term": [], "def_ranges": [167, 0, 169, 70], "proof_ranges": [170, 0, 199, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold union_disj in H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x (map injgauche a) \\/ dans x (map injdroite b)); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, dans y a /\\ x = injgauche y).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y Ht; elim Ht; clear Ht; intros H3 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans y c); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold union_disj in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply union_g.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_map_inv; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, dans y b /\\ x = injdroite y :>Elt).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y Ht; elim Ht; clear Ht; intros H3 H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans y d); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold union_disj in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply union_d.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H4.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_map_inv; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inclus in |- *. Show Proof.", "intros. Show Proof.", "unfold union_disj in H1. Show Proof.", "cut (dans x (map injgauche a) \\/ dans x (map injdroite b)); auto. Show Proof.", "intro Ht; elim Ht; clear Ht. Show Proof.", "intro. Show Proof.", "cut (exists y : Elt, dans y a /\\ x = injgauche y). Show Proof.", "2: apply dans_map; auto. Show Proof.", "intro Ht; elim Ht; clear Ht. Show Proof.", "intros y Ht; elim Ht; clear Ht; intros H3 H4. Show Proof.", "cut (dans y c); auto. Show Proof.", "intro. Show Proof.", "unfold union_disj in |- *. Show Proof.", "apply union_g. Show Proof.", "rewrite H4. Show Proof.", "apply dans_map_inv; auto. Show Proof.", "intro. Show Proof.", "cut (exists y : Elt, dans y b /\\ x = injdroite y :>Elt). Show Proof.", "2: apply dans_map; auto. Show Proof.", "intro Ht; elim Ht; clear Ht. Show Proof.", "intros y Ht; elim Ht; clear Ht; intros H3 H4. Show Proof.", "cut (dans y d); auto. Show Proof.", "intro. Show Proof.", "unfold union_disj in |- *. Show Proof.", "apply union_d. Show Proof.", "rewrite H4. Show Proof.", "apply dans_map_inv; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_disj.v", "name": "pair_equal", "text": "Lemma pair_equal :\n forall (A B : Set) (x x' : A) (y y' : B),\n x = x' :>A -> y = y' :>B -> pair x y = pair x' y' :>A * B.\nintros A B x x' y y' X Y.\nrewrite X.\nrewrite Y.\napply refl_equal.\nQed.\n", "definition": "\n forall (A B : Set) (x x' : A) (y y' : B),\n x = x' :>A -> y = y' :>B -> pair x y = pair x' y' :>A * B.", "proof": "\nintros A B x x' y y' X Y.\nrewrite X.\nrewrite Y.\napply refl_equal.\nQed.", "proof_term": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') =>\n eq_ind_r (fun x0 : A => (x0, y) = (x', y'))\n   (eq_ind_r (fun y0 : B => (x', y0) = (x', y')) eq_refl Y) X)"], "def_ranges": [206, 0, 208, 59], "proof_ranges": [209, 0, 213, 4], "only_proof_term": false, "proof_steps": [{"text": "intros A B x x' y y' X Y.", "goal_before": ["forall (A B : Set) (x x' : A) (y y' : B),\nx = x' -> y = y' -> (x, y) = (x', y')"], "goal_after": ["(x, y) = (x', y')"], "proof_term_before": [], "proof_term_after": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') => ?Goal)"]}, {"text": "rewrite X.", "goal_before": ["(x, y) = (x', y')"], "goal_after": ["(x', y) = (x', y')"], "proof_term_before": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') => ?Goal)"], "proof_term_after": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') =>\n eq_ind_r (fun x0 : A => (x0, y) = (x', y')) ?Goal X)"]}, {"text": "rewrite Y.", "goal_before": ["(x', y) = (x', y')"], "goal_after": ["(x', y') = (x', y')"], "proof_term_before": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') =>\n eq_ind_r (fun x0 : A => (x0, y) = (x', y')) ?Goal X)"], "proof_term_after": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') =>\n eq_ind_r (fun x0 : A => (x0, y) = (x', y'))\n   (eq_ind_r (fun y0 : B => (x', y0) = (x', y')) ?Goal Y) X)"]}, {"text": "apply refl_equal.", "goal_before": ["(x', y') = (x', y')"], "goal_after": [], "proof_term_before": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') =>\n eq_ind_r (fun x0 : A => (x0, y) = (x', y'))\n   (eq_ind_r (fun y0 : B => (x', y0) = (x', y')) ?Goal Y) X)"], "proof_term_after": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') =>\n eq_ind_r (fun x0 : A => (x0, y) = (x', y'))\n   (eq_ind_r (fun y0 : B => (x', y0) = (x', y')) eq_refl Y) X)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B : Set) (x x' : A) (y y' : B) (X : x = x') (Y : y = y') =>\n eq_ind_r (fun x0 : A => (x0, y) = (x', y'))\n   (eq_ind_r (fun y0 : B => (x', y0) = (x', y')) eq_refl Y) X)"], "proof_term_after": []}], "augmented_proof": ["intros A B x x' y y' X Y. Show Proof.", "rewrite X. Show Proof.", "rewrite Y. Show Proof.", "apply refl_equal. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_map.v", "name": "dans_map", "text": "Lemma dans_map :\n forall (f : Elt -> Elt) (a : Ensf) (x : Elt),\n dans x (map f a) -> exists y : Elt, dans y a /\\ x = f y.\nintros f.\nsimple induction a.\nsimpl in |- *.\nintros x H.\nabsurd (dans x empty); auto.\n\nintros a0 b H x.\nsimpl in |- *.\nintro.\ncut (f a0 = x :>Elt \\/ dans x (map f b)).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro; exists a0; auto.\nintro.\ncut (exists y : Elt, dans y b /\\ x = f y).\nintro H2; elim H2; clear H2.\n2: auto.\nintros x0 H2; elim H2; clear H2.\nintros.\nexists x0.\nsplit; auto.\nQed.\n", "definition": "\n forall (f : Elt -> Elt) (a : Ensf) (x : Elt),\n dans x (map f a) -> exists y : Elt, dans y a /\\ x = f y.", "proof": "\nintros f.\nsimple induction a.\nsimpl in |- *.\nintros x H.\nabsurd (dans x empty); auto.\n\nintros a0 b H x.\nsimpl in |- *.\nintro.\ncut (f a0 = x :>Elt \\/ dans x (map f b)).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro; exists a0; auto.\nintro.\ncut (exists y : Elt, dans y b /\\ x = f y).\nintro H2; elim H2; clear H2.\n2: auto.\nintros x0 H2; elim H2; clear H2.\nintros.\nexists x0.\nsplit; auto.\nQed.", "proof_term": [], "def_ranges": [64, 0, 66, 57], "proof_ranges": [67, 0, 88, 4], "only_proof_term": false, "proof_steps": [{"text": "intros f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "absurd (dans x empty); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (f a0 = x :>Elt \\/ dans x (map f b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; exists a0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, dans y b /\\ x = f y).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x0 H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros f. Show Proof.", "simple induction a. Show Proof.", "simpl in |- *. Show Proof.", "intros x H. Show Proof.", "absurd (dans x empty); auto. Show Proof.", "intros a0 b H x. Show Proof.", "simpl in |- *. Show Proof.", "intro. Show Proof.", "cut (f a0 = x :>Elt \\/ dans x (map f b)). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro; exists a0; auto. Show Proof.", "intro. Show Proof.", "cut (exists y : Elt, dans y b /\\ x = f y). Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "2: auto. Show Proof.", "intros x0 H2; elim H2; clear H2. Show Proof.", "intros. Show Proof.", "exists x0. Show Proof.", "split; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_map.v", "name": "dans_map_inv", "text": "Lemma dans_map_inv :\n forall (f : Elt -> Elt) (x : Elt) (a : Ensf),\n dans x a -> dans (f x) (map f a).\nintros f x.\nsimple induction a.\nintro.\napply (dans_empty_imp_P x); auto.\n\nintros a0 b H.\nsimpl in |- *.\nintro H1.\ncut (a0 = x :>Elt \\/ dans x b).\n2: apply dans_add; auto.\nintro H2; elim H2; clear H2.\nintro.\nrewrite H0; auto.\nauto.\nQed.\n", "definition": "\n forall (f : Elt -> Elt) (x : Elt) (a : Ensf),\n dans x a -> dans (f x) (map f a).", "proof": "\nintros f x.\nsimple induction a.\nintro.\napply (dans_empty_imp_P x); auto.\n\nintros a0 b H.\nsimpl in |- *.\nintro H1.\ncut (a0 = x :>Elt \\/ dans x b).\n2: apply dans_add; auto.\nintro H2; elim H2; clear H2.\nintro.\nrewrite H0; auto.\nauto.\nQed.", "proof_term": [], "def_ranges": [91, 0, 93, 34], "proof_ranges": [94, 0, 108, 4], "only_proof_term": false, "proof_steps": [{"text": "intros f x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a0 = x :>Elt \\/ dans x b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; clear H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros f x. Show Proof.", "simple induction a. Show Proof.", "intro. Show Proof.", "apply (dans_empty_imp_P x); auto. Show Proof.", "intros a0 b H. Show Proof.", "simpl in |- *. Show Proof.", "intro H1. Show Proof.", "cut (a0 = x :>Elt \\/ dans x b). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H2; elim H2; clear H2. Show Proof.", "intro. Show Proof.", "rewrite H0; auto. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_map.v", "name": "map_union", "text": "Lemma map_union :\n forall (f : Elt -> Elt) (a b : Ensf),\n union (map f a) (map f b) = map f (union a b) :>Ensf.\nintro f.\nsimple induction a; simpl in |- *; auto.\nQed.\n", "definition": "\n forall (f : Elt -> Elt) (a b : Ensf),\n union (map f a) (map f b) = map f (union a b) :>Ensf.", "proof": "\nintro f.\nsimple induction a; simpl in |- *; auto.\nQed.", "proof_term": [], "def_ranges": [111, 0, 113, 54], "proof_ranges": [114, 0, 116, 4], "only_proof_term": false, "proof_steps": [{"text": "intro f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intro f. Show Proof.", "simple induction a; simpl in |- *; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_map.v", "name": "dans_map_trans", "text": "Lemma dans_map_trans :\n forall (x : Elt) (f : Elt -> Elt) (a b : Ensf),\n dans x (map f a) -> inclus a b -> dans x (map f b).\nintros.\ncut (exists y : Elt, dans y a /\\ x = f y :>Elt).\n2: apply dans_map; auto. \nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht.\nintros.\ncut (dans y b).\n2: apply dans_trans with a; auto.\nintro.\nrewrite H2.\napply dans_map_inv; auto.\nQed.\n", "definition": "\n forall (x : Elt) (f : Elt -> Elt) (a b : Ensf),\n dans x (map f a) -> inclus a b -> dans x (map f b).", "proof": "\nintros.\ncut (exists y : Elt, dans y a /\\ x = f y :>Elt).\n2: apply dans_map; auto. \nintro Ht; elim Ht; clear Ht.\nintros y Ht; elim Ht; clear Ht.\nintros.\ncut (dans y b).\n2: apply dans_trans with a; auto.\nintro.\nrewrite H2.\napply dans_map_inv; auto.\nQed.", "proof_term": [], "def_ranges": [119, 0, 121, 52], "proof_ranges": [122, 0, 133, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, dans y a /\\ x = f y :>Elt).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros y Ht; elim Ht; clear Ht.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans y b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_trans with a; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_map_inv; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "cut (exists y : Elt, dans y a /\\ x = f y :>Elt). Show Proof.", "2: apply dans_map; auto. Show Proof.", "intro Ht; elim Ht; clear Ht. Show Proof.", "intros y Ht; elim Ht; clear Ht. Show Proof.", "intros. Show Proof.", "cut (dans y b). Show Proof.", "2: apply dans_trans with a; auto. Show Proof.", "intro. Show Proof.", "rewrite H2. Show Proof.", "apply dans_map_inv; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_map.v", "name": "map_egal", "text": "Lemma map_egal :\n forall (f g : Elt -> Elt) (E : Ensf),\n (forall x : Elt, dans x E -> f x = g x :>Elt) -> map f E = map g E :>Ensf.\nintros f g.\nsimple induction E; simpl in |- *; auto.\nQed.\n", "definition": "\n forall (f g : Elt -> Elt) (E : Ensf),\n (forall x : Elt, dans x E -> f x = g x :>Elt) -> map f E = map g E :>Ensf.", "proof": "\nintros f g.\nsimple induction E; simpl in |- *; auto.\nQed.", "proof_term": [], "def_ranges": [135, 0, 137, 75], "proof_ranges": [138, 0, 140, 4], "only_proof_term": false, "proof_steps": [{"text": "intros f g.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction E; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros f g. Show Proof.", "simple induction E; simpl in |- *; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_map.v", "name": "map_inclus", "text": "Lemma map_inclus :\n forall (a b : Ensf) (f : Elt -> Elt),\n inclus a b -> inclus (map f a) (map f b).\nunfold inclus in |- *.\nintros.\ncut (exists y : Elt, dans y a /\\ x = f y :>Elt).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht; intros y Ht; elim Ht; clear Ht; intros.\ncut (dans y b); auto.\nintro.\nreplace x with (f y); auto.\nQed.", "definition": "\n forall (a b : Ensf) (f : Elt -> Elt),\n inclus a b -> inclus (map f a) (map f b).", "proof": "\nunfold inclus in |- *.\nintros.\ncut (exists y : Elt, dans y a /\\ x = f y :>Elt).\n2: apply dans_map; auto.\nintro Ht; elim Ht; clear Ht; intros y Ht; elim Ht; clear Ht; intros.\ncut (dans y b); auto.\nintro.\nreplace x with (f y); auto.\nQed", "proof_term": [], "def_ranges": [142, 0, 144, 42], "proof_ranges": [145, 0, 153, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (exists y : Elt, dans y a /\\ x = f y :>Elt).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_map; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Ht; elim Ht; clear Ht; intros y Ht; elim Ht; clear Ht; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans y b); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace x with (f y); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inclus in |- *. Show Proof.", "intros. Show Proof.", "cut (exists y : Elt, dans y a /\\ x = f y :>Elt). Show Proof.", "2: apply dans_map; auto. Show Proof.", "intro Ht; elim Ht; clear Ht; intros y Ht; elim Ht; clear Ht; intros. Show Proof.", "cut (dans y b); auto. Show Proof.", "intro. Show Proof.", "replace x with (f y); auto. Show Proof.", "Qed Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/more_words.v", "name": "refl_l_inclus", "text": "Lemma refl_l_inclus : forall l1 : wordset, l_inclus l1 l1.\nauto.\nQed.\n", "definition": " forall l1 : wordset, l_inclus l1 l1.", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [49, 0, 49, 58], "proof_ranges": [50, 0, 51, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/more_words.v", "name": "trans_l_inclus", "text": "Lemma trans_l_inclus :\n forall l1 l2 l3 : wordset,\n l_inclus l1 l2 -> l_inclus l2 l3 -> l_inclus l1 l3.\nauto.\nQed.\n", "definition": "\n forall l1 l2 l3 : wordset,\n l_inclus l1 l2 -> l_inclus l2 l3 -> l_inclus l1 l3.", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [54, 0, 56, 52], "proof_ranges": [57, 0, 58, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/more_words.v", "name": "equiv_l_egal_eqwordset", "text": "Lemma equiv_l_egal_eqwordset :\n forall a b : wordset, l_egal a b <-> eqwordset a b.\nintros a b.\nunfold iff in |- *.\nsplit.\nintro Hyp; elim Hyp; auto.\nintros Hyp.\nsplit; unfold l_inclus in |- *; intro w; elim (Hyp w); auto.\nQed.\n", "definition": "\n forall a b : wordset, l_egal a b <-> eqwordset a b.", "proof": "\nintros a b.\nunfold iff in |- *.\nsplit.\nintro Hyp; elim Hyp; auto.\nintros Hyp.\nsplit; unfold l_inclus in |- *; intro w; elim (Hyp w); auto.\nQed.", "proof_term": [], "def_ranges": [69, 0, 70, 52], "proof_ranges": [71, 0, 77, 4], "only_proof_term": false, "proof_steps": [{"text": "intros a b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold iff in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Hyp; elim Hyp; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Hyp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; unfold l_inclus in |- *; intro w; elim (Hyp w); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros a b. Show Proof.", "unfold iff in |- *. Show Proof.", "split. Show Proof.", "intro Hyp; elim Hyp; auto. Show Proof.", "intros Hyp. Show Proof.", "split; unfold l_inclus in |- *; intro w; elim (Hyp w); auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/more_words.v", "name": "refl_l_egal", "text": "Lemma refl_l_egal : forall l1 : wordset, l_egal l1 l1.\nauto.\nQed.\n", "definition": " forall l1 : wordset, l_egal l1 l1.", "proof": "\nauto.\nQed.", "proof_term": [], "def_ranges": [80, 0, 80, 54], "proof_ranges": [81, 0, 82, 4], "only_proof_term": false, "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/more_words.v", "name": "wef_append", "text": "Lemma wef_append :\n forall u v : Word, wef (Append u v) = Append (wef u) (wef v).\nintros u v.\nelim u.\n\n\ttrivial.\n\n\tunfold wef in |- *.\n\tintros x w H.\n\tsimpl in |- *.\n\n\trewrite <- H.\n\treflexivity.\n\nQed.\n", "definition": "\n forall u v : Word, wef (Append u v) = Append (wef u) (wef v).", "proof": "\nintros u v.\nelim u.\n\n\ttrivial.\n\n\tunfold wef in |- *.\n\tintros x w H.\n\tsimpl in |- *.\n\n\trewrite <- H.\n\treflexivity.\n\nQed.", "proof_term": [], "def_ranges": [99, 0, 100, 62], "proof_ranges": [101, 0, 113, 4], "only_proof_term": false, "proof_steps": [{"text": "intros u v.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim u.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold wef in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x w H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros u v. Show Proof.", "elim u. Show Proof.", "trivial. Show Proof.", "unfold wef in |- *. Show Proof.", "intros x w H. Show Proof.", "simpl in |- *. Show Proof.", "rewrite <- H. Show Proof.", "reflexivity. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/more_words.v", "name": "wef_nil", "text": "Lemma wef_nil : forall a : Word, wef a = nil -> a = nil.\nintro a.\ncase a.\nauto.\n\nunfold wef in |- *; simpl in |- *; intros x w H; discriminate H.\n\nQed.\n", "definition": " forall a : Word, wef a = nil -> a = nil.", "proof": "\nintro a.\ncase a.\nauto.\n\nunfold wef in |- *; simpl in |- *; intros x w H; discriminate H.\n\nQed.", "proof_term": [], "def_ranges": [115, 0, 115, 56], "proof_ranges": [116, 0, 122, 4], "only_proof_term": false, "proof_steps": [{"text": "intro a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold wef in |- *; simpl in |- *; intros x w H; discriminate H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intro a. Show Proof.", "case a. Show Proof.", "auto. Show Proof.", "unfold wef in |- *; simpl in |- *; intros x w H; discriminate H. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/more_words.v", "name": "wef_cons", "text": "Lemma wef_cons :\n forall (a b : Word) (e : Elt),\n cons e a = wef b ->\n exists x : Elt,\n   ex2 (fun w : Word => cons x w = b) (fun w : Word => f x = e /\\ wef w = a).\n\nintros a b e.\nunfold wef in |- *.\ncase b.\n\tsimpl in |- *; intro H; discriminate H.\n\n\tsimpl in |- *; intros x w H.\n\texists x.\n\texists w.\n\t\ttrivial.\n\t\tinjection H; auto.\n\nQed.\n", "definition": "\n forall (a b : Word) (e : Elt),\n cons e a = wef b ->\n exists x : Elt,\n   ex2 (fun w : Word => cons x w = b) (fun w : Word => f x = e /\\ wef w = a).", "proof": "\n\nintros a b e.\nunfold wef in |- *.\ncase b.\n\tsimpl in |- *; intro H; discriminate H.\n\n\tsimpl in |- *; intros x w H.\n\texists x.\n\texists w.\n\t\ttrivial.\n\t\tinjection H; auto.\n\nQed.", "proof_term": [], "def_ranges": [125, 0, 129, 77], "proof_ranges": [130, 0, 142, 4], "only_proof_term": false, "proof_steps": [{"text": "intros a b e.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold wef in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "case b.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intro H; discriminate H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; intros x w H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists w.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros a b e. Show Proof.", "unfold wef in |- *. Show Proof.", "case b. Show Proof.", "simpl in |- *; intro H; discriminate H. Show Proof.", "simpl in |- *; intros x w H. Show Proof.", "exists x. Show Proof.", "exists w. Show Proof.", "trivial. Show Proof.", "injection H; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/more_words.v", "name": "Append_assoc", "text": "Lemma Append_assoc :\n forall a b c : Word, Append a (Append b c) = Append (Append a b) c.\nintros a b c. \nunfold Append in |- *.\nelim a; auto.\nQed.\n", "definition": "\n forall a b c : Word, Append a (Append b c) = Append (Append a b) c.", "proof": "\nintros a b c. \nunfold Append in |- *.\nelim a; auto.\nQed.", "proof_term": [], "def_ranges": [148, 0, 149, 68], "proof_ranges": [150, 0, 153, 4], "only_proof_term": false, "proof_steps": [{"text": "intros a b c.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Append in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim a; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros a b c. Show Proof.", "unfold Append in |- *. Show Proof.", "elim a; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/PushdownAutomata.v", "name": "not_dans_X_eps", "text": "Lemma not_dans_X_eps : ~ dans eps X.\nunfold eps in |- *.\napply sup_out.\nQed.\n", "definition": " ~ dans eps X.", "proof": "\nunfold eps in |- *.\napply sup_out.\nQed.", "proof_term": [], "def_ranges": [57, 0, 57, 36], "proof_ranges": [58, 0, 60, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold eps in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sup_out.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold eps in |- *. Show Proof.", "apply sup_out. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/PushdownAutomata.v", "name": "P_automata_1", "text": "Lemma P_automata_1 : P_automata -> inmonoid P wd.\nunfold P_automata in |- *.\nintro temp; elim temp.\nauto.\nQed.\n", "definition": " P_automata -> inmonoid P wd.", "proof": "\nunfold P_automata in |- *.\nintro temp; elim temp.\nauto.\nQed.", "proof_term": [], "def_ranges": [78, 0, 78, 49], "proof_ranges": [79, 0, 82, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold P_automata in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro temp; elim temp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold P_automata in |- *. Show Proof.", "intro temp; elim temp. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/PushdownAutomata.v", "name": "P_automata_2", "text": "Lemma P_automata_2 : P_automata -> Transition.\nunfold P_automata in |- *.\nintro temp; elim temp; clear temp.\nintros H temp; elim temp; clear temp.\nauto.\nQed.\n", "definition": " P_automata -> Transition.", "proof": "\nunfold P_automata in |- *.\nintro temp; elim temp; clear temp.\nintros H temp; elim temp; clear temp.\nauto.\nQed.", "proof_term": [], "def_ranges": [84, 0, 84, 46], "proof_ranges": [85, 0, 89, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold P_automata in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro temp; elim temp; clear temp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H temp; elim temp; clear temp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold P_automata in |- *. Show Proof.", "intro temp; elim temp; clear temp. Show Proof.", "intros H temp; elim temp; clear temp. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/PushdownAutomata.v", "name": "LA_langage", "text": "Lemma LA_langage : islanguage X LA.\nunfold LA, islanguage in |- *.\nintros w temp; elim temp; clear temp; auto.\nQed.\n", "definition": " islanguage X LA.", "proof": "\nunfold LA, islanguage in |- *.\nintros w temp; elim temp; clear temp; auto.\nQed.", "proof_term": [], "def_ranges": [114, 0, 114, 35], "proof_ranges": [115, 0, 117, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold LA, islanguage in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros w temp; elim temp; clear temp; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold LA, islanguage in |- *. Show Proof.", "intros w temp; elim temp; clear temp; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_union.v", "name": "union_a_empty", "text": "Lemma union_a_empty : forall a : Ensf, a = union a empty :>Ensf.\nsimple induction a.\napply refl_equal.\nintros a0 b H.\nsimpl in |- *; auto.\nQed.\n", "definition": " forall a : Ensf, a = union a empty :>Ensf.", "proof": "\nsimple induction a.\napply refl_equal.\nintros a0 b H.\nsimpl in |- *; auto.\nQed.", "proof_term": [], "def_ranges": [62, 0, 62, 64], "proof_ranges": [63, 0, 67, 4], "only_proof_term": false, "proof_steps": [{"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply refl_equal.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["simple induction a. Show Proof.", "apply refl_equal. Show Proof.", "intros a0 b H. Show Proof.", "simpl in |- *; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_union.v", "name": "dans_union", "text": "Lemma dans_union :\n forall (x : Elt) (a b : Ensf), dans x (union a b) -> dans x a \\/ dans x b.\nintros x.\nsimple induction a.\nauto.\n\nintros a0 b H b0.\nsimpl in |- *.\nintro H0.\ncut (a0 = x :>Elt \\/ dans x (union b b0)).\n2: apply dans_add; auto.\nintro H1; elim H1.\nintro; left.\nrewrite H2; auto.\nintro.\ncut (dans x b \\/ dans x b0); auto.\nintro H3; elim H3; auto.\nQed.\n", "definition": "\n forall (x : Elt) (a b : Ensf), dans x (union a b) -> dans x a \\/ dans x b.", "proof": "\nintros x.\nsimple induction a.\nauto.\n\nintros a0 b H b0.\nsimpl in |- *.\nintro H0.\ncut (a0 = x :>Elt \\/ dans x (union b b0)).\n2: apply dans_add; auto.\nintro H1; elim H1.\nintro; left.\nrewrite H2; auto.\nintro.\ncut (dans x b \\/ dans x b0); auto.\nintro H3; elim H3; auto.\nQed.", "proof_term": [], "def_ranges": [71, 0, 72, 75], "proof_ranges": [73, 0, 88, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H b0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a0 = x :>Elt \\/ dans x (union b b0)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; left.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x b \\/ dans x b0); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H3; elim H3; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x. Show Proof.", "simple induction a. Show Proof.", "auto. Show Proof.", "intros a0 b H b0. Show Proof.", "simpl in |- *. Show Proof.", "intro H0. Show Proof.", "cut (a0 = x :>Elt \\/ dans x (union b b0)). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H1; elim H1. Show Proof.", "intro; left. Show Proof.", "rewrite H2; auto. Show Proof.", "intro. Show Proof.", "cut (dans x b \\/ dans x b0); auto. Show Proof.", "intro H3; elim H3; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_union.v", "name": "union_g", "text": "Lemma union_g : forall (x : Elt) (a b : Ensf), dans x a -> dans x (union a b).\nintro x.\nsimple induction a.\nintros.\napply (dans_empty_imp_P x); auto.\nintros a0 b H b0.\nsimpl in |- *.\nintro.\ncut (a0 = x :>Elt \\/ dans x b).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro H1.\nrewrite H1; auto.\nauto.\nQed.\n", "definition": " forall (x : Elt) (a b : Ensf), dans x a -> dans x (union a b).", "proof": "\nintro x.\nsimple induction a.\nintros.\napply (dans_empty_imp_P x); auto.\nintros a0 b H b0.\nsimpl in |- *.\nintro.\ncut (a0 = x :>Elt \\/ dans x b).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro H1.\nrewrite H1; auto.\nauto.\nQed.", "proof_term": [], "def_ranges": [92, 0, 92, 78], "proof_ranges": [93, 0, 106, 4], "only_proof_term": false, "proof_steps": [{"text": "intro x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 b H b0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a0 = x :>Elt \\/ dans x b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intro x. Show Proof.", "simple induction a. Show Proof.", "intros. Show Proof.", "apply (dans_empty_imp_P x); auto. Show Proof.", "intros a0 b H b0. Show Proof.", "simpl in |- *. Show Proof.", "intro. Show Proof.", "cut (a0 = x :>Elt \\/ dans x b). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro H1. Show Proof.", "rewrite H1; auto. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_union.v", "name": "union_d", "text": "Lemma union_d : forall (x : Elt) (a b : Ensf), dans x b -> dans x (union a b).\nintro x.\nsimple induction a; simpl in |- *; auto.\nQed.\n", "definition": " forall (x : Elt) (a b : Ensf), dans x b -> dans x (union a b).", "proof": "\nintro x.\nsimple induction a; simpl in |- *; auto.\nQed.", "proof_term": [], "def_ranges": [109, 0, 109, 78], "proof_ranges": [110, 0, 112, 4], "only_proof_term": false, "proof_steps": [{"text": "intro x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction a; simpl in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intro x. Show Proof.", "simple induction a; simpl in |- *; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_union.v", "name": "dans_union_inv", "text": "Lemma dans_union_inv :\n forall (x : Elt) (a b : Ensf), dans x a \\/ dans x b -> dans x (union a b).\nintros x a b H; elim H; auto.\nQed.", "definition": "\n forall (x : Elt) (a b : Ensf), dans x a \\/ dans x b -> dans x (union a b).", "proof": "\nintros x a b H; elim H; auto.\nQed", "proof_term": [], "def_ranges": [116, 0, 117, 75], "proof_ranges": [118, 0, 119, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x a b H; elim H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x a b H; elim H; auto. Show Proof.", "Qed Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/gram_g.v", "name": "Deriveg_Derive", "text": "Lemma Deriveg_Derive :\n forall (X R : Ensf) (u v : Word), Deriveg X R u v -> Derive R u v.\nintros X R u v Der_g.\nelim Der_g.\nintros.\napply Derive1; auto.\nintros.\napply Derive2; auto.\nQed.\n", "definition": "\n forall (X R : Ensf) (u v : Word), Deriveg X R u v -> Derive R u v.", "proof": "\nintros X R u v Der_g.\nelim Der_g.\nintros.\napply Derive1; auto.\nintros.\napply Derive2; auto.\nQed.", "proof_term": [], "def_ranges": [60, 0, 61, 67], "proof_ranges": [62, 0, 68, 4], "only_proof_term": false, "proof_steps": [{"text": "intros X R u v Der_g.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim Der_g.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Derive1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Derive2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros X R u v Der_g. Show Proof.", "elim Der_g. Show Proof.", "intros. Show Proof.", "apply Derive1; auto. Show Proof.", "intros. Show Proof.", "apply Derive2; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/gram_g.v", "name": "Derivegstar_Derivestar", "text": "Lemma Derivegstar_Derivestar :\n forall (X R : Ensf) (u v : Word), Derivegstar X R u v -> Derivestar R u v.\nunfold Derivegstar, Rstar, Derivestar in |- *.\nintros X R x y Derivegstar_x_y.\npattern x, y in |- *.\napply Derivegstar_x_y.\nintro. apply Rstar_reflexive.\nintros u v w Der Der_star.\napply Rstar_R with v.\napply Deriveg_Derive with X; assumption.\nassumption.\nQed.\n", "definition": "\n forall (X R : Ensf) (u v : Word), Derivegstar X R u v -> Derivestar R u v.", "proof": "\nunfold Derivegstar, Rstar, Derivestar in |- *.\nintros X R x y Derivegstar_x_y.\npattern x, y in |- *.\napply Derivegstar_x_y.\nintro. apply Rstar_reflexive.\nintros u v w Der Der_star.\napply Rstar_R with v.\napply Deriveg_Derive with X; assumption.\nassumption.\nQed.", "proof_term": [], "def_ranges": [70, 0, 71, 75], "proof_ranges": [72, 0, 81, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold Derivegstar, Rstar, Derivestar in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros X R x y Derivegstar_x_y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pattern x, y in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Derivegstar_x_y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rstar_reflexive.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros u v w Der Der_star.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Rstar_R with v.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Deriveg_Derive with X; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold Derivegstar, Rstar, Derivestar in |- *. Show Proof.", "intros X R x y Derivegstar_x_y. Show Proof.", "pattern x, y in |- *. Show Proof.", "apply Derivegstar_x_y. Show Proof.", "intro. Show Proof.", "apply Rstar_reflexive. Show Proof.", "intros u v w Der Der_star. Show Proof.", "apply Rstar_R with v. Show Proof.", "apply Deriveg_Derive with X; assumption. Show Proof.", "assumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Dec.v", "name": "dans_tq_imp", "text": "Lemma dans_tq_imp :\n forall (x : Elt) (f : Elt -> Prop) (E : Ensf),\n dans x (tq f E) -> dans x E /\\ f x.\nintros x f.\nsimple induction E.\nreplace (tq f empty) with empty; auto.\nintro.\napply (dans_empty_imp_P x); auto.\nintros a b H.\nreplace (tq f (add a b)) with\n match Pdec f a return Ensf with\n | left fa => add a (tq f b)\n | right nfa => tq f b\n end; auto.\nelim (Pdec f a).\nintros a0 H0.\ncut (a = x :>Elt \\/ dans x (tq f b)).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro H1; rewrite <- H1; auto.\nintro.\ncut (dans x b /\\ f x); auto.\nintro H2; elim H2; auto.\nintros.\ncut (dans x b /\\ f x); auto.\nintro H1; elim H1; auto.\nQed.\n", "definition": "\n forall (x : Elt) (f : Elt -> Prop) (E : Ensf),\n dans x (tq f E) -> dans x E /\\ f x.", "proof": "\nintros x f.\nsimple induction E.\nreplace (tq f empty) with empty; auto.\nintro.\napply (dans_empty_imp_P x); auto.\nintros a b H.\nreplace (tq f (add a b)) with\n match Pdec f a return Ensf with\n | left fa => add a (tq f b)\n | right nfa => tq f b\n end; auto.\nelim (Pdec f a).\nintros a0 H0.\ncut (a = x :>Elt \\/ dans x (tq f b)).\n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro H1; rewrite <- H1; auto.\nintro.\ncut (dans x b /\\ f x); auto.\nintro H2; elim H2; auto.\nintros.\ncut (dans x b /\\ f x); auto.\nintro H1; elim H1; auto.\nQed.", "proof_term": [], "def_ranges": [69, 0, 71, 36], "proof_ranges": [72, 0, 95, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction E.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (tq f empty) with empty; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (tq f (add a b)) with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "match Pdec f a return Ensf with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| left fa => add a (tq f b)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| right nfa => tq f b", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "end; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (Pdec f a).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a0 H0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a = x :>Elt \\/ dans x (tq f b)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; rewrite <- H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x b /\\ f x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H2; elim H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x b /\\ f x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x f. Show Proof.", "simple induction E. Show Proof.", "replace (tq f empty) with empty; auto. Show Proof.", "intro. Show Proof.", "apply (dans_empty_imp_P x); auto. Show Proof.", "intros a b H. Show Proof.", "replace (tq f (add a b)) with Show Proof.", "match Pdec f a return Ensf with Show Proof.", "| left fa => add a (tq f b) Show Proof.", "| right nfa => tq f b Show Proof.", "end; auto. Show Proof.", "elim (Pdec f a). Show Proof.", "intros a0 H0. Show Proof.", "cut (a = x :>Elt \\/ dans x (tq f b)). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro H1; rewrite <- H1; auto. Show Proof.", "intro. Show Proof.", "cut (dans x b /\\ f x); auto. Show Proof.", "intro H2; elim H2; auto. Show Proof.", "intros. Show Proof.", "cut (dans x b /\\ f x); auto. Show Proof.", "intro H1; elim H1; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Dec.v", "name": "imp_dans_tq", "text": "Lemma imp_dans_tq :\n forall (x : Elt) (f : Elt -> Prop) (E : Ensf),\n dans x E -> f x -> dans x (tq f E).\nintros x f.\nsimple induction E.\nintro.\napply (dans_empty_imp_P x); auto.\nintros a b H H0 x0.\nreplace (tq f (add a b)) with\n match Pdec f a return Ensf with\n | left fa => add a (tq f b)\n | right nfa => tq f b\n end; auto.\nelim (Pdec f a).\n\nintro.\ncut (a = x :>Elt \\/ dans x b). \n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro H1; rewrite H1; auto.\nauto.\n\nintro.\ncut (a = x :>Elt \\/ dans x b). \n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro.\nabsurd (f a); auto.\nrewrite H1; auto.\nauto.\nQed.\n", "definition": "\n forall (x : Elt) (f : Elt -> Prop) (E : Ensf),\n dans x E -> f x -> dans x (tq f E).", "proof": "\nintros x f.\nsimple induction E.\nintro.\napply (dans_empty_imp_P x); auto.\nintros a b H H0 x0.\nreplace (tq f (add a b)) with\n match Pdec f a return Ensf with\n | left fa => add a (tq f b)\n | right nfa => tq f b\n end; auto.\nelim (Pdec f a).\n\nintro.\ncut (a = x :>Elt \\/ dans x b). \n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro H1; rewrite H1; auto.\nauto.\n\nintro.\ncut (a = x :>Elt \\/ dans x b). \n2: apply dans_add; auto.\nintro H1; elim H1; clear H1.\nintro.\nabsurd (f a); auto.\nrewrite H1; auto.\nauto.\nQed.", "proof_term": [], "def_ranges": [102, 0, 104, 36], "proof_ranges": [105, 0, 132, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x f.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple induction E.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (dans_empty_imp_P x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros a b H H0 x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "replace (tq f (add a b)) with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "match Pdec f a return Ensf with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| left fa => add a (tq f b)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "| right nfa => tq f b", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "end; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim (Pdec f a).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a = x :>Elt \\/ dans x b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; rewrite H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (a = x :>Elt \\/ dans x b).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H1; elim H1; clear H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "absurd (f a); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x f. Show Proof.", "simple induction E. Show Proof.", "intro. Show Proof.", "apply (dans_empty_imp_P x); auto. Show Proof.", "intros a b H H0 x0. Show Proof.", "replace (tq f (add a b)) with Show Proof.", "match Pdec f a return Ensf with Show Proof.", "| left fa => add a (tq f b) Show Proof.", "| right nfa => tq f b Show Proof.", "end; auto. Show Proof.", "elim (Pdec f a). Show Proof.", "intro. Show Proof.", "cut (a = x :>Elt \\/ dans x b). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro H1; rewrite H1; auto. Show Proof.", "auto. Show Proof.", "intro. Show Proof.", "cut (a = x :>Elt \\/ dans x b). Show Proof.", "2: apply dans_add; auto. Show Proof.", "intro H1; elim H1; clear H1. Show Proof.", "intro. Show Proof.", "absurd (f a); auto. Show Proof.", "rewrite H1; auto. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Dec.v", "name": "inclus_tq", "text": "Lemma inclus_tq : forall (f : Elt -> Prop) (a : Ensf), inclus (tq f a) a.\nunfold inclus in |- *.\nintros.\ncut (dans x a /\\ f x); auto.\n2: apply dans_tq_imp; auto.\nintro H0; elim H0; auto.\nQed.", "definition": " forall (f : Elt -> Prop) (a : Ensf), inclus (tq f a) a.", "proof": "\nunfold inclus in |- *.\nintros.\ncut (dans x a /\\ f x); auto.\n2: apply dans_tq_imp; auto.\nintro H0; elim H0; auto.\nQed", "proof_term": [], "def_ranges": [139, 0, 139, 73], "proof_ranges": [140, 0, 145, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (dans x a /\\ f x); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_tq_imp; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro H0; elim H0; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold inclus in |- *. Show Proof.", "intros. Show Proof.", "cut (dans x a /\\ f x); auto. Show Proof.", "2: apply dans_tq_imp; auto. Show Proof.", "intro H0; elim H0; auto. Show Proof.", "Qed Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_couple.v", "name": "equal_couple", "text": "Lemma equal_couple :\n forall x y z t : Elt,\n couple x y = couple z t :>Elt -> x = z :>Elt /\\ y = t :>Elt.\nintros x y z t H.\ninjection H; auto.\nQed.\n", "definition": "\n forall x y z t : Elt,\n couple x y = couple z t :>Elt -> x = z :>Elt /\\ y = t :>Elt.", "proof": "\nintros x y z t H.\ninjection H; auto.\nQed.", "proof_term": [], "def_ranges": [74, 0, 76, 61], "proof_ranges": [77, 0, 79, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x y z t H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x y z t H. Show Proof.", "injection H; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_couple.v", "name": "couple_couple_inv1", "text": "Lemma couple_couple_inv1 :\n forall a b c d : Elt, couple a c = couple b d :>Elt -> a = b :>Elt.\nintros a b c d H.\ninjection H; auto.\nQed.\n", "definition": "\n forall a b c d : Elt, couple a c = couple b d :>Elt -> a = b :>Elt.", "proof": "\nintros a b c d H.\ninjection H; auto.\nQed.", "proof_term": [], "def_ranges": [81, 0, 82, 68], "proof_ranges": [83, 0, 85, 4], "only_proof_term": false, "proof_steps": [{"text": "intros a b c d H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros a b c d H. Show Proof.", "injection H; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_couple.v", "name": "couple_couple_inv2", "text": "Lemma couple_couple_inv2 :\n forall a b c d : Elt, couple a c = couple b d :>Elt -> c = d :>Elt.\nintros a b c d H.\ninjection H; auto.\nQed.", "definition": "\n forall a b c d : Elt, couple a c = couple b d :>Elt -> c = d :>Elt.", "proof": "\nintros a b c d H.\ninjection H; auto.\nQed", "proof_term": [], "def_ranges": [87, 0, 88, 68], "proof_ranges": [89, 0, 91, 4], "only_proof_term": false, "proof_steps": [{"text": "intros a b c d H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros a b c d H. Show Proof.", "injection H; auto. Show Proof.", "Qed Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_dans.v", "name": "dans_add", "text": "Lemma dans_add :\n forall (x y : Elt) (e : Ensf), dans x (add y e) -> y = x \\/ dans x e.\nintros x y e H.\nsimple inversion H.\nleft.\ninjection H1.\nintros.\napply trans_equal with x0; [ auto | assumption ].\n\nintro.\nright.\ninjection H2.\nintros.\nrewrite <- H3.\nrewrite <- H1.\nassumption.\nQed. \n", "definition": "\n forall (x y : Elt) (e : Ensf), dans x (add y e) -> y = x \\/ dans x e.", "proof": "\nintros x y e H.\nsimple inversion H.\nleft.\ninjection H1.\nintros.\napply trans_equal with x0; [ auto | assumption ].\n\nintro.\nright.\ninjection H2.\nintros.\nrewrite <- H3.\nrewrite <- H1.\nassumption.\nQed. ", "proof_term": [], "def_ranges": [56, 0, 57, 70], "proof_ranges": [58, 0, 72, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x y e H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple inversion H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply trans_equal with x0; [ auto | assumption ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "right.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros x y e H. Show Proof.", "simple inversion H. Show Proof.", "left. Show Proof.", "injection H1. Show Proof.", "intros. Show Proof.", "apply trans_equal with x0; [ auto | assumption ]. Show Proof.", "intro. Show Proof.", "right. Show Proof.", "injection H2. Show Proof.", "intros. Show Proof.", "rewrite <- H3. Show Proof.", "rewrite <- H1. Show Proof.", "assumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_dans.v", "name": "dans_add_contr", "text": "Lemma dans_add_contr :\n forall (x y : Elt) (e : Ensf), y <> x -> ~ dans x e -> ~ dans x (add y e).\nintros; red in |- *; intro.\nabsurd (y = x \\/ dans x e).\n2: apply dans_add; auto.\nred in |- *.\nintro.\nelim H2; auto.\nQed.\n", "definition": "\n forall (x y : Elt) (e : Ensf), y <> x -> ~ dans x e -> ~ dans x (add y e).", "proof": "\nintros; red in |- *; intro.\nabsurd (y = x \\/ dans x e).\n2: apply dans_add; auto.\nred in |- *.\nintro.\nelim H2; auto.\nQed.", "proof_term": [], "def_ranges": [74, 0, 75, 75], "proof_ranges": [76, 0, 82, 4], "only_proof_term": false, "proof_steps": [{"text": "intros; red in |- *; intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "absurd (y = x \\/ dans x e).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "2: apply dans_add; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "red in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elim H2; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros; red in |- *; intro. Show Proof.", "absurd (y = x \\/ dans x e). Show Proof.", "2: apply dans_add; auto. Show Proof.", "red in |- *. Show Proof.", "intro. Show Proof.", "elim H2; auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_dans.v", "name": "empty_empty", "text": "Lemma empty_empty : forall E : Elt, ~ dans E empty.\nunfold not in |- *; intros E H.\nsimple inversion H; [ discriminate H1 | discriminate H2 ].\nQed.\n", "definition": " forall E : Elt, ~ dans E empty.", "proof": "\nunfold not in |- *; intros E H.\nsimple inversion H; [ discriminate H1 | discriminate H2 ].\nQed.", "proof_term": [], "def_ranges": [84, 0, 84, 51], "proof_ranges": [85, 0, 87, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold not in |- *; intros E H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple inversion H; [ discriminate H1 | discriminate H2 ].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold not in |- *; intros E H. Show Proof.", "simple inversion H; [ discriminate H1 | discriminate H2 ]. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_dans.v", "name": "dans_empty_imp_P", "text": "Lemma dans_empty_imp_P : forall (x : Elt) (P : Prop), dans x empty -> P.\nintros.\nelimtype False.\ncut (~ dans x empty); auto.\nQed.\n", "definition": " forall (x : Elt) (P : Prop), dans x empty -> P.", "proof": "\nintros.\nelimtype False.\ncut (~ dans x empty); auto.\nQed.", "proof_term": [], "def_ranges": [90, 0, 90, 72], "proof_ranges": [91, 0, 94, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elimtype False.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (~ dans x empty); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "elimtype False. Show Proof.", "cut (~ dans x empty); auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_dans.v", "name": "singl2", "text": "Lemma singl2 : forall x : Elt, dans x (singleton x).\nunfold singleton in |- *.\nauto.\nQed.\n", "definition": " forall x : Elt, dans x (singleton x).", "proof": "\nunfold singleton in |- *.\nauto.\nQed.", "proof_term": [], "def_ranges": [96, 0, 96, 52], "proof_ranges": [97, 0, 99, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold singleton in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold singleton in |- *. Show Proof.", "auto. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Ensf_dans.v", "name": "singl2_inv", "text": "Lemma singl2_inv : forall x e : Elt, dans x (singleton e) -> x = e :>Elt.\nunfold singleton in |- *.\nintros x e H.\nsimple inversion H.\ninjection H1; intros.\nrewrite <- H0; assumption.\ninjection H2; intros.\napply dans_empty_imp_P with x0.\nrewrite <- H0; assumption.\nQed.\n", "definition": " forall x e : Elt, dans x (singleton e) -> x = e :>Elt.", "proof": "\nunfold singleton in |- *.\nintros x e H.\nsimple inversion H.\ninjection H1; intros.\nrewrite <- H0; assumption.\ninjection H2; intros.\napply dans_empty_imp_P with x0.\nrewrite <- H0; assumption.\nQed.", "proof_term": [], "def_ranges": [104, 0, 104, 73], "proof_ranges": [105, 0, 113, 4], "only_proof_term": false, "proof_steps": [{"text": "unfold singleton in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros x e H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simple inversion H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H1; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H0; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "injection H2; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply dans_empty_imp_P with x0.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- H0; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["unfold singleton in |- *. Show Proof.", "intros x e H. Show Proof.", "simple inversion H. Show Proof.", "injection H1; intros. Show Proof.", "rewrite <- H0; assumption. Show Proof.", "injection H2; intros. Show Proof.", "apply dans_empty_imp_P with x0. Show Proof.", "rewrite <- H0; assumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/extract.v", "name": "Parser1", "text": "Theorem Parser1 : forall u : Word, {LL u} + {~ LL u}.\nintros.\nelimtype ({L u} + {~ L u}).\n\nintro Hyp.\nleft.\ncut (l_egal L LL).\nintro temp; elim temp.\nunfold l_inclus in |- *.\nintros.\nauto.\nunfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *.\napply equiv_APD_Gram.\nexact H.\n\nunfold not in |- *.\nintro Hyp.\nright.\nintro LL_u.\napply Hyp.\ncut (l_egal L LL).\nintro temp; elim temp.\nunfold l_inclus in |- *.\nintros.\nauto.\nunfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *.\napply equiv_APD_Gram.\nexact H.\n\nunfold L in |- *.\napply axiom_APD with P.\nunfold P, wd, wa, d, f_R_d, f_X_d in |- *.\napply X_P_wd_wa_d.\nexact H.\nQed.\n", "definition": " forall u : Word, {LL u} + {~ LL u}.", "proof": "\nintros.\nelimtype ({L u} + {~ L u}).\n\nintro Hyp.\nleft.\ncut (l_egal L LL).\nintro temp; elim temp.\nunfold l_inclus in |- *.\nintros.\nauto.\nunfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *.\napply equiv_APD_Gram.\nexact H.\n\nunfold not in |- *.\nintro Hyp.\nright.\nintro LL_u.\napply Hyp.\ncut (l_egal L LL).\nintro temp; elim temp.\nunfold l_inclus in |- *.\nintros.\nauto.\nunfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *.\napply equiv_APD_Gram.\nexact H.\n\nunfold L in |- *.\napply axiom_APD with P.\nunfold P, wd, wa, d, f_R_d, f_X_d in |- *.\napply X_P_wd_wa_d.\nexact H.\nQed.", "proof_term": [], "def_ranges": [82, 0, 82, 53], "proof_ranges": [83, 0, 116, 4], "only_proof_term": false, "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "elimtype ({L u + {~ L u).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Hyp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (l_egal L LL).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro temp; elim temp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold l_inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply equiv_APD_Gram.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold not in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro Hyp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "right.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro LL_u.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Hyp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (l_egal L LL).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro temp; elim temp.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold l_inclus in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply equiv_APD_Gram.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold L in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply axiom_APD with P.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold P, wd, wa, d, f_R_d, f_X_d in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply X_P_wd_wa_d.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exact H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["intros. Show Proof.", "elimtype ({L u + {~ L u). Show Proof.", "intro Hyp. Show Proof.", "left. Show Proof.", "cut (l_egal L LL). Show Proof.", "intro temp; elim temp. Show Proof.", "unfold l_inclus in |- *. Show Proof.", "intros. Show Proof.", "auto. Show Proof.", "unfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *. Show Proof.", "apply equiv_APD_Gram. Show Proof.", "exact H. Show Proof.", "unfold not in |- *. Show Proof.", "intro Hyp. Show Proof.", "right. Show Proof.", "intro LL_u. Show Proof.", "apply Hyp. Show Proof.", "cut (l_egal L LL). Show Proof.", "intro temp; elim temp. Show Proof.", "unfold l_inclus in |- *. Show Proof.", "intros. Show Proof.", "auto. Show Proof.", "unfold L, LL, wa, wd, d, f_R_d, f_X_d in |- *. Show Proof.", "apply equiv_APD_Gram. Show Proof.", "exact H. Show Proof.", "unfold L in |- *. Show Proof.", "apply axiom_APD with P. Show Proof.", "unfold P, wd, wa, d, f_R_d, f_X_d in |- *. Show Proof.", "apply X_P_wd_wa_d. Show Proof.", "exact H. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Relations.v", "name": "Rstar_reflexive", "text": "Theorem Rstar_reflexive : forall x : A, Rstar x x.\n Proof\n   fun (x : A) (P : A -> A -> Prop) (h1 : forall u : A, P u u)\n     (h2 : forall u v w : A, R u v -> P v w -> P u w) => \n   h1 x.  \n\n  \nTheorem Rstar_R : forall x y z : A, R x y -> Rstar y z -> Rstar x z.\n", "definition": " forall x : A, Rstar x x.\n ", "proof": "Proof\n   fun (x : A) (P : A -> A -> Prop) (h1 : forall u : A, P u u)\n     (h2 : forall u v w : A, R u v -> P v w -> P u w) => \n   h1 x.  \n\n  \nTheorem Rstar_R : forall x y z : A, R x y -> Rstar y z -> Rstar x z.", "proof_term": "Proof\n   fun (x : A) (P : A -> A -> Prop) (h1 : forall u : A, P u u)\n     (h2 : forall u v w : A, R u v -> P v w -> P u w) => \n   h1 x.  \n\n  \nTheorem Rstar_R : forall x y z : A, R x y -> Rstar y z -> Rstar x z.", "def_ranges": [60, 0, 60, 50], "proof_ranges": [61, 0, 67, 68], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Relations.v", "name": "Rstar_R", "text": "Theorem Rstar_R : forall x y z : A, R x y -> Rstar y z -> Rstar x z.\n Proof\n   fun (x y z : A) (t1 : R x y) (t2 : Rstar y z) (P : A -> A -> Prop)\n     (h1 : forall u : A, P u u)\n     (h2 : forall u v w : A, R u v -> P v w -> P u w) =>\n   h2 x y z t1 (t2 P h1 h2).  \n\n(* We conclude with transitivity of Rstar : *)\n\nTheorem Rstar_transitive :\n forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z.\n", "definition": " forall x y z : A, R x y -> Rstar y z -> Rstar x z.\n ", "proof": "Proof\n   fun (x y z : A) (t1 : R x y) (t2 : Rstar y z) (P : A -> A -> Prop)\n     (h1 : forall u : A, P u u)\n     (h2 : forall u v w : A, R u v -> P v w -> P u w) =>\n   h2 x y z t1 (t2 P h1 h2).  \n\n(* We conclude with transitivity of Rstar : *)\n\nTheorem Rstar_transitive :\n forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z.", "proof_term": "Proof\n   fun (x y z : A) (t1 : R x y) (t2 : Rstar y z) (P : A -> A -> Prop)\n     (h1 : forall u : A, P u u)\n     (h2 : forall u v w : A, R u v -> P v w -> P u w) =>\n   h2 x y z t1 (t2 P h1 h2).  \n\n(* We conclude with transitivity of Rstar : *)\n\nTheorem Rstar_transitive :\n forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z.", "def_ranges": [67, 0, 67, 68], "proof_ranges": [68, 0, 77, 55], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Relations.v", "name": "Rstar_transitive", "text": "Theorem Rstar_transitive :\n forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z.\n Proof\n   fun (x y z : A) (h : Rstar x y) =>\n   h (fun u v : A => Rstar v z -> Rstar u z)\n     (fun (u : A) (t : Rstar u z) => t)\n     (fun (u v w : A) (t1 : R u v) (t2 : Rstar w z -> Rstar v z)\n        (t3 : Rstar w z) => Rstar_R u v z t1 (t2 t3)).  \n\n(* Another characterization of R* *)\n(* Smallest reflexive P containing R o R* *)\n\nDefinition Rstar' (x y : A) :=\n  forall P : A -> A -> Prop,\n  P x x -> (forall u : A, R x u -> Rstar u y -> P x y) -> P x y.  \n\nTheorem Rstar'_reflexive : forall x : A, Rstar' x x.\n", "definition": "\n forall x y z : A, Rstar x y -> Rstar y z -> Rstar x z.\n ", "proof": "Proof\n   fun (x y z : A) (h : Rstar x y) =>\n   h (fun u v : A => Rstar v z -> Rstar u z)\n     (fun (u : A) (t : Rstar u z) => t)\n     (fun (u v w : A) (t1 : R u v) (t2 : Rstar w z -> Rstar v z)\n        (t3 : Rstar w z) => Rstar_R u v z t1 (t2 t3)).  \n\n(* Another characterization of R* *)\n(* Smallest reflexive P containing R o R* *)\n\nDefinition Rstar' (x y : A) :=\n  forall P : A -> A -> Prop,\n  P x x -> (forall u : A, R x u -> Rstar u y -> P x y) -> P x y.  \n\nTheorem Rstar'_reflexive : forall x : A, Rstar' x x.", "proof_term": "Proof\n   fun (x y z : A) (h : Rstar x y) =>\n   h (fun u v : A => Rstar v z -> Rstar u z)\n     (fun (u : A) (t : Rstar u z) => t)\n     (fun (u v w : A) (t1 : R u v) (t2 : Rstar w z -> Rstar v z)\n        (t3 : Rstar w z) => Rstar_R u v z t1 (t2 t3)).  \n\n(* Another characterization of R* *)\n(* Smallest reflexive P containing R o R* *)\n\nDefinition Rstar' (x y : A) :=\n  forall P : A -> A -> Prop,\n  P x x -> (forall u : A, R x u -> Rstar u y -> P x y) -> P x y.  \n\nTheorem Rstar'_reflexive : forall x : A, Rstar' x x.", "def_ranges": [76, 0, 77, 55], "proof_ranges": [78, 0, 92, 52], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Relations.v", "name": "Rstar'_reflexive", "text": "Theorem Rstar'_reflexive : forall x : A, Rstar' x x.\n Proof\n   fun (x : A) (P : A -> A -> Prop) (h : P x x)\n     (h' : forall u : A, R x u -> Rstar u x -> P x x) => h.\n", "definition": " forall x : A, Rstar' x x.\n ", "proof": "Proof\n   fun (x : A) (P : A -> A -> Prop) (h : P x x)\n     (h' : forall u : A, R x u -> Rstar u x -> P x x) => h.", "proof_term": "Proof\n   fun (x : A) (P : A -> A -> Prop) (h : P x x)\n     (h' : forall u : A, R x u -> Rstar u x -> P x x) => h.", "def_ranges": [92, 0, 92, 52], "proof_ranges": [93, 0, 95, 59], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Relations.v", "name": "Rstar'_R", "text": "Theorem Rstar'_R : forall x y z : A, R x z -> Rstar z y -> Rstar' x y.\n Proof\n   fun (x y z : A) (t1 : R x z) (t2 : Rstar z y) (P : A -> A -> Prop)\n     (h1 : P x x) (h2 : forall u : A, R x u -> Rstar u y -> P x y) =>\n   h2 z t1 t2.  \n\n(* Equivalence of the two definitions: *)\n\nTheorem Rstar'_Rstar : forall x y : A, Rstar' x y -> Rstar x y.\n", "definition": " forall x y z : A, R x z -> Rstar z y -> Rstar' x y.\n ", "proof": "Proof\n   fun (x y z : A) (t1 : R x z) (t2 : Rstar z y) (P : A -> A -> Prop)\n     (h1 : P x x) (h2 : forall u : A, R x u -> Rstar u y -> P x y) =>\n   h2 z t1 t2.  \n\n(* Equivalence of the two definitions: *)\n\nTheorem Rstar'_Rstar : forall x y : A, Rstar' x y -> Rstar x y.", "proof_term": "Proof\n   fun (x y z : A) (t1 : R x z) (t2 : Rstar z y) (P : A -> A -> Prop)\n     (h1 : P x x) (h2 : forall u : A, R x u -> Rstar u y -> P x y) =>\n   h2 z t1 t2.  \n\n(* Equivalence of the two definitions: *)\n\nTheorem Rstar'_Rstar : forall x y : A, Rstar' x y -> Rstar x y.", "def_ranges": [97, 0, 97, 70], "proof_ranges": [98, 0, 105, 63], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Relations.v", "name": "Rstar'_Rstar", "text": "Theorem Rstar'_Rstar : forall x y : A, Rstar' x y -> Rstar x y.\n Proof\n   fun (x y : A) (h : Rstar' x y) =>\n   h Rstar (Rstar_reflexive x) (fun u : A => Rstar_R x u y).  \n  \nTheorem Rstar_Rstar' : forall x y : A, Rstar x y -> Rstar' x y.\n", "definition": " forall x y : A, Rstar' x y -> Rstar x y.\n ", "proof": "Proof\n   fun (x y : A) (h : Rstar' x y) =>\n   h Rstar (Rstar_reflexive x) (fun u : A => Rstar_R x u y).  \n  \nTheorem Rstar_Rstar' : forall x y : A, Rstar x y -> Rstar' x y.", "proof_term": "Proof\n   fun (x y : A) (h : Rstar' x y) =>\n   h Rstar (Rstar_reflexive x) (fun u : A => Rstar_R x u y).  \n  \nTheorem Rstar_Rstar' : forall x y : A, Rstar x y -> Rstar' x y.", "def_ranges": [105, 0, 105, 63], "proof_ranges": [106, 0, 110, 63], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Relations.v", "name": "Rstar_Rstar'", "text": "Theorem Rstar_Rstar' : forall x y : A, Rstar x y -> Rstar' x y.\n Proof\n   fun (x y : A) (h : Rstar x y) =>\n   h Rstar' (fun u : A => Rstar'_reflexive u)\n     (fun (u v w : A) (h1 : R u v) (h2 : Rstar' v w) =>\n      Rstar'_R u w v h1 (Rstar'_Rstar v w h2)).  \n\n\n(* inversion de Rstar*)\n\nLemma Rstar_inv :\n forall x y : A,\n Rstar x y -> x = y \\/ ex2 (fun z : A => R x z) (fun z : A => Rstar z y).\n", "definition": " forall x y : A, Rstar x y -> Rstar' x y.\n ", "proof": "Proof\n   fun (x y : A) (h : Rstar x y) =>\n   h Rstar' (fun u : A => Rstar'_reflexive u)\n     (fun (u v w : A) (h1 : R u v) (h2 : Rstar' v w) =>\n      Rstar'_R u w v h1 (Rstar'_Rstar v w h2)).  \n\n\n(* inversion de Rstar*)\n\nLemma Rstar_inv :\n forall x y : A,\n Rstar x y -> x = y \\/ ex2 (fun z : A => R x z) (fun z : A => Rstar z y).", "proof_term": "Proof\n   fun (x y : A) (h : Rstar x y) =>\n   h Rstar' (fun u : A => Rstar'_reflexive u)\n     (fun (u v w : A) (h1 : R u v) (h2 : Rstar' v w) =>\n      Rstar'_R u w v h1 (Rstar'_Rstar v w h2)).  \n\n\n(* inversion de Rstar*)\n\nLemma Rstar_inv :\n forall x y : A,\n Rstar x y -> x = y \\/ ex2 (fun z : A => R x z) (fun z : A => Rstar z y).", "def_ranges": [110, 0, 110, 63], "proof_ranges": [111, 0, 122, 73], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/automata/Relations.v", "name": "Rstar_inv", "text": "Lemma Rstar_inv :\n forall x y : A,\n Rstar x y -> x = y \\/ ex2 (fun z : A => R x z) (fun z : A => Rstar z y).\nintros x y Rstar_x_y.\npattern x, y in |- *.\napply Rstar_x_y.\n\tauto.\n\n\tintros u v w R_u_v Hyp.\n\tapply or_intror.\n\texists v.\n\t\tassumption.\n\t\telim Hyp.\n\t\t\tintro Rew.\n\t\t\trewrite Rew.\n\t\t\tapply Rstar_reflexive.\n\n\t\t\tintro temp; elim temp; clear temp.\n\t\t\tintros z R_v_z Rstar_z_w.\n\t\t\tapply Rstar_R with z; assumption.\nQed.\n", "definition": "\n forall x y : A,\n Rstar x y -> x = y \\/ ex2 (fun z : A => R x z) (fun z : A => Rstar z y).", "proof": "\nintros x y Rstar_x_y.\npattern x, y in |- *.\napply Rstar_x_y.\n\tauto.\n\n\tintros u v w R_u_v Hyp.\n\tapply or_intror.\n\texists v.\n\t\tassumption.\n\t\telim Hyp.\n\t\t\tintro Rew.\n\t\t\trewrite Rew.\n\t\t\tapply Rstar_reflexive.\n\n\t\t\tintro temp; elim temp; clear temp.\n\t\t\tintros z R_v_z Rstar_z_w.\n\t\t\tapply Rstar_R with z; assumption.\nQed.", "proof_term": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            (fun temp : exists2 z : A, R v z & Rstar z w =>\n             ex2_ind\n               (fun (z : A) (R_v_z : R v z) (Rstar_z_w : Rstar z w) =>\n                Rstar_R v z w R_v_z Rstar_z_w) temp) Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "def_ranges": [120, 0, 122, 73], "proof_ranges": [123, 0, 140, 4], "only_proof_term": false, "proof_steps": [{"text": "intros x y Rstar_x_y.", "goal_before": ["forall x y : A, Rstar x y -> x = y \\/ (exists2 z : A, R x z & Rstar z y)"], "goal_after": ["x = y \\/ (exists2 z : A, R x z & Rstar z y)"], "proof_term_before": [], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) => ?Goal)"]}, {"text": "pattern x, y in |- *.", "goal_before": ["x = y \\/ (exists2 z : A, R x z & Rstar z y)"], "goal_after": ["(fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0)) x y"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) => ?Goal)"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n ?Goal : x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "apply Rstar_x_y.", "goal_before": ["(fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0)) x y"], "goal_after": ["forall u : A, u = u \\/ (exists2 z : A, R u z & Rstar z u)", "forall u v w : A,\nR u v ->\nv = w \\/ (exists2 z : A, R v z & Rstar z w) ->\nu = w \\/ (exists2 z : A, R u z & Rstar z w)"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n ?Goal : x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   ?Goal ?Goal0\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "auto.", "goal_before": ["forall u : A, u = u \\/ (exists2 z : A, R u z & Rstar z u)", "forall u v w : A,\nR u v ->\nv = w \\/ (exists2 z : A, R v z & Rstar z w) ->\nu = w \\/ (exists2 z : A, R u z & Rstar z w)"], "goal_after": ["forall u v w : A,\nR u v ->\nv = w \\/ (exists2 z : A, R v z & Rstar z w) ->\nu = w \\/ (exists2 z : A, R u z & Rstar z w)"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   ?Goal ?Goal0\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl) ?Goal\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "intros u v w R_u_v Hyp.", "goal_before": ["forall u v w : A,\nR u v ->\nv = w \\/ (exists2 z : A, R v z & Rstar z w) ->\nu = w \\/ (exists2 z : A, R u z & Rstar z w)"], "goal_after": ["u = w \\/ (exists2 z : A, R u z & Rstar z w)"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl) ?Goal\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) => \n    ?Goal)\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "apply or_intror.", "goal_before": ["u = w \\/ (exists2 z : A, R u z & Rstar z w)"], "goal_after": ["exists2 z : A, R u z & Rstar z w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) => \n    ?Goal)\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) => \n    or_intror ?Goal)\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "exists v.", "goal_before": ["exists2 z : A, R u z & Rstar z w"], "goal_after": ["R u v", "Rstar v w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) => \n    or_intror ?Goal)\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v ?Goal ?Goal0))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "assumption.", "goal_before": ["R u v", "Rstar v w"], "goal_after": ["Rstar v w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v ?Goal ?Goal0))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v ?Goal))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "elim Hyp.", "goal_before": ["Rstar v w"], "goal_after": ["v = w -> Rstar v w", "(exists2 z : A, R v z & Rstar z w) -> Rstar v w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v ?Goal))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind ?Goal ?Goal0 Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "intro Rew.", "goal_before": ["v = w -> Rstar v w", "(exists2 z : A, R v z & Rstar z w) -> Rstar v w"], "goal_after": ["Rstar v w", "(exists2 z : A, R v z & Rstar z w) -> Rstar v w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind ?Goal ?Goal0 Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind (fun Rew : v = w => ?Goal0) ?Goal Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "rewrite Rew.", "goal_before": ["Rstar v w", "(exists2 z : A, R v z & Rstar z w) -> Rstar v w"], "goal_after": ["Rstar w w", "(exists2 z : A, R v z & Rstar z w) -> Rstar v w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind (fun Rew : v = w => ?Goal0) ?Goal Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) ?Goal0 Rew) \n            ?Goal Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "apply Rstar_reflexive.", "goal_before": ["Rstar w w", "(exists2 z : A, R v z & Rstar z w) -> Rstar v w"], "goal_after": ["(exists2 z : A, R v z & Rstar z w) -> Rstar v w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) ?Goal0 Rew) \n            ?Goal Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            ?Goal Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "intro temp; elim temp; clear temp.", "goal_before": ["(exists2 z : A, R v z & Rstar z w) -> Rstar v w"], "goal_after": ["forall x0 : A, R v x0 -> Rstar x0 w -> Rstar v w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            ?Goal Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            (fun temp : exists2 z : A, R v z & Rstar z w =>\n             ex2_ind ?Goal temp) Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "intros z R_v_z Rstar_z_w.", "goal_before": ["forall x0 : A, R v x0 -> Rstar x0 w -> Rstar v w"], "goal_after": ["Rstar v w"], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            (fun temp : exists2 z : A, R v z & Rstar z w =>\n             ex2_ind ?Goal temp) Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            (fun temp : exists2 z : A, R v z & Rstar z w =>\n             ex2_ind\n               (fun (z : A) (R_v_z : R v z) (Rstar_z_w : Rstar z w) => ?Goal)\n               temp) Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "apply Rstar_R with z; assumption.", "goal_before": ["Rstar v w"], "goal_after": [], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            (fun temp : exists2 z : A, R v z & Rstar z w =>\n             ex2_ind\n               (fun (z : A) (R_v_z : R v z) (Rstar_z_w : Rstar z w) => ?Goal)\n               temp) Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            (fun temp : exists2 z : A, R v z & Rstar z w =>\n             ex2_ind\n               (fun (z : A) (R_v_z : R v z) (Rstar_z_w : Rstar z w) =>\n                Rstar_R v z w R_v_z Rstar_z_w) temp) Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : A) (Rstar_x_y : Rstar x y) =>\n Rstar_x_y (fun a a0 : A => a = a0 \\/ (exists2 z : A, R a z & Rstar z a0))\n   (fun u : A => or_introl eq_refl)\n   (fun (u v w : A) (R_u_v : R u v)\n      (Hyp : v = w \\/ (exists2 z : A, R v z & Rstar z w)) =>\n    or_intror\n      (ex_intro2 (fun z : A => R u z) (fun z : A => Rstar z w) v R_u_v\n         (or_ind\n            (fun Rew : v = w =>\n             eq_ind_r (fun v0 : A => Rstar v0 w) (Rstar_reflexive w) Rew)\n            (fun temp : exists2 z : A, R v z & Rstar z w =>\n             ex2_ind\n               (fun (z : A) (R_v_z : R v z) (Rstar_z_w : Rstar z w) =>\n                Rstar_R v z w R_v_z Rstar_z_w) temp) Hyp)))\n :\n x = y \\/ (exists2 z : A, R x z & Rstar z y))"], "proof_term_after": []}], "augmented_proof": ["intros x y Rstar_x_y. Show Proof.", "pattern x, y in |- *. Show Proof.", "apply Rstar_x_y. Show Proof.", "auto. Show Proof.", "intros u v w R_u_v Hyp. Show Proof.", "apply or_intror. Show Proof.", "exists v. Show Proof.", "assumption. Show Proof.", "elim Hyp. Show Proof.", "intro Rew. Show Proof.", "rewrite Rew. Show Proof.", "apply Rstar_reflexive. Show Proof.", "intro temp; elim temp; clear temp. Show Proof.", "intros z R_v_z Rstar_z_w. Show Proof.", "apply Rstar_R with z; assumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "false_implies_everything", "text": "Theorem false_implies_everything : forall P : Prop, False -> P.\nProof False_ind.\n", "definition": " forall P : Prop, False -> P.\n", "proof": "Proof False_ind.", "proof_term": "Proof False_ind.", "def_ranges": [1661, 0, 1661, 63], "proof_ranges": [1662, 0, 1662, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EXISTS_th1_proof_Out", "text": "Lemma EXISTS_th1_proof_Out : False.\nProof step1 p.\n", "definition": " False.\n", "proof": "Proof step1 p.", "proof_term": "Proof step1 p.", "def_ranges": [1770, 0, 1770, 35], "proof_ranges": [1771, 0, 1771, 14], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EXISTS_th1", "text": "Theorem EXISTS_th1 : forall (P : Ens -> Prop) (X : Ens) (p : P X), EXISTS P.\nProof EXISTS_th1_proof_Out.\n", "definition": " forall (P : Ens -> Prop) (X : Ens) (p : P X), EXISTS P.\n", "proof": "Proof EXISTS_th1_proof_Out.", "proof_term": "Proof EXISTS_th1_proof_Out.", "def_ranges": [1775, 0, 1775, 76], "proof_ranges": [1776, 0, 1776, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "subset_reflexive_Out", "text": "Lemma subset_reflexive_Out : IN B A.\nProof h.\n", "definition": " IN B A.\n", "proof": "Proof h.", "proof_term": "Proof h.", "def_ranges": [1788, 0, 1788, 36], "proof_ranges": [1789, 0, 1789, 8], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "SUB_refl", "text": "Theorem SUB_refl : forall A : Ens, SUB A A.\nProof subset_reflexive_Out.\n", "definition": " forall A : Ens, SUB A A.\n", "proof": "Proof subset_reflexive_Out.", "proof_term": "Proof subset_reflexive_Out.", "def_ranges": [1793, 0, 1793, 43], "proof_ranges": [1794, 0, 1794, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "equality_reflexive_Out", "text": "Lemma equality_reflexive_Out : EQ A A.\nProof Build_EQ A A step1_1 step1_1.\n", "definition": " EQ A A.\n", "proof": "Proof Build_EQ A A step1_1 step1_1.", "proof_term": "Proof Build_EQ A A step1_1 step1_1.", "def_ranges": [1803, 0, 1803, 38], "proof_ranges": [1804, 0, 1804, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EQ_refl", "text": "Theorem EQ_refl : forall A : Ens, EQ A A.\nProof equality_reflexive_Out.\n", "definition": " forall A : Ens, EQ A A.\n", "proof": "Proof equality_reflexive_Out.", "proof_term": "Proof equality_reflexive_Out.", "def_ranges": [1808, 0, 1808, 41], "proof_ranges": [1809, 0, 1809, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "equality_symmetric_Out", "text": "Lemma equality_symmetric_Out : EQ B A.\nProof Build_EQ B A stepback stepfor.\n", "definition": " EQ B A.\n", "proof": "Proof Build_EQ B A stepback stepfor.", "proof_term": "Proof Build_EQ B A stepback stepfor.", "def_ranges": [1822, 0, 1822, 38], "proof_ranges": [1823, 0, 1823, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EQ_symm", "text": "Theorem EQ_symm : forall A B : Ens, EQ A B -> EQ B A.\nProof equality_symmetric_Out.\n", "definition": " forall A B : Ens, EQ A B -> EQ B A.\n", "proof": "Proof equality_symmetric_Out.", "proof_term": "Proof equality_symmetric_Out.", "def_ranges": [1827, 0, 1827, 53], "proof_ranges": [1828, 0, 1828, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "neq_symm_Out", "text": "Lemma neq_symm_Out : False.\nProof k step1.\n", "definition": " False.\n", "proof": "Proof k step1.", "proof_term": "Proof k step1.", "def_ranges": [1844, 0, 1844, 27], "proof_ranges": [1845, 0, 1845, 14], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "NEQ_symm", "text": "Theorem NEQ_symm : forall (A B : Ens) (k : NEQ A B), NEQ B A.\nProof neq_symm_Out.\n", "definition": " forall (A B : Ens) (k : NEQ A B), NEQ B A.\n", "proof": "Proof neq_symm_Out.", "proof_term": "Proof neq_symm_Out.", "def_ranges": [1849, 0, 1849, 61], "proof_ranges": [1850, 0, 1850, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "SUB_trans_proof_Out", "text": "Lemma SUB_trans_proof_Out : IN X C.\nProof k X step1.\n", "definition": " IN X C.\n", "proof": "Proof k X step1.", "proof_term": "Proof k X step1.", "def_ranges": [1867, 0, 1867, 35], "proof_ranges": [1868, 0, 1868, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "SUB_trans", "text": "Theorem SUB_trans : forall (A B C : Ens) (h : SUB A B) (k : SUB B C), SUB A C.\nProof SUB_trans_proof_Out.\n", "definition": " forall (A B C : Ens) (h : SUB A B) (k : SUB B C), SUB A C.\n", "proof": "Proof SUB_trans_proof_Out.", "proof_term": "Proof SUB_trans_proof_Out.", "def_ranges": [1872, 0, 1872, 78], "proof_ranges": [1873, 0, 1873, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EQ_trans_proof_Out", "text": "Lemma EQ_trans_proof_Out : EQ A C.\nProof Build_EQ A C step5 step6.\n", "definition": " EQ A C.\n", "proof": "Proof Build_EQ A C step5 step6.", "proof_term": "Proof Build_EQ A C step5 step6.", "def_ranges": [1901, 0, 1901, 34], "proof_ranges": [1902, 0, 1902, 31], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EQ_trans", "text": "Theorem EQ_trans : forall (A B C : Ens) (h : EQ A B) (k : EQ B C), EQ A C.\nProof EQ_trans_proof_Out.\n", "definition": " forall (A B C : Ens) (h : EQ A B) (k : EQ B C), EQ A C.\n", "proof": "Proof EQ_trans_proof_Out.", "proof_term": "Proof EQ_trans_proof_Out.", "def_ranges": [1906, 0, 1906, 74], "proof_ranges": [1907, 0, 1907, 25], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "strictsub_trans1a_Out", "text": "Lemma strictsub_trans1a_Out : False.\nProof h2 step4.\n", "definition": " False.\n", "proof": "Proof h2 step4.", "proof_term": "Proof h2 step4.", "def_ranges": [1940, 0, 1940, 36], "proof_ranges": [1941, 0, 1941, 15], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "strictsub_trans1_Out", "text": "Lemma strictsub_trans1_Out : StrictSUB A C.\nProof Build_StrictSUB A C step1 step5.\n", "definition": " StrictSUB A C.\n", "proof": "Proof Build_StrictSUB A C step1 step5.", "proof_term": "Proof Build_StrictSUB A C step1 step5.", "def_ranges": [1947, 0, 1947, 43], "proof_ranges": [1948, 0, 1948, 38], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "StrictSUB_trans1", "text": "Theorem StrictSUB_trans1 :\n forall (A B C : Ens) (h : StrictSUB A B) (k : SUB B C), StrictSUB A C.\nProof strictsub_trans1_Out.\n", "definition": "\n forall (A B C : Ens) (h : StrictSUB A B) (k : SUB B C), StrictSUB A C.\n", "proof": "Proof strictsub_trans1_Out.", "proof_term": "Proof strictsub_trans1_Out.", "def_ranges": [1952, 0, 1953, 71], "proof_ranges": [1954, 0, 1954, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "emptyset_empty_Out", "text": "Lemma emptyset_empty_Out : False.\nProof EmptySet_pr X h.\n", "definition": " False.\n", "proof": "Proof EmptySet_pr X h.", "proof_term": "Proof EmptySet_pr X h.", "def_ranges": [1968, 0, 1968, 33], "proof_ranges": [1969, 0, 1969, 22], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EmptySet_th1", "text": "Theorem EmptySet_th1 : forall (X : Ens) (h : IN X EmptySet), False.\nProof emptyset_empty_Out.\n", "definition": " forall (X : Ens) (h : IN X EmptySet), False.\n", "proof": "Proof emptyset_empty_Out.", "proof_term": "Proof emptyset_empty_Out.", "def_ranges": [1973, 0, 1973, 67], "proof_ranges": [1974, 0, 1974, 25], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "emptyset_subset_everything_2_Out", "text": "Lemma emptyset_subset_everything_2_Out : IN B A.\nProof false_implies_everything (IN B A) step1.\n", "definition": " IN B A.\n", "proof": "Proof false_implies_everything (IN B A) step1.", "proof_term": "Proof false_implies_everything (IN B A) step1.", "def_ranges": [1983, 0, 1983, 48], "proof_ranges": [1984, 0, 1984, 46], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "emptyset_subset_everything_Out", "text": "Lemma emptyset_subset_everything_Out : SUB EmptySet A.\nProof step2.\n", "definition": " SUB EmptySet A.\n", "proof": "Proof step2.", "proof_term": "Proof step2.", "def_ranges": [1988, 0, 1988, 54], "proof_ranges": [1989, 0, 1989, 12], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EmptySet_th2", "text": "Theorem EmptySet_th2 : forall A : Ens, SUB EmptySet A.\nProof emptyset_subset_everything_Out.\n", "definition": " forall A : Ens, SUB EmptySet A.\n", "proof": "Proof emptyset_subset_everything_Out.", "proof_term": "Proof emptyset_subset_everything_Out.", "def_ranges": [1992, 0, 1992, 54], "proof_ranges": [1993, 0, 1993, 37], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "ieieep1_Out", "text": "Lemma ieieep1_Out : IN X EmptySet.\nProof false_implies_everything (IN X EmptySet) step1_1.\n", "definition": " IN X EmptySet.\n", "proof": "Proof false_implies_everything (IN X EmptySet) step1_1.", "proof_term": "Proof false_implies_everything (IN X EmptySet) step1_1.", "def_ranges": [2008, 0, 2008, 34], "proof_ranges": [2009, 0, 2009, 55], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "ieieep2_Out", "text": "Lemma ieieep2_Out : IN X A.\nProof false_implies_everything (IN X A) step2_1.\n", "definition": " IN X A.\n", "proof": "Proof false_implies_everything (IN X A) step2_1.", "proof_term": "Proof false_implies_everything (IN X A) step2_1.", "def_ranges": [2023, 0, 2023, 27], "proof_ranges": [2024, 0, 2024, 48], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "ieieep_Out", "text": "Lemma ieieep_Out : EQ A EmptySet.\nProof Build_EQ A EmptySet step1 step2.\n", "definition": " EQ A EmptySet.\n", "proof": "Proof Build_EQ A EmptySet step1 step2.", "proof_term": "Proof Build_EQ A EmptySet step1 step2.", "def_ranges": [2031, 0, 2031, 33], "proof_ranges": [2032, 0, 2032, 38], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "its_empty_implies_equals_emptyset", "text": "Theorem its_empty_implies_equals_emptyset :\n forall (A : Ens) (k : Its_empty A), EQ A EmptySet.\nProof ieieep_Out.\n", "definition": "\n forall (A : Ens) (k : Its_empty A), EQ A EmptySet.\n", "proof": "Proof ieieep_Out.", "proof_term": "Proof ieieep_Out.", "def_ranges": [2036, 0, 2037, 51], "proof_ranges": [2038, 0, 2038, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Its_empty_emptyset", "text": "Theorem Its_empty_emptyset : Its_empty EmptySet.\nProof EmptySet_th1.\n", "definition": " Its_empty EmptySet.\n", "proof": "Proof EmptySet_th1.", "proof_term": "Proof EmptySet_th1.", "def_ranges": [2040, 0, 2040, 48], "proof_ranges": [2041, 0, 2041, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Its_nonempty_th1", "text": "Theorem Its_nonempty_th1 : forall (X A : Ens) (h : IN X A), Its_nonempty A.\n\nProof Its_nonempty_proof_Out.\n", "definition": " forall (X A : Ens) (h : IN X A), Its_nonempty A.\n\n", "proof": "Proof Its_nonempty_proof_Out.", "proof_term": "Proof Its_nonempty_proof_Out.", "def_ranges": [2054, 0, 2054, 75], "proof_ranges": [2055, 0, 2056, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Nothing_strictsub_Zero", "text": "Theorem Nothing_strictsub_Zero : forall X : Ens, ~ StrictSUB X Zero.\nProof nothing_strictsub_Zero_Out.\n", "definition": " forall X : Ens, ~ StrictSUB X Zero.\n", "proof": "Proof nothing_strictsub_Zero_Out.", "proof_term": "Proof nothing_strictsub_Zero_Out.", "def_ranges": [2077, 0, 2077, 68], "proof_ranges": [2078, 0, 2078, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Bounded_th1", "text": "Theorem Bounded_th1 :\n forall (P : Ens -> Prop) (A : Ens) (h : forall X : Ens, P X -> IN X A),\n Bounded P.\nProof Bounded_th1_proof_Out.\n", "definition": "\n forall (P : Ens -> Prop) (A : Ens) (h : forall X : Ens, P X -> IN X A),\n Bounded P.\n", "proof": "Proof Bounded_th1_proof_Out.", "proof_term": "Proof Bounded_th1_proof_Out.", "def_ranges": [2098, 0, 2100, 11], "proof_ranges": [2101, 0, 2101, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Bounded_th2", "text": "Theorem Bounded_th2 :\n forall (P : Ens -> Prop) (A : Ens) (h : Bounded_By A P), Bounded P.\nProof\n  fun (P : Ens -> Prop) (A : Ens) (h : Bounded_By A P) => Bounded_th1 P A h.\n", "definition": "\n forall (P : Ens -> Prop) (A : Ens) (h : Bounded_By A P), Bounded P.\n", "proof": "Proof\n  fun (P : Ens -> Prop) (A : Ens) (h : Bounded_By A P) => Bounded_th1 P A h.", "proof_term": "Proof\n  fun (P : Ens -> Prop) (A : Ens) (h : Bounded_By A P) => Bounded_th1 P A h.", "def_ranges": [2105, 0, 2106, 68], "proof_ranges": [2107, 0, 2108, 76], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Bounded_CHOICE_pr", "text": "Theorem Bounded_CHOICE_pr :\n forall (P : Ens -> Prop) (b : Bounded P), Bounded_By (Bounded_CHOICE P) P.\nProof fun (P : Ens -> Prop) (b : Bounded P) => REPLACEMENT_pr1 P b. \n\n\n\nDefinition SUBPROP (P Q : Ens -> Prop) := forall X : Ens, P X -> Q X.\n", "definition": "\n forall (P : Ens -> Prop) (b : Bounded P), Bounded_By (Bounded_CHOICE P) P.\n", "proof": "Proof fun (P : Ens -> Prop) (b : Bounded P) => REPLACEMENT_pr1 P b. \n\n\n\nDefinition SUBPROP (P Q : Ens -> Prop) := forall X : Ens, P X -> Q X.", "proof_term": "Proof fun (P : Ens -> Prop) (b : Bounded P) => REPLACEMENT_pr1 P b. \n\n\n\nDefinition SUBPROP (P Q : Ens -> Prop) := forall X : Ens, P X -> Q X.", "def_ranges": [2119, 0, 2120, 75], "proof_ranges": [2121, 0, 2125, 69], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Bounded_subprops_th1", "text": "Theorem Bounded_subprops_th1 :\n forall (P Q : Ens -> Prop) (s : SUBPROP P Q) (A : Ens) (h : Bounded_By A Q),\n Bounded_By A P.\nProof Bounded_subprops1_Out.\n", "definition": "\n forall (P Q : Ens -> Prop) (s : SUBPROP P Q) (A : Ens) (h : Bounded_By A Q),\n Bounded_By A P.\n", "proof": "Proof Bounded_subprops1_Out.", "proof_term": "Proof Bounded_subprops1_Out.", "def_ranges": [2147, 0, 2149, 16], "proof_ranges": [2150, 0, 2150, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Bounded_sub2_Out", "text": "Lemma Bounded_sub2_Out : Bounded P.\nProof Bounded_th2 P A step1.\n", "definition": " Bounded P.\n", "proof": "Proof Bounded_th2 P A step1.", "proof_term": "Proof Bounded_th2 P A step1.", "def_ranges": [2163, 0, 2163, 35], "proof_ranges": [2164, 0, 2164, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Bounded_subprops_th2", "text": "Theorem Bounded_subprops_th2 :\n forall (P Q : Ens -> Prop) (s : SUBPROP P Q) (b : Bounded Q), Bounded P.\nProof Bounded_sub2_Out.\n", "definition": "\n forall (P Q : Ens -> Prop) (s : SUBPROP P Q) (b : Bounded Q), Bounded P.\n", "proof": "Proof Bounded_sub2_Out.", "proof_term": "Proof Bounded_sub2_Out.", "def_ranges": [2168, 0, 2169, 73], "proof_ranges": [2170, 0, 2170, 23], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Restriction_bounded", "text": "Theorem Restriction_bounded :\n forall (P : Ens -> Prop) (A : Ens), Bounded (Restriction P A).\nProof restriction_bounded_Out.\n", "definition": "\n forall (P : Ens -> Prop) (A : Ens), Bounded (Restriction P A).\n", "proof": "Proof restriction_bounded_Out.", "proof_term": "Proof restriction_bounded_Out.", "def_ranges": [2194, 0, 2195, 63], "proof_ranges": [2196, 0, 2196, 30], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Set_Of_pr1", "text": "Theorem Set_Of_pr1 :\n forall (A : Ens) (P : Ens -> Prop) (X : Ens),\n Restriction P A X -> IN X (Set_Of A P).\nProof\n  fun (A : Ens) (P : Ens -> Prop) =>\n  REPLACEMENT_pr1 (Restriction P A) (Restriction_bounded P A).\n", "definition": "\n forall (A : Ens) (P : Ens -> Prop) (X : Ens),\n Restriction P A X -> IN X (Set_Of A P).\n", "proof": "Proof\n  fun (A : Ens) (P : Ens -> Prop) =>\n  REPLACEMENT_pr1 (Restriction P A) (Restriction_bounded P A).", "proof_term": "Proof\n  fun (A : Ens) (P : Ens -> Prop) =>\n  REPLACEMENT_pr1 (Restriction P A) (Restriction_bounded P A).", "def_ranges": [2201, 0, 2203, 40], "proof_ranges": [2204, 0, 2206, 62], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Set_Of_pr2", "text": "Theorem Set_Of_pr2 :\n forall (A : Ens) (P : Ens -> Prop) (X : Ens),\n IN X (Set_Of A P) -> Restriction P A X.\nProof\n  fun (A : Ens) (P : Ens -> Prop) =>\n  REPLACEMENT_pr2 (Restriction P A) (Restriction_bounded P A).\n", "definition": "\n forall (A : Ens) (P : Ens -> Prop) (X : Ens),\n IN X (Set_Of A P) -> Restriction P A X.\n", "proof": "Proof\n  fun (A : Ens) (P : Ens -> Prop) =>\n  REPLACEMENT_pr2 (Restriction P A) (Restriction_bounded P A).", "proof_term": "Proof\n  fun (A : Ens) (P : Ens -> Prop) =>\n  REPLACEMENT_pr2 (Restriction P A) (Restriction_bounded P A).", "def_ranges": [2208, 0, 2210, 40], "proof_ranges": [2211, 0, 2213, 62], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Set_Of_th1", "text": "Theorem Set_Of_th1 :\n forall (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X A) (k : P X),\n IN X (Set_Of A P).\nProof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X A) (k : P X) =>\n  Set_Of_pr1 A P X (Build_Restriction P A X k h).\n", "definition": "\n forall (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X A) (k : P X),\n IN X (Set_Of A P).\n", "proof": "Proof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X A) (k : P X) =>\n  Set_Of_pr1 A P X (Build_Restriction P A X k h).", "proof_term": "Proof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X A) (k : P X) =>\n  Set_Of_pr1 A P X (Build_Restriction P A X k h).", "def_ranges": [2215, 0, 2217, 19], "proof_ranges": [2218, 0, 2220, 49], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Set_Of_th2", "text": "Theorem Set_Of_th2 :\n forall (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)), P X.\nProof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)) =>\n  remaining_property P A X (Set_Of_pr2 A P X h).\n", "definition": "\n forall (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)), P X.\n", "proof": "Proof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)) =>\n  remaining_property P A X (Set_Of_pr2 A P X h).", "proof_term": "Proof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)) =>\n  remaining_property P A X (Set_Of_pr2 A P X h).", "def_ranges": [2223, 0, 2224, 75], "proof_ranges": [2225, 0, 2227, 48], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Set_Of_th3", "text": "Theorem Set_Of_th3 :\n forall (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)), IN X A.\nProof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)) =>\n  the_restriction P A X (Set_Of_pr2 A P X h).\n", "definition": "\n forall (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)), IN X A.\n", "proof": "Proof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)) =>\n  the_restriction P A X (Set_Of_pr2 A P X h).", "proof_term": "Proof\n  fun (A : Ens) (P : Ens -> Prop) (X : Ens) (h : IN X (Set_Of A P)) =>\n  the_restriction P A X (Set_Of_pr2 A P X h).", "def_ranges": [2229, 0, 2230, 78], "proof_ranges": [2231, 0, 2233, 45], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Set_Of_th4", "text": "Theorem Set_Of_th4 : forall (A : Ens) (P : Ens -> Prop), SUB (Set_Of A P) A.\nProof Set_Of_th3.\n", "definition": " forall (A : Ens) (P : Ens -> Prop), SUB (Set_Of A P) A.\n", "proof": "Proof Set_Of_th3.", "proof_term": "Proof Set_Of_th3.", "def_ranges": [2235, 0, 2235, 76], "proof_ranges": [2236, 0, 2236, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "intersection_th1", "text": "Theorem intersection_th1 : forall A B : Ens, SUB (intersection A B) A.\nProof\n  fun (A B U : Ens) (i : IN U (intersection A B)) =>\n  Set_Of_th3 A (fun X : Ens => IN X B) U i.\n", "definition": " forall A B : Ens, SUB (intersection A B) A.\n", "proof": "Proof\n  fun (A B U : Ens) (i : IN U (intersection A B)) =>\n  Set_Of_th3 A (fun X : Ens => IN X B) U i.", "proof_term": "Proof\n  fun (A B U : Ens) (i : IN U (intersection A B)) =>\n  Set_Of_th3 A (fun X : Ens => IN X B) U i.", "def_ranges": [2248, 0, 2248, 70], "proof_ranges": [2249, 0, 2251, 43], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "intersection_th2", "text": "Theorem intersection_th2 : forall A B : Ens, SUB (intersection A B) B.\nProof\n  fun (A B U : Ens) (i : IN U (intersection A B)) =>\n  Set_Of_th2 A (fun X : Ens => IN X B) U i.\n", "definition": " forall A B : Ens, SUB (intersection A B) B.\n", "proof": "Proof\n  fun (A B U : Ens) (i : IN U (intersection A B)) =>\n  Set_Of_th2 A (fun X : Ens => IN X B) U i.", "proof_term": "Proof\n  fun (A B U : Ens) (i : IN U (intersection A B)) =>\n  Set_Of_th2 A (fun X : Ens => IN X B) U i.", "def_ranges": [2253, 0, 2253, 70], "proof_ranges": [2254, 0, 2256, 43], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "intersection_th3", "text": "Theorem intersection_th3 :\n forall (A B X : Ens) (i : IN X A) (j : IN X B), IN X (intersection A B).\nProof\n  fun (A B X : Ens) (i : IN X A) (j : IN X B) =>\n  Set_Of_th1 A (fun U : Ens => IN U B) X i j.\n", "definition": "\n forall (A B X : Ens) (i : IN X A) (j : IN X B), IN X (intersection A B).\n", "proof": "Proof\n  fun (A B X : Ens) (i : IN X A) (j : IN X B) =>\n  Set_Of_th1 A (fun U : Ens => IN U B) X i j.", "proof_term": "Proof\n  fun (A B X : Ens) (i : IN X A) (j : IN X B) =>\n  Set_Of_th1 A (fun U : Ens => IN U B) X i j.", "def_ranges": [2258, 0, 2259, 73], "proof_ranges": [2260, 0, 2262, 45], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "intersection4_Out", "text": "Lemma intersection4_Out : IN X (intersection A B).\nProof intersection_th3 A B X step1 step2.\n", "definition": " IN X (intersection A B).\n", "proof": "Proof intersection_th3 A B X step1 step2.", "proof_term": "Proof intersection_th3 A B X step1 step2.", "def_ranges": [2276, 0, 2276, 50], "proof_ranges": [2277, 0, 2277, 41], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "intersection_th4", "text": "Theorem intersection_th4 :\n forall (A B C : Ens) (s : SUB C A) (t : SUB C B), SUB C (intersection A B).\nProof intersection4_Out.\n", "definition": "\n forall (A B C : Ens) (s : SUB C A) (t : SUB C B), SUB C (intersection A B).\n", "proof": "Proof intersection4_Out.", "proof_term": "Proof intersection4_Out.", "def_ranges": [2281, 0, 2282, 76], "proof_ranges": [2283, 0, 2283, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Intersection_pr1", "text": "Theorem Intersection_pr1 :\n forall (F : Ens -> Ens) (X : Ens),\n IntersectionProp F X -> IN X (Intersection F).\nProof\n  fun F : Ens -> Ens =>\n  REPLACEMENT_pr1 (IntersectionProp F) (Intersection_Bounded F).\n", "definition": "\n forall (F : Ens -> Ens) (X : Ens),\n IntersectionProp F X -> IN X (Intersection F).\n", "proof": "Proof\n  fun F : Ens -> Ens =>\n  REPLACEMENT_pr1 (IntersectionProp F) (Intersection_Bounded F).", "proof_term": "Proof\n  fun F : Ens -> Ens =>\n  REPLACEMENT_pr1 (IntersectionProp F) (Intersection_Bounded F).", "def_ranges": [2323, 0, 2325, 47], "proof_ranges": [2326, 0, 2328, 64], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Intersection_pr2", "text": "Theorem Intersection_pr2 :\n forall (F : Ens -> Ens) (X : Ens),\n IN X (Intersection F) -> IntersectionProp F X.\nProof\n  fun F : Ens -> Ens =>\n  REPLACEMENT_pr2 (IntersectionProp F) (Intersection_Bounded F).\n", "definition": "\n forall (F : Ens -> Ens) (X : Ens),\n IN X (Intersection F) -> IntersectionProp F X.\n", "proof": "Proof\n  fun F : Ens -> Ens =>\n  REPLACEMENT_pr2 (IntersectionProp F) (Intersection_Bounded F).", "proof_term": "Proof\n  fun F : Ens -> Ens =>\n  REPLACEMENT_pr2 (IntersectionProp F) (Intersection_Bounded F).", "def_ranges": [2330, 0, 2332, 47], "proof_ranges": [2333, 0, 2335, 64], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Intersection_th1", "text": "Theorem Intersection_th1 :\n forall (F : Ens -> Ens) (X : Ens) (h : forall Y : Ens, IN X (F Y)),\n IN X (Intersection F).\nProof Intersection_pr1.\n", "definition": "\n forall (F : Ens -> Ens) (X : Ens) (h : forall Y : Ens, IN X (F Y)),\n IN X (Intersection F).\n", "proof": "Proof Intersection_pr1.", "proof_term": "Proof Intersection_pr1.", "def_ranges": [2338, 0, 2340, 23], "proof_ranges": [2341, 0, 2341, 23], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Intersection_th2", "text": "Theorem Intersection_th2 :\n forall (F : Ens -> Ens) (X Y : Ens) (i : IN X (Intersection F)), IN X (F Y).\nProof\n  fun (F : Ens -> Ens) (X Y : Ens) (i : IN X (Intersection F)) =>\n  Intersection_pr2 F X i Y.\n", "definition": "\n forall (F : Ens -> Ens) (X Y : Ens) (i : IN X (Intersection F)), IN X (F Y).\n", "proof": "Proof\n  fun (F : Ens -> Ens) (X Y : Ens) (i : IN X (Intersection F)) =>\n  Intersection_pr2 F X i Y.", "proof_term": "Proof\n  fun (F : Ens -> Ens) (X Y : Ens) (i : IN X (Intersection F)) =>\n  Intersection_pr2 F X i Y.", "def_ranges": [2343, 0, 2344, 77], "proof_ranges": [2345, 0, 2347, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Singleton_th1", "text": "Theorem Singleton_th1 : forall (X A : Ens) (h : IN X A), SUB (Singleton X) A.\nProof Singleton_th1_sub1_Out.\n", "definition": " forall (X A : Ens) (h : IN X A), SUB (Singleton X) A.\n", "proof": "Proof Singleton_th1_sub1_Out.", "proof_term": "Proof Singleton_th1_sub1_Out.", "def_ranges": [2381, 0, 2381, 77], "proof_ranges": [2382, 0, 2382, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Singleton_th2", "text": "Theorem Singleton_th2 : forall X : Ens, Its_nonempty (Singleton X).\nProof Singleton_th2_proof_Out.\n", "definition": " forall X : Ens, Its_nonempty (Singleton X).\n", "proof": "Proof Singleton_th2_proof_Out.", "proof_term": "Proof Singleton_th2_proof_Out.", "def_ranges": [2399, 0, 2399, 67], "proof_ranges": [2400, 0, 2400, 30], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_th1", "text": "Theorem union_th1 : forall (A B X : Ens) (h : IN X A), IN X (union A B).\nProof union_th1_Out.\n", "definition": " forall (A B X : Ens) (h : IN X A), IN X (union A B).\n", "proof": "Proof union_th1_Out.", "proof_term": "Proof union_th1_Out.", "def_ranges": [2424, 0, 2424, 72], "proof_ranges": [2425, 0, 2425, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_th2", "text": "Theorem union_th2 : forall (A B X : Ens) (h : IN X B), IN X (union A B).\nProof union_th2_Out.\n", "definition": " forall (A B X : Ens) (h : IN X B), IN X (union A B).\n", "proof": "Proof union_th2_Out.", "proof_term": "Proof union_th2_Out.", "def_ranges": [2441, 0, 2441, 72], "proof_ranges": [2442, 0, 2442, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "A_sub_V_proof_Out", "text": "Lemma A_sub_V_proof_Out : IN Z V.\nProof V_pr1 Z step4.\n", "definition": " IN Z V.\n", "proof": "Proof V_pr1 Z step4.", "proof_term": "Proof V_pr1 Z step4.", "def_ranges": [2498, 0, 2498, 33], "proof_ranges": [2499, 0, 2499, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "B_sub_V_proof1_Out", "text": "Lemma B_sub_V_proof1_Out : False. \n\nProof k step1_1.\n", "definition": " False. \n\n", "proof": "Proof k step1_1.", "proof_term": "Proof k step1_1.", "def_ranges": [2518, 0, 2518, 33], "proof_ranges": [2518, 34, 2519, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_th3_proof_Out", "text": "Lemma union_th3_proof_Out : False.\nProof step6 step7.\n", "definition": " False.\n", "proof": "Proof step6 step7.", "proof_term": "Proof step6 step7.", "def_ranges": [2552, 0, 2552, 34], "proof_ranges": [2553, 0, 2553, 18], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_th3", "text": "Theorem union_th3 :\n forall (A B X : Ens) (h : ~ IN X A) (k : ~ IN X B), ~ IN X (union A B).\nProof union_th3_proof_Out.\n", "definition": "\n forall (A B X : Ens) (h : ~ IN X A) (k : ~ IN X B), ~ IN X (union A B).\n", "proof": "Proof union_th3_proof_Out.", "proof_term": "Proof union_th3_proof_Out.", "def_ranges": [2557, 0, 2558, 72], "proof_ranges": [2559, 0, 2559, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "step2", "text": "Lemma  (*Fact*) step2 : False.\nProof contra step1.\n", "definition": " False.\n", "proof": "Proof contra step1.", "proof_term": "Proof contra step1.", "def_ranges": [2575, 0, 2575, 30], "proof_ranges": [2576, 0, 2576, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "step5", "text": "Lemma  (*Fact*) step5 : False.\nProof contra step4.\n", "definition": " False.\n", "proof": "Proof contra step4.", "proof_term": "Proof contra step4.", "def_ranges": [2585, 0, 2585, 30], "proof_ranges": [2586, 0, 2586, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "step8", "text": "Lemma  (*Fact*) step8 : False.\nProof step7 i.\n", "definition": " False.\n", "proof": "Proof step7 i.", "proof_term": "Proof step7 i.", "def_ranges": [2593, 0, 2593, 30], "proof_ranges": [2594, 0, 2594, 14], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_th4_Out", "text": "Lemma union_th4_Out : P.\nProof excluded_middle P step8.\n", "definition": " P.\n", "proof": "Proof excluded_middle P step8.", "proof_term": "Proof excluded_middle P step8.", "def_ranges": [2598, 0, 2598, 24], "proof_ranges": [2599, 0, 2599, 30], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_th4", "text": "Theorem union_th4 :\n forall (P : Prop) (A B X : Ens) (i : IN X (union A B)) \n   (a : IN X A -> P) (b : IN X B -> P), P.\nProof union_th4_Out.\n", "definition": "\n forall (P : Prop) (A B X : Ens) (i : IN X (union A B)) \n   (a : IN X A -> P) (b : IN X B -> P), P.\n", "proof": "Proof union_th4_Out.", "proof_term": "Proof union_th4_Out.", "def_ranges": [2603, 0, 2605, 42], "proof_ranges": [2606, 0, 2606, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_refl_proof_Out", "text": "Lemma union_refl_proof_Out : EQ A U.\nProof Build_EQ A U step1 step3.\n", "definition": " EQ A U.\n", "proof": "Proof Build_EQ A U step1 step3.", "proof_term": "Proof Build_EQ A U step1 step3.", "def_ranges": [2620, 0, 2620, 36], "proof_ranges": [2621, 0, 2621, 31], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_refl", "text": "Theorem union_refl : forall A : Ens, EQ A (union A A).\nProof union_refl_proof_Out.\n", "definition": " forall A : Ens, EQ A (union A A).\n", "proof": "Proof union_refl_proof_Out.", "proof_term": "Proof union_refl_proof_Out.", "def_ranges": [2625, 0, 2625, 54], "proof_ranges": [2626, 0, 2626, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_symm_proof_Out", "text": "Lemma union_symm_proof_Out : EQ U V.\nProof Build_EQ U V step5 step6.\n", "definition": " EQ U V.\n", "proof": "Proof Build_EQ U V step5 step6.", "proof_term": "Proof Build_EQ U V step5 step6.", "def_ranges": [2649, 0, 2649, 36], "proof_ranges": [2650, 0, 2650, 31], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_symm", "text": "Theorem union_symm : forall A B : Ens, EQ (union A B) (union B A).\nProof union_symm_proof_Out.\n", "definition": " forall A B : Ens, EQ (union A B) (union B A).\n", "proof": "Proof union_symm_proof_Out.", "proof_term": "Proof union_symm_proof_Out.", "def_ranges": [2654, 0, 2654, 66], "proof_ranges": [2655, 0, 2655, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Union_pr1", "text": "Theorem Union_pr1 :\n forall (F X : Ens) (h : EXISTS (fun U : Ens => nested_IN X U F)),\n IN X (Union F).\nProof\n  fun (F X : Ens) (h : EXISTS (fun U : Ens => nested_IN X U F)) =>\n  REPLACEMENT_pr1 (b_in_Union_a F) (Union_bounded F) X h.\n", "definition": "\n forall (F X : Ens) (h : EXISTS (fun U : Ens => nested_IN X U F)),\n IN X (Union F).\n", "proof": "Proof\n  fun (F X : Ens) (h : EXISTS (fun U : Ens => nested_IN X U F)) =>\n  REPLACEMENT_pr1 (b_in_Union_a F) (Union_bounded F) X h.", "proof_term": "Proof\n  fun (F X : Ens) (h : EXISTS (fun U : Ens => nested_IN X U F)) =>\n  REPLACEMENT_pr1 (b_in_Union_a F) (Union_bounded F) X h.", "def_ranges": [2664, 0, 2666, 16], "proof_ranges": [2667, 0, 2669, 57], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Union_pr2", "text": "Theorem Union_pr2 :\n forall (F X : Ens) (i : IN X (Union F)),\n EXISTS (fun U : Ens => nested_IN X U F).\nProof fun F : Ens => REPLACEMENT_pr2 (b_in_Union_a F) (Union_bounded F).\n", "definition": "\n forall (F X : Ens) (i : IN X (Union F)),\n EXISTS (fun U : Ens => nested_IN X U F).\n", "proof": "Proof fun F : Ens => REPLACEMENT_pr2 (b_in_Union_a F) (Union_bounded F).", "proof_term": "Proof fun F : Ens => REPLACEMENT_pr2 (b_in_Union_a F) (Union_bounded F).", "def_ranges": [2672, 0, 2674, 41], "proof_ranges": [2675, 0, 2675, 72], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Union_intermediate_pr", "text": "Theorem Union_intermediate_pr :\n forall (F X : Ens) (i : IN X (Union F)),\n nested_IN X (Union_intermediate F X i) F.\nProof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  CHOICE_pr (fun U : Ens => nested_IN X U F) (Union_pr2 F X i).\n", "definition": "\n forall (F X : Ens) (i : IN X (Union F)),\n nested_IN X (Union_intermediate F X i) F.\n", "proof": "Proof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  CHOICE_pr (fun U : Ens => nested_IN X U F) (Union_pr2 F X i).", "proof_term": "Proof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  CHOICE_pr (fun U : Ens => nested_IN X U F) (Union_pr2 F X i).", "def_ranges": [2680, 0, 2682, 42], "proof_ranges": [2683, 0, 2685, 63], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Union_intermediate_th1", "text": "Theorem Union_intermediate_th1 :\n forall (F X : Ens) (i : IN X (Union F)), IN X (Union_intermediate F X i).\nProof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  nested_IN_ab X (Union_intermediate F X i) F (Union_intermediate_pr F X i).\n", "definition": "\n forall (F X : Ens) (i : IN X (Union F)), IN X (Union_intermediate F X i).\n", "proof": "Proof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  nested_IN_ab X (Union_intermediate F X i) F (Union_intermediate_pr F X i).", "proof_term": "Proof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  nested_IN_ab X (Union_intermediate F X i) F (Union_intermediate_pr F X i).", "def_ranges": [2687, 0, 2688, 74], "proof_ranges": [2689, 0, 2691, 76], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Union_intermediate_th2", "text": "Theorem Union_intermediate_th2 :\n forall (F X : Ens) (i : IN X (Union F)), IN (Union_intermediate F X i) F.\nProof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  nested_IN_bc X (Union_intermediate F X i) F (Union_intermediate_pr F X i).\n", "definition": "\n forall (F X : Ens) (i : IN X (Union F)), IN (Union_intermediate F X i) F.\n", "proof": "Proof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  nested_IN_bc X (Union_intermediate F X i) F (Union_intermediate_pr F X i).", "proof_term": "Proof\n  fun (F X : Ens) (i : IN X (Union F)) =>\n  nested_IN_bc X (Union_intermediate F X i) F (Union_intermediate_pr F X i).", "def_ranges": [2693, 0, 2694, 74], "proof_ranges": [2695, 0, 2697, 76], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "union_th1_OutA", "text": "Lemma union_th1_OutA : IN X (Union F).\nProof Union_pr1 F X step2.\n", "definition": " IN X (Union F).\n", "proof": "Proof Union_pr1 F X step2.", "proof_term": "Proof Union_pr1 F X step2.", "def_ranges": [2713, 0, 2713, 38], "proof_ranges": [2714, 0, 2714, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Union_th1", "text": "Theorem Union_th1 :\n forall (F X U : Ens) (h : IN X U) (k : IN U F), IN X (Union F).\nProof union_th1_OutA.\n", "definition": "\n forall (F X U : Ens) (h : IN X U) (k : IN U F), IN X (Union F).\n", "proof": "Proof union_th1_OutA.", "proof_term": "Proof union_th1_OutA.", "def_ranges": [2718, 0, 2719, 64], "proof_ranges": [2720, 0, 2720, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "zero_has_leq_0_elements", "text": "Theorem zero_has_leq_0_elements : has_leq_0_elements Zero.\nProof EmptySet_th1.\n", "definition": " has_leq_0_elements Zero.\n", "proof": "Proof EmptySet_th1.", "proof_term": "Proof EmptySet_th1.", "def_ranges": [2731, 0, 2731, 58], "proof_ranges": [2732, 0, 2732, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Choose_an_element_pr", "text": "Theorem Choose_an_element_pr :\n forall (A : Ens) (k : has_geq_1_elements A), IN (Choose_an_element A k) A.\nProof\n  fun (A : Ens) (k : has_geq_1_elements A) =>\n  CHOICE_pr (fun X : Ens => IN X A) k.\n", "definition": "\n forall (A : Ens) (k : has_geq_1_elements A), IN (Choose_an_element A k) A.\n", "proof": "Proof\n  fun (A : Ens) (k : has_geq_1_elements A) =>\n  CHOICE_pr (fun X : Ens => IN X A) k.", "proof_term": "Proof\n  fun (A : Ens) (k : has_geq_1_elements A) =>\n  CHOICE_pr (fun X : Ens => IN X A) k.", "def_ranges": [2741, 0, 2742, 75], "proof_ranges": [2743, 0, 2745, 38], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "has_geq_1_elements_th1", "text": "Theorem has_geq_1_elements_th1 :\n forall (A X : Ens) (k : IN X A), has_geq_1_elements A.\nProof given_an_element_Out.\n", "definition": "\n forall (A X : Ens) (k : IN X A), has_geq_1_elements A.\n", "proof": "Proof given_an_element_Out.", "proof_term": "Proof given_an_element_Out.", "def_ranges": [2757, 0, 2758, 55], "proof_ranges": [2759, 0, 2759, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Singletons_have_geq_1_elements", "text": "Theorem Singletons_have_geq_1_elements :\n forall X : Ens, has_geq_1_elements (Singleton X).\nProof Singleton_th2.\n", "definition": "\n forall X : Ens, has_geq_1_elements (Singleton X).\n", "proof": "Proof Singleton_th2.", "proof_term": "Proof Singleton_th2.", "def_ranges": [2765, 0, 2766, 50], "proof_ranges": [2767, 0, 2767, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "has_leq_0_elements_implies_leq_1", "text": "Theorem has_leq_0_elements_implies_leq_1 :\n forall (A : Ens) (q : has_leq_0_elements A), has_leq_1_elements A.\nProof has_leq_0_implies_leq_1_Out. \n\n\n\nSection singletons_have_leq_1_elements_proof.\n", "definition": "\n forall (A : Ens) (q : has_leq_0_elements A), has_leq_1_elements A.\n", "proof": "Proof has_leq_0_implies_leq_1_Out. \n\n\n\nSection singletons_have_leq_1_elements_proof.", "proof_term": "Proof has_leq_0_implies_leq_1_Out. \n\n\n\nSection singletons_have_leq_1_elements_proof.", "def_ranges": [2792, 0, 2793, 67], "proof_ranges": [2794, 0, 2798, 45], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Singletons_have_leq_1_elements", "text": "Theorem Singletons_have_leq_1_elements :\n forall A : Ens, has_leq_1_elements (Singleton A).\nProof singletons_have_leq_1_elements_Out.\n", "definition": "\n forall A : Ens, has_leq_1_elements (Singleton A).\n", "proof": "Proof singletons_have_leq_1_elements_Out.", "proof_term": "Proof singletons_have_leq_1_elements_Out.", "def_ranges": [2820, 0, 2821, 50], "proof_ranges": [2822, 0, 2822, 41], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "has_geq_2_elements_th1", "text": "Theorem has_geq_2_elements_th1 :\n forall (A X Y : Ens) (k : IN X A) (l : IN Y A) (m : ~ EQ X Y),\n has_geq_2_elements A.\nProof when_given_two_distinct_elements_Out.\n", "definition": "\n forall (A X Y : Ens) (k : IN X A) (l : IN Y A) (m : ~ EQ X Y),\n has_geq_2_elements A.\n", "proof": "Proof when_given_two_distinct_elements_Out.", "proof_term": "Proof when_given_two_distinct_elements_Out.", "def_ranges": [2841, 0, 2843, 22], "proof_ranges": [2844, 0, 2844, 43], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Doubleton_th1", "text": "Theorem Doubleton_th1 : forall X Y : Ens, IN X (Doubleton X Y).\nProof doubleton_th1_Out.\n", "definition": " forall X Y : Ens, IN X (Doubleton X Y).\n", "proof": "Proof doubleton_th1_Out.", "proof_term": "Proof doubleton_th1_Out.", "def_ranges": [2870, 0, 2870, 63], "proof_ranges": [2871, 0, 2871, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Doubleton_th2", "text": "Theorem Doubleton_th2 : forall X Y : Ens, IN Y (Doubleton X Y).\nProof doubleton_th2_Out.\n", "definition": " forall X Y : Ens, IN Y (Doubleton X Y).\n", "proof": "Proof doubleton_th2_Out.", "proof_term": "Proof doubleton_th2_Out.", "def_ranges": [2887, 0, 2887, 63], "proof_ranges": [2888, 0, 2888, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Doubleton_th3", "text": "Theorem Doubleton_th3 :\n forall (X Y A : Ens) (iXA : IN X A) (iYA : IN Y A), SUB (Doubleton X Y) A.\nProof doubleton_th3_Out.\n", "definition": "\n forall (X Y A : Ens) (iXA : IN X A) (iYA : IN Y A), SUB (Doubleton X Y) A.\n", "proof": "Proof doubleton_th3_Out.", "proof_term": "Proof doubleton_th3_Out.", "def_ranges": [2908, 0, 2909, 75], "proof_ranges": [2910, 0, 2910, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Doubleton_th4", "text": "Theorem Doubleton_th4 :\n forall (X Y Z : Ens) (k : IN Z (Doubleton X Y)) (m : ~ EQ Z X)\n   (n : ~ EQ Z Y), False.\nProof doubleton_th4_Out.\n", "definition": "\n forall (X Y Z : Ens) (k : IN Z (Doubleton X Y)) (m : ~ EQ Z X)\n   (n : ~ EQ Z Y), False.\n", "proof": "Proof doubleton_th4_Out.", "proof_term": "Proof doubleton_th4_Out.", "def_ranges": [2958, 0, 2960, 25], "proof_ranges": [2961, 0, 2961, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Doubleton_th4_a", "text": "Theorem Doubleton_th4_a :\n forall (X Y Z : Ens) (k : IN Z (Doubleton X Y)) (m : ~ EQ Z X), EQ Z Y.\nProof doubleton_th4a_Out.\n", "definition": "\n forall (X Y Z : Ens) (k : IN Z (Doubleton X Y)) (m : ~ EQ Z X), EQ Z Y.\n", "proof": "Proof doubleton_th4a_Out.", "proof_term": "Proof doubleton_th4a_Out.", "def_ranges": [2976, 0, 2977, 72], "proof_ranges": [2978, 0, 2978, 25], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Doubleton_th4_b", "text": "Theorem Doubleton_th4_b :\n forall (X Y Z : Ens) (k : IN Z (Doubleton X Y)) (n : ~ EQ Z Y), EQ Z X.\nProof doubleton_th4b_Out.\n", "definition": "\n forall (X Y Z : Ens) (k : IN Z (Doubleton X Y)) (n : ~ EQ Z Y), EQ Z X.\n", "proof": "Proof doubleton_th4b_Out.", "proof_term": "Proof doubleton_th4b_Out.", "def_ranges": [2993, 0, 2994, 72], "proof_ranges": [2995, 0, 2995, 25], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "distinct_Doubletons_have_geq_2_elements", "text": "Theorem distinct_Doubletons_have_geq_2_elements :\n forall (X Y : Ens) (n : ~ EQ X Y), has_geq_2_elements (Doubleton X Y).\nProof distinct_doubletons_have_geq_2_elements_Out.\n", "definition": "\n forall (X Y : Ens) (n : ~ EQ X Y), has_geq_2_elements (Doubleton X Y).\n", "proof": "Proof distinct_doubletons_have_geq_2_elements_Out.", "proof_term": "Proof distinct_doubletons_have_geq_2_elements_Out.", "def_ranges": [3017, 0, 3018, 71], "proof_ranges": [3019, 0, 3019, 50], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Big_Extensionality", "text": "Theorem Big_Extensionality :\n forall (P : Ens -> Prop) (X Y : Ens) (p : P X) (e : EQ X Y), P Y.\nProof big_extensionality_Out.\n", "definition": "\n forall (P : Ens -> Prop) (X Y : Ens) (p : P X) (e : EQ X Y), P Y.\n", "proof": "Proof big_extensionality_Out.", "proof_term": "Proof big_extensionality_Out.", "def_ranges": [3054, 0, 3055, 66], "proof_ranges": [3056, 0, 3056, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Substitute", "text": "Theorem Substitute :\n forall (X Y : Ens) (P : Ens -> Prop) (e : EQ X Y) (p : P Y), P X.\nProof\n  fun (X Y : Ens) (P : Ens -> Prop) (e : EQ X Y) (p : P Y) =>\n  Big_Extensionality P Y X p (EQ_symm X Y e).\n", "definition": "\n forall (X Y : Ens) (P : Ens -> Prop) (e : EQ X Y) (p : P Y), P X.\n", "proof": "Proof\n  fun (X Y : Ens) (P : Ens -> Prop) (e : EQ X Y) (p : P Y) =>\n  Big_Extensionality P Y X p (EQ_symm X Y e).", "proof_term": "Proof\n  fun (X Y : Ens) (P : Ens -> Prop) (e : EQ X Y) (p : P Y) =>\n  Big_Extensionality P Y X p (EQ_symm X Y e).", "def_ranges": [3060, 0, 3061, 66], "proof_ranges": [3062, 0, 3064, 45], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "counting_lem1", "text": "Theorem counting_lem1 :\n forall (X Y : Ens) (m : has_leq_0_elements X) (n : has_geq_1_elements Y),\n ~ EQ X Y.\nProof zero_different_from_one_Out.\n", "definition": "\n forall (X Y : Ens) (m : has_leq_0_elements X) (n : has_geq_1_elements Y),\n ~ EQ X Y.\n", "proof": "Proof zero_different_from_one_Out.", "proof_term": "Proof zero_different_from_one_Out.", "def_ranges": [3084, 0, 3086, 10], "proof_ranges": [3087, 0, 3087, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "counting_lem2", "text": "Theorem counting_lem2 :\n forall (X Y : Ens) (m : has_leq_1_elements X) (n : has_geq_2_elements Y),\n ~ EQ X Y.\nProof one_different_from_two_Out.\n", "definition": "\n forall (X Y : Ens) (m : has_leq_1_elements X) (n : has_geq_2_elements Y),\n ~ EQ X Y.\n", "proof": "Proof one_different_from_two_Out.", "proof_term": "Proof one_different_from_two_Out.", "def_ranges": [3105, 0, 3107, 10], "proof_ranges": [3108, 0, 3108, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "First_uniqueness", "text": "Theorem First_uniqueness :\n forall (A B : Ens) (m : EQ (First A) (First B)), EQ A B.\nProof first_uniqueness_Out.\n", "definition": "\n forall (A B : Ens) (m : EQ (First A) (First B)), EQ A B.\n", "proof": "Proof first_uniqueness_Out.", "proof_term": "Proof first_uniqueness_Out.", "def_ranges": [3141, 0, 3142, 57], "proof_ranges": [3143, 0, 3143, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Singleton_uniqueness", "text": "Theorem Singleton_uniqueness :\n forall (A B : Ens) (m : EQ (Singleton A) (Singleton B)), EQ A B.\nProof First_uniqueness.\n", "definition": "\n forall (A B : Ens) (m : EQ (Singleton A) (Singleton B)), EQ A B.\n", "proof": "Proof First_uniqueness.", "proof_term": "Proof First_uniqueness.", "def_ranges": [3145, 0, 3146, 65], "proof_ranges": [3147, 0, 3147, 23], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Doubleton_uniqueness", "text": "Theorem Doubleton_uniqueness :\n forall (P : Ens -> Prop) (A B C D : Ens) (pA : P A) \n   (nB : ~ P B) (pC : P C) (nD : ~ P D)\n   (e : EQ (Doubleton A B) (Doubleton C D)), pairwise_EQ A B C D.\nProof doubleton_uniqueness_Out.\n", "definition": "\n forall (P : Ens -> Prop) (A B C D : Ens) (pA : P A) \n   (nB : ~ P B) (pC : P C) (nD : ~ P D)\n   (e : EQ (Doubleton A B) (Doubleton C D)), pairwise_EQ A B C D.\n", "proof": "Proof doubleton_uniqueness_Out.", "proof_term": "Proof doubleton_uniqueness_Out.", "def_ranges": [3245, 0, 3248, 65], "proof_ranges": [3249, 0, 3249, 31], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Second_has_geq_2_elements", "text": "Theorem Second_has_geq_2_elements :\n forall A : Ens, has_geq_2_elements (Second A).\nProof second_has_geq_2_elements_Out.\n", "definition": "\n forall A : Ens, has_geq_2_elements (Second A).\n", "proof": "Proof second_has_geq_2_elements_Out.", "proof_term": "Proof second_has_geq_2_elements_Out.", "def_ranges": [3281, 0, 3282, 47], "proof_ranges": [3283, 0, 3283, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Second_uniqueness", "text": "Theorem Second_uniqueness :\n forall (A B : Ens) (k : EQ (Second A) (Second B)), EQ A B.\nProof second_uniqueness_Out.\n", "definition": "\n forall (A B : Ens) (k : EQ (Second A) (Second B)), EQ A B.\n", "proof": "Proof second_uniqueness_Out.", "proof_term": "Proof second_uniqueness_Out.", "def_ranges": [3314, 0, 3315, 59], "proof_ranges": [3316, 0, 3316, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_uniqueness", "text": "Theorem PAIR_uniqueness :\n forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), pairwise_EQ A B C D.\nProof pair_uniqueness_Out.\n", "definition": "\n forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), pairwise_EQ A B C D.\n", "proof": "Proof pair_uniqueness_Out.", "proof_term": "Proof pair_uniqueness_Out.", "def_ranges": [3357, 0, 3358, 76], "proof_ranges": [3359, 0, 3359, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_uni_ac", "text": "Theorem PAIR_uni_ac :\n forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), EQ A C.\nProof\n  fun (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)) =>\n  pairwise_EQ_ac A B C D (PAIR_uniqueness A B C D e).\n", "definition": "\n forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), EQ A C.\n", "proof": "Proof\n  fun (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)) =>\n  pairwise_EQ_ac A B C D (PAIR_uniqueness A B C D e).", "proof_term": "Proof\n  fun (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)) =>\n  pairwise_EQ_ac A B C D (PAIR_uniqueness A B C D e).", "def_ranges": [3364, 0, 3365, 63], "proof_ranges": [3366, 0, 3368, 53], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_uni_bd", "text": "Theorem PAIR_uni_bd :\n forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), EQ B D.\nProof\n  fun (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)) =>\n  pairwise_EQ_bd A B C D (PAIR_uniqueness A B C D e).\n", "definition": "\n forall (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)), EQ B D.\n", "proof": "Proof\n  fun (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)) =>\n  pairwise_EQ_bd A B C D (PAIR_uniqueness A B C D e).", "proof_term": "Proof\n  fun (A B C D : Ens) (e : EQ (PAIR A B) (PAIR C D)) =>\n  pairwise_EQ_bd A B C D (PAIR_uniqueness A B C D e).", "def_ranges": [3371, 0, 3372, 63], "proof_ranges": [3373, 0, 3375, 53], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "a_pair_is_a_pair", "text": "Theorem a_pair_is_a_pair : forall A B : Ens, is_a_pair (PAIR A B).\nProof a_pair_is_a_pair_Out.\n", "definition": " forall A B : Ens, is_a_pair (PAIR A B).\n", "proof": "Proof a_pair_is_a_pair_Out.", "proof_term": "Proof a_pair_is_a_pair_Out.", "def_ranges": [3398, 0, 3398, 66], "proof_ranges": [3399, 0, 3399, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "a_pair_is_a_pair_th2", "text": "Theorem a_pair_is_a_pair_th2 :\n forall (A B U : Ens) (i : EQ (PAIR A B) U), is_a_pair U.\nProof\n  fun (A B U : Ens) (i : EQ (PAIR A B) U) =>\n  Big_Extensionality (fun V : Ens => is_a_pair V) (PAIR A B) U\n    (a_pair_is_a_pair A B) i.\n", "definition": "\n forall (A B U : Ens) (i : EQ (PAIR A B) U), is_a_pair U.\n", "proof": "Proof\n  fun (A B U : Ens) (i : EQ (PAIR A B) U) =>\n  Big_Extensionality (fun V : Ens => is_a_pair V) (PAIR A B) U\n    (a_pair_is_a_pair A B) i.", "proof_term": "Proof\n  fun (A B U : Ens) (i : EQ (PAIR A B) U) =>\n  Big_Extensionality (fun V : Ens => is_a_pair V) (PAIR A B) U\n    (a_pair_is_a_pair A B) i.", "def_ranges": [3401, 0, 3402, 57], "proof_ranges": [3403, 0, 3406, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_proj1_pr1", "text": "Theorem PAIR_proj1_pr1 :\n forall (M : Ens) (p : is_a_pair M),\n EXISTS (fun B : Ens => EQ M (PAIR (PR1 M) B)).\n Proof\n   fun (M : Ens) (p : is_a_pair M) =>\n   CHOICE_pr (fun A : Ens => EXISTS (fun B : Ens => EQ M (PAIR A B))) p.\n", "definition": "\n forall (M : Ens) (p : is_a_pair M),\n EXISTS (fun B : Ens => EQ M (PAIR (PR1 M) B)).\n ", "proof": "Proof\n   fun (M : Ens) (p : is_a_pair M) =>\n   CHOICE_pr (fun A : Ens => EXISTS (fun B : Ens => EQ M (PAIR A B))) p.", "proof_term": "Proof\n   fun (M : Ens) (p : is_a_pair M) =>\n   CHOICE_pr (fun A : Ens => EXISTS (fun B : Ens => EQ M (PAIR A B))) p.", "def_ranges": [3415, 0, 3417, 47], "proof_ranges": [3418, 0, 3420, 72], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_proj_th1", "text": "Theorem PAIR_proj_th1 :\n forall (M : Ens) (p : is_a_pair M), EQ M (PAIR (PR1 M) (PR2 M)).\nProof\n  fun (M : Ens) (p : is_a_pair M) =>\n  CHOICE_pr (fun B : Ens => EQ M (PAIR (PR1 M) B)) (PAIR_proj1_pr1 M p).\n", "definition": "\n forall (M : Ens) (p : is_a_pair M), EQ M (PAIR (PR1 M) (PR2 M)).\n", "proof": "Proof\n  fun (M : Ens) (p : is_a_pair M) =>\n  CHOICE_pr (fun B : Ens => EQ M (PAIR (PR1 M) B)) (PAIR_proj1_pr1 M p).", "proof_term": "Proof\n  fun (M : Ens) (p : is_a_pair M) =>\n  CHOICE_pr (fun B : Ens => EQ M (PAIR (PR1 M) B)) (PAIR_proj1_pr1 M p).", "def_ranges": [3425, 0, 3426, 65], "proof_ranges": [3427, 0, 3429, 72], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "pair_proj2_Out", "text": "Lemma pair_proj2_Out : pairwise_EQ X Y (PR1 M) (PR2 M).\nProof PAIR_uniqueness X Y (PR1 M) (PR2 M) step2.\n", "definition": " pairwise_EQ X Y (PR1 M) (PR2 M).\n", "proof": "Proof PAIR_uniqueness X Y (PR1 M) (PR2 M) step2.", "proof_term": "Proof PAIR_uniqueness X Y (PR1 M) (PR2 M) step2.", "def_ranges": [3442, 0, 3442, 55], "proof_ranges": [3443, 0, 3443, 48], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_proj_th2", "text": "Theorem PAIR_proj_th2 :\n forall X Y : Ens, pairwise_EQ X Y (PR1 (PAIR X Y)) (PR2 (PAIR X Y)).\nProof pair_proj2_Out.\n", "definition": "\n forall X Y : Ens, pairwise_EQ X Y (PR1 (PAIR X Y)) (PR2 (PAIR X Y)).\n", "proof": "Proof pair_proj2_Out.", "proof_term": "Proof pair_proj2_Out.", "def_ranges": [3447, 0, 3448, 69], "proof_ranges": [3449, 0, 3449, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_proj_th3", "text": "Theorem PAIR_proj_th3 : forall X Y : Ens, EQ X (PR1 (PAIR X Y)).\nProof\n  fun X Y : Ens =>\n  pairwise_EQ_ac X Y (PR1 (PAIR X Y)) (PR2 (PAIR X Y)) (PAIR_proj_th2 X Y).\n", "definition": " forall X Y : Ens, EQ X (PR1 (PAIR X Y)).\n", "proof": "Proof\n  fun X Y : Ens =>\n  pairwise_EQ_ac X Y (PR1 (PAIR X Y)) (PR2 (PAIR X Y)) (PAIR_proj_th2 X Y).", "proof_term": "Proof\n  fun X Y : Ens =>\n  pairwise_EQ_ac X Y (PR1 (PAIR X Y)) (PR2 (PAIR X Y)) (PAIR_proj_th2 X Y).", "def_ranges": [3451, 0, 3451, 64], "proof_ranges": [3452, 0, 3454, 75], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_proj_th4", "text": "Theorem PAIR_proj_th4 : forall X Y : Ens, EQ Y (PR2 (PAIR X Y)).\nProof\n  fun X Y : Ens =>\n  pairwise_EQ_bd X Y (PR1 (PAIR X Y)) (PR2 (PAIR X Y)) (PAIR_proj_th2 X Y).\n", "definition": " forall X Y : Ens, EQ Y (PR2 (PAIR X Y)).\n", "proof": "Proof\n  fun X Y : Ens =>\n  pairwise_EQ_bd X Y (PR1 (PAIR X Y)) (PR2 (PAIR X Y)) (PAIR_proj_th2 X Y).", "proof_term": "Proof\n  fun X Y : Ens =>\n  pairwise_EQ_bd X Y (PR1 (PAIR X Y)) (PR2 (PAIR X Y)) (PAIR_proj_th2 X Y).", "def_ranges": [3456, 0, 3456, 64], "proof_ranges": [3457, 0, 3459, 75], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PAIR_proj_uni", "text": "Theorem PAIR_proj_uni :\n forall (M : Ens) (m : is_a_pair M) (N : Ens) (n : is_a_pair N)\n   (e : EQ (PR1 M) (PR1 N)) (f : EQ (PR2 M) (PR2 N)), \n EQ M N.\nProof PAIR_proj_uni_Out.\n", "definition": "\n forall (M : Ens) (m : is_a_pair M) (N : Ens) (n : is_a_pair N)\n   (e : EQ (PR1 M) (PR1 N)) (f : EQ (PR2 M) (PR2 N)), \n EQ M N.\n", "proof": "Proof PAIR_proj_uni_Out.", "proof_term": "Proof PAIR_proj_uni_Out.", "def_ranges": [3508, 0, 3511, 8], "proof_ranges": [3512, 0, 3512, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_pr1", "text": "Theorem Powerset_pr1 : forall (X Y : Ens) (h : SUB Y X), IN Y (Powerset X).\nProof\n  fun X : Ens =>\n  REPLACEMENT_pr1 (fun Y : Ens => SUB Y X) (Powerset_bounded X).\n", "definition": " forall (X Y : Ens) (h : SUB Y X), IN Y (Powerset X).\n", "proof": "Proof\n  fun X : Ens =>\n  REPLACEMENT_pr1 (fun Y : Ens => SUB Y X) (Powerset_bounded X).", "proof_term": "Proof\n  fun X : Ens =>\n  REPLACEMENT_pr1 (fun Y : Ens => SUB Y X) (Powerset_bounded X).", "def_ranges": [3524, 0, 3524, 75], "proof_ranges": [3525, 0, 3527, 64], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_pr2", "text": "Theorem Powerset_pr2 : forall (X Y : Ens) (i : IN Y (Powerset X)), SUB Y X.\nProof\n  fun X : Ens =>\n  REPLACEMENT_pr2 (fun Y : Ens => SUB Y X) (Powerset_bounded X).\n", "definition": " forall (X Y : Ens) (i : IN Y (Powerset X)), SUB Y X.\n", "proof": "Proof\n  fun X : Ens =>\n  REPLACEMENT_pr2 (fun Y : Ens => SUB Y X) (Powerset_bounded X).", "proof_term": "Proof\n  fun X : Ens =>\n  REPLACEMENT_pr2 (fun Y : Ens => SUB Y X) (Powerset_bounded X).", "def_ranges": [3529, 0, 3529, 75], "proof_ranges": [3530, 0, 3532, 64], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "power0_Out", "text": "Lemma power0_Out : IN Zero (Powerset A).\nProof Powerset_pr1 A Zero step1.\n", "definition": " IN Zero (Powerset A).\n", "proof": "Proof Powerset_pr1 A Zero step1.", "proof_term": "Proof Powerset_pr1 A Zero step1.", "def_ranges": [3541, 0, 3541, 40], "proof_ranges": [3542, 0, 3542, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_th1", "text": "Theorem Powerset_th1 : forall A : Ens, IN Zero (Powerset A).\nProof power0_Out.\n", "definition": " forall A : Ens, IN Zero (Powerset A).\n", "proof": "Proof power0_Out.", "proof_term": "Proof power0_Out.", "def_ranges": [3545, 0, 3545, 60], "proof_ranges": [3546, 0, 3546, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "power1_Out1", "text": "Lemma power1_Out1 : IN (union X Y) (Powerset A).\nProof Powerset_pr1 A (union X Y) step3.\n", "definition": " IN (union X Y) (Powerset A).\n", "proof": "Proof Powerset_pr1 A (union X Y) step3.", "proof_term": "Proof Powerset_pr1 A (union X Y) step3.", "def_ranges": [3562, 0, 3562, 48], "proof_ranges": [3563, 0, 3563, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "power1_Out2", "text": "Lemma power1_Out2 : IN (intersection X Y) (Powerset A).\nProof Powerset_pr1 A (intersection X Y) step5.\n", "definition": " IN (intersection X Y) (Powerset A).\n", "proof": "Proof Powerset_pr1 A (intersection X Y) step5.", "proof_term": "Proof Powerset_pr1 A (intersection X Y) step5.", "def_ranges": [3571, 0, 3571, 55], "proof_ranges": [3572, 0, 3572, 46], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_th2", "text": "Theorem Powerset_th2 :\n forall (A X Y : Ens) (x : IN X (Powerset A)) (y : IN Y (Powerset A)),\n IN (union X Y) (Powerset A).\nProof power1_Out1.\n", "definition": "\n forall (A X Y : Ens) (x : IN X (Powerset A)) (y : IN Y (Powerset A)),\n IN (union X Y) (Powerset A).\n", "proof": "Proof power1_Out1.", "proof_term": "Proof power1_Out1.", "def_ranges": [3576, 0, 3578, 29], "proof_ranges": [3579, 0, 3579, 18], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_th3", "text": "Theorem Powerset_th3 :\n forall (A X Y : Ens) (x : IN X (Powerset A)),\n (*    (y : (IN Y (Powerset A)))  *)\n IN (intersection X Y) (Powerset A).\nProof power1_Out2.\n", "definition": "\n forall (A X Y : Ens) (x : IN X (Powerset A)),\n (*    (y : (IN Y (Powerset A)))  *)\n IN (intersection X Y) (Powerset A).\n", "proof": "Proof power1_Out2.", "proof_term": "Proof power1_Out2.", "def_ranges": [3581, 0, 3584, 36], "proof_ranges": [3585, 0, 3585, 18], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "power2_Out", "text": "Lemma power2_Out : IN (Singleton X) (Powerset A).\nProof Powerset_pr1 A (Singleton X) step1.\n", "definition": " IN (Singleton X) (Powerset A).\n", "proof": "Proof Powerset_pr1 A (Singleton X) step1.", "proof_term": "Proof Powerset_pr1 A (Singleton X) step1.", "def_ranges": [3596, 0, 3596, 49], "proof_ranges": [3597, 0, 3597, 41], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_th4", "text": "Theorem Powerset_th4 :\n forall (A X : Ens) (x : IN X A), IN (Singleton X) (Powerset A).\nProof power2_Out.\n", "definition": "\n forall (A X : Ens) (x : IN X A), IN (Singleton X) (Powerset A).\n", "proof": "Proof power2_Out.", "proof_term": "Proof power2_Out.", "def_ranges": [3601, 0, 3602, 64], "proof_ranges": [3603, 0, 3603, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "power3_Out", "text": "Lemma power3_Out : IN (Doubleton X Y) (Powerset A).\nProof Powerset_th2 A (Singleton X) (Singleton Y) step1 step2.\n", "definition": " IN (Doubleton X Y) (Powerset A).\n", "proof": "Proof Powerset_th2 A (Singleton X) (Singleton Y) step1 step2.", "proof_term": "Proof Powerset_th2 A (Singleton X) (Singleton Y) step1 step2.", "def_ranges": [3615, 0, 3615, 51], "proof_ranges": [3616, 0, 3616, 61], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_th5", "text": "Theorem Powerset_th5 :\n forall (A X Y : Ens) (x : IN X A) (y : IN Y A),\n IN (Doubleton X Y) (Powerset A).\nProof power3_Out.\n", "definition": "\n forall (A X Y : Ens) (x : IN X A) (y : IN Y A),\n IN (Doubleton X Y) (Powerset A).\n", "proof": "Proof power3_Out.", "proof_term": "Proof power3_Out.", "def_ranges": [3620, 0, 3622, 33], "proof_ranges": [3623, 0, 3623, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "power4_Out", "text": "Lemma power4_Out : IN (Second X) (Powerset P).\nProof Powerset_th5 P Zero sX step1 step2.\n", "definition": " IN (Second X) (Powerset P).\n", "proof": "Proof Powerset_th5 P Zero sX step1 step2.", "proof_term": "Proof Powerset_th5 P Zero sX step1 step2.", "def_ranges": [3640, 0, 3640, 46], "proof_ranges": [3641, 0, 3641, 41], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_th6", "text": "Theorem Powerset_th6 :\n forall (A X : Ens) (x : IN X A), IN (Second X) (Powerset (Powerset A)).\nProof power4_Out.\n", "definition": "\n forall (A X : Ens) (x : IN X A), IN (Second X) (Powerset (Powerset A)).\n", "proof": "Proof power4_Out.", "proof_term": "Proof power4_Out.", "def_ranges": [3645, 0, 3646, 72], "proof_ranges": [3647, 0, 3647, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "power5_Out", "text": "Lemma power5_Out : IN X (Powerset B).\nProof Powerset_pr1 B X step2.\n", "definition": " IN X (Powerset B).\n", "proof": "Proof Powerset_pr1 B X step2.", "proof_term": "Proof Powerset_pr1 B X step2.", "def_ranges": [3662, 0, 3662, 37], "proof_ranges": [3663, 0, 3663, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Powerset_th7", "text": "Theorem Powerset_th7 :\n forall (A B : Ens) (a : SUB A B), SUB (Powerset A) (Powerset B).\nProof power5_Out.\n", "definition": "\n forall (A B : Ens) (a : SUB A B), SUB (Powerset A) (Powerset B).\n", "proof": "Proof power5_Out.", "proof_term": "Proof power5_Out.", "def_ranges": [3667, 0, 3668, 65], "proof_ranges": [3669, 0, 3669, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Zero_element_of_NN", "text": "Theorem Zero_element_of_NN : Element_of_NN Zero.\nProof Zero_element_of_NN_proof_Out.\n", "definition": " Element_of_NN Zero.\n", "proof": "Proof Zero_element_of_NN_proof_Out.", "proof_term": "Proof Zero_element_of_NN_proof_Out.", "def_ranges": [3691, 0, 3691, 48], "proof_ranges": [3692, 0, 3692, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Nexts_element_of_NN", "text": "Theorem Nexts_element_of_NN :\n forall (A : Ens) (h : Element_of_NN A), Element_of_NN (Next A).\nProof Nexts_element_of_NN_proof_Out.\n", "definition": "\n forall (A : Ens) (h : Element_of_NN A), Element_of_NN (Next A).\n", "proof": "Proof Nexts_element_of_NN_proof_Out.", "proof_term": "Proof Nexts_element_of_NN_proof_Out.", "def_ranges": [3710, 0, 3711, 64], "proof_ranges": [3712, 0, 3712, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Set_containing_NN_pr", "text": "Theorem Set_containing_NN_pr : Contains_NN Set_containing_NN.\nProof CHOICE_pr Contains_NN Infinity_exists.\n", "definition": " Contains_NN Set_containing_NN.\n", "proof": "Proof CHOICE_pr Contains_NN Infinity_exists.", "proof_term": "Proof CHOICE_pr Contains_NN Infinity_exists.", "def_ranges": [3722, 0, 3722, 61], "proof_ranges": [3723, 0, 3723, 44], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Bounded_NN_pre", "text": "Theorem Bounded_NN_pre : EXISTS (fun A : Ens => Bounded_By A Element_of_NN).\nProof Bounded_NN_proof_Out.\n", "definition": " EXISTS (fun A : Ens => Bounded_By A Element_of_NN).\n", "proof": "Proof Bounded_NN_proof_Out.", "proof_term": "Proof Bounded_NN_proof_Out.", "def_ranges": [3751, 0, 3751, 76], "proof_ranges": [3752, 0, 3752, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Bounded_NN", "text": "Theorem Bounded_NN : Bounded Element_of_NN.\nProof Bounded_NN_pre.\n", "definition": " Bounded Element_of_NN.\n", "proof": "Proof Bounded_NN_pre.", "proof_term": "Proof Bounded_NN_pre.", "def_ranges": [3754, 0, 3754, 43], "proof_ranges": [3755, 0, 3755, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Naturals_pr1", "text": "Theorem Naturals_pr1 : forall X : Ens, Element_of_NN X -> IN X Naturals.\nProof REPLACEMENT_pr1 Element_of_NN Bounded_NN.\n", "definition": " forall X : Ens, Element_of_NN X -> IN X Naturals.\n", "proof": "Proof REPLACEMENT_pr1 Element_of_NN Bounded_NN.", "proof_term": "Proof REPLACEMENT_pr1 Element_of_NN Bounded_NN.", "def_ranges": [3760, 0, 3760, 72], "proof_ranges": [3761, 0, 3761, 47], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Naturals_pr2", "text": "Theorem Naturals_pr2 : forall X : Ens, IN X Naturals -> Element_of_NN X.\nProof REPLACEMENT_pr2 Element_of_NN Bounded_NN.\n", "definition": " forall X : Ens, IN X Naturals -> Element_of_NN X.\n", "proof": "Proof REPLACEMENT_pr2 Element_of_NN Bounded_NN.", "proof_term": "Proof REPLACEMENT_pr2 Element_of_NN Bounded_NN.", "def_ranges": [3763, 0, 3763, 72], "proof_ranges": [3764, 0, 3764, 47], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Zero_in_Naturals", "text": "Theorem Zero_in_Naturals : IN Zero Naturals.\nProof Naturals_pr1 Zero Zero_element_of_NN.\n", "definition": " IN Zero Naturals.\n", "proof": "Proof Naturals_pr1 Zero Zero_element_of_NN.", "proof_term": "Proof Naturals_pr1 Zero Zero_element_of_NN.", "def_ranges": [3769, 0, 3769, 44], "proof_ranges": [3770, 0, 3770, 43], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Nexts_in_Naturals", "text": "Theorem Nexts_in_Naturals :\n forall (A : Ens) (h : IN A Naturals), IN (Next A) Naturals.\nProof\n  fun (A : Ens) (h : IN A Naturals) =>\n  Naturals_pr1 (Next A) (Nexts_element_of_NN A (Naturals_pr2 A h)).\n", "definition": "\n forall (A : Ens) (h : IN A Naturals), IN (Next A) Naturals.\n", "proof": "Proof\n  fun (A : Ens) (h : IN A Naturals) =>\n  Naturals_pr1 (Next A) (Nexts_element_of_NN A (Naturals_pr2 A h)).", "proof_term": "Proof\n  fun (A : Ens) (h : IN A Naturals) =>\n  Naturals_pr1 (Next A) (Nexts_element_of_NN A (Naturals_pr2 A h)).", "def_ranges": [3772, 0, 3773, 60], "proof_ranges": [3774, 0, 3776, 67], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Contains_NN_Naturals", "text": "Theorem Contains_NN_Naturals : Contains_NN Naturals.\nProof Build_Contains_NN Naturals Zero_in_Naturals Nexts_in_Naturals.\n", "definition": " Contains_NN Naturals.\n", "proof": "Proof Build_Contains_NN Naturals Zero_in_Naturals Nexts_in_Naturals.", "proof_term": "Proof Build_Contains_NN Naturals Zero_in_Naturals Nexts_in_Naturals.", "def_ranges": [3778, 0, 3778, 52], "proof_ranges": [3779, 0, 3779, 68], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Naturals_th1", "text": "Theorem Naturals_th1 : forall (X : Ens) (h : Contains_NN X), SUB Naturals X.\nProof Naturals_th1_proof_Out.\n", "definition": " forall (X : Ens) (h : Contains_NN X), SUB Naturals X.\n", "proof": "Proof Naturals_th1_proof_Out.", "proof_term": "Proof Naturals_th1_proof_Out.", "def_ranges": [3794, 0, 3794, 76], "proof_ranges": [3795, 0, 3795, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "anything_sub_next_of_itself", "text": "Theorem anything_sub_next_of_itself : forall A : Ens, SUB A (Next A).\nProof A_sub_next_A_Out.\n", "definition": " forall A : Ens, SUB A (Next A).\n", "proof": "Proof A_sub_next_A_Out.", "proof_term": "Proof A_sub_next_A_Out.", "def_ranges": [3811, 0, 3811, 69], "proof_ranges": [3812, 0, 3812, 23], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "anything_in_next_of_itself", "text": "Theorem anything_in_next_of_itself : forall A : Ens, IN A (Next A).\nProof A_in_next_A_Out.\n", "definition": " forall A : Ens, IN A (Next A).\n", "proof": "Proof A_in_next_A_Out.", "proof_term": "Proof A_in_next_A_Out.", "def_ranges": [3824, 0, 3824, 67], "proof_ranges": [3825, 0, 3825, 22], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_inductionA", "text": "Theorem naturals_inductionA :\n forall (P : Ens -> Prop) (IH_zero : P Zero)\n   (IH_nexts : naturals_induction_nexts P) (B : Ens) \n   (p : IN B Naturals), P B.\nProof naturals_inductionA_Out.\n", "definition": "\n forall (P : Ens -> Prop) (IH_zero : P Zero)\n   (IH_nexts : naturals_induction_nexts P) (B : Ens) \n   (p : IN B Naturals), P B.\n", "proof": "Proof naturals_inductionA_Out.", "proof_term": "Proof naturals_inductionA_Out.", "def_ranges": [3890, 0, 3893, 28], "proof_ranges": [3894, 0, 3894, 30], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "some_things_strictsub_their_nexts", "text": "Theorem some_things_strictsub_their_nexts :\n forall (A : Ens) (h : not_in_itself A), StrictSUB A (Next A).\nProof strictsub_next_Out.\n", "definition": "\n forall (A : Ens) (h : not_in_itself A), StrictSUB A (Next A).\n", "proof": "Proof strictsub_next_Out.", "proof_term": "Proof strictsub_next_Out.", "def_ranges": [3936, 0, 3937, 62], "proof_ranges": [3938, 0, 3938, 25], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "in_then_strictsub_Zero", "text": "Theorem in_then_strictsub_Zero :\n forall X : Ens, IN X Zero -> StrictSUB X Zero.\nProof in_iff_strictsub_Zero_Out.\n", "definition": "\n forall X : Ens, IN X Zero -> StrictSUB X Zero.\n", "proof": "Proof in_iff_strictsub_Zero_Out.", "proof_term": "Proof in_iff_strictsub_Zero_Out.", "def_ranges": [3957, 0, 3958, 47], "proof_ranges": [3959, 0, 3959, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "zero_not_in_itself", "text": "Theorem zero_not_in_itself : not_in_itself Zero.\nProof not_in_itself_Zero_Out.\n", "definition": " not_in_itself Zero.\n", "proof": "Proof not_in_itself_Zero_Out.", "proof_term": "Proof not_in_itself_Zero_Out.", "def_ranges": [3967, 0, 3967, 48], "proof_ranges": [3968, 0, 3968, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_main_ind_for_Zero", "text": "Theorem naturals_main_ind_for_Zero : naturals_main_ind_hyp Zero.\nProof\n  Build_naturals_main_ind_hyp Zero in_then_strictsub_Zero zero_not_in_itself.\n", "definition": " naturals_main_ind_hyp Zero.\n", "proof": "Proof\n  Build_naturals_main_ind_hyp Zero in_then_strictsub_Zero zero_not_in_itself.", "proof_term": "Proof\n  Build_naturals_main_ind_hyp Zero in_then_strictsub_Zero zero_not_in_itself.", "def_ranges": [3970, 0, 3970, 64], "proof_ranges": [3971, 0, 3972, 77], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_main_induction_next", "text": "Theorem naturals_main_induction_next :\n forall (A : Ens) (h : naturals_main_ind_hyp A),\n naturals_main_ind_hyp (Next A).\nProof naturals_main_induction_step_Out.\n", "definition": "\n forall (A : Ens) (h : naturals_main_ind_hyp A),\n naturals_main_ind_hyp (Next A).\n", "proof": "Proof naturals_main_induction_step_Out.", "proof_term": "Proof naturals_main_induction_step_Out.", "def_ranges": [4118, 0, 4120, 32], "proof_ranges": [4121, 0, 4121, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_main_induction_next_1", "text": "Theorem naturals_main_induction_next_1 :\n naturals_induction_nexts naturals_main_ind_hyp.\nProof\n  fun (A : Ens) (u : IN A Naturals) (h : naturals_main_ind_hyp A) =>\n  naturals_main_induction_next A h. \n\nTheorem naturals_main_th1 :\n forall (B : Ens) (i : IN B Naturals), naturals_main_ind_hyp B.\n", "definition": "\n naturals_induction_nexts naturals_main_ind_hyp.\n", "proof": "Proof\n  fun (A : Ens) (u : IN A Naturals) (h : naturals_main_ind_hyp A) =>\n  naturals_main_induction_next A h. \n\nTheorem naturals_main_th1 :\n forall (B : Ens) (i : IN B Naturals), naturals_main_ind_hyp B.", "proof_term": "Proof\n  fun (A : Ens) (u : IN A Naturals) (h : naturals_main_ind_hyp A) =>\n  naturals_main_induction_next A h. \n\nTheorem naturals_main_th1 :\n forall (B : Ens) (i : IN B Naturals), naturals_main_ind_hyp B.", "def_ranges": [4127, 0, 4128, 48], "proof_ranges": [4129, 0, 4134, 63], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_main_th1", "text": "Theorem naturals_main_th1 :\n forall (B : Ens) (i : IN B Naturals), naturals_main_ind_hyp B.\nProof\n  naturals_inductionA naturals_main_ind_hyp naturals_main_ind_for_Zero\n    naturals_main_induction_next_1. \n\nTheorem naturals_main_th2 :\n forall (B : Ens) (i : IN B Naturals), in_then_strictsub B.\n", "definition": "\n forall (B : Ens) (i : IN B Naturals), naturals_main_ind_hyp B.\n", "proof": "Proof\n  naturals_inductionA naturals_main_ind_hyp naturals_main_ind_for_Zero\n    naturals_main_induction_next_1. \n\nTheorem naturals_main_th2 :\n forall (B : Ens) (i : IN B Naturals), in_then_strictsub B.", "proof_term": "Proof\n  naturals_inductionA naturals_main_ind_hyp naturals_main_ind_for_Zero\n    naturals_main_induction_next_1. \n\nTheorem naturals_main_th2 :\n forall (B : Ens) (i : IN B Naturals), in_then_strictsub B.", "def_ranges": [4133, 0, 4134, 63], "proof_ranges": [4135, 0, 4140, 59], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_main_th2", "text": "Theorem naturals_main_th2 :\n forall (B : Ens) (i : IN B Naturals), in_then_strictsub B.\nProof\n  fun (B : Ens) (i : IN B Naturals) =>\n  naturals_main_ind1 B (naturals_main_th1 B i).\n", "definition": "\n forall (B : Ens) (i : IN B Naturals), in_then_strictsub B.\n", "proof": "Proof\n  fun (B : Ens) (i : IN B Naturals) =>\n  naturals_main_ind1 B (naturals_main_th1 B i).", "proof_term": "Proof\n  fun (B : Ens) (i : IN B Naturals) =>\n  naturals_main_ind1 B (naturals_main_th1 B i).", "def_ranges": [4139, 0, 4140, 59], "proof_ranges": [4141, 0, 4143, 47], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_main_th2_rewrite", "text": "Theorem naturals_main_th2_rewrite :\n forall (B : Ens) (i : IN B Naturals) (A : Ens) (j : IN A B), StrictSUB A B.\nProof naturals_main_th2.\n", "definition": "\n forall (B : Ens) (i : IN B Naturals) (A : Ens) (j : IN A B), StrictSUB A B.\n", "proof": "Proof naturals_main_th2.", "proof_term": "Proof naturals_main_th2.", "def_ranges": [4145, 0, 4146, 76], "proof_ranges": [4147, 0, 4147, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_main_th3", "text": "Theorem naturals_main_th3 :\n forall (B : Ens) (i : IN B Naturals), not_in_itself B.\nProof\n  fun (B : Ens) (i : IN B Naturals) =>\n  naturals_main_ind2 B (naturals_main_th1 B i).\n", "definition": "\n forall (B : Ens) (i : IN B Naturals), not_in_itself B.\n", "proof": "Proof\n  fun (B : Ens) (i : IN B Naturals) =>\n  naturals_main_ind2 B (naturals_main_th1 B i).", "proof_term": "Proof\n  fun (B : Ens) (i : IN B Naturals) =>\n  naturals_main_ind2 B (naturals_main_th1 B i).", "def_ranges": [4149, 0, 4150, 55], "proof_ranges": [4151, 0, 4153, 47], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "naturals_main_th3_rewrite", "text": "Theorem naturals_main_th3_rewrite :\n forall (B : Ens) (i : IN B Naturals), ~ IN B B.\nProof naturals_main_th3.\n", "definition": "\n forall (B : Ens) (i : IN B Naturals), ~ IN B B.\n", "proof": "Proof naturals_main_th3.", "proof_term": "Proof naturals_main_th3.", "def_ranges": [4155, 0, 4156, 48], "proof_ranges": [4157, 0, 4157, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "UnionPlus_th1", "text": "Theorem UnionPlus_th1 : forall (X F : Ens) (i : IN X F), IN X (UnionPlus F).\nProof fun (X F : Ens) (i : IN X F) => union_th1 F (Union F) X i.\n", "definition": " forall (X F : Ens) (i : IN X F), IN X (UnionPlus F).\n", "proof": "Proof fun (X F : Ens) (i : IN X F) => union_th1 F (Union F) X i.", "proof_term": "Proof fun (X F : Ens) (i : IN X F) => union_th1 F (Union F) X i.", "def_ranges": [4176, 0, 4176, 76], "proof_ranges": [4177, 0, 4177, 64], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "UnionPlus_th2", "text": "Theorem UnionPlus_th2 :\n forall (X U F : Ens) (i : IN X U) (j : IN U F), IN X (UnionPlus F).\nProof\n  fun (X U F : Ens) (i : IN X U) (j : IN U F) =>\n  union_th2 F (Union F) X (Union_th1 F X U i j).\n", "definition": "\n forall (X U F : Ens) (i : IN X U) (j : IN U F), IN X (UnionPlus F).\n", "proof": "Proof\n  fun (X U F : Ens) (i : IN X U) (j : IN U F) =>\n  union_th2 F (Union F) X (Union_th1 F X U i j).", "proof_term": "Proof\n  fun (X U F : Ens) (i : IN X U) (j : IN U F) =>\n  union_th2 F (Union F) X (Union_th1 F X U i j).", "def_ranges": [4179, 0, 4180, 68], "proof_ranges": [4181, 0, 4183, 48], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "total_th1_Out", "text": "Lemma total_th1_Out : IN X (Total F).\nProof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th1_proof.\n", "definition": " IN X (Total F).\n", "proof": "Proof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th1_proof.", "proof_term": "Proof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th1_proof.", "def_ranges": [4195, 0, 4195, 37], "proof_ranges": [4196, 0, 4199, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Total_th1", "text": "Theorem Total_th1 : forall (X F : Ens) (i : IN X F), IN X (Total F).\nProof total_th1_Out.\n", "definition": " forall (X F : Ens) (i : IN X F), IN X (Total F).\n", "proof": "Proof total_th1_Out.", "proof_term": "Proof total_th1_Out.", "def_ranges": [4201, 0, 4201, 68], "proof_ranges": [4202, 0, 4202, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "total_th2_Out", "text": "Lemma total_th2_Out : IN X (Total F).\nProof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th2_proof.\n", "definition": " IN X (Total F).\n", "proof": "Proof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th2_proof.", "proof_term": "Proof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th2_proof.", "def_ranges": [4215, 0, 4215, 37], "proof_ranges": [4216, 0, 4219, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Total_th2", "text": "Theorem Total_th2 :\n forall (X Y F : Ens) (i : IN X Y) (j : IN Y F), IN X (Total F).\nProof total_th2_Out.\n", "definition": "\n forall (X Y F : Ens) (i : IN X Y) (j : IN Y F), IN X (Total F).\n", "proof": "Proof total_th2_Out.", "proof_term": "Proof total_th2_Out.", "def_ranges": [4221, 0, 4222, 64], "proof_ranges": [4223, 0, 4223, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "total_th3_Out", "text": "Lemma total_th3_Out : IN X (Total F).\nProof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th3_proof.\n", "definition": " IN X (Total F).\n", "proof": "Proof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th3_proof.", "proof_term": "Proof UnionPlus_th1 X (UnionPlus (UnionPlus F)) step2.  \n\n\nEnd total_th3_proof.", "def_ranges": [4237, 0, 4237, 37], "proof_ranges": [4238, 0, 4241, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Total_th3", "text": "Theorem Total_th3 :\n forall (X Y Z F : Ens) (i : IN X Y) (j : IN Y Z) (k : IN Z F),\n IN X (Total F).\nProof total_th3_Out.\n", "definition": "\n forall (X Y Z F : Ens) (i : IN X Y) (j : IN Y Z) (k : IN Z F),\n IN X (Total F).\n", "proof": "Proof total_th3_Out.", "proof_term": "Proof total_th3_Out.", "def_ranges": [4243, 0, 4245, 16], "proof_ranges": [4246, 0, 4246, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "total_th4_Out", "text": "Lemma total_th4_Out : IN X (Total F).\nProof UnionPlus_th2 X Y (UnionPlus (UnionPlus F)) i step2.  \n\n\nEnd total_th4_proof.\n", "definition": " IN X (Total F).\n", "proof": "Proof UnionPlus_th2 X Y (UnionPlus (UnionPlus F)) i step2.  \n\n\nEnd total_th4_proof.", "proof_term": "Proof UnionPlus_th2 X Y (UnionPlus (UnionPlus F)) i step2.  \n\n\nEnd total_th4_proof.", "def_ranges": [4261, 0, 4261, 37], "proof_ranges": [4262, 0, 4265, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Total_th4", "text": "Theorem Total_th4 :\n forall (X Y Z W F : Ens) (i : IN X Y) (j : IN Y Z) (k : IN Z W) (l : IN W F),\n IN X (Total F).\nProof total_th4_Out.\n", "definition": "\n forall (X Y Z W F : Ens) (i : IN X Y) (j : IN Y Z) (k : IN Z W) (l : IN W F),\n IN X (Total F).\n", "proof": "Proof total_th4_Out.", "proof_term": "Proof total_th4_Out.", "def_ranges": [4267, 0, 4269, 16], "proof_ranges": [4270, 0, 4270, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "total_and_pairs_1_OutA", "text": "Lemma total_and_pairs_1_OutA : IN A (Total R).\nProof Total_th3 A (First A) (PAIR A B) R step1 step4 i.\n", "definition": " IN A (Total R).\n", "proof": "Proof Total_th3 A (First A) (PAIR A B) R step1 step4 i.", "proof_term": "Proof Total_th3 A (First A) (PAIR A B) R step1 step4 i.", "def_ranges": [4292, 0, 4292, 46], "proof_ranges": [4293, 0, 4293, 55], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "total_and_pairs_1_OutB", "text": "Lemma total_and_pairs_1_OutB : IN B (Total R).\nProof Total_th4 B (Singleton B) (Second B) (PAIR A B) R step2 step3 step5 i.\n", "definition": " IN B (Total R).\n", "proof": "Proof Total_th4 B (Singleton B) (Second B) (PAIR A B) R step2 step3 step5 i.", "proof_term": "Proof Total_th4 B (Singleton B) (Second B) (PAIR A B) R step2 step3 step5 i.", "def_ranges": [4295, 0, 4295, 46], "proof_ranges": [4296, 0, 4296, 76], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Relation_Total_th1", "text": "Theorem Relation_Total_th1 :\n forall (R A B : Ens) (i : IN (PAIR A B) R), IN A (Total R).\nProof total_and_pairs_1_OutA.\n", "definition": "\n forall (R A B : Ens) (i : IN (PAIR A B) R), IN A (Total R).\n", "proof": "Proof total_and_pairs_1_OutA.", "proof_term": "Proof total_and_pairs_1_OutA.", "def_ranges": [4300, 0, 4301, 60], "proof_ranges": [4302, 0, 4302, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Relation_Total_th2", "text": "Theorem Relation_Total_th2 :\n forall (R A B : Ens) (i : IN (PAIR A B) R), IN B (Total R).\nProof total_and_pairs_1_OutB.\n", "definition": "\n forall (R A B : Ens) (i : IN (PAIR A B) R), IN B (Total R).\n", "proof": "Proof total_and_pairs_1_OutB.", "proof_term": "Proof total_and_pairs_1_OutB.", "def_ranges": [4304, 0, 4305, 60], "proof_ranges": [4306, 0, 4306, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EV_pr", "text": "Theorem EV_pr :\n forall (R X : Ens) (p : Domain_prop R X), IN (PAIR X (EV R X)) R.\nProof\n  fun (R X : Ens) (p : Domain_prop R X) =>\n  CHOICE_pr (fun Y : Ens => IN (PAIR X Y) R) p.\n", "definition": "\n forall (R X : Ens) (p : Domain_prop R X), IN (PAIR X (EV R X)) R.\n", "proof": "Proof\n  fun (R X : Ens) (p : Domain_prop R X) =>\n  CHOICE_pr (fun Y : Ens => IN (PAIR X Y) R) p.", "proof_term": "Proof\n  fun (R X : Ens) (p : Domain_prop R X) =>\n  CHOICE_pr (fun Y : Ens => IN (PAIR X Y) R) p.", "def_ranges": [4325, 0, 4326, 66], "proof_ranges": [4327, 0, 4329, 47], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "inverse_EV_pr", "text": "Theorem inverse_EV_pr :\n forall (R Y : Ens) (p : Range_prop R Y), IN (PAIR (inverse_EV R Y) Y) R.\nProof\n  fun (R Y : Ens) (p : Range_prop R Y) =>\n  CHOICE_pr (fun X : Ens => IN (PAIR X Y) R) p.\n", "definition": "\n forall (R Y : Ens) (p : Range_prop R Y), IN (PAIR (inverse_EV R Y) Y) R.\n", "proof": "Proof\n  fun (R Y : Ens) (p : Range_prop R Y) =>\n  CHOICE_pr (fun X : Ens => IN (PAIR X Y) R) p.", "proof_term": "Proof\n  fun (R Y : Ens) (p : Range_prop R Y) =>\n  CHOICE_pr (fun X : Ens => IN (PAIR X Y) R) p.", "def_ranges": [4333, 0, 4334, 73], "proof_ranges": [4335, 0, 4337, 47], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Domain_prop_bounded_proof_1_Out", "text": "Lemma Domain_prop_bounded_proof_1_Out : IN X T.\nProof Relation_Total_th1 R X Y step1_1.\n", "definition": " IN X T.\n", "proof": "Proof Relation_Total_th1 R X Y step1_1.", "proof_term": "Proof Relation_Total_th1 R X Y step1_1.", "def_ranges": [4357, 0, 4357, 47], "proof_ranges": [4358, 0, 4358, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Domain_prop_bounded_Out", "text": "Lemma Domain_prop_bounded_Out : Bounded (Domain_prop R).\nProof Bounded_th2 (Domain_prop R) T step1.\n", "definition": " Bounded (Domain_prop R).\n", "proof": "Proof Bounded_th2 (Domain_prop R) T step1.", "proof_term": "Proof Bounded_th2 (Domain_prop R) T step1.", "def_ranges": [4365, 0, 4365, 56], "proof_ranges": [4366, 0, 4366, 42], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Domain_prop_bounded", "text": "Theorem Domain_prop_bounded : forall R : Ens, Bounded (Domain_prop R).\nProof Domain_prop_bounded_Out.\n", "definition": " forall R : Ens, Bounded (Domain_prop R).\n", "proof": "Proof Domain_prop_bounded_Out.", "proof_term": "Proof Domain_prop_bounded_Out.", "def_ranges": [4370, 0, 4370, 70], "proof_ranges": [4371, 0, 4371, 30], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Range_prop_bounded_proof_1_Out", "text": "Lemma Range_prop_bounded_proof_1_Out : IN Y T.\nProof Relation_Total_th2 R X Y step1_1.\n", "definition": " IN Y T.\n", "proof": "Proof Relation_Total_th2 R X Y step1_1.", "proof_term": "Proof Relation_Total_th2 R X Y step1_1.", "def_ranges": [4388, 0, 4388, 46], "proof_ranges": [4389, 0, 4389, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Range_prop_bounded_Out", "text": "Lemma Range_prop_bounded_Out : Bounded (Range_prop R).\nProof Bounded_th2 (Range_prop R) T step1.\n", "definition": " Bounded (Range_prop R).\n", "proof": "Proof Bounded_th2 (Range_prop R) T step1.", "proof_term": "Proof Bounded_th2 (Range_prop R) T step1.", "def_ranges": [4396, 0, 4396, 54], "proof_ranges": [4397, 0, 4397, 41], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Range_prop_bounded", "text": "Theorem Range_prop_bounded : forall R : Ens, Bounded (Range_prop R).\nProof Range_prop_bounded_Out.\n", "definition": " forall R : Ens, Bounded (Range_prop R).\n", "proof": "Proof Range_prop_bounded_Out.", "proof_term": "Proof Range_prop_bounded_Out.", "def_ranges": [4401, 0, 4401, 68], "proof_ranges": [4402, 0, 4402, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Domain_pr1", "text": "Theorem Domain_pr1 :\n forall (R X : Ens) (p : Domain_prop R X), IN X (Domain R).\nProof fun R : Ens => REPLACEMENT_pr1 (Domain_prop R) (Domain_prop_bounded R).\n", "definition": "\n forall (R X : Ens) (p : Domain_prop R X), IN X (Domain R).\n", "proof": "Proof fun R : Ens => REPLACEMENT_pr1 (Domain_prop R) (Domain_prop_bounded R).", "proof_term": "Proof fun R : Ens => REPLACEMENT_pr1 (Domain_prop R) (Domain_prop_bounded R).", "def_ranges": [4408, 0, 4409, 59], "proof_ranges": [4410, 0, 4410, 77], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Domain_pr2", "text": "Theorem Domain_pr2 :\n forall (R X : Ens) (i : IN X (Domain R)), Domain_prop R X.\nProof fun R : Ens => REPLACEMENT_pr2 (Domain_prop R) (Domain_prop_bounded R).\n", "definition": "\n forall (R X : Ens) (i : IN X (Domain R)), Domain_prop R X.\n", "proof": "Proof fun R : Ens => REPLACEMENT_pr2 (Domain_prop R) (Domain_prop_bounded R).", "proof_term": "Proof fun R : Ens => REPLACEMENT_pr2 (Domain_prop R) (Domain_prop_bounded R).", "def_ranges": [4412, 0, 4413, 59], "proof_ranges": [4414, 0, 4414, 77], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EV_th1", "text": "Theorem EV_th1 :\n forall (R X : Ens) (i : IN X (Domain R)), IN (PAIR X (EV R X)) R.\nProof fun (R X : Ens) (i : IN X (Domain R)) => EV_pr R X (Domain_pr2 R X i).\n", "definition": "\n forall (R X : Ens) (i : IN X (Domain R)), IN (PAIR X (EV R X)) R.\n", "proof": "Proof fun (R X : Ens) (i : IN X (Domain R)) => EV_pr R X (Domain_pr2 R X i).", "proof_term": "Proof fun (R X : Ens) (i : IN X (Domain R)) => EV_pr R X (Domain_pr2 R X i).", "def_ranges": [4416, 0, 4417, 66], "proof_ranges": [4418, 0, 4418, 76], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Domain_th1_Out", "text": "Lemma Domain_th1_Out : IN X (Domain R).\nProof Domain_pr1 R X step1.\n", "definition": " IN X (Domain R).\n", "proof": "Proof Domain_pr1 R X step1.", "proof_term": "Proof Domain_pr1 R X step1.", "def_ranges": [4430, 0, 4430, 39], "proof_ranges": [4431, 0, 4431, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Domain_th1", "text": "Theorem Domain_th1 :\n forall (R X Y : Ens) (i : IN (PAIR X Y) R), IN X (Domain R).\nProof Domain_th1_Out.\n", "definition": "\n forall (R X Y : Ens) (i : IN (PAIR X Y) R), IN X (Domain R).\n", "proof": "Proof Domain_th1_Out.", "proof_term": "Proof Domain_th1_Out.", "def_ranges": [4436, 0, 4437, 61], "proof_ranges": [4438, 0, 4438, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Range_pr1", "text": "Theorem Range_pr1 : forall (R X : Ens) (p : Range_prop R X), IN X (Range R).\nProof fun R : Ens => REPLACEMENT_pr1 (Range_prop R) (Range_prop_bounded R).\n", "definition": " forall (R X : Ens) (p : Range_prop R X), IN X (Range R).\n", "proof": "Proof fun R : Ens => REPLACEMENT_pr1 (Range_prop R) (Range_prop_bounded R).", "proof_term": "Proof fun R : Ens => REPLACEMENT_pr1 (Range_prop R) (Range_prop_bounded R).", "def_ranges": [4445, 0, 4445, 76], "proof_ranges": [4446, 0, 4446, 75], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Range_pr2", "text": "Theorem Range_pr2 : forall (R X : Ens) (i : IN X (Range R)), Range_prop R X.\nProof fun R : Ens => REPLACEMENT_pr2 (Range_prop R) (Range_prop_bounded R).\n", "definition": " forall (R X : Ens) (i : IN X (Range R)), Range_prop R X.\n", "proof": "Proof fun R : Ens => REPLACEMENT_pr2 (Range_prop R) (Range_prop_bounded R).", "proof_term": "Proof fun R : Ens => REPLACEMENT_pr2 (Range_prop R) (Range_prop_bounded R).", "def_ranges": [4448, 0, 4448, 76], "proof_ranges": [4449, 0, 4449, 75], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "inverse_EV_th1", "text": "Theorem inverse_EV_th1 :\n forall (R Y : Ens) (i : IN Y (Range R)), IN (PAIR (inverse_EV R Y) Y) R.\nProof\n  fun (R Y : Ens) (i : IN Y (Range R)) => inverse_EV_pr R Y (Range_pr2 R Y i).\n", "definition": "\n forall (R Y : Ens) (i : IN Y (Range R)), IN (PAIR (inverse_EV R Y) Y) R.\n", "proof": "Proof\n  fun (R Y : Ens) (i : IN Y (Range R)) => inverse_EV_pr R Y (Range_pr2 R Y i).", "proof_term": "Proof\n  fun (R Y : Ens) (i : IN Y (Range R)) => inverse_EV_pr R Y (Range_pr2 R Y i).", "def_ranges": [4453, 0, 4454, 73], "proof_ranges": [4455, 0, 4456, 78], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Range_th1_Out", "text": "Lemma Range_th1_Out : IN Y (Range R).\nProof Range_pr1 R Y step1.\n", "definition": " IN Y (Range R).\n", "proof": "Proof Range_pr1 R Y step1.", "proof_term": "Proof Range_pr1 R Y step1.", "def_ranges": [4469, 0, 4469, 37], "proof_ranges": [4470, 0, 4470, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Range_th1", "text": "Theorem Range_th1 :\n forall (R X Y : Ens) (i : IN (PAIR X Y) R), IN Y (Range R).\nProof Range_th1_Out.\n", "definition": "\n forall (R X Y : Ens) (i : IN (PAIR X Y) R), IN Y (Range R).\n", "proof": "Proof Range_th1_Out.", "proof_term": "Proof Range_th1_Out.", "def_ranges": [4475, 0, 4476, 60], "proof_ranges": [4477, 0, 4477, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "eval_in_range_Out", "text": "Lemma eval_in_range_Out : IN Y (Range R).\nProof Range_th1 R X Y step1.\n", "definition": " IN Y (Range R).\n", "proof": "Proof Range_th1 R X Y step1.", "proof_term": "Proof Range_th1 R X Y step1.", "def_ranges": [4492, 0, 4492, 41], "proof_ranges": [4493, 0, 4493, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "EV_in_range", "text": "Theorem EV_in_range :\n forall (R X : Ens) (i : IN X (Domain R)), IN (EV R X) (Range R).\nProof eval_in_range_Out.\n", "definition": "\n forall (R X : Ens) (i : IN X (Domain R)), IN (EV R X) (Range R).\n", "proof": "Proof eval_in_range_Out.", "proof_term": "Proof eval_in_range_Out.", "def_ranges": [4497, 0, 4498, 65], "proof_ranges": [4499, 0, 4499, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "inv_eval_in_domain_Out", "text": "Lemma inv_eval_in_domain_Out : IN X (Domain R).\nProof Domain_th1 R X Y step1.\n", "definition": " IN X (Domain R).\n", "proof": "Proof Domain_th1 R X Y step1.", "proof_term": "Proof Domain_th1 R X Y step1.", "def_ranges": [4516, 0, 4516, 47], "proof_ranges": [4517, 0, 4517, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "inverse_EV_in_domain", "text": "Theorem inverse_EV_in_domain :\n forall (R Y : Ens) (i : IN Y (Range R)), IN (inverse_EV R Y) (Domain R).\nProof inv_eval_in_domain_Out.\n", "definition": "\n forall (R Y : Ens) (i : IN Y (Range R)), IN (inverse_EV R Y) (Domain R).\n", "proof": "Proof inv_eval_in_domain_Out.", "proof_term": "Proof inv_eval_in_domain_Out.", "def_ranges": [4521, 0, 4522, 73], "proof_ranges": [4523, 0, 4523, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "relation_1_Out", "text": "Lemma relation_1_Out : is_a_pair X.\nProof r X step1.\n", "definition": " is_a_pair X.\n", "proof": "Proof r X step1.", "proof_term": "Proof r X step1.", "def_ranges": [4544, 0, 4544, 35], "proof_ranges": [4545, 0, 4545, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "relation_sub", "text": "Theorem relation_sub :\n forall (R : Ens) (r : is_a_relation R) (S : Ens), SUB S R -> is_a_relation S.\nProof relation_1_Out.\n", "definition": "\n forall (R : Ens) (r : is_a_relation R) (S : Ens), SUB S R -> is_a_relation S.\n", "proof": "Proof relation_1_Out.", "proof_term": "Proof relation_1_Out.", "def_ranges": [4549, 0, 4550, 78], "proof_ranges": [4551, 0, 4551, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "well_def_1_Out", "text": "Lemma well_def_1_Out : EQ Y Z.\nProof w X Y Z step1 step2.\n", "definition": " EQ Y Z.\n", "proof": "Proof w X Y Z step1 step2.", "proof_term": "Proof w X Y Z step1 step2.", "def_ranges": [4572, 0, 4572, 30], "proof_ranges": [4573, 0, 4573, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "well_definedness_sub", "text": "Theorem well_definedness_sub :\n forall (F : Ens) (w : well_definedness F) (R : Ens) (h : SUB R F),\n well_definedness R.\nProof well_def_1_Out.\n", "definition": "\n forall (F : Ens) (w : well_definedness F) (R : Ens) (h : SUB R F),\n well_definedness R.\n", "proof": "Proof well_def_1_Out.", "proof_term": "Proof well_def_1_Out.", "def_ranges": [4578, 0, 4580, 20], "proof_ranges": [4581, 0, 4581, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "function_sub", "text": "Theorem function_sub :\n forall (F : Ens) (f : is_a_function F) (G : Ens) (s : SUB G F),\n is_a_function G.\nProof\n  fun (F : Ens) (f : is_a_function F) (G : Ens) (s : SUB G F) =>\n  Build_is_a_function G (relation_sub F (function_is_a_relation F f) G s)\n    (well_definedness_sub F (function_well_definedness F f) G s).\n", "definition": "\n forall (F : Ens) (f : is_a_function F) (G : Ens) (s : SUB G F),\n is_a_function G.\n", "proof": "Proof\n  fun (F : Ens) (f : is_a_function F) (G : Ens) (s : SUB G F) =>\n  Build_is_a_function G (relation_sub F (function_is_a_relation F f) G s)\n    (well_definedness_sub F (function_well_definedness F f) G s).", "proof_term": "Proof\n  fun (F : Ens) (f : is_a_function F) (G : Ens) (s : SUB G F) =>\n  Build_is_a_function G (relation_sub F (function_is_a_relation F f) G s)\n    (well_definedness_sub F (function_well_definedness F f) G s).", "def_ranges": [4587, 0, 4589, 17], "proof_ranges": [4590, 0, 4593, 65], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "function_is_a_function_on", "text": "Theorem function_is_a_function_on :\n forall (F : Ens) (f : is_a_function F), is_a_function_on (Domain F) F.\nProof\n  fun (F : Ens) (f : is_a_function F) =>\n  Build_is_a_function_on (Domain F) F f (EQ_refl (Domain F)).\n", "definition": "\n forall (F : Ens) (f : is_a_function F), is_a_function_on (Domain F) F.\n", "proof": "Proof\n  fun (F : Ens) (f : is_a_function F) =>\n  Build_is_a_function_on (Domain F) F f (EQ_refl (Domain F)).", "proof_term": "Proof\n  fun (F : Ens) (f : is_a_function F) =>\n  Build_is_a_function_on (Domain F) F f (EQ_refl (Domain F)).", "def_ranges": [4598, 0, 4599, 71], "proof_ranges": [4600, 0, 4602, 61], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "function_1_Out_F", "text": "Lemma function_1_Out_F : EQ Y V.\nProof step5 X Y V i step3.\n", "definition": " EQ Y V.\n", "proof": "Proof step5 X Y V i step3.", "proof_term": "Proof step5 X Y V i step3.", "def_ranges": [4625, 0, 4625, 32], "proof_ranges": [4626, 0, 4626, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "function_th1", "text": "Theorem function_th1 :\n forall (F : Ens) (f : is_a_function F) (X Y : Ens) (i : IN (PAIR X Y) F),\n EQ Y (EV F X).\nProof function_1_Out_F.\n", "definition": "\n forall (F : Ens) (f : is_a_function F) (X Y : Ens) (i : IN (PAIR X Y) F),\n EQ Y (EV F X).\n", "proof": "Proof function_1_Out_F.", "proof_term": "Proof function_1_Out_F.", "def_ranges": [4632, 0, 4634, 15], "proof_ranges": [4635, 0, 4635, 23], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "ee_symm_Out", "text": "Lemma ee_symm_Out : EQ (EV G X) (EV F X).\nProof EQ_symm (EV F X) (EV G X) step1.\n", "definition": " EQ (EV G X) (EV F X).\n", "proof": "Proof EQ_symm (EV F X) (EV G X) step1.", "proof_term": "Proof EQ_symm (EV F X) (EV G X) step1.", "def_ranges": [4652, 0, 4652, 41], "proof_ranges": [4653, 0, 4653, 38], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "ex_eq_symm", "text": "Theorem ex_eq_symm :\n forall F G : Ens,\n Extensionally_equivalent F G -> Extensionally_equivalent G F.\nProof ee_symm_Out.\n", "definition": "\n forall F G : Ens,\n Extensionally_equivalent F G -> Extensionally_equivalent G F.\n", "proof": "Proof ee_symm_Out.", "proof_term": "Proof ee_symm_Out.", "def_ranges": [4658, 0, 4660, 62], "proof_ranges": [4661, 0, 4661, 18], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "ee_sub_Out", "text": "Lemma ee_sub_Out : IN M G.\nProof Extensionality M (PAIR X Y) G step3 step12.\n", "definition": " IN M G.\n", "proof": "Proof Extensionality M (PAIR X Y) G step3 step12.", "proof_term": "Proof Extensionality M (PAIR X Y) G step3 step12.", "def_ranges": [4720, 0, 4720, 26], "proof_ranges": [4721, 0, 4721, 49], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "ex_eq_sub", "text": "Theorem ex_eq_sub :\n forall (F G : Ens) (f : is_a_function F) (s : SUB (Domain F) (Domain G))\n   (e : Extensionally_equivalent F G), SUB F G.\nProof ee_sub_Out.\n", "definition": "\n forall (F G : Ens) (f : is_a_function F) (s : SUB (Domain F) (Domain G))\n   (e : Extensionally_equivalent F G), SUB F G.\n", "proof": "Proof ee_sub_Out.", "proof_term": "Proof ee_sub_Out.", "def_ranges": [4725, 0, 4727, 47], "proof_ranges": [4728, 0, 4728, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "ee_eq_Out", "text": "Lemma ee_eq_Out : EQ F G.\nProof Build_EQ F G step4 step5.\n", "definition": " EQ F G.\n", "proof": "Proof Build_EQ F G step4 step5.", "proof_term": "Proof Build_EQ F G step4 step5.", "def_ranges": [4752, 0, 4752, 25], "proof_ranges": [4753, 0, 4753, 31], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Extensionality_for_functions", "text": "Theorem Extensionality_for_functions :\n forall (F G : Ens) (f : is_a_function F) (g : is_a_function G)\n   (d : EQ (Domain F) (Domain G)) (e : Extensionally_equivalent F G), \n EQ F G.\nProof ee_eq_Out.\n", "definition": "\n forall (F G : Ens) (f : is_a_function F) (g : is_a_function G)\n   (d : EQ (Domain F) (Domain G)) (e : Extensionally_equivalent F G), \n EQ F G.\n", "proof": "Proof ee_eq_Out.", "proof_term": "Proof ee_eq_Out.", "def_ranges": [4759, 0, 4762, 8], "proof_ranges": [4763, 0, 4763, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "fe_Out", "text": "Lemma fe_Out : EQ Y Z.\nProof function_well_definedness F f X Y Z i step2.\n", "definition": " EQ Y Z.\n", "proof": "Proof function_well_definedness F f X Y Z i step2.", "proof_term": "Proof function_well_definedness F f X Y Z i step2.", "def_ranges": [4780, 0, 4780, 22], "proof_ranges": [4781, 0, 4781, 50], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "function_evaluation", "text": "Theorem function_evaluation :\n forall (F X Y : Ens) (f : is_a_function F) (i : IN (PAIR X Y) F),\n EQ Y (EV F X).\nProof fe_Out.\n", "definition": "\n forall (F X Y : Ens) (f : is_a_function F) (i : IN (PAIR X Y) F),\n EQ Y (EV F X).\n", "proof": "Proof fe_Out.", "proof_term": "Proof fe_Out.", "def_ranges": [4785, 0, 4787, 15], "proof_ranges": [4788, 0, 4788, 13], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th1", "text": "Theorem restricted_to_th1 :\n forall (A F U : Ens) (i : IN U F) (j : IN (PR1 U) A),\n IN U (restricted_to A F).\nProof\n  fun (A F U : Ens) (i : IN U F) (j : IN (PR1 U) A) =>\n  Set_Of_th1 F (fun M : Ens => IN (PR1 M) A) U i j.\n", "definition": "\n forall (A F U : Ens) (i : IN U F) (j : IN (PR1 U) A),\n IN U (restricted_to A F).\n", "proof": "Proof\n  fun (A F U : Ens) (i : IN U F) (j : IN (PR1 U) A) =>\n  Set_Of_th1 F (fun M : Ens => IN (PR1 M) A) U i j.", "proof_term": "Proof\n  fun (A F U : Ens) (i : IN U F) (j : IN (PR1 U) A) =>\n  Set_Of_th1 F (fun M : Ens => IN (PR1 M) A) U i j.", "def_ranges": [4796, 0, 4798, 26], "proof_ranges": [4799, 0, 4801, 51], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th2", "text": "Theorem restricted_to_th2 :\n forall (A F U : Ens) (i : IN U (restricted_to A F)), IN (PR1 U) A.\nProof\n  fun (A F U : Ens) (i : IN U (restricted_to A F)) =>\n  Set_Of_th2 F (fun M : Ens => IN (PR1 M) A) U i.\n", "definition": "\n forall (A F U : Ens) (i : IN U (restricted_to A F)), IN (PR1 U) A.\n", "proof": "Proof\n  fun (A F U : Ens) (i : IN U (restricted_to A F)) =>\n  Set_Of_th2 F (fun M : Ens => IN (PR1 M) A) U i.", "proof_term": "Proof\n  fun (A F U : Ens) (i : IN U (restricted_to A F)) =>\n  Set_Of_th2 F (fun M : Ens => IN (PR1 M) A) U i.", "def_ranges": [4803, 0, 4804, 67], "proof_ranges": [4805, 0, 4807, 49], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th3", "text": "Theorem restricted_to_th3 :\n forall (A F U : Ens) (i : IN U (restricted_to A F)), IN U F.\nProof\n  fun (A F U : Ens) (i : IN U (restricted_to A F)) =>\n  Set_Of_th3 F (fun M : Ens => IN (PR1 M) A) U i.\n", "definition": "\n forall (A F U : Ens) (i : IN U (restricted_to A F)), IN U F.\n", "proof": "Proof\n  fun (A F U : Ens) (i : IN U (restricted_to A F)) =>\n  Set_Of_th3 F (fun M : Ens => IN (PR1 M) A) U i.", "proof_term": "Proof\n  fun (A F U : Ens) (i : IN U (restricted_to A F)) =>\n  Set_Of_th3 F (fun M : Ens => IN (PR1 M) A) U i.", "def_ranges": [4809, 0, 4810, 61], "proof_ranges": [4811, 0, 4813, 49], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th4", "text": "Theorem restricted_to_th4 : forall A F : Ens, SUB (restricted_to A F) F.\nProof fun A F : Ens => restricted_to_th3 A F.\n", "definition": " forall A F : Ens, SUB (restricted_to A F) F.\n", "proof": "Proof fun A F : Ens => restricted_to_th3 A F.", "proof_term": "Proof fun A F : Ens => restricted_to_th3 A F.", "def_ranges": [4815, 0, 4815, 72], "proof_ranges": [4816, 0, 4816, 45], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "res_to_1a_Out", "text": "Lemma  (*Fact*) res_to_1a_Out : IN X (intersection A (Domain F)).\nProof intersection_th3 A (Domain F) X stepa5 stepa6.\n", "definition": " IN X (intersection A (Domain F)).\n", "proof": "Proof intersection_th3 A (Domain F) X stepa5 stepa6.", "proof_term": "Proof intersection_th3 A (Domain F) X stepa5 stepa6.", "def_ranges": [4851, 0, 4851, 65], "proof_ranges": [4852, 0, 4852, 52], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "res_to_1b_Out", "text": "Lemma  (*Fact*) res_to_1b_Out : IN X (Domain (restricted_to A F)).\nProof Domain_th1 (restricted_to A F) X Y stepb7.\n", "definition": " IN X (Domain (restricted_to A F)).\n", "proof": "Proof Domain_th1 (restricted_to A F) X Y stepb7.", "proof_term": "Proof Domain_th1 (restricted_to A F) X Y stepb7.", "def_ranges": [4887, 0, 4887, 66], "proof_ranges": [4888, 0, 4888, 48], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "res_to_1_Out", "text": "Lemma res_to_1_Out :\n EQ (intersection A (Domain F)) (Domain (restricted_to A F)).\nProof\n  Build_EQ (intersection A (Domain F)) (Domain (restricted_to A F)) step2\n    step1.\n", "definition": "\n EQ (intersection A (Domain F)) (Domain (restricted_to A F)).\n", "proof": "Proof\n  Build_EQ (intersection A (Domain F)) (Domain (restricted_to A F)) step2\n    step1.", "proof_term": "Proof\n  Build_EQ (intersection A (Domain F)) (Domain (restricted_to A F)) step2\n    step1.", "def_ranges": [4895, 0, 4896, 61], "proof_ranges": [4897, 0, 4899, 10], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th5", "text": "Theorem restricted_to_th5 :\n forall A F : Ens,\n EQ (intersection A (Domain F)) (Domain (restricted_to A F)).\nProof res_to_1_Out.\n", "definition": "\n forall A F : Ens,\n EQ (intersection A (Domain F)) (Domain (restricted_to A F)).\n", "proof": "Proof res_to_1_Out.", "proof_term": "Proof res_to_1_Out.", "def_ranges": [4904, 0, 4906, 61], "proof_ranges": [4907, 0, 4907, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "res_to_2_Out", "text": "Lemma res_to_2_Out : IN U (restricted_to A F).\nProof restricted_to_th1 A F U i step7.\n", "definition": " IN U (restricted_to A F).\n", "proof": "Proof restricted_to_th1 A F U i step7.", "proof_term": "Proof restricted_to_th1 A F U i step7.", "def_ranges": [4942, 0, 4942, 46], "proof_ranges": [4943, 0, 4943, 38], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th6", "text": "Theorem restricted_to_th6 :\n forall (A F : Ens) (f : is_a_function F) (s : SUB (Domain F) A),\n SUB F (restricted_to A F).\nProof res_to_2_Out.\n", "definition": "\n forall (A F : Ens) (f : is_a_function F) (s : SUB (Domain F) A),\n SUB F (restricted_to A F).\n", "proof": "Proof res_to_2_Out.", "proof_term": "Proof res_to_2_Out.", "def_ranges": [4947, 0, 4949, 27], "proof_ranges": [4950, 0, 4950, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th7", "text": "Theorem restricted_to_th7 :\n forall (A F : Ens) (f : is_a_function F) (s : SUB (Domain F) A),\n EQ F (restricted_to A F).\nProof\n  fun (A F : Ens) (f : is_a_function F) (s : SUB (Domain F) A) =>\n  Build_EQ F (restricted_to A F) (restricted_to_th6 A F f s)\n    (restricted_to_th4 A F).\n", "definition": "\n forall (A F : Ens) (f : is_a_function F) (s : SUB (Domain F) A),\n EQ F (restricted_to A F).\n", "proof": "Proof\n  fun (A F : Ens) (f : is_a_function F) (s : SUB (Domain F) A) =>\n  Build_EQ F (restricted_to A F) (restricted_to_th6 A F f s)\n    (restricted_to_th4 A F).", "proof_term": "Proof\n  fun (A F : Ens) (f : is_a_function F) (s : SUB (Domain F) A) =>\n  Build_EQ F (restricted_to A F) (restricted_to_th6 A F f s)\n    (restricted_to_th4 A F).", "def_ranges": [4952, 0, 4954, 26], "proof_ranges": [4955, 0, 4958, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "res_to_3_Out", "text": "Lemma res_to_3_Out : EQ Y Z.\nProof function_well_definedness F f X Y Z step5 step7.\n", "definition": " EQ Y Z.\n", "proof": "Proof function_well_definedness F f X Y Z step5 step7.", "proof_term": "Proof function_well_definedness F f X Y Z step5 step7.", "def_ranges": [4992, 0, 4992, 28], "proof_ranges": [4993, 0, 4993, 54], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th8", "text": "Theorem restricted_to_th8 :\n forall (A F : Ens) (f : is_a_function F) (X : Ens)\n   (i : IN X (intersection A (Domain F))),\n EQ (EV F X) (EV (restricted_to A F) X).\nProof res_to_3_Out.\n", "definition": "\n forall (A F : Ens) (f : is_a_function F) (X : Ens)\n   (i : IN X (intersection A (Domain F))),\n EQ (EV F X) (EV (restricted_to A F) X).\n", "proof": "Proof res_to_3_Out.", "proof_term": "Proof res_to_3_Out.", "def_ranges": [4997, 0, 5000, 40], "proof_ranges": [5001, 0, 5001, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "restricted_to_th9", "text": "Theorem restricted_to_th9 :\n forall (A F : Ens) (f : is_a_function F) (X : Ens) \n   (i : IN X A) (j : IN X (Domain F)), EQ (EV F X) (EV (restricted_to A F) X).\nProof\n  fun (A F : Ens) (f : is_a_function F) (X : Ens) (i : IN X A)\n    (j : IN X (Domain F)) =>\n  restricted_to_th8 A F f X (intersection_th3 A (Domain F) X i j).\n", "definition": "\n forall (A F : Ens) (f : is_a_function F) (X : Ens) \n   (i : IN X A) (j : IN X (Domain F)), EQ (EV F X) (EV (restricted_to A F) X).\n", "proof": "Proof\n  fun (A F : Ens) (f : is_a_function F) (X : Ens) (i : IN X A)\n    (j : IN X (Domain F)) =>\n  restricted_to_th8 A F f X (intersection_th3 A (Domain F) X i j).", "proof_term": "Proof\n  fun (A F : Ens) (f : is_a_function F) (X : Ens) (i : IN X A)\n    (j : IN X (Domain F)) =>\n  restricted_to_th8 A F f X (intersection_th3 A (Domain F) X i j).", "def_ranges": [5003, 0, 5005, 78], "proof_ranges": [5006, 0, 5009, 66], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "emptyfn1_Out", "text": "Lemma emptyfn1_Out : is_a_pair X.\nProof false_implies_everything (is_a_pair X) step1.\n", "definition": " is_a_pair X.\n", "proof": "Proof false_implies_everything (is_a_pair X) step1.", "proof_term": "Proof false_implies_everything (is_a_pair X) step1.", "def_ranges": [5023, 0, 5023, 33], "proof_ranges": [5024, 0, 5024, 51], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "empty_function_relation", "text": "Theorem empty_function_relation : is_a_relation Zero.\nProof emptyfn1_Out.\n", "definition": " is_a_relation Zero.\n", "proof": "Proof emptyfn1_Out.", "proof_term": "Proof emptyfn1_Out.", "def_ranges": [5028, 0, 5028, 53], "proof_ranges": [5029, 0, 5029, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "emptyfn2_Out", "text": "Lemma emptyfn2_Out : EQ Y Z.\nProof false_implies_everything (EQ Y Z) step1.\n", "definition": " EQ Y Z.\n", "proof": "Proof false_implies_everything (EQ Y Z) step1.", "proof_term": "Proof false_implies_everything (EQ Y Z) step1.", "def_ranges": [5038, 0, 5038, 28], "proof_ranges": [5039, 0, 5039, 46], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "empty_function_well_definedness", "text": "Theorem empty_function_well_definedness : well_definedness Zero.\nProof\n  fun (X Y Z : Ens) (i : IN (PAIR X Y) Zero) (j : IN (PAIR X Z) Zero) =>\n  emptyfn2_Out X Y Z i.\n", "definition": " well_definedness Zero.\n", "proof": "Proof\n  fun (X Y Z : Ens) (i : IN (PAIR X Y) Zero) (j : IN (PAIR X Z) Zero) =>\n  emptyfn2_Out X Y Z i.", "proof_term": "Proof\n  fun (X Y Z : Ens) (i : IN (PAIR X Y) Zero) (j : IN (PAIR X Z) Zero) =>\n  emptyfn2_Out X Y Z i.", "def_ranges": [5043, 0, 5043, 64], "proof_ranges": [5044, 0, 5046, 23], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "empty_function_function", "text": "Theorem empty_function_function : is_a_function Zero.\nProof\n  Build_is_a_function Zero empty_function_relation\n    empty_function_well_definedness.\n", "definition": " is_a_function Zero.\n", "proof": "Proof\n  Build_is_a_function Zero empty_function_relation\n    empty_function_well_definedness.", "proof_term": "Proof\n  Build_is_a_function Zero empty_function_relation\n    empty_function_well_definedness.", "def_ranges": [5048, 0, 5048, 53], "proof_ranges": [5049, 0, 5051, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "efdom_Out", "text": "Lemma efdom_Out : False.\nProof EmptySet_th1 (PAIR X Y) step1.\n", "definition": " False.\n", "proof": "Proof EmptySet_th1 (PAIR X Y) step1.", "proof_term": "Proof EmptySet_th1 (PAIR X Y) step1.", "def_ranges": [5062, 0, 5062, 24], "proof_ranges": [5063, 0, 5063, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "empty_function_domain_empty", "text": "Theorem empty_function_domain_empty : Its_empty (Domain Zero).\nProof efdom_Out.\n", "definition": " Its_empty (Domain Zero).\n", "proof": "Proof efdom_Out.", "proof_term": "Proof efdom_Out.", "def_ranges": [5067, 0, 5067, 62], "proof_ranges": [5068, 0, 5068, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "empty_function_domain", "text": "Theorem empty_function_domain : EQ Zero (Domain Zero).\nProof\n  EQ_symm (Domain Zero) Zero\n    (its_empty_implies_equals_emptyset (Domain Zero)\n       empty_function_domain_empty).\n", "definition": " EQ Zero (Domain Zero).\n", "proof": "Proof\n  EQ_symm (Domain Zero) Zero\n    (its_empty_implies_equals_emptyset (Domain Zero)\n       empty_function_domain_empty).", "proof_term": "Proof\n  EQ_symm (Domain Zero) Zero\n    (its_empty_implies_equals_emptyset (Domain Zero)\n       empty_function_domain_empty).", "def_ranges": [5070, 0, 5070, 54], "proof_ranges": [5071, 0, 5074, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PowerPlus_th1", "text": "Theorem PowerPlus_th1 : forall A : Ens, SUB A (PowerPlus A).\nProof fun A : Ens => union_pr1 A (Powerset A).\n", "definition": " forall A : Ens, SUB A (PowerPlus A).\n", "proof": "Proof fun A : Ens => union_pr1 A (Powerset A).", "proof_term": "Proof fun A : Ens => union_pr1 A (Powerset A).", "def_ranges": [5085, 0, 5085, 60], "proof_ranges": [5086, 0, 5086, 46], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PowerPlus_th2", "text": "Theorem PowerPlus_th2 : forall A : Ens, SUB (Powerset A) (PowerPlus A).\nProof fun A : Ens => union_pr2 A (Powerset A).\n", "definition": " forall A : Ens, SUB (Powerset A) (PowerPlus A).\n", "proof": "Proof fun A : Ens => union_pr2 A (Powerset A).", "proof_term": "Proof fun A : Ens => union_pr2 A (Powerset A).", "def_ranges": [5088, 0, 5088, 71], "proof_ranges": [5089, 0, 5089, 46], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "powerplus1_Out", "text": "Lemma powerplus1_Out : IN (PAIR X Y) (Powerset PP).\nProof Powerset_th5 PP (First X) (Second Y) step3 step9.\n", "definition": " IN (PAIR X Y) (Powerset PP).\n", "proof": "Proof Powerset_th5 PP (First X) (Second Y) step3 step9.", "proof_term": "Proof Powerset_th5 PP (First X) (Second Y) step3 step9.", "def_ranges": [5131, 0, 5131, 51], "proof_ranges": [5132, 0, 5132, 55], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PowerTotal_th1", "text": "Theorem PowerTotal_th1 :\n forall (A X Y : Ens) (x : IN X A) (y : IN Y A), IN (PAIR X Y) (PowerTotal A).\nProof powerplus1_Out.\n", "definition": "\n forall (A X Y : Ens) (x : IN X A) (y : IN Y A), IN (PAIR X Y) (PowerTotal A).\n", "proof": "Proof powerplus1_Out.", "proof_term": "Proof powerplus1_Out.", "def_ranges": [5138, 0, 5139, 78], "proof_ranges": [5140, 0, 5140, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "powerplus2_Out", "text": "Lemma powerplus2_Out : IN (PAIR X Y) (PowerTotal U).\nProof PowerTotal_th1 U X Y step3 step4.\n", "definition": " IN (PAIR X Y) (PowerTotal U).\n", "proof": "Proof PowerTotal_th1 U X Y step3 step4.", "proof_term": "Proof PowerTotal_th1 U X Y step3 step4.", "def_ranges": [5157, 0, 5157, 52], "proof_ranges": [5158, 0, 5158, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "PowerTotal_th2", "text": "Theorem PowerTotal_th2 :\n forall (A B X Y : Ens) (x : IN X A) (y : IN Y B),\n IN (PAIR X Y) (PowerTotal (union A B)).\nProof powerplus2_Out.\n", "definition": "\n forall (A B X Y : Ens) (x : IN X A) (y : IN Y B),\n IN (PAIR X Y) (PowerTotal (union A B)).\n", "proof": "Proof powerplus2_Out.", "proof_term": "Proof powerplus2_Out.", "def_ranges": [5162, 0, 5164, 40], "proof_ranges": [5165, 0, 5165, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "cpb1_Out", "text": "Lemma cpb1_Out : IN U (PowerTotal (union A B)).\nProof Extensionality U (PAIR X Y) (PowerTotal (union A B)) step4 step7.\n", "definition": " IN U (PowerTotal (union A B)).\n", "proof": "Proof Extensionality U (PAIR X Y) (PowerTotal (union A B)) step4 step7.", "proof_term": "Proof Extensionality U (PAIR X Y) (PowerTotal (union A B)) step4 step7.", "def_ranges": [5201, 0, 5201, 47], "proof_ranges": [5202, 0, 5202, 71], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "in_cartesian_bounded_Out", "text": "Lemma in_cartesian_bounded_Out : Bounded (in_cartesian A B).\nProof Bounded_th2 (in_cartesian A B) (PowerTotal (union A B)) step8.\n", "definition": " Bounded (in_cartesian A B).\n", "proof": "Proof Bounded_th2 (in_cartesian A B) (PowerTotal (union A B)) step8.", "proof_term": "Proof Bounded_th2 (in_cartesian A B) (PowerTotal (union A B)) step8.", "def_ranges": [5209, 0, 5209, 60], "proof_ranges": [5210, 0, 5210, 68], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "in_cartesian_bounded", "text": "Theorem in_cartesian_bounded : forall A B : Ens, Bounded (in_cartesian A B).\nProof in_cartesian_bounded_Out.\n", "definition": " forall A B : Ens, Bounded (in_cartesian A B).\n", "proof": "Proof in_cartesian_bounded_Out.", "proof_term": "Proof in_cartesian_bounded_Out.", "def_ranges": [5214, 0, 5214, 76], "proof_ranges": [5215, 0, 5215, 31], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Cartesian_pr1", "text": "Theorem Cartesian_pr1 :\n forall (A B M : Ens) (h : in_cartesian A B M), IN M (Cartesian A B).\nProof\n  fun A B : Ens =>\n  REPLACEMENT_pr1 (in_cartesian A B) (in_cartesian_bounded A B).\n", "definition": "\n forall (A B M : Ens) (h : in_cartesian A B M), IN M (Cartesian A B).\n", "proof": "Proof\n  fun A B : Ens =>\n  REPLACEMENT_pr1 (in_cartesian A B) (in_cartesian_bounded A B).", "proof_term": "Proof\n  fun A B : Ens =>\n  REPLACEMENT_pr1 (in_cartesian A B) (in_cartesian_bounded A B).", "def_ranges": [5220, 0, 5221, 69], "proof_ranges": [5222, 0, 5224, 64], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Cartesian_pr2", "text": "Theorem Cartesian_pr2 :\n forall (A B M : Ens) (i : IN M (Cartesian A B)), in_cartesian A B M.\nProof\n  fun A B : Ens =>\n  REPLACEMENT_pr2 (in_cartesian A B) (in_cartesian_bounded A B).\n", "definition": "\n forall (A B M : Ens) (i : IN M (Cartesian A B)), in_cartesian A B M.\n", "proof": "Proof\n  fun A B : Ens =>\n  REPLACEMENT_pr2 (in_cartesian A B) (in_cartesian_bounded A B).", "proof_term": "Proof\n  fun A B : Ens =>\n  REPLACEMENT_pr2 (in_cartesian A B) (in_cartesian_bounded A B).", "def_ranges": [5226, 0, 5227, 69], "proof_ranges": [5228, 0, 5230, 64], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "cartesian_construction_Out", "text": "Lemma cartesian_construction_Out : IN U (Cartesian A B).\nProof Cartesian_pr1 A B U step9.\n", "definition": " IN U (Cartesian A B).\n", "proof": "Proof Cartesian_pr1 A B U step9.", "proof_term": "Proof Cartesian_pr1 A B U step9.", "def_ranges": [5266, 0, 5266, 56], "proof_ranges": [5267, 0, 5267, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Cartesian_construction", "text": "Theorem Cartesian_construction :\n forall (A B X Y : Ens) (i : IN X A) (j : IN Y B),\n IN (PAIR X Y) (Cartesian A B).\nProof cartesian_construction_Out.\n", "definition": "\n forall (A B X Y : Ens) (i : IN X A) (j : IN Y B),\n IN (PAIR X Y) (Cartesian A B).\n", "proof": "Proof cartesian_construction_Out.", "proof_term": "Proof cartesian_construction_Out.", "def_ranges": [5273, 0, 5275, 31], "proof_ranges": [5276, 0, 5276, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Cartesian_th1", "text": "Theorem Cartesian_th1 :\n forall (A B U : Ens) (i : IN U (Cartesian A B)), is_a_pair U.\nProof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pair A B U (Cartesian_pr2 A B U i).\n", "definition": "\n forall (A B U : Ens) (i : IN U (Cartesian A B)), is_a_pair U.\n", "proof": "Proof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pair A B U (Cartesian_pr2 A B U i).", "proof_term": "Proof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pair A B U (Cartesian_pr2 A B U i).", "def_ranges": [5278, 0, 5279, 62], "proof_ranges": [5280, 0, 5282, 50], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Cartesian_proj1_th", "text": "Theorem Cartesian_proj1_th :\n forall (A B U : Ens) (i : IN U (Cartesian A B)), IN (PR1 U) A.\nProof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pr1 A B U (Cartesian_pr2 A B U i).\n", "definition": "\n forall (A B U : Ens) (i : IN U (Cartesian A B)), IN (PR1 U) A.\n", "proof": "Proof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pr1 A B U (Cartesian_pr2 A B U i).", "proof_term": "Proof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pr1 A B U (Cartesian_pr2 A B U i).", "def_ranges": [5284, 0, 5285, 63], "proof_ranges": [5286, 0, 5288, 49], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Cartesian_proj2_th", "text": "Theorem Cartesian_proj2_th :\n forall (A B U : Ens) (i : IN U (Cartesian A B)), IN (PR2 U) B.\nProof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pr2 A B U (Cartesian_pr2 A B U i).\n", "definition": "\n forall (A B U : Ens) (i : IN U (Cartesian A B)), IN (PR2 U) B.\n", "proof": "Proof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pr2 A B U (Cartesian_pr2 A B U i).", "proof_term": "Proof\n  fun (A B U : Ens) (i : IN U (Cartesian A B)) =>\n  in_cartesian_pr2 A B U (Cartesian_pr2 A B U i).", "def_ranges": [5290, 0, 5291, 63], "proof_ranges": [5292, 0, 5294, 49], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "cartpairA_Out", "text": "Lemma cartpairA_Out : IN X A.\nProof Extensionality X X1 A step1 step2.\n", "definition": " IN X A.\n", "proof": "Proof Extensionality X X1 A step1 step2.", "proof_term": "Proof Extensionality X X1 A step1 step2.", "def_ranges": [5311, 0, 5311, 29], "proof_ranges": [5312, 0, 5312, 40], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "cartpairB_Out", "text": "Lemma cartpairB_Out : IN Y B.\nProof Extensionality Y Y1 B step3 step4.\n", "definition": " IN Y B.\n", "proof": "Proof Extensionality Y Y1 B step3 step4.", "proof_term": "Proof Extensionality Y Y1 B step3 step4.", "def_ranges": [5320, 0, 5320, 29], "proof_ranges": [5321, 0, 5321, 40], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Cartesian_pair_th1", "text": "Theorem Cartesian_pair_th1 :\n forall (A B X Y : Ens) (i : IN (PAIR X Y) (Cartesian A B)), IN X A.\nProof cartpairA_Out.\n", "definition": "\n forall (A B X Y : Ens) (i : IN (PAIR X Y) (Cartesian A B)), IN X A.\n", "proof": "Proof cartpairA_Out.", "proof_term": "Proof cartpairA_Out.", "def_ranges": [5325, 0, 5326, 68], "proof_ranges": [5327, 0, 5327, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Cartesian_pair_th2", "text": "Theorem Cartesian_pair_th2 :\n forall (A B X Y : Ens) (i : IN (PAIR X Y) (Cartesian A B)), IN Y B.\nProof cartpairB_Out.\n", "definition": "\n forall (A B X Y : Ens) (i : IN (PAIR X Y) (Cartesian A B)), IN Y B.\n", "proof": "Proof cartpairB_Out.", "proof_term": "Proof cartpairB_Out.", "def_ranges": [5329, 0, 5330, 68], "proof_ranges": [5331, 0, 5331, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "relations_in_cartesian_Out", "text": "Lemma relations_in_cartesian_Out : IN U (Cartesian A B).\nProof Extensionality U (PAIR X Y) (Cartesian A B) step2 step7.\n", "definition": " IN U (Cartesian A B).\n", "proof": "Proof Extensionality U (PAIR X Y) (Cartesian A B) step2 step7.", "proof_term": "Proof Extensionality U (PAIR X Y) (Cartesian A B) step2 step7.", "def_ranges": [5370, 0, 5370, 56], "proof_ranges": [5371, 0, 5371, 62], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "relations_in_cartesian", "text": "Theorem relations_in_cartesian :\n forall (R : Ens) (r : is_a_relation R),\n SUB R (Cartesian (Domain R) (Range R)).\nProof relations_in_cartesian_Out.\n", "definition": "\n forall (R : Ens) (r : is_a_relation R),\n SUB R (Cartesian (Domain R) (Range R)).\n", "proof": "Proof relations_in_cartesian_Out.", "proof_term": "Proof relations_in_cartesian_Out.", "def_ranges": [5378, 0, 5380, 40], "proof_ranges": [5381, 0, 5381, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "cartesian_is_relation_Out", "text": "Lemma cartesian_is_relation_Out : is_a_pair U.\nProof in_cartesian_pair A B U step1.\n", "definition": " is_a_pair U.\n", "proof": "Proof in_cartesian_pair A B U step1.", "proof_term": "Proof in_cartesian_pair A B U step1.", "def_ranges": [5392, 0, 5392, 46], "proof_ranges": [5393, 0, 5393, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "cartesian_is_relation", "text": "Theorem cartesian_is_relation :\n forall A B : Ens, is_a_relation (Cartesian A B).\nProof cartesian_is_relation_Out.\n", "definition": "\n forall A B : Ens, is_a_relation (Cartesian A B).\n", "proof": "Proof cartesian_is_relation_Out.", "proof_term": "Proof cartesian_is_relation_Out.", "def_ranges": [5397, 0, 5398, 49], "proof_ranges": [5399, 0, 5399, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "cartesian_subs_are_relations", "text": "Theorem cartesian_subs_are_relations :\n forall (A B R : Ens) (s : SUB R (Cartesian A B)), is_a_relation R.\nProof\n  fun (A B R : Ens) (s : SUB R (Cartesian A B)) =>\n  relation_sub (Cartesian A B) (cartesian_is_relation A B) R s. \n\n(******* covering ***********)\n\nSection covering_1.\n", "definition": "\n forall (A B R : Ens) (s : SUB R (Cartesian A B)), is_a_relation R.\n", "proof": "Proof\n  fun (A B R : Ens) (s : SUB R (Cartesian A B)) =>\n  relation_sub (Cartesian A B) (cartesian_is_relation A B) R s. \n\n(******* covering ***********)\n\nSection covering_1.", "proof_term": "Proof\n  fun (A B R : Ens) (s : SUB R (Cartesian A B)) =>\n  relation_sub (Cartesian A B) (cartesian_is_relation A B) R s. \n\n(******* covering ***********)\n\nSection covering_1.", "def_ranges": [5401, 0, 5402, 67], "proof_ranges": [5403, 0, 5409, 19], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "stepA6", "text": "Lemma  (*Fact*) stepA6 : False.\nProof contra stepA5.\n", "definition": " False.\n", "proof": "Proof contra stepA5.", "proof_term": "Proof contra stepA5.", "def_ranges": [5501, 0, 5501, 31], "proof_ranges": [5502, 0, 5502, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "stepB6", "text": "Lemma  (*Fact*) stepB6 : False.\nProof contra stepB5.\n", "definition": " False.\n", "proof": "Proof contra stepB5.", "proof_term": "Proof contra stepB5.", "def_ranges": [5527, 0, 5527, 31], "proof_ranges": [5528, 0, 5528, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "covering_em_Out", "text": "Lemma  (*Fact*) covering_em_Out : False.\nProof step13 iX.\n", "definition": " False.\n", "proof": "Proof step13 iX.", "proof_term": "Proof step13 iX.", "def_ranges": [5538, 0, 5538, 40], "proof_ranges": [5539, 0, 5539, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "covering_1_Out", "text": "Lemma covering_1_Out : EQ (EV F X) (EV G X).\nProof excluded_middle (EQ (EV F X) (EV G X)) covering_em_Out.\n", "definition": " EQ (EV F X) (EV G X).\n", "proof": "Proof excluded_middle (EQ (EV F X) (EV G X)) covering_em_Out.", "proof_term": "Proof excluded_middle (EQ (EV F X) (EV G X)) covering_em_Out.", "def_ranges": [5543, 0, 5543, 44], "proof_ranges": [5544, 0, 5544, 61], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "covering_th1", "text": "Theorem covering_th1 :\n forall (A B F G : Ens) (f : is_a_function F) (g : is_a_function G)\n   (u : EQ (Domain F) (union A B))\n   (i : EQ (restricted_to A F) (restricted_to A G))\n   (j : EQ (restricted_to B F) (restricted_to B G)),\n Extensionally_equivalent F G.\nProof covering_1_Out.\n", "definition": "\n forall (A B F G : Ens) (f : is_a_function F) (g : is_a_function G)\n   (u : EQ (Domain F) (union A B))\n   (i : EQ (restricted_to A F) (restricted_to A G))\n   (j : EQ (restricted_to B F) (restricted_to B G)),\n Extensionally_equivalent F G.\n", "proof": "Proof covering_1_Out.", "proof_term": "Proof covering_1_Out.", "def_ranges": [5550, 0, 5555, 30], "proof_ranges": [5556, 0, 5556, 21], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "covering_th2", "text": "Theorem covering_th2 :\n forall (A B F G : Ens) (f : is_a_function F) (g : is_a_function G)\n   (u : EQ (Domain F) (union A B)) (v : EQ (Domain G) (union A B))\n   (i : EQ (restricted_to A F) (restricted_to A G))\n   (j : EQ (restricted_to B F) (restricted_to B G)), \n EQ F G.\nProof\n  fun (A B F G : Ens) (f : is_a_function F) (g : is_a_function G)\n    (u : EQ (Domain F) (union A B)) (v : EQ (Domain G) (union A B))\n    (i : EQ (restricted_to A F) (restricted_to A G))\n    (j : EQ (restricted_to B F) (restricted_to B G)) =>\n  Extensionality_for_functions F G f g\n    (EQ_trans (Domain F) (union A B) (Domain G) u\n       (EQ_symm (Domain G) (union A B) v)) (covering_th1 A B F G f g u i j). \n\n\n(***** glueing two functions ******)\n\nSection glueing_relation_proof.\n", "definition": "\n forall (A B F G : Ens) (f : is_a_function F) (g : is_a_function G)\n   (u : EQ (Domain F) (union A B)) (v : EQ (Domain G) (union A B))\n   (i : EQ (restricted_to A F) (restricted_to A G))\n   (j : EQ (restricted_to B F) (restricted_to B G)), \n EQ F G.\n", "proof": "Proof\n  fun (A B F G : Ens) (f : is_a_function F) (g : is_a_function G)\n    (u : EQ (Domain F) (union A B)) (v : EQ (Domain G) (union A B))\n    (i : EQ (restricted_to A F) (restricted_to A G))\n    (j : EQ (restricted_to B F) (restricted_to B G)) =>\n  Extensionality_for_functions F G f g\n    (EQ_trans (Domain F) (union A B) (Domain G) u\n       (EQ_symm (Domain G) (union A B) v)) (covering_th1 A B F G f g u i j). \n\n\n(***** glueing two functions ******)\n\nSection glueing_relation_proof.", "proof_term": "Proof\n  fun (A B F G : Ens) (f : is_a_function F) (g : is_a_function G)\n    (u : EQ (Domain F) (union A B)) (v : EQ (Domain G) (union A B))\n    (i : EQ (restricted_to A F) (restricted_to A G))\n    (j : EQ (restricted_to B F) (restricted_to B G)) =>\n  Extensionality_for_functions F G f g\n    (EQ_trans (Domain F) (union A B) (Domain G) u\n       (EQ_symm (Domain G) (union A B) v)) (covering_th1 A B F G f g u i j). \n\n\n(***** glueing two functions ******)\n\nSection glueing_relation_proof.", "def_ranges": [5558, 0, 5563, 8], "proof_ranges": [5564, 0, 5576, 31], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gr1_Out", "text": "Lemma gr1_Out : is_a_pair X.\nProof f X x1.\n", "definition": " is_a_pair X.\n", "proof": "Proof f X x1.", "proof_term": "Proof f X x1.", "def_ranges": [5588, 0, 5588, 28], "proof_ranges": [5589, 0, 5589, 13], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gr2_Out", "text": "Lemma gr2_Out : is_a_pair X.\nProof g X x2.\n", "definition": " is_a_pair X.\n", "proof": "Proof g X x2.", "proof_term": "Proof g X x2.", "def_ranges": [5594, 0, 5594, 28], "proof_ranges": [5595, 0, 5595, 13], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gr_Out", "text": "Lemma gr_Out : is_a_pair X.\nProof union_th4 (is_a_pair X) F G X x gr1_Out gr2_Out.\n", "definition": " is_a_pair X.\n", "proof": "Proof union_th4 (is_a_pair X) F G X x gr1_Out gr2_Out.", "proof_term": "Proof union_th4 (is_a_pair X) F G X x gr1_Out gr2_Out.", "def_ranges": [5598, 0, 5598, 27], "proof_ranges": [5599, 0, 5599, 54], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "glueing_th1", "text": "Theorem glueing_th1 :\n forall (F G : Ens) (f : is_a_relation F) (g : is_a_relation G),\n is_a_relation (union F G).\nProof gr_Out.\n", "definition": "\n forall (F G : Ens) (f : is_a_relation F) (g : is_a_relation G),\n is_a_relation (union F G).\n", "proof": "Proof gr_Out.", "proof_term": "Proof gr_Out.", "def_ranges": [5603, 0, 5605, 27], "proof_ranges": [5606, 0, 5606, 13], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gd1a_Out", "text": "Lemma gd1a_Out : IN X (union (Domain F) (Domain G)).\nProof union_th1 (Domain F) (Domain G) X step2.\n", "definition": " IN X (union (Domain F) (Domain G)).\n", "proof": "Proof union_th1 (Domain F) (Domain G) X step2.", "proof_term": "Proof union_th1 (Domain F) (Domain G) X step2.", "def_ranges": [5623, 0, 5623, 52], "proof_ranges": [5624, 0, 5624, 46], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gd1b_Out", "text": "Lemma gd1b_Out : IN X (union (Domain F) (Domain G)).\nProof union_th2 (Domain F) (Domain G) X step3.\n", "definition": " IN X (union (Domain F) (Domain G)).\n", "proof": "Proof union_th2 (Domain F) (Domain G) X step3.", "proof_term": "Proof union_th2 (Domain F) (Domain G) X step3.", "def_ranges": [5632, 0, 5632, 52], "proof_ranges": [5633, 0, 5633, 46], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "glueing_domain1_Out", "text": "Lemma glueing_domain1_Out : IN X (union (Domain F) (Domain G)).\nProof\n  union_th4 (IN X (union (Domain F) (Domain G))) F G \n    (PAIR X Y) step1 gd1a_Out gd1b_Out.\n", "definition": " IN X (union (Domain F) (Domain G)).\n", "proof": "Proof\n  union_th4 (IN X (union (Domain F) (Domain G))) F G \n    (PAIR X Y) step1 gd1a_Out gd1b_Out.", "proof_term": "Proof\n  union_th4 (IN X (union (Domain F) (Domain G))) F G \n    (PAIR X Y) step1 gd1a_Out gd1b_Out.", "def_ranges": [5636, 0, 5636, 63], "proof_ranges": [5637, 0, 5639, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "glueing_th2", "text": "Theorem glueing_th2 :\n forall F G : Ens, SUB (Domain (union F G)) (union (Domain F) (Domain G)).\nProof glueing_domain1_Out.\n", "definition": "\n forall F G : Ens, SUB (Domain (union F G)) (union (Domain F) (Domain G)).\n", "proof": "Proof glueing_domain1_Out.", "proof_term": "Proof glueing_domain1_Out.", "def_ranges": [5642, 0, 5643, 74], "proof_ranges": [5644, 0, 5644, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gd2A_Out", "text": "Lemma gd2A_Out : IN X (Domain H).\nProof Domain_th1 H X Y step2.\n", "definition": " IN X (Domain H).\n", "proof": "Proof Domain_th1 H X Y step2.", "proof_term": "Proof Domain_th1 H X Y step2.", "def_ranges": [5663, 0, 5663, 33], "proof_ranges": [5664, 0, 5664, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gd2B_Out", "text": "Lemma gd2B_Out : IN X (Domain H).\nProof Domain_th1 H X Y step2.\n", "definition": " IN X (Domain H).\n", "proof": "Proof Domain_th1 H X Y step2.", "proof_term": "Proof Domain_th1 H X Y step2.", "def_ranges": [5679, 0, 5679, 33], "proof_ranges": [5680, 0, 5680, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gd2_Out", "text": "Lemma gd2_Out : IN X (Domain H).\nProof union_th4 (IN X (Domain H)) (Domain F) (Domain G) X x gd2A_Out gd2B_Out.\n", "definition": " IN X (Domain H).\n", "proof": "Proof union_th4 (IN X (Domain H)) (Domain F) (Domain G) X x gd2A_Out gd2B_Out.", "proof_term": "Proof union_th4 (IN X (Domain H)) (Domain F) (Domain G) X x gd2A_Out gd2B_Out.", "def_ranges": [5684, 0, 5684, 32], "proof_ranges": [5685, 0, 5685, 78], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "glueing_th3", "text": "Theorem glueing_th3 :\n forall F G : Ens, SUB (union (Domain F) (Domain G)) (Domain (union F G)).\nProof gd2_Out.\n", "definition": "\n forall F G : Ens, SUB (union (Domain F) (Domain G)) (Domain (union F G)).\n", "proof": "Proof gd2_Out.", "proof_term": "Proof gd2_Out.", "def_ranges": [5689, 0, 5690, 74], "proof_ranges": [5691, 0, 5691, 14], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "glueing_th4", "text": "Theorem glueing_th4 :\n forall F G : Ens, EQ (Domain (union F G)) (union (Domain F) (Domain G)).\nProof\n  fun F G : Ens =>\n  Build_EQ (Domain (union F G)) (union (Domain F) (Domain G))\n    (glueing_th2 F G) (glueing_th3 F G).\n", "definition": "\n forall F G : Ens, EQ (Domain (union F G)) (union (Domain F) (Domain G)).\n", "proof": "Proof\n  fun F G : Ens =>\n  Build_EQ (Domain (union F G)) (union (Domain F) (Domain G))\n    (glueing_th2 F G) (glueing_th3 F G).", "proof_term": "Proof\n  fun F G : Ens =>\n  Build_EQ (Domain (union F G)) (union (Domain F) (Domain G))\n    (glueing_th2 F G) (glueing_th3 F G).", "def_ranges": [5693, 0, 5694, 73], "proof_ranges": [5695, 0, 5698, 40], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gluA_Out", "text": "Lemma gluA_Out : EQ Y Z.\nProof step3 X Y Z i1 j1.\n", "definition": " EQ Y Z.\n", "proof": "Proof step3 X Y Z i1 j1.", "proof_term": "Proof step3 X Y Z i1 j1.", "def_ranges": [5739, 0, 5739, 24], "proof_ranges": [5740, 0, 5740, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gluB_Out", "text": "Lemma gluB_Out : EQ Y Z.\nProof EQ_trans Y (EV G X) Z Bstep7 Bstep5.\n", "definition": " EQ Y Z.\n", "proof": "Proof EQ_trans Y (EV G X) Z Bstep7 Bstep5.", "proof_term": "Proof EQ_trans Y (EV G X) Z Bstep7 Bstep5.", "def_ranges": [5768, 0, 5768, 24], "proof_ranges": [5769, 0, 5769, 42], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gluC_Out", "text": "Lemma gluC_Out : EQ Y Z.\nProof EQ_trans Y (EV F X) Z Cstep7 Cstep5.\n", "definition": " EQ Y Z.\n", "proof": "Proof EQ_trans Y (EV F X) Z Cstep7 Cstep5.", "proof_term": "Proof EQ_trans Y (EV F X) Z Cstep7 Cstep5.", "def_ranges": [5801, 0, 5801, 24], "proof_ranges": [5802, 0, 5802, 42], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "gluD_Out", "text": "Lemma gluD_Out : EQ Y Z.\nProof step4 X Y Z i1 j1.\n", "definition": " EQ Y Z.\n", "proof": "Proof step4 X Y Z i1 j1.", "proof_term": "Proof step4 X Y Z i1 j1.", "def_ranges": [5812, 0, 5812, 24], "proof_ranges": [5813, 0, 5813, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "glu_wd_Out", "text": "Lemma glu_wd_Out : EQ Y Z.\nProof union_th4 (EQ Y Z) F G (PAIR X Y) i step6 step7.\n", "definition": " EQ Y Z.\n", "proof": "Proof union_th4 (EQ Y Z) F G (PAIR X Y) i step6 step7.", "proof_term": "Proof union_th4 (EQ Y Z) F G (PAIR X Y) i step6 step7.", "def_ranges": [5824, 0, 5824, 26], "proof_ranges": [5825, 0, 5825, 54], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "glueing_proof_Out", "text": "Lemma glueing_proof_Out : is_a_function H.\nProof Build_is_a_function H step5 step8.\n", "definition": " is_a_function H.\n", "proof": "Proof Build_is_a_function H step5 step8.", "proof_term": "Proof Build_is_a_function H step5 step8.", "def_ranges": [5832, 0, 5832, 42], "proof_ranges": [5833, 0, 5833, 40], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "glueing_th5", "text": "Theorem glueing_th5 :\n forall (F G : Ens) (f : is_a_function F) (g : is_a_function G)\n   (e : Extensionally_equivalent F G), is_a_function (union F G).\nProof glueing_proof_Out.\n", "definition": "\n forall (F G : Ens) (f : is_a_function F) (g : is_a_function G)\n   (e : Extensionally_equivalent F G), is_a_function (union F G).\n", "proof": "Proof glueing_proof_Out.", "proof_term": "Proof glueing_proof_Out.", "def_ranges": [5837, 0, 5839, 65], "proof_ranges": [5840, 0, 5840, 24], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Comp_INTER_pr1", "text": "Theorem Comp_INTER_pr1 :\n forall (F G X : Ens) (c : Comp_prop F G X),\n Comp_inter F G (PR1 X) (Comp_INTER F G X) (PR2 X).\nProof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  CHOICE_pr (fun Y : Ens => Comp_inter F G (PR1 X) Y (PR2 X))\n    (Comp_intern F G X c).\n", "definition": "\n forall (F G X : Ens) (c : Comp_prop F G X),\n Comp_inter F G (PR1 X) (Comp_INTER F G X) (PR2 X).\n", "proof": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  CHOICE_pr (fun Y : Ens => Comp_inter F G (PR1 X) Y (PR2 X))\n    (Comp_intern F G X c).", "proof_term": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  CHOICE_pr (fun Y : Ens => Comp_inter F G (PR1 X) Y (PR2 X))\n    (Comp_intern F G X c).", "def_ranges": [5854, 0, 5856, 51], "proof_ranges": [5857, 0, 5860, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Comp_INTER_th1", "text": "Theorem Comp_INTER_th1 :\n forall (F G X : Ens) (c : Comp_prop F G X),\n IN (PAIR (PR1 X) (Comp_INTER F G X)) F.\nProof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Comp_inter_xy F G (PR1 X) (Comp_INTER F G X) (PR2 X)\n    (Comp_INTER_pr1 F G X c).\n", "definition": "\n forall (F G X : Ens) (c : Comp_prop F G X),\n IN (PAIR (PR1 X) (Comp_INTER F G X)) F.\n", "proof": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Comp_inter_xy F G (PR1 X) (Comp_INTER F G X) (PR2 X)\n    (Comp_INTER_pr1 F G X c).", "proof_term": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Comp_inter_xy F G (PR1 X) (Comp_INTER F G X) (PR2 X)\n    (Comp_INTER_pr1 F G X c).", "def_ranges": [5862, 0, 5864, 40], "proof_ranges": [5865, 0, 5868, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Comp_INTER_th2", "text": "Theorem Comp_INTER_th2 :\n forall (F G X : Ens) (c : Comp_prop F G X),\n IN (PAIR (Comp_INTER F G X) (PR2 X)) G.\nProof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Comp_inter_yz F G (PR1 X) (Comp_INTER F G X) (PR2 X)\n    (Comp_INTER_pr1 F G X c).\n", "definition": "\n forall (F G X : Ens) (c : Comp_prop F G X),\n IN (PAIR (Comp_INTER F G X) (PR2 X)) G.\n", "proof": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Comp_inter_yz F G (PR1 X) (Comp_INTER F G X) (PR2 X)\n    (Comp_INTER_pr1 F G X c).", "proof_term": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Comp_inter_yz F G (PR1 X) (Comp_INTER F G X) (PR2 X)\n    (Comp_INTER_pr1 F G X c).", "def_ranges": [5870, 0, 5872, 40], "proof_ranges": [5873, 0, 5876, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Comp_prop_th1", "text": "Theorem Comp_prop_th1 :\n forall (F G X : Ens) (c : Comp_prop F G X), IN (PR1 X) (Domain F).\nProof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Domain_th1 F (PR1 X) (Comp_INTER F G X) (Comp_INTER_th1 F G X c).\n", "definition": "\n forall (F G X : Ens) (c : Comp_prop F G X), IN (PR1 X) (Domain F).\n", "proof": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Domain_th1 F (PR1 X) (Comp_INTER F G X) (Comp_INTER_th1 F G X c).", "proof_term": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Domain_th1 F (PR1 X) (Comp_INTER F G X) (Comp_INTER_th1 F G X c).", "def_ranges": [5878, 0, 5879, 67], "proof_ranges": [5880, 0, 5882, 67], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Comp_prop_th2", "text": "Theorem Comp_prop_th2 :\n forall (F G X : Ens) (c : Comp_prop F G X), IN (PR2 X) (Range G).\nProof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Range_th1 G (Comp_INTER F G X) (PR2 X) (Comp_INTER_th2 F G X c).\n", "definition": "\n forall (F G X : Ens) (c : Comp_prop F G X), IN (PR2 X) (Range G).\n", "proof": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Range_th1 G (Comp_INTER F G X) (PR2 X) (Comp_INTER_th2 F G X c).", "proof_term": "Proof\n  fun (F G X : Ens) (c : Comp_prop F G X) =>\n  Range_th1 G (Comp_INTER F G X) (PR2 X) (Comp_INTER_th2 F G X c).", "def_ranges": [5884, 0, 5885, 66], "proof_ranges": [5886, 0, 5888, 66], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "comp_prop_3_Out", "text": "Lemma comp_prop_3_Out : IN X (Cartesian (Domain F) (Range G)).\nProof Cartesian_pr1 (Domain F) (Range G) X step4.\n", "definition": " IN X (Cartesian (Domain F) (Range G)).\n", "proof": "Proof Cartesian_pr1 (Domain F) (Range G) X step4.", "proof_term": "Proof Cartesian_pr1 (Domain F) (Range G) X step4.", "def_ranges": [5904, 0, 5904, 62], "proof_ranges": [5905, 0, 5905, 49], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "Comp_prop_th3", "text": "Theorem Comp_prop_th3 :\n forall (F G X : Ens) (c : Comp_prop F G X),\n IN X (Cartesian (Domain F) (Range G)).\nProof comp_prop_3_Out.\n", "definition": "\n forall (F G X : Ens) (c : Comp_prop F G X),\n IN X (Cartesian (Domain F) (Range G)).\n", "proof": "Proof comp_prop_3_Out.", "proof_term": "Proof comp_prop_3_Out.", "def_ranges": [5909, 0, 5911, 39], "proof_ranges": [5912, 0, 5912, 22], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "composition_bounded_by", "text": "Theorem composition_bounded_by :\n forall F G : Ens,\n Bounded_By (Cartesian (Domain F) (Range G)) (Comp_prop F G).\nProof Comp_prop_th3.\n", "definition": "\n forall F G : Ens,\n Bounded_By (Cartesian (Domain F) (Range G)) (Comp_prop F G).\n", "proof": "Proof Comp_prop_th3.", "proof_term": "Proof Comp_prop_th3.", "def_ranges": [5916, 0, 5918, 61], "proof_ranges": [5919, 0, 5919, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "composition_bounded", "text": "Theorem composition_bounded : forall F G : Ens, Bounded (Comp_prop F G).\nProof\n  fun F G : Ens =>\n  Bounded_th2 (Comp_prop F G) (Cartesian (Domain F) (Range G))\n    (composition_bounded_by F G).\n", "definition": " forall F G : Ens, Bounded (Comp_prop F G).\n", "proof": "Proof\n  fun F G : Ens =>\n  Bounded_th2 (Comp_prop F G) (Cartesian (Domain F) (Range G))\n    (composition_bounded_by F G).", "proof_term": "Proof\n  fun F G : Ens =>\n  Bounded_th2 (Comp_prop F G) (Cartesian (Domain F) (Range G))\n    (composition_bounded_by F G).", "def_ranges": [5921, 0, 5921, 72], "proof_ranges": [5922, 0, 5925, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_pr1", "text": "Theorem COMP_pr1 : forall F G X : Ens, Comp_prop F G X -> IN X (COMP F G).\nProof\n  fun F G X : Ens =>\n  REPLACEMENT_pr1 (Comp_prop F G) (composition_bounded F G) X.\n", "definition": " forall F G X : Ens, Comp_prop F G X -> IN X (COMP F G).\n", "proof": "Proof\n  fun F G X : Ens =>\n  REPLACEMENT_pr1 (Comp_prop F G) (composition_bounded F G) X.", "proof_term": "Proof\n  fun F G X : Ens =>\n  REPLACEMENT_pr1 (Comp_prop F G) (composition_bounded F G) X.", "def_ranges": [5932, 0, 5932, 74], "proof_ranges": [5933, 0, 5935, 62], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_pr2", "text": "Theorem COMP_pr2 : forall F G X : Ens, IN X (COMP F G) -> Comp_prop F G X.\nProof\n  fun F G X : Ens =>\n  REPLACEMENT_pr2 (Comp_prop F G) (composition_bounded F G) X.\n", "definition": " forall F G X : Ens, IN X (COMP F G) -> Comp_prop F G X.\n", "proof": "Proof\n  fun F G X : Ens =>\n  REPLACEMENT_pr2 (Comp_prop F G) (composition_bounded F G) X.", "proof_term": "Proof\n  fun F G X : Ens =>\n  REPLACEMENT_pr2 (Comp_prop F G) (composition_bounded F G) X.", "def_ranges": [5937, 0, 5937, 74], "proof_ranges": [5938, 0, 5940, 62], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_th1", "text": "Theorem COMP_th1 : forall F G : Ens, is_a_relation (COMP F G).\nProof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_pair F G X (COMP_pr2 F G X i).\n", "definition": " forall F G : Ens, is_a_relation (COMP F G).\n", "proof": "Proof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_pair F G X (COMP_pr2 F G X i).", "proof_term": "Proof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_pair F G X (COMP_pr2 F G X i).", "def_ranges": [5942, 0, 5942, 62], "proof_ranges": [5943, 0, 5945, 37], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_th2", "text": "Theorem COMP_th2 :\n forall F G : Ens, SUB (COMP F G) (Cartesian (Domain F) (Range G)).\nProof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_prop_th3 F G X (COMP_pr2 F G X i).\n", "definition": "\n forall F G : Ens, SUB (COMP F G) (Cartesian (Domain F) (Range G)).\n", "proof": "Proof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_prop_th3 F G X (COMP_pr2 F G X i).", "proof_term": "Proof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_prop_th3 F G X (COMP_pr2 F G X i).", "def_ranges": [5947, 0, 5948, 67], "proof_ranges": [5949, 0, 5951, 41], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_th3", "text": "Theorem COMP_th3 :\n forall (F G X : Ens) (i : IN X (COMP F G)),\n IN (PAIR (PR1 X) (Comp_INTER F G X)) F.\nProof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_INTER_th1 F G X (COMP_pr2 F G X i).\n", "definition": "\n forall (F G X : Ens) (i : IN X (COMP F G)),\n IN (PAIR (PR1 X) (Comp_INTER F G X)) F.\n", "proof": "Proof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_INTER_th1 F G X (COMP_pr2 F G X i).", "proof_term": "Proof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_INTER_th1 F G X (COMP_pr2 F G X i).", "def_ranges": [5953, 0, 5955, 40], "proof_ranges": [5956, 0, 5958, 42], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_th4", "text": "Theorem COMP_th4 :\n forall (F G X : Ens) (i : IN X (COMP F G)),\n IN (PAIR (Comp_INTER F G X) (PR2 X)) G.\nProof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_INTER_th2 F G X (COMP_pr2 F G X i).\n", "definition": "\n forall (F G X : Ens) (i : IN X (COMP F G)),\n IN (PAIR (Comp_INTER F G X) (PR2 X)) G.\n", "proof": "Proof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_INTER_th2 F G X (COMP_pr2 F G X i).", "proof_term": "Proof\n  fun (F G X : Ens) (i : IN X (COMP F G)) =>\n  Comp_INTER_th2 F G X (COMP_pr2 F G X i).", "def_ranges": [5960, 0, 5962, 40], "proof_ranges": [5963, 0, 5965, 42], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMPp_Out3", "text": "Lemma COMPp_Out3 : IN (PAIR X (Comp_INTERp F G X Y)) F.\nProof\n  Substitute X (PR1 Z) (fun U : Ens => IN (PAIR U (Comp_INTERp F G X Y)) F)\n    step2 step4.\n", "definition": " IN (PAIR X (Comp_INTERp F G X Y)) F.\n", "proof": "Proof\n  Substitute X (PR1 Z) (fun U : Ens => IN (PAIR U (Comp_INTERp F G X Y)) F)\n    step2 step4.", "proof_term": "Proof\n  Substitute X (PR1 Z) (fun U : Ens => IN (PAIR U (Comp_INTERp F G X Y)) F)\n    step2 step4.", "def_ranges": [5990, 0, 5990, 55], "proof_ranges": [5991, 0, 5993, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMPp_Out4", "text": "Lemma COMPp_Out4 : IN (PAIR (Comp_INTERp F G X Y) Y) G.\nProof\n  Substitute Y (PR2 Z) (fun U : Ens => IN (PAIR (Comp_INTERp F G X Y) U) G)\n    step3 step5.\n", "definition": " IN (PAIR (Comp_INTERp F G X Y) Y) G.\n", "proof": "Proof\n  Substitute Y (PR2 Z) (fun U : Ens => IN (PAIR (Comp_INTERp F G X Y) U) G)\n    step3 step5.", "proof_term": "Proof\n  Substitute Y (PR2 Z) (fun U : Ens => IN (PAIR (Comp_INTERp F G X Y) U) G)\n    step3 step5.", "def_ranges": [5995, 0, 5995, 55], "proof_ranges": [5996, 0, 5998, 16], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_th3p", "text": "Theorem COMP_th3p :\n forall (F G X Y : Ens) (i : IN (PAIR X Y) (COMP F G)),\n IN (PAIR X (Comp_INTERp F G X Y)) F.\nProof COMPp_Out3.\n", "definition": "\n forall (F G X Y : Ens) (i : IN (PAIR X Y) (COMP F G)),\n IN (PAIR X (Comp_INTERp F G X Y)) F.\n", "proof": "Proof COMPp_Out3.", "proof_term": "Proof COMPp_Out3.", "def_ranges": [6002, 0, 6004, 37], "proof_ranges": [6005, 0, 6005, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_th4p", "text": "Theorem COMP_th4p :\n forall (F G X Y : Ens) (i : IN (PAIR X Y) (COMP F G)),\n IN (PAIR (Comp_INTERp F G X Y) Y) G.\nProof COMPp_Out4.\n", "definition": "\n forall (F G X Y : Ens) (i : IN (PAIR X Y) (COMP F G)),\n IN (PAIR (Comp_INTERp F G X Y) Y) G.\n", "proof": "Proof COMPp_Out4.", "proof_term": "Proof COMPp_Out4.", "def_ranges": [6007, 0, 6009, 37], "proof_ranges": [6010, 0, 6010, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "comp_wd_Out", "text": "Lemma comp_wd_Out : EQ Y Z.\nProof g V Y Z step2 step6.\n", "definition": " EQ Y Z.\n", "proof": "Proof g V Y Z step2 step6.", "proof_term": "Proof g V Y Z step2 step6.", "def_ranges": [6042, 0, 6042, 27], "proof_ranges": [6043, 0, 6043, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "composition_well_definedness", "text": "Theorem composition_well_definedness :\n forall (F G : Ens) (f : well_definedness F) (g : well_definedness G),\n well_definedness (COMP F G).\nProof comp_wd_Out.\n", "definition": "\n forall (F G : Ens) (f : well_definedness F) (g : well_definedness G),\n well_definedness (COMP F G).\n", "proof": "Proof comp_wd_Out.", "proof_term": "Proof comp_wd_Out.", "def_ranges": [6047, 0, 6049, 29], "proof_ranges": [6050, 0, 6050, 18], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "composition_th1", "text": "Theorem composition_th1 :\n forall (F G : Ens) (f : well_definedness F) (g : well_definedness G),\n is_a_function (COMP F G).\nProof\n  fun (F G : Ens) (f : well_definedness F) (g : well_definedness G) =>\n  Build_is_a_function (COMP F G) (COMP_th1 F G)\n    (composition_well_definedness F G f g).\n", "definition": "\n forall (F G : Ens) (f : well_definedness F) (g : well_definedness G),\n is_a_function (COMP F G).\n", "proof": "Proof\n  fun (F G : Ens) (f : well_definedness F) (g : well_definedness G) =>\n  Build_is_a_function (COMP F G) (COMP_th1 F G)\n    (composition_well_definedness F G f g).", "proof_term": "Proof\n  fun (F G : Ens) (f : well_definedness F) (g : well_definedness G) =>\n  Build_is_a_function (COMP F G) (COMP_th1 F G)\n    (composition_well_definedness F G f g).", "def_ranges": [6052, 0, 6054, 26], "proof_ranges": [6055, 0, 6058, 43], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "composition_th2", "text": "Theorem composition_th2 :\n forall (F G : Ens) (f : is_a_function F) (g : is_a_function G),\n is_a_function (COMP F G).\nProof\n  fun (F G : Ens) (f : is_a_function F) (g : is_a_function G) =>\n  composition_th1 F G (function_well_definedness F f)\n    (function_well_definedness G g).\n", "definition": "\n forall (F G : Ens) (f : is_a_function F) (g : is_a_function G),\n is_a_function (COMP F G).\n", "proof": "Proof\n  fun (F G : Ens) (f : is_a_function F) (g : is_a_function G) =>\n  composition_th1 F G (function_well_definedness F f)\n    (function_well_definedness G g).", "proof_term": "Proof\n  fun (F G : Ens) (f : is_a_function F) (g : is_a_function G) =>\n  composition_th1 F G (function_well_definedness F f)\n    (function_well_definedness G g).", "def_ranges": [6060, 0, 6062, 26], "proof_ranges": [6063, 0, 6066, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "comp_ev_1_Out", "text": "Lemma comp_ev_1_Out : IN W (COMP F G).\nProof COMP_pr1 F G W step9.\n", "definition": " IN W (COMP F G).\n", "proof": "Proof COMP_pr1 F G W step9.", "proof_term": "Proof COMP_pr1 F G W step9.", "def_ranges": [6102, 0, 6102, 38], "proof_ranges": [6103, 0, 6103, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_th5", "text": "Theorem COMP_th5 :\n forall (F G X Y Z : Ens) (i : IN (PAIR X Y) F) (j : IN (PAIR Y Z) G),\n IN (PAIR X Z) (COMP F G).\nProof comp_ev_1_Out.\n", "definition": "\n forall (F G X Y Z : Ens) (i : IN (PAIR X Y) F) (j : IN (PAIR Y Z) G),\n IN (PAIR X Z) (COMP F G).\n", "proof": "Proof comp_ev_1_Out.", "proof_term": "Proof comp_ev_1_Out.", "def_ranges": [6107, 0, 6109, 26], "proof_ranges": [6110, 0, 6110, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "comp_ev_2_Out", "text": "Lemma comp_ev_2_Out : IN (PAIR X Z) (COMP F G).\nProof COMP_th5 F G X Y Z step1 step2.\n", "definition": " IN (PAIR X Z) (COMP F G).\n", "proof": "Proof COMP_th5 F G X Y Z step1 step2.", "proof_term": "Proof COMP_th5 F G X Y Z step1 step2.", "def_ranges": [6127, 0, 6127, 47], "proof_ranges": [6128, 0, 6128, 37], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "composition_th3", "text": "Theorem composition_th3 :\n forall (F G X : Ens) (i : IN X (Domain F)) (j : IN (EV F X) (Domain G)),\n IN (PAIR X (EV G (EV F X))) (COMP F G).\nProof comp_ev_2_Out.\n", "definition": "\n forall (F G X : Ens) (i : IN X (Domain F)) (j : IN (EV F X) (Domain G)),\n IN (PAIR X (EV G (EV F X))) (COMP F G).\n", "proof": "Proof comp_ev_2_Out.", "proof_term": "Proof comp_ev_2_Out.", "def_ranges": [6132, 0, 6134, 40], "proof_ranges": [6135, 0, 6135, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "comp_ev_3_Out", "text": "Lemma comp_ev_3_Out : EQ W Z.\nProof step2 X W Z step5 step3.\n", "definition": " EQ W Z.\n", "proof": "Proof step2 X W Z step5 step3.", "proof_term": "Proof step2 X W Z step5 step3.", "def_ranges": [6162, 0, 6162, 29], "proof_ranges": [6163, 0, 6163, 30], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "composition_th4", "text": "Theorem composition_th4 :\n forall (F G X : Ens) (f : is_a_function F) (g : is_a_function G)\n   (i : IN X (Domain F)) (j : IN (EV F X) (Domain G)),\n EQ (EV (COMP F G) X) (EV G (EV F X)).\nProof comp_ev_3_Out.\n", "definition": "\n forall (F G X : Ens) (f : is_a_function F) (g : is_a_function G)\n   (i : IN X (Domain F)) (j : IN (EV F X) (Domain G)),\n EQ (EV (COMP F G) X) (EV G (EV F X)).\n", "proof": "Proof comp_ev_3_Out.", "proof_term": "Proof comp_ev_3_Out.", "def_ranges": [6167, 0, 6170, 38], "proof_ranges": [6171, 0, 6171, 20], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "comp_assoc_1_Out", "text": "Lemma comp_assoc_1_Out : IN P (COMP (COMP F G) H).\nProof\n  Substitute P (PAIR X W) (fun U : Ens => IN U (COMP (COMP F G) H)) step2\n    step10.\n", "definition": " IN P (COMP (COMP F G) H).\n", "proof": "Proof\n  Substitute P (PAIR X W) (fun U : Ens => IN U (COMP (COMP F G) H)) step2\n    step10.", "proof_term": "Proof\n  Substitute P (PAIR X W) (fun U : Ens => IN U (COMP (COMP F G) H)) step2\n    step10.", "def_ranges": [6214, 0, 6214, 50], "proof_ranges": [6215, 0, 6217, 11], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_assoc_th1", "text": "Theorem COMP_assoc_th1 :\n forall F G H : Ens, SUB (COMP F (COMP G H)) (COMP (COMP F G) H).\nProof comp_assoc_1_Out.\n", "definition": "\n forall F G H : Ens, SUB (COMP F (COMP G H)) (COMP (COMP F G) H).\n", "proof": "Proof comp_assoc_1_Out.", "proof_term": "Proof comp_assoc_1_Out.", "def_ranges": [6221, 0, 6222, 65], "proof_ranges": [6223, 0, 6223, 23], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "comp_assoc_2_Out", "text": "Lemma comp_assoc_2_Out : IN P (COMP F (COMP G H)).\nProof\n  Substitute P (PAIR X W) (fun U : Ens => IN U (COMP F (COMP G H))) step2\n    step10.\n", "definition": " IN P (COMP F (COMP G H)).\n", "proof": "Proof\n  Substitute P (PAIR X W) (fun U : Ens => IN U (COMP F (COMP G H))) step2\n    step10.", "proof_term": "Proof\n  Substitute P (PAIR X W) (fun U : Ens => IN U (COMP F (COMP G H))) step2\n    step10.", "def_ranges": [6264, 0, 6264, 50], "proof_ranges": [6265, 0, 6267, 11], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_assoc_th2", "text": "Theorem COMP_assoc_th2 :\n forall F G H : Ens, SUB (COMP (COMP F G) H) (COMP F (COMP G H)).\nProof comp_assoc_2_Out.\n", "definition": "\n forall F G H : Ens, SUB (COMP (COMP F G) H) (COMP F (COMP G H)).\n", "proof": "Proof comp_assoc_2_Out.", "proof_term": "Proof comp_assoc_2_Out.", "def_ranges": [6271, 0, 6272, 65], "proof_ranges": [6273, 0, 6273, 23], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functions-in-zfc/Functions_in_ZFC.v", "name": "COMP_assoc", "text": "Theorem COMP_assoc :\n forall F G H : Ens, EQ (COMP F (COMP G H)) (COMP (COMP F G) H).\nProof\n  fun F G H : Ens =>\n  Build_EQ (COMP F (COMP G H)) (COMP (COMP F G) H) \n    (COMP_assoc_th1 F G H) (COMP_assoc_th2 F G H).\n", "definition": "\n forall F G H : Ens, EQ (COMP F (COMP G H)) (COMP (COMP F G) H).\n", "proof": "Proof\n  fun F G H : Ens =>\n  Build_EQ (COMP F (COMP G H)) (COMP (COMP F G) H) \n    (COMP_assoc_th1 F G H) (COMP_assoc_th2 F G H).", "proof_term": "Proof\n  fun F G H : Ens =>\n  Build_EQ (COMP F (COMP G H)) (COMP (COMP F G) H) \n    (COMP_assoc_th1 F G H) (COMP_assoc_th2 F G H).", "def_ranges": [6275, 0, 6276, 64], "proof_ranges": [6277, 0, 6280, 50], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_id", "text": "Theorem op_id\n  :  is_id M {+} 0.\nProof conj op_id_l op_id_r.\n", "definition": "  is_id M {+} 0.\n", "proof": "Proof conj op_id_l op_id_r.", "proof_term": "Proof conj op_id_l op_id_r.", "def_ranges": [160, 0, 161, 19], "proof_ranges": [162, 0, 162, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_id_l_uniq", "text": "Theorem op_id_l_uniq\n  :  forall x : M, (op_is_id_l x) -> x = 0.\nProof\n  fun x H\n    => H 0 || a = 0 @a by <- op_id_r x.\n", "definition": "  forall x : M, (op_is_id_l x) -> x = 0.\n", "proof": "Proof\n  fun x H\n    => H 0 || a = 0 @a by <- op_id_r x.", "proof_term": "Proof\n  fun x H\n    => H 0 || a = 0 @a by <- op_id_r x.", "def_ranges": [165, 0, 166, 43], "proof_ranges": [167, 0, 169, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_id_r_uniq", "text": "Theorem op_id_r_uniq\n  :  forall x : M, (op_is_id_r x) -> x = 0.\nProof\n  fun x H\n    => H 0 || a = 0 @a by <- op_id_l x.\n", "definition": "  forall x : M, (op_is_id_r x) -> x = 0.\n", "proof": "Proof\n  fun x H\n    => H 0 || a = 0 @a by <- op_id_l x.", "proof_term": "Proof\n  fun x H\n    => H 0 || a = 0 @a by <- op_id_l x.", "def_ranges": [172, 0, 173, 43], "proof_ranges": [174, 0, 176, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_id_uniq", "text": "Theorem op_id_uniq\n  :  forall x : M, (op_is_id x) -> x = 0.\nProof\n  fun x\n    => and_ind (fun H _ => op_id_l_uniq x H).\n", "definition": "  forall x : M, (op_is_id x) -> x = 0.\n", "proof": "Proof\n  fun x\n    => and_ind (fun H _ => op_id_l_uniq x H).", "proof_term": "Proof\n  fun x\n    => and_ind (fun H _ => op_id_l_uniq x H).", "def_ranges": [179, 0, 180, 41], "proof_ranges": [181, 0, 183, 45], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_intro_l", "text": "Theorem op_intro_l\n  :  forall x y z : M, x = y -> z + x = z + y.\nProof\n  fun x y z H\n    => f_equal ({+} z) H.\n", "definition": "  forall x y z : M, x = y -> z + x = z + y.\n", "proof": "Proof\n  fun x y z H\n    => f_equal ({+} z) H.", "proof_term": "Proof\n  fun x y z H\n    => f_equal ({+} z) H.", "def_ranges": [186, 0, 187, 46], "proof_ranges": [188, 0, 190, 25], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_intro_r", "text": "Theorem op_intro_r\n  :  forall x y z : M, x = y -> x + z = y + z.\nProof\n  fun x y z H\n    =>  eq_refl (x + z)\n       || x + z = a + z @a by <- H.\n", "definition": "  forall x y z : M, x = y -> x + z = y + z.\n", "proof": "Proof\n  fun x y z H\n    =>  eq_refl (x + z)\n       || x + z = a + z @a by <- H.", "proof_term": "Proof\n  fun x y z H\n    =>  eq_refl (x + z)\n       || x + z = a + z @a by <- H.", "def_ranges": [193, 0, 194, 46], "proof_ranges": [195, 0, 198, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_l_r_eq", "text": "Theorem op_inv_l_r_eq\n  :  forall x y : M, op_is_inv_l x y -> forall z : M, op_is_inv_r x z -> y = z.\nProof\n  fun x y H1 z H2\n    => op_is_assoc y x z\n          || y + a = (y + x) + z @a by <- H2\n          || a = (y + x) + z     @a by <- op_id_r y\n          || y = a + z           @a by <- H1\n          || y = a               @a by <- op_id_l z.\n", "definition": "  forall x y : M, op_is_inv_l x y -> forall z : M, op_is_inv_r x z -> y = z.\n", "proof": "Proof\n  fun x y H1 z H2\n    => op_is_assoc y x z\n          || y + a = (y + x) + z @a by <- H2\n          || a = (y + x) + z     @a by <- op_id_r y\n          || y = a + z           @a by <- H1\n          || y = a               @a by <- op_id_l z.", "proof_term": "Proof\n  fun x y H1 z H2\n    => op_is_assoc y x z\n          || y + a = (y + x) + z @a by <- H2\n          || a = (y + x) + z     @a by <- op_id_r y\n          || y = a + z           @a by <- H1\n          || y = a               @a by <- op_id_l z.", "def_ranges": [243, 0, 244, 79], "proof_ranges": [245, 0, 251, 52], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_sym", "text": "Theorem op_inv_sym\n  :  forall x y : M, op_is_inv x y <-> op_is_inv y x.\nProof\n  fun x y\n    => conj\n            (fun H : op_is_inv x y\n              => conj (proj2 H) (proj1 H))\n            (fun H : op_is_inv y x\n              => conj (proj2 H) (proj1 H)).\n", "definition": "  forall x y : M, op_is_inv x y <-> op_is_inv y x.\n", "proof": "Proof\n  fun x y\n    => conj\n            (fun H : op_is_inv x y\n              => conj (proj2 H) (proj1 H))\n            (fun H : op_is_inv y x\n              => conj (proj2 H) (proj1 H)).", "proof_term": "Proof\n  fun x y\n    => conj\n            (fun H : op_is_inv x y\n              => conj (proj2 H) (proj1 H))\n            (fun H : op_is_inv y x\n              => conj (proj2 H) (proj1 H)).", "def_ranges": [257, 0, 258, 53], "proof_ranges": [259, 0, 265, 43], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_cancel_l", "text": "Theorem op_cancel_l\n  :  forall x y z : M, has_inv_l z -> z + x = z + y -> x = y.\nProof\n  fun x y z H H0\n    => ex_ind \n            (fun u H1\n              => op_intro_l (z + x) (z + y) u H0\n              || a = u + (z + y) @a by <- op_is_assoc u z x\n              || (u + z) + x = a @a by <- op_is_assoc u z y\n              || a + x = a + y   @a by <- H1\n              || a = 0 + y       @a by <- op_id_l x\n              || x = a           @a by <- op_id_l y)\n            H.\n", "definition": "  forall x y z : M, has_inv_l z -> z + x = z + y -> x = y.\n", "proof": "Proof\n  fun x y z H H0\n    => ex_ind \n            (fun u H1\n              => op_intro_l (z + x) (z + y) u H0\n              || a = u + (z + y) @a by <- op_is_assoc u z x\n              || (u + z) + x = a @a by <- op_is_assoc u z y\n              || a + x = a + y   @a by <- H1\n              || a = 0 + y       @a by <- op_id_l x\n              || x = a           @a by <- op_id_l y)\n            H.", "proof_term": "Proof\n  fun x y z H H0\n    => ex_ind \n            (fun u H1\n              => op_intro_l (z + x) (z + y) u H0\n              || a = u + (z + y) @a by <- op_is_assoc u z x\n              || (u + z) + x = a @a by <- op_is_assoc u z y\n              || a + x = a + y   @a by <- H1\n              || a = 0 + y       @a by <- op_id_l x\n              || x = a           @a by <- op_id_l y)\n            H.", "def_ranges": [279, 0, 280, 61], "proof_ranges": [281, 0, 291, 14], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_cancel_r", "text": "Theorem op_cancel_r\n  :  forall x y z : M, has_inv_r z -> x + z = y + z -> x = y.\nProof\n  fun x y z H H0\n    => ex_ind\n            (fun u H1\n              =>  op_intro_r (x + z) (y + z) u H0\n              || a = (y + z) + u @a by op_is_assoc x z u\n              || x + (z + u) = a @a by op_is_assoc y z u\n              || x + a = y + a   @a by <- H1\n              || a = y + 0       @a by <- op_id_r x\n              || x = a           @a by <- op_id_r y)\n            H.\n", "definition": "  forall x y z : M, has_inv_r z -> x + z = y + z -> x = y.\n", "proof": "Proof\n  fun x y z H H0\n    => ex_ind\n            (fun u H1\n              =>  op_intro_r (x + z) (y + z) u H0\n              || a = (y + z) + u @a by op_is_assoc x z u\n              || x + (z + u) = a @a by op_is_assoc y z u\n              || x + a = y + a   @a by <- H1\n              || a = y + 0       @a by <- op_id_r x\n              || x = a           @a by <- op_id_r y)\n            H.", "proof_term": "Proof\n  fun x y z H H0\n    => ex_ind\n            (fun u H1\n              =>  op_intro_r (x + z) (y + z) u H0\n              || a = (y + z) + u @a by op_is_assoc x z u\n              || x + (z + u) = a @a by op_is_assoc y z u\n              || x + a = y + a   @a by <- H1\n              || a = y + 0       @a by <- op_id_r x\n              || x = a           @a by <- op_id_r y)\n            H.", "def_ranges": [297, 0, 298, 61], "proof_ranges": [299, 0, 309, 14], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_l_uniq", "text": "Theorem op_inv_l_uniq\n  :  forall x : M, has_inv_r x -> forall y z : M, op_is_inv_l x y -> op_is_inv_l x z -> z = y.\nProof\n  fun x H y z H0 H1\n    => let H2\n            :  z + x = y + x\n            := H1 || z + x = a @a by H0 in\n          let H3\n            :  z = y\n            := op_cancel_r z y x H H2 in\n          H3.\n", "definition": "  forall x : M, has_inv_r x -> forall y z : M, op_is_inv_l x y -> op_is_inv_l x z -> z = y.\n", "proof": "Proof\n  fun x H y z H0 H1\n    => let H2\n            :  z + x = y + x\n            := H1 || z + x = a @a by H0 in\n          let H3\n            :  z = y\n            := op_cancel_r z y x H H2 in\n          H3.", "proof_term": "Proof\n  fun x H y z H0 H1\n    => let H2\n            :  z + x = y + x\n            := H1 || z + x = a @a by H0 in\n          let H3\n            :  z = y\n            := op_cancel_r z y x H H2 in\n          H3.", "def_ranges": [315, 0, 316, 94], "proof_ranges": [317, 0, 325, 13], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_r_uniq", "text": "Theorem op_inv_r_uniq\n  :  forall x : M, has_inv_l x -> forall y z : M, op_is_inv_r x y -> op_is_inv_r x z -> z = y.\nProof\n  fun x H y z H0 H1\n    => let H2\n            :  x + z = x + y\n            := H1 || x + z = a @a by H0 in\n          let H3\n            :  z = y\n            := op_cancel_l z y x H H2 in\n          H3.\n", "definition": "  forall x : M, has_inv_l x -> forall y z : M, op_is_inv_r x y -> op_is_inv_r x z -> z = y.\n", "proof": "Proof\n  fun x H y z H0 H1\n    => let H2\n            :  x + z = x + y\n            := H1 || x + z = a @a by H0 in\n          let H3\n            :  z = y\n            := op_cancel_l z y x H H2 in\n          H3.", "proof_term": "Proof\n  fun x H y z H0 H1\n    => let H2\n            :  x + z = x + y\n            := H1 || x + z = a @a by H0 in\n          let H3\n            :  z = y\n            := op_cancel_l z y x H H2 in\n          H3.", "def_ranges": [331, 0, 332, 94], "proof_ranges": [333, 0, 341, 13], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_uniq", "text": "Theorem op_inv_uniq\n  :  forall x y z : M, op_is_inv x y -> op_is_inv x z -> z = y.\nProof\n  fun x y z H H0\n    => op_inv_l_uniq x\n            (ex_intro (fun y => op_is_inv_r x y) y (proj2 H))\n            y z (proj1 H) (proj1 H0).\n", "definition": "  forall x y z : M, op_is_inv x y -> op_is_inv x z -> z = y.\n", "proof": "Proof\n  fun x y z H H0\n    => op_inv_l_uniq x\n            (ex_intro (fun y => op_is_inv_r x y) y (proj2 H))\n            y z (proj1 H) (proj1 H0).", "proof_term": "Proof\n  fun x y z H H0\n    => op_inv_l_uniq x\n            (ex_intro (fun y => op_is_inv_r x y) y (proj2 H))\n            y z (proj1 H) (proj1 H0).", "def_ranges": [344, 0, 345, 63], "proof_ranges": [346, 0, 350, 37], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_0_l", "text": "Theorem op_inv_0_l\n  :  op_is_inv_l 0 0.\nProof op_id_l 0 : 0 + 0 = 0.\n", "definition": "  op_is_inv_l 0 0.\n", "proof": "Proof op_id_l 0 : 0 + 0 = 0.", "proof_term": "Proof op_id_l 0 : 0 + 0 = 0.", "def_ranges": [356, 0, 357, 21], "proof_ranges": [358, 0, 358, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_0_r", "text": "Theorem op_inv_0_r\n  :  op_is_inv_r 0 0.\nProof op_id_r 0 : 0 + 0 = 0.\n", "definition": "  op_is_inv_r 0 0.\n", "proof": "Proof op_id_r 0 : 0 + 0 = 0.", "proof_term": "Proof op_id_r 0 : 0 + 0 = 0.", "def_ranges": [364, 0, 365, 21], "proof_ranges": [366, 0, 366, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_0", "text": "Theorem op_inv_0\n  :  op_is_inv 0 0.\nProof conj op_inv_0_l op_inv_0_r.\n", "definition": "  op_is_inv 0 0.\n", "proof": "Proof conj op_inv_0_l op_inv_0_r.", "proof_term": "Proof conj op_inv_0_l op_inv_0_r.", "def_ranges": [372, 0, 373, 19], "proof_ranges": [374, 0, 374, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_has_inv_l_0", "text": "Theorem op_has_inv_l_0\n  :  has_inv_l 0.\nProof ex_intro (op_is_inv_l 0) 0 op_inv_0_l.\n", "definition": "  has_inv_l 0.\n", "proof": "Proof ex_intro (op_is_inv_l 0) 0 op_inv_0_l.", "proof_term": "Proof ex_intro (op_is_inv_l 0) 0 op_inv_0_l.", "def_ranges": [380, 0, 381, 17], "proof_ranges": [382, 0, 382, 44], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_has_inv_r_0", "text": "Theorem op_has_inv_r_0\n  :  has_inv_r 0.\nProof ex_intro (op_is_inv_r 0) 0 op_inv_0_r.\n", "definition": "  has_inv_r 0.\n", "proof": "Proof ex_intro (op_is_inv_r 0) 0 op_inv_0_r.", "proof_term": "Proof ex_intro (op_is_inv_r 0) 0 op_inv_0_r.", "def_ranges": [388, 0, 389, 17], "proof_ranges": [390, 0, 390, 44], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_has_inv_0", "text": "Theorem op_has_inv_0\n  :  has_inv 0.\nProof ex_intro (op_is_inv 0) 0 op_inv_0.\n", "definition": "  has_inv 0.\n", "proof": "Proof ex_intro (op_is_inv 0) 0 op_inv_0.", "proof_term": "Proof ex_intro (op_is_inv 0) 0 op_inv_0.", "def_ranges": [396, 0, 397, 15], "proof_ranges": [398, 0, 398, 40], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_0_eq_0", "text": "Theorem op_inv_0_eq_0\n  :  forall x : M, op_is_inv x 0 -> x = 0.\nProof\n  fun x H\n    => proj1 H\n       || a = 0 @a by <- op_id_l x.\n", "definition": "  forall x : M, op_is_inv x 0 -> x = 0.\n", "proof": "Proof\n  fun x H\n    => proj1 H\n       || a = 0 @a by <- op_id_l x.", "proof_term": "Proof\n  fun x H\n    => proj1 H\n       || a = 0 @a by <- op_id_l x.", "def_ranges": [404, 0, 405, 42], "proof_ranges": [406, 0, 409, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_0_uniq", "text": "Theorem op_inv_0_uniq\n  :  unique (fun x => op_is_inv x 0) 0.\nProof\n  conj op_inv_0\n    (fun x H => eq_sym (op_inv_0_eq_0 x H)).\n", "definition": "  unique (fun x => op_is_inv x 0) 0.\n", "proof": "Proof\n  conj op_inv_0\n    (fun x H => eq_sym (op_inv_0_eq_0 x H)).", "proof_term": "Proof\n  conj op_inv_0\n    (fun x H => eq_sym (op_inv_0_eq_0 x H)).", "def_ranges": [415, 0, 416, 39], "proof_ranges": [417, 0, 419, 44], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid.v", "name": "op_inv_closed", "text": "Theorem op_inv_closed\n  :  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y), has_inv (x + y).\nProof\n  fun x H y H0\n    => ex_ind\n         (fun u (H1 : op_is_inv x u)\n           => ex_ind\n                (fun v (H2 : op_is_inv y v)\n                  => ex_intro\n                       (op_is_inv (x + y))\n                       (v + u)\n                       (conj\n                         (op_is_assoc (v + u) x y\n                           || (v + u) + (x + y) = a + y @a by op_is_assoc v u x\n                           || (v + u) + (x + y) = (v + a) + y @a by <- proj1 H1\n                           || (v + u) + (x + y) = a + y @a by <- op_id_r v\n                           || (v + u) + (x + y) = a @a by <- proj1 H2\n                         ) \n                         (op_is_assoc (x + y) v u\n                           || (x + y) + (v + u) = a + u @a by op_is_assoc x y v\n                           || (x + y) + (v + u) = (x + a) + u @a by <- proj2 H2\n                           || (x + y) + (v + u) = a + u @a by <- op_id_r x\n                           || (x + y) + (v + u) = a @a by <- proj2 H1\n                         )))\n                H0)\n         H.\n", "definition": "  forall (x : M) (H : has_inv x) (y : M) (H0 : has_inv y), has_inv (x + y).\n", "proof": "Proof\n  fun x H y H0\n    => ex_ind\n         (fun u (H1 : op_is_inv x u)\n           => ex_ind\n                (fun v (H2 : op_is_inv y v)\n                  => ex_intro\n                       (op_is_inv (x + y))\n                       (v + u)\n                       (conj\n                         (op_is_assoc (v + u) x y\n                           || (v + u) + (x + y) = a + y @a by op_is_assoc v u x\n                           || (v + u) + (x + y) = (v + a) + y @a by <- proj1 H1\n                           || (v + u) + (x + y) = a + y @a by <- op_id_r v\n                           || (v + u) + (x + y) = a @a by <- proj1 H2\n                         ) \n                         (op_is_assoc (x + y) v u\n                           || (x + y) + (v + u) = a + u @a by op_is_assoc x y v\n                           || (x + y) + (v + u) = (x + a) + u @a by <- proj2 H2\n                           || (x + y) + (v + u) = a + u @a by <- op_id_r x\n                           || (x + y) + (v + u) = a @a by <- proj2 H1\n                         )))\n                H0)\n         H.", "proof_term": "Proof\n  fun x H y H0\n    => ex_ind\n         (fun u (H1 : op_is_inv x u)\n           => ex_ind\n                (fun v (H2 : op_is_inv y v)\n                  => ex_intro\n                       (op_is_inv (x + y))\n                       (v + u)\n                       (conj\n                         (op_is_assoc (v + u) x y\n                           || (v + u) + (x + y) = a + y @a by op_is_assoc v u x\n                           || (v + u) + (x + y) = (v + a) + y @a by <- proj1 H1\n                           || (v + u) + (x + y) = a + y @a by <- op_id_r v\n                           || (v + u) + (x + y) = a @a by <- proj1 H2\n                         ) \n                         (op_is_assoc (x + y) v u\n                           || (x + y) + (v + u) = a + u @a by op_is_assoc x y v\n                           || (x + y) + (v + u) = (x + a) + u @a by <- proj2 H2\n                           || (x + y) + (v + u) = a + u @a by <- op_id_r x\n                           || (x + y) + (v + u) = a @a by <- proj2 H1\n                         )))\n                H0)\n         H.", "def_ranges": [593, 0, 594, 78], "proof_ranges": [595, 0, 618, 11], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_is_id_lr", "text": "Theorem op_is_id_lr\n  :  forall x : E, op_is_id_l x -> op_is_id_r x.\nProof\n  fun x H y\n    => H y\n    || a = y @a by op_is_comm y x.\n", "definition": "  forall x : E, op_is_id_l x -> op_is_id_r x.\n", "proof": "Proof\n  fun x H y\n    => H y\n    || a = y @a by op_is_comm y x.", "proof_term": "Proof\n  fun x H y\n    => H y\n    || a = y @a by op_is_comm y x.", "def_ranges": [144, 0, 145, 48], "proof_ranges": [146, 0, 149, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_is_id_lid", "text": "Theorem op_is_id_lid\n  : forall x : E, op_is_id_l x -> op_is_id x.\nProof\n  fun x H\n    => conj H (op_is_id_lr x H).\n", "definition": " forall x : E, op_is_id_l x -> op_is_id x.\n", "proof": "Proof\n  fun x H\n    => conj H (op_is_id_lr x H).", "proof_term": "Proof\n  fun x H\n    => conj H (op_is_id_lr x H).", "def_ranges": [155, 0, 156, 45], "proof_ranges": [157, 0, 159, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_id_r", "text": "Theorem op_id_r\n  :  op_is_id_r 0.\nProof op_is_id_lr 0 op_id_l.\n", "definition": "  op_is_id_r 0.\n", "proof": "Proof op_is_id_lr 0 op_id_l.", "proof_term": "Proof op_is_id_lr 0 op_id_l.", "def_ranges": [162, 0, 163, 18], "proof_ranges": [164, 0, 164, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_id", "text": "Theorem op_id\n  :  op_is_id 0.\nProof conj op_id_l op_id_r.\n", "definition": "  op_is_id 0.\n", "proof": "Proof conj op_id_l op_id_r.", "proof_term": "Proof conj op_id_l op_id_r.", "def_ranges": [167, 0, 168, 16], "proof_ranges": [169, 0, 169, 27], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_r_ex", "text": "Theorem op_inv_r_ex\n  :  forall x : E, exists y : E, op_is_inv_r x y.\nProof\n  fun x\n    => ex_ind\n         (fun (y : E) (H : op_is_inv_l x y)\n           => ex_intro\n                (op_is_inv_r x)\n                y\n                (H || a = 0 @a by op_is_comm x y))\n         (op_inv_l_ex x).\n", "definition": "  forall x : E, exists y : E, op_is_inv_r x y.\n", "proof": "Proof\n  fun x\n    => ex_ind\n         (fun (y : E) (H : op_is_inv_l x y)\n           => ex_intro\n                (op_is_inv_r x)\n                y\n                (H || a = 0 @a by op_is_comm x y))\n         (op_inv_l_ex x).", "proof_term": "Proof\n  fun x\n    => ex_ind\n         (fun (y : E) (H : op_is_inv_l x y)\n           => ex_intro\n                (op_is_inv_r x)\n                y\n                (H || a = 0 @a by op_is_comm x y))\n         (op_inv_l_ex x).", "def_ranges": [190, 0, 191, 49], "proof_ranges": [192, 0, 200, 25], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_l_r_eq", "text": "Theorem op_inv_l_r_eq\n  :  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.\nProof Group.op_inv_l_r_eq op_group.\n", "definition": "  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.\n", "proof": "Proof Group.op_inv_l_r_eq op_group.", "proof_term": "Proof Group.op_inv_l_r_eq op_group.", "def_ranges": [248, 0, 249, 79], "proof_ranges": [250, 0, 250, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_sym", "text": "Theorem op_inv_sym\n  :  forall x y : E, op_is_inv x y <-> op_is_inv y x.\nProof Group.op_inv_sym op_group.\n", "definition": "  forall x y : E, op_is_inv x y <-> op_is_inv y x.\n", "proof": "Proof Group.op_inv_sym op_group.", "proof_term": "Proof Group.op_inv_sym op_group.", "def_ranges": [256, 0, 257, 53], "proof_ranges": [258, 0, 258, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_ex", "text": "Theorem op_inv_ex\n  :  forall x : E, exists y : E, op_is_inv x y.\nProof Group.op_inv_ex op_group.\n", "definition": "  forall x : E, exists y : E, op_is_inv x y.\n", "proof": "Proof Group.op_inv_ex op_group.", "proof_term": "Proof Group.op_inv_ex op_group.", "def_ranges": [264, 0, 265, 47], "proof_ranges": [266, 0, 266, 31], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_intro_l", "text": "Theorem op_intro_l\n  :  forall x y z : E, x = y -> z + x = z + y.\nProof Group.op_intro_l op_group.\n", "definition": "  forall x y z : E, x = y -> z + x = z + y.\n", "proof": "Proof Group.op_intro_l op_group.", "proof_term": "Proof Group.op_intro_l op_group.", "def_ranges": [269, 0, 270, 46], "proof_ranges": [271, 0, 271, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_intro_r", "text": "Theorem op_intro_r\n  :  forall x y z : E, x = y -> x + z = y + z.\nProof Group.op_intro_r op_group.\n", "definition": "  forall x y z : E, x = y -> x + z = y + z.\n", "proof": "Proof Group.op_intro_r op_group.", "proof_term": "Proof Group.op_intro_r op_group.", "def_ranges": [274, 0, 275, 46], "proof_ranges": [276, 0, 276, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_cancel_l", "text": "Theorem op_cancel_l\n  :   forall x y z : E, z + x = z + y -> x = y.\nProof Group.op_cancel_l op_group.\n", "definition": "   forall x y z : E, z + x = z + y -> x = y.\n", "proof": "Proof Group.op_cancel_l op_group.", "proof_term": "Proof Group.op_cancel_l op_group.", "def_ranges": [279, 0, 280, 47], "proof_ranges": [281, 0, 281, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_cancel_r", "text": "Theorem op_cancel_r\n  :   forall x y z : E, x + z = y + z -> x = y.\nProof Group.op_cancel_r op_group.\n", "definition": "   forall x y z : E, x + z = y + z -> x = y.\n", "proof": "Proof Group.op_cancel_r op_group.", "proof_term": "Proof Group.op_cancel_r op_group.", "def_ranges": [284, 0, 285, 47], "proof_ranges": [286, 0, 286, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_l_uniq", "text": "Theorem op_inv_l_uniq\n  :  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.\nProof Group.op_inv_l_uniq op_group.\n", "definition": "  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.\n", "proof": "Proof Group.op_inv_l_uniq op_group.", "proof_term": "Proof Group.op_inv_l_uniq op_group.", "def_ranges": [292, 0, 293, 67], "proof_ranges": [294, 0, 294, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_r_uniq", "text": "Theorem op_inv_r_uniq\n  :  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.\nProof Group.op_inv_r_uniq op_group.\n", "definition": "  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.\n", "proof": "Proof Group.op_inv_r_uniq op_group.", "proof_term": "Proof Group.op_inv_r_uniq op_group.", "def_ranges": [300, 0, 301, 67], "proof_ranges": [302, 0, 302, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_uniq", "text": "Theorem op_inv_uniq\n  :  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.\nProof Group.op_inv_uniq op_group.\n", "definition": "  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.\n", "proof": "Proof Group.op_inv_uniq op_group.", "proof_term": "Proof Group.op_inv_uniq op_group.", "def_ranges": [305, 0, 306, 63], "proof_ranges": [307, 0, 307, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_uniq_ex", "text": "Theorem op_inv_uniq_ex\n  :  forall x : E, exists! y : E, op_is_inv x y.\nProof Group.op_inv_uniq_ex op_group.\n", "definition": "  forall x : E, exists! y : E, op_is_inv x y.\n", "proof": "Proof Group.op_inv_uniq_ex op_group.", "proof_term": "Proof Group.op_inv_uniq_ex op_group.", "def_ranges": [313, 0, 314, 48], "proof_ranges": [315, 0, 315, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_0_l", "text": "Theorem op_inv_0_l\n  :  op_is_inv_l 0 0.\nProof Group.op_inv_0_l op_group.\n", "definition": "  op_is_inv_l 0 0.\n", "proof": "Proof Group.op_inv_0_l op_group.", "proof_term": "Proof Group.op_inv_0_l op_group.", "def_ranges": [321, 0, 322, 21], "proof_ranges": [323, 0, 323, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_0_r", "text": "Theorem op_inv_0_r\n  :  op_is_inv_r 0 0.\nProof Group.op_inv_0_r op_group.\n", "definition": "  op_is_inv_r 0 0.\n", "proof": "Proof Group.op_inv_0_r op_group.", "proof_term": "Proof Group.op_inv_0_r op_group.", "def_ranges": [329, 0, 330, 21], "proof_ranges": [331, 0, 331, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_0", "text": "Theorem op_inv_0\n  :  op_is_inv 0 0.\nProof Group.op_inv_0 op_group.\n", "definition": "  op_is_inv 0 0.\n", "proof": "Proof Group.op_inv_0 op_group.", "proof_term": "Proof Group.op_inv_0 op_group.", "def_ranges": [337, 0, 338, 19], "proof_ranges": [339, 0, 339, 30], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_has_inv_l_0", "text": "Theorem op_has_inv_l_0\n  :  has_inv_l 0.\nProof Group.op_has_inv_l_0 op_group.\n", "definition": "  has_inv_l 0.\n", "proof": "Proof Group.op_has_inv_l_0 op_group.", "proof_term": "Proof Group.op_has_inv_l_0 op_group.", "def_ranges": [345, 0, 346, 17], "proof_ranges": [347, 0, 347, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_has_inv_r_0", "text": "Theorem op_has_inv_r_0\n  :  has_inv_r 0.\nProof Group.op_has_inv_r_0 op_group.\n", "definition": "  has_inv_r 0.\n", "proof": "Proof Group.op_has_inv_r_0 op_group.", "proof_term": "Proof Group.op_has_inv_r_0 op_group.", "def_ranges": [353, 0, 354, 17], "proof_ranges": [355, 0, 355, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_has_inv_0", "text": "Theorem op_has_inv_0\n  :  has_inv 0.\nProof Group.op_has_inv_0 op_group.\n", "definition": "  has_inv 0.\n", "proof": "Proof Group.op_has_inv_0 op_group.", "proof_term": "Proof Group.op_has_inv_0 op_group.", "def_ranges": [361, 0, 362, 15], "proof_ranges": [363, 0, 363, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_0_eq_0", "text": "Theorem op_inv_0_eq_0\n  :  forall x : E, op_is_inv x 0 -> x = 0.\nProof Group.op_inv_0_eq_0 op_group.\n", "definition": "  forall x : E, op_is_inv x 0 -> x = 0.\n", "proof": "Proof Group.op_inv_0_eq_0 op_group.", "proof_term": "Proof Group.op_inv_0_eq_0 op_group.", "def_ranges": [369, 0, 370, 42], "proof_ranges": [371, 0, 371, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_inv_0_uniq", "text": "Theorem op_inv_0_uniq\n  :  unique (fun x => op_is_inv x 0) 0.\nProof Group.op_inv_0_uniq op_group.\n", "definition": "  unique (fun x => op_is_inv x 0) 0.\n", "proof": "Proof Group.op_inv_0_uniq op_group.", "proof_term": "Proof Group.op_inv_0_uniq op_group.", "def_ranges": [377, 0, 378, 39], "proof_ranges": [379, 0, 379, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_def", "text": "Theorem op_neg_def\n  :  forall x : E, op_is_inv x (- x).\nProof Group.op_neg_def op_group.\n", "definition": "  forall x : E, op_is_inv x (- x).\n", "proof": "Proof Group.op_neg_def op_group.", "proof_term": "Proof Group.op_neg_def op_group.", "def_ranges": [401, 0, 402, 37], "proof_ranges": [403, 0, 403, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_inj", "text": "Theorem op_neg_inj\n  :  is_injective E E op_neg.\nProof Group.op_neg_inj op_group.\n", "definition": "  is_injective E E op_neg.\n", "proof": "Proof Group.op_neg_inj op_group.", "proof_term": "Proof Group.op_neg_inj op_group.", "def_ranges": [406, 0, 407, 29], "proof_ranges": [408, 0, 408, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_cancel_neg", "text": "Theorem op_cancel_neg\n  :  forall x : E, op_neg (- x) = x.\nProof Group.op_cancel_neg op_group.\n", "definition": "  forall x : E, op_neg (- x) = x.\n", "proof": "Proof Group.op_cancel_neg op_group.", "proof_term": "Proof Group.op_cancel_neg op_group.", "def_ranges": [411, 0, 412, 36], "proof_ranges": [413, 0, 413, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_onto", "text": "Theorem op_neg_onto\n  :  is_onto E E op_neg.\nProof Group.op_neg_onto op_group.\n", "definition": "  is_onto E E op_neg.\n", "proof": "Proof Group.op_neg_onto op_group.", "proof_term": "Proof Group.op_neg_onto op_group.", "def_ranges": [416, 0, 417, 24], "proof_ranges": [418, 0, 418, 33], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_bijective", "text": "Theorem op_neg_bijective\n  :  is_bijective E E op_neg.\nProof Group.op_neg_bijective op_group.\n", "definition": "  is_bijective E E op_neg.\n", "proof": "Proof Group.op_neg_bijective op_group.", "proof_term": "Proof Group.op_neg_bijective op_group.", "def_ranges": [421, 0, 422, 29], "proof_ranges": [423, 0, 423, 38], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_rev", "text": "Theorem op_neg_rev\n  :  forall x y : E, - x = y -> - y = x.\nProof Group.op_neg_rev op_group.\n", "definition": "  forall x y : E, - x = y -> - y = x.\n", "proof": "Proof Group.op_neg_rev op_group.", "proof_term": "Proof Group.op_neg_rev op_group.", "def_ranges": [426, 0, 427, 40], "proof_ranges": [428, 0, 428, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_distrib_inv_l", "text": "Theorem op_neg_distrib_inv_l\n  :  forall x y : E, op_is_inv_l (x + y) (- y + - x).\nProof Group.op_neg_distrib_inv_l op_group.\n", "definition": "  forall x y : E, op_is_inv_l (x + y) (- y + - x).\n", "proof": "Proof Group.op_neg_distrib_inv_l op_group.", "proof_term": "Proof Group.op_neg_distrib_inv_l op_group.", "def_ranges": [433, 0, 434, 53], "proof_ranges": [435, 0, 435, 42], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_distrib_inv_r", "text": "Theorem op_neg_distrib_inv_r\n  :  forall x y : E, op_is_inv_r (x + y) (- y + - x).\nProof Group.op_neg_distrib_inv_r op_group.\n", "definition": "  forall x y : E, op_is_inv_r (x + y) (- y + - x).\n", "proof": "Proof Group.op_neg_distrib_inv_r op_group.", "proof_term": "Proof Group.op_neg_distrib_inv_r op_group.", "def_ranges": [440, 0, 441, 53], "proof_ranges": [442, 0, 442, 42], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_distrib_inv", "text": "Theorem op_neg_distrib_inv\n  :  forall x y : E, op_is_inv (x + y) (- y + - x).\nProof Group.op_neg_distrib_inv op_group.\n", "definition": "  forall x y : E, op_is_inv (x + y) (- y + - x).\n", "proof": "Proof Group.op_neg_distrib_inv op_group.", "proof_term": "Proof Group.op_neg_distrib_inv op_group.", "def_ranges": [447, 0, 448, 51], "proof_ranges": [449, 0, 449, 40], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/abelian_group.v", "name": "op_neg_distrib", "text": "Theorem op_neg_distrib\n  :  forall x y : E, - (x + y) = - y + - x.\nProof Group.op_neg_distrib op_group.\n", "definition": "  forall x y : E, - (x + y) = - y + - x.\n", "proof": "Proof Group.op_neg_distrib op_group.", "proof_term": "Proof Group.op_neg_distrib op_group.", "def_ranges": [455, 0, 456, 43], "proof_ranges": [457, 0, 457, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid_expr.v", "name": "BTree_rassoc_thm", "text": "Theorem BTree_rassoc_thm\n  :  forall t u : BTree, BTree_is_rassoc (node t u) = true -> BTree_is_rassoc u = true.\nProof\n  fun t u H\n    => proj2 (\n            andb_prop \n              (BTree_is_leaf t)\n              (BTree_is_rassoc u)\n              H).\n", "definition": "  forall t u : BTree, BTree_is_rassoc (node t u) = true -> BTree_is_rassoc u = true.\n", "proof": "Proof\n  fun t u H\n    => proj2 (\n            andb_prop \n              (BTree_is_leaf t)\n              (BTree_is_rassoc u)\n              H).", "proof_term": "Proof\n  fun t u H\n    => proj2 (\n            andb_prop \n              (BTree_is_leaf t)\n              (BTree_is_rassoc u)\n              H).", "def_ranges": [102, 0, 103, 87], "proof_ranges": [104, 0, 110, 17], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/monoid_expr.v", "name": "Term_is_zero_thm", "text": "Theorem Term_is_zero_thm\n  :  forall t, Term_is_zero t = true -> Term_eval t = 0.\nProof\n  Term_ind\n    (fun t => Term_is_zero t = true -> Term_eval t = 0)\n       (fun _ => eq_refl 0)\n       (fun x H\n         => False_ind\n              (Term_eval (term_const x) = 0)\n              (diff_false_true H)).\n", "definition": "  forall t, Term_is_zero t = true -> Term_eval t = 0.\n", "proof": "Proof\n  Term_ind\n    (fun t => Term_is_zero t = true -> Term_eval t = 0)\n       (fun _ => eq_refl 0)\n       (fun x H\n         => False_ind\n              (Term_eval (term_const x) = 0)\n              (diff_false_true H)).", "proof_term": "Proof\n  Term_ind\n    (fun t => Term_is_zero t = true -> Term_eval t = 0)\n       (fun _ => eq_refl 0)\n       (fun x H\n         => False_ind\n              (Term_eval (term_const x) = 0)\n              (diff_false_true H)).", "def_ranges": [518, 0, 519, 56], "proof_ranges": [520, 0, 527, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_id", "text": "Theorem op_id\n  :  op_is_id 0.\nProof Monoid.op_id op_monoid.\n", "definition": "  op_is_id 0.\n", "proof": "Proof Monoid.op_id op_monoid.", "proof_term": "Proof Monoid.op_id op_monoid.", "def_ranges": [129, 0, 130, 16], "proof_ranges": [131, 0, 131, 29], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_id_l_uniq", "text": "Theorem op_id_l_uniq\n  :  forall x : E, (op_is_id_l x) -> x = 0.\nProof Monoid.op_id_l_uniq op_monoid.\n", "definition": "  forall x : E, (op_is_id_l x) -> x = 0.\n", "proof": "Proof Monoid.op_id_l_uniq op_monoid.", "proof_term": "Proof Monoid.op_id_l_uniq op_monoid.", "def_ranges": [146, 0, 147, 43], "proof_ranges": [148, 0, 148, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_id_r_uniq", "text": "Theorem op_id_r_uniq \n  :  forall x : E, (op_is_id_r x) -> x = 0.\nProof Monoid.op_id_r_uniq op_monoid.\n", "definition": "  forall x : E, (op_is_id_r x) -> x = 0.\n", "proof": "Proof Monoid.op_id_r_uniq op_monoid.", "proof_term": "Proof Monoid.op_id_r_uniq op_monoid.", "def_ranges": [151, 0, 152, 43], "proof_ranges": [153, 0, 153, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_id_uniq", "text": "Theorem op_id_uniq\n  :  forall x : E, (op_is_id x) -> x = 0.\nProof Monoid.op_id_uniq op_monoid.\n", "definition": "  forall x : E, (op_is_id x) -> x = 0.\n", "proof": "Proof Monoid.op_id_uniq op_monoid.", "proof_term": "Proof Monoid.op_id_uniq op_monoid.", "def_ranges": [156, 0, 157, 41], "proof_ranges": [158, 0, 158, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_intro_l", "text": "Theorem op_intro_l\n  :  forall x y z : E, x = y -> z + x = z + y.\nProof Monoid.op_intro_l op_monoid.\n", "definition": "  forall x y z : E, x = y -> z + x = z + y.\n", "proof": "Proof Monoid.op_intro_l op_monoid.", "proof_term": "Proof Monoid.op_intro_l op_monoid.", "def_ranges": [161, 0, 162, 46], "proof_ranges": [163, 0, 163, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_intro_r", "text": "Theorem op_intro_r\n  :  forall x y z : E, x = y -> x + z = y + z.\nProof Monoid.op_intro_r op_monoid.\n", "definition": "  forall x y z : E, x = y -> x + z = y + z.\n", "proof": "Proof Monoid.op_intro_r op_monoid.", "proof_term": "Proof Monoid.op_intro_r op_monoid.", "def_ranges": [166, 0, 167, 46], "proof_ranges": [168, 0, 168, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_l_r_eq", "text": "Theorem op_inv_l_r_eq\n  :  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.\nProof Monoid.op_inv_l_r_eq op_monoid.\n", "definition": "  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.\n", "proof": "Proof Monoid.op_inv_l_r_eq op_monoid.", "proof_term": "Proof Monoid.op_inv_l_r_eq op_monoid.", "def_ranges": [198, 0, 199, 79], "proof_ranges": [200, 0, 200, 37], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_sym", "text": "Theorem op_inv_sym\n  :  forall x y : E, op_is_inv x y <-> op_is_inv y x.\nProof Monoid.op_inv_sym op_monoid.\n", "definition": "  forall x y : E, op_is_inv x y <-> op_is_inv y x.\n", "proof": "Proof Monoid.op_inv_sym op_monoid.", "proof_term": "Proof Monoid.op_inv_sym op_monoid.", "def_ranges": [206, 0, 207, 53], "proof_ranges": [208, 0, 208, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_ex", "text": "Theorem op_inv_ex\n  :  forall x : E, exists y : E, op_is_inv x y.\nProof\n  fun x : E\n    => ex_ind\n            (fun y H\n              => ex_ind\n                   (fun z H0\n                     => let H1\n                          :  op_is_inv_r x y\n                          :=  H0\n                          || op_is_inv_r x a @a\n                             by op_inv_l_r_eq x y H z H0 in\n                        ex_intro\n                          (fun a => op_is_inv x a)\n                          y\n                          (conj H H1))\n                   (op_inv_r_ex x))\n            (op_inv_l_ex x).\n", "definition": "  forall x : E, exists y : E, op_is_inv x y.\n", "proof": "Proof\n  fun x : E\n    => ex_ind\n            (fun y H\n              => ex_ind\n                   (fun z H0\n                     => let H1\n                          :  op_is_inv_r x y\n                          :=  H0\n                          || op_is_inv_r x a @a\n                             by op_inv_l_r_eq x y H z H0 in\n                        ex_intro\n                          (fun a => op_is_inv x a)\n                          y\n                          (conj H H1))\n                   (op_inv_r_ex x))\n            (op_inv_l_ex x).", "proof_term": "Proof\n  fun x : E\n    => ex_ind\n            (fun y H\n              => ex_ind\n                   (fun z H0\n                     => let H1\n                          :  op_is_inv_r x y\n                          :=  H0\n                          || op_is_inv_r x a @a\n                             by op_inv_l_r_eq x y H z H0 in\n                        ex_intro\n                          (fun a => op_is_inv x a)\n                          y\n                          (conj H H1))\n                   (op_inv_r_ex x))\n            (op_inv_l_ex x).", "def_ranges": [214, 0, 215, 47], "proof_ranges": [216, 0, 232, 28], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_cancel_l", "text": "Theorem op_cancel_l\n  :  forall x y z : E, z + x = z + y -> x = y.\nProof\n  fun x y z H \n    => Monoid.op_cancel_l op_monoid x y z (op_inv_l_ex z) H.\n", "definition": "  forall x y z : E, z + x = z + y -> x = y.\n", "proof": "Proof\n  fun x y z H \n    => Monoid.op_cancel_l op_monoid x y z (op_inv_l_ex z) H.", "proof_term": "Proof\n  fun x y z H \n    => Monoid.op_cancel_l op_monoid x y z (op_inv_l_ex z) H.", "def_ranges": [235, 0, 236, 46], "proof_ranges": [237, 0, 239, 60], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_cancel_r", "text": "Theorem op_cancel_r\n  :  forall x y z : E, x + z = y + z -> x = y.\nProof\n  fun x y z\n    => Monoid.op_cancel_r op_monoid x y z (op_inv_r_ex z).\n", "definition": "  forall x y z : E, x + z = y + z -> x = y.\n", "proof": "Proof\n  fun x y z\n    => Monoid.op_cancel_r op_monoid x y z (op_inv_r_ex z).", "proof_term": "Proof\n  fun x y z\n    => Monoid.op_cancel_r op_monoid x y z (op_inv_r_ex z).", "def_ranges": [242, 0, 243, 46], "proof_ranges": [244, 0, 246, 58], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_l_uniq", "text": "Theorem op_inv_l_uniq\n  :  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.\nProof\n  fun x\n    => Monoid.op_inv_l_uniq op_monoid x (op_inv_r_ex x).\n", "definition": "  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.\n", "proof": "Proof\n  fun x\n    => Monoid.op_inv_l_uniq op_monoid x (op_inv_r_ex x).", "proof_term": "Proof\n  fun x\n    => Monoid.op_inv_l_uniq op_monoid x (op_inv_r_ex x).", "def_ranges": [252, 0, 253, 67], "proof_ranges": [254, 0, 256, 56], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_r_uniq", "text": "Theorem op_inv_r_uniq\n  :  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.\nProof\n  fun x\n    => Monoid.op_inv_r_uniq op_monoid x (op_inv_l_ex x).\n", "definition": "  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.\n", "proof": "Proof\n  fun x\n    => Monoid.op_inv_r_uniq op_monoid x (op_inv_l_ex x).", "proof_term": "Proof\n  fun x\n    => Monoid.op_inv_r_uniq op_monoid x (op_inv_l_ex x).", "def_ranges": [262, 0, 263, 67], "proof_ranges": [264, 0, 266, 56], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_uniq", "text": "Theorem op_inv_uniq\n  :  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.\nProof Monoid.op_inv_uniq op_monoid.\n", "definition": "  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.\n", "proof": "Proof Monoid.op_inv_uniq op_monoid.", "proof_term": "Proof Monoid.op_inv_uniq op_monoid.", "def_ranges": [269, 0, 270, 63], "proof_ranges": [271, 0, 271, 35], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_uniq_ex", "text": "Theorem op_inv_uniq_ex\n  :  forall x : E, exists! y : E, op_is_inv x y.\nProof\n  fun x\n    => ex_ind\n            (fun y (H : op_is_inv x y)\n              => ex_intro \n                   (fun y => op_is_inv x y /\\ forall z, op_is_inv x z -> y = z)\n                   y\n                   (conj H (fun z H0 => eq_sym (op_inv_uniq x y z H H0))))\n            (op_inv_ex x).\n", "definition": "  forall x : E, exists! y : E, op_is_inv x y.\n", "proof": "Proof\n  fun x\n    => ex_ind\n            (fun y (H : op_is_inv x y)\n              => ex_intro \n                   (fun y => op_is_inv x y /\\ forall z, op_is_inv x z -> y = z)\n                   y\n                   (conj H (fun z H0 => eq_sym (op_inv_uniq x y z H H0))))\n            (op_inv_ex x).", "proof_term": "Proof\n  fun x\n    => ex_ind\n            (fun y (H : op_is_inv x y)\n              => ex_intro \n                   (fun y => op_is_inv x y /\\ forall z, op_is_inv x z -> y = z)\n                   y\n                   (conj H (fun z H0 => eq_sym (op_inv_uniq x y z H H0))))\n            (op_inv_ex x).", "def_ranges": [277, 0, 278, 48], "proof_ranges": [279, 0, 287, 26], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_0_l", "text": "Theorem op_inv_0_l\n  :  op_is_inv_l 0 0.\nProof Monoid.op_inv_0_l op_monoid.\n", "definition": "  op_is_inv_l 0 0.\n", "proof": "Proof Monoid.op_inv_0_l op_monoid.", "proof_term": "Proof Monoid.op_inv_0_l op_monoid.", "def_ranges": [293, 0, 294, 21], "proof_ranges": [295, 0, 295, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_0_r", "text": "Theorem op_inv_0_r\n  :  op_is_inv_r 0 0.\nProof Monoid.op_inv_0_r op_monoid.\n", "definition": "  op_is_inv_r 0 0.\n", "proof": "Proof Monoid.op_inv_0_r op_monoid.", "proof_term": "Proof Monoid.op_inv_0_r op_monoid.", "def_ranges": [301, 0, 302, 21], "proof_ranges": [303, 0, 303, 34], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_0", "text": "Theorem op_inv_0\n  :  op_is_inv 0 0.\nProof Monoid.op_inv_0 op_monoid.\n", "definition": "  op_is_inv 0 0.\n", "proof": "Proof Monoid.op_inv_0 op_monoid.", "proof_term": "Proof Monoid.op_inv_0 op_monoid.", "def_ranges": [309, 0, 310, 19], "proof_ranges": [311, 0, 311, 32], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_has_inv_l_0", "text": "Theorem op_has_inv_l_0\n  :  has_inv_l 0.\nProof Monoid.op_has_inv_l_0 op_monoid.\n", "definition": "  has_inv_l 0.\n", "proof": "Proof Monoid.op_has_inv_l_0 op_monoid.", "proof_term": "Proof Monoid.op_has_inv_l_0 op_monoid.", "def_ranges": [317, 0, 318, 17], "proof_ranges": [319, 0, 319, 38], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_has_inv_r_0", "text": "Theorem op_has_inv_r_0\n  :  has_inv_r 0.\nProof Monoid.op_has_inv_r_0 op_monoid.\n", "definition": "  has_inv_r 0.\n", "proof": "Proof Monoid.op_has_inv_r_0 op_monoid.", "proof_term": "Proof Monoid.op_has_inv_r_0 op_monoid.", "def_ranges": [325, 0, 326, 17], "proof_ranges": [327, 0, 327, 38], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_has_inv_0", "text": "Theorem op_has_inv_0\n  :  has_inv 0.\nProof Monoid.op_has_inv_0 op_monoid.\n", "definition": "  has_inv 0.\n", "proof": "Proof Monoid.op_has_inv_0 op_monoid.", "proof_term": "Proof Monoid.op_has_inv_0 op_monoid.", "def_ranges": [333, 0, 334, 15], "proof_ranges": [335, 0, 335, 36], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_0_eq_0", "text": "Theorem op_inv_0_eq_0\n  :  forall x : E, op_is_inv x 0 -> x = 0.\nProof Monoid.op_inv_0_eq_0 op_monoid.\n", "definition": "  forall x : E, op_is_inv x 0 -> x = 0.\n", "proof": "Proof Monoid.op_inv_0_eq_0 op_monoid.", "proof_term": "Proof Monoid.op_inv_0_eq_0 op_monoid.", "def_ranges": [341, 0, 342, 42], "proof_ranges": [343, 0, 343, 37], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_inv_0_uniq", "text": "Theorem op_inv_0_uniq\n  :  unique (fun x => op_is_inv x 0) 0.\nProof Monoid.op_inv_0_uniq op_monoid.\n", "definition": "  unique (fun x => op_is_inv x 0) 0.\n", "proof": "Proof Monoid.op_inv_0_uniq op_monoid.", "proof_term": "Proof Monoid.op_inv_0_uniq op_monoid.", "def_ranges": [349, 0, 350, 39], "proof_ranges": [351, 0, 351, 37], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_neg_def", "text": "Theorem op_neg_def\n  :  forall x : E, op_is_inv x (- x).\nProof\n  fun x\n    => Monoid.op_neg_def op_monoid x (op_inv_ex x).\n", "definition": "  forall x : E, op_is_inv x (- x).\n", "proof": "Proof\n  fun x\n    => Monoid.op_neg_def op_monoid x (op_inv_ex x).", "proof_term": "Proof\n  fun x\n    => Monoid.op_neg_def op_monoid x (op_inv_ex x).", "def_ranges": [368, 0, 369, 37], "proof_ranges": [370, 0, 372, 51], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_neg_inj", "text": "Theorem op_neg_inj\n  :  is_injective E E op_neg.\nProof\n  fun x y\n    => Monoid.op_neg_inj op_monoid x (op_inv_ex x) y (op_inv_ex y).\n", "definition": "  is_injective E E op_neg.\n", "proof": "Proof\n  fun x y\n    => Monoid.op_neg_inj op_monoid x (op_inv_ex x) y (op_inv_ex y).", "proof_term": "Proof\n  fun x y\n    => Monoid.op_neg_inj op_monoid x (op_inv_ex x) y (op_inv_ex y).", "def_ranges": [381, 0, 382, 29], "proof_ranges": [383, 0, 385, 67], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_cancel_neg", "text": "Theorem op_cancel_neg\n  :  forall x : E, - (- x) = x.\nProof\n  fun x\n    => Monoid.op_cancel_neg_gen op_monoid x (op_inv_ex x) (op_inv_ex (- x)).\n", "definition": "  forall x : E, - (- x) = x.\n", "proof": "Proof\n  fun x\n    => Monoid.op_cancel_neg_gen op_monoid x (op_inv_ex x) (op_inv_ex (- x)).", "proof_term": "Proof\n  fun x\n    => Monoid.op_cancel_neg_gen op_monoid x (op_inv_ex x) (op_inv_ex (- x)).", "def_ranges": [388, 0, 389, 31], "proof_ranges": [390, 0, 392, 76], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_neg_rev", "text": "Theorem op_neg_rev\n  :  forall x y : E, - x = y -> - y = x.\nProof\n  fun x y H\n    => eq_sym\n            (f_equal {-} H\n             || a = - y @a by <- op_cancel_neg x).\n", "definition": "  forall x y : E, - x = y -> - y = x.\n", "proof": "Proof\n  fun x y H\n    => eq_sym\n            (f_equal {-} H\n             || a = - y @a by <- op_cancel_neg x).", "proof_term": "Proof\n  fun x y H\n    => eq_sym\n            (f_equal {-} H\n             || a = - y @a by <- op_cancel_neg x).", "def_ranges": [407, 0, 408, 40], "proof_ranges": [409, 0, 413, 50], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_neg_distrib_inv_l", "text": "Theorem op_neg_distrib_inv_l\n  :  forall x y : E, op_is_inv_l (x + y) (- y + - x).\nProof\n  fun x y\n    => ((proj2 (op_neg_def (- y)))\n            || - y + a = 0                 @a by <- op_cancel_neg y\n            || - y + a = 0                 @a by op_id_l y\n            || - y + (a + y) = 0           @a by proj2 (op_neg_def (- x))\n            || - y + ((- x + a) + y) = 0 @a by <- op_cancel_neg x\n            || - y + a = 0                 @a by op_is_assoc (- x) x y\n            || a = 0                         @a by <- op_is_assoc (- y) (- x) (x + y)).\n", "definition": "  forall x y : E, op_is_inv_l (x + y) (- y + - x).\n", "proof": "Proof\n  fun x y\n    => ((proj2 (op_neg_def (- y)))\n            || - y + a = 0                 @a by <- op_cancel_neg y\n            || - y + a = 0                 @a by op_id_l y\n            || - y + (a + y) = 0           @a by proj2 (op_neg_def (- x))\n            || - y + ((- x + a) + y) = 0 @a by <- op_cancel_neg x\n            || - y + a = 0                 @a by op_is_assoc (- x) x y\n            || a = 0                         @a by <- op_is_assoc (- y) (- x) (x + y)).", "proof_term": "Proof\n  fun x y\n    => ((proj2 (op_neg_def (- y)))\n            || - y + a = 0                 @a by <- op_cancel_neg y\n            || - y + a = 0                 @a by op_id_l y\n            || - y + (a + y) = 0           @a by proj2 (op_neg_def (- x))\n            || - y + ((- x + a) + y) = 0 @a by <- op_cancel_neg x\n            || - y + a = 0                 @a by op_is_assoc (- x) x y\n            || a = 0                         @a by <- op_is_assoc (- y) (- x) (x + y)).", "def_ranges": [418, 0, 419, 53], "proof_ranges": [420, 0, 428, 87], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_neg_distrib_inv_r", "text": "Theorem op_neg_distrib_inv_r\n  :  forall x y : E, op_is_inv_r (x + y) (- y + - x).\nProof\n  fun x y\n    => ((proj2 (op_neg_def x))\n            || x + a = 0           @a by op_id_l (- x)\n            || x + (a + - x) = 0 @a by proj2 (op_neg_def y)\n            || x + a = 0           @a by op_is_assoc y (- y) (- x)\n            || a = 0               @a by <- op_is_assoc x y (- y + - x)).\n", "definition": "  forall x y : E, op_is_inv_r (x + y) (- y + - x).\n", "proof": "Proof\n  fun x y\n    => ((proj2 (op_neg_def x))\n            || x + a = 0           @a by op_id_l (- x)\n            || x + (a + - x) = 0 @a by proj2 (op_neg_def y)\n            || x + a = 0           @a by op_is_assoc y (- y) (- x)\n            || a = 0               @a by <- op_is_assoc x y (- y + - x)).", "proof_term": "Proof\n  fun x y\n    => ((proj2 (op_neg_def x))\n            || x + a = 0           @a by op_id_l (- x)\n            || x + (a + - x) = 0 @a by proj2 (op_neg_def y)\n            || x + a = 0           @a by op_is_assoc y (- y) (- x)\n            || a = 0               @a by <- op_is_assoc x y (- y + - x)).", "def_ranges": [433, 0, 434, 53], "proof_ranges": [435, 0, 441, 73], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_neg_distrib_inv", "text": "Theorem op_neg_distrib_inv\n  :  forall x y : E, op_is_inv (x + y) (- y + - x).\nProof\n  fun x y\n    => conj\n            (op_neg_distrib_inv_l x y)\n            (op_neg_distrib_inv_r x y).\n", "definition": "  forall x y : E, op_is_inv (x + y) (- y + - x).\n", "proof": "Proof\n  fun x y\n    => conj\n            (op_neg_distrib_inv_l x y)\n            (op_neg_distrib_inv_r x y).", "proof_term": "Proof\n  fun x y\n    => conj\n            (op_neg_distrib_inv_l x y)\n            (op_neg_distrib_inv_r x y).", "def_ranges": [446, 0, 447, 51], "proof_ranges": [448, 0, 452, 39], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/functional-algebra/group.v", "name": "op_neg_distrib", "text": "Theorem op_neg_distrib\n  :  forall x y : E, - (x + y) = - y + - x.\nProof\n  fun x y\n    => ex_ind\n            (fun z (H : unique (op_is_inv (x + y)) z)\n              => let H0\n                   :  z = - (x + y)\n                   := (proj2 H) \n                       (- (x + y))\n                       (op_neg_def (x + y)) in\n                 let H1\n                   :  z = (- y + - x)\n                   := (proj2 H)\n                        (- y + - x)\n                        (op_neg_distrib_inv x y) in\n                 (H1 || a = - y + - x @a by <- H0))\n            (op_inv_uniq_ex (x + y)).\n", "definition": "  forall x y : E, - (x + y) = - y + - x.\n", "proof": "Proof\n  fun x y\n    => ex_ind\n            (fun z (H : unique (op_is_inv (x + y)) z)\n              => let H0\n                   :  z = - (x + y)\n                   := (proj2 H) \n                       (- (x + y))\n                       (op_neg_def (x + y)) in\n                 let H1\n                   :  z = (- y + - x)\n                   := (proj2 H)\n                        (- y + - x)\n                        (op_neg_distrib_inv x y) in\n                 (H1 || a = - y + - x @a by <- H0))\n            (op_inv_uniq_ex (x + y)).", "proof_term": "Proof\n  fun x y\n    => ex_ind\n            (fun z (H : unique (op_is_inv (x + y)) z)\n              => let H0\n                   :  z = - (x + y)\n                   := (proj2 H) \n                       (- (x + y))\n                       (op_neg_def (x + y)) in\n                 let H1\n                   :  z = (- y + - x)\n                   := (proj2 H)\n                        (- y + - x)\n                        (op_neg_distrib_inv x y) in\n                 (H1 || a = - y + - x @a by <- H0))\n            (op_inv_uniq_ex (x + y)).", "def_ranges": [458, 0, 459, 43], "proof_ranges": [460, 0, 475, 37], "only_proof_term": true, "proof_steps": []}, {"path": "/home/jizej/proverbot9001/coq-projects/dep-map/Coqlib.v", "name": "eq_sym", "text": "Lemma eq_sym : forall x y : t, eq x y -> eq y x.\n  Proof. intros. now symmetry. Qed. \n", "definition": " forall x y : t, eq x y -> eq y x.\n  ", "proof": "Proof. intros. now symmetry. Qed. ", "proof_term": ["(fun (x y : t) (H : eq x y) => symmetry H)"], "def_ranges": [30, 0, 30, 50], "proof_ranges": [31, 0, 31, 35], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": ["forall x y : t, eq x y -> eq y x"], "goal_after": ["forall x y : t, eq x y -> eq y x"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros.", "goal_before": ["forall x y : t, eq x y -> eq y x"], "goal_after": ["eq y x"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (x y : t) (H : eq x y) => ?Goal)"]}, {"text": "now symmetry.", "goal_before": ["eq y x"], "goal_after": [], "proof_term_before": ["(fun (x y : t) (H : eq x y) => ?Goal)"], "proof_term_after": ["(fun (x y : t) (H : eq x y) => symmetry H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : t) (H : eq x y) => symmetry H)"], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "intros. Show Proof.", "now symmetry. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/dep-map/Coqlib.v", "name": "eq_trans", "text": "Lemma eq_trans : forall x y z : t, eq x y -> eq y z -> eq x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n", "definition": " forall x y z : t, eq x y -> eq y z -> eq x z.\n  ", "proof": "Proof. intros. etransitivity; eassumption. Qed.", "proof_term": ["(fun (x y z : t) (H : eq x y) (H0 : eq y z) => transitivity H H0)"], "def_ranges": [32, 0, 32, 64], "proof_ranges": [33, 0, 33, 49], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": ["forall x y z : t, eq x y -> eq y z -> eq x z"], "goal_after": ["forall x y z : t, eq x y -> eq y z -> eq x z"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros.", "goal_before": ["forall x y z : t, eq x y -> eq y z -> eq x z"], "goal_after": ["eq x z"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (x y z : t) (H : eq x y) (H0 : eq y z) => ?Goal)"]}, {"text": "etransitivity; eassumption.", "goal_before": ["eq x z"], "goal_after": [], "proof_term_before": ["(fun (x y z : t) (H : eq x y) (H0 : eq y z) => ?Goal)"], "proof_term_after": ["(fun (x y z : t) (H : eq x y) (H0 : eq y z) => transitivity H H0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y z : t) (H : eq x y) (H0 : eq y z) => transitivity H H0)"], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "intros. Show Proof.", "etransitivity; eassumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/dep-map/Coqlib.v", "name": "lt_trans", "text": "Lemma lt_trans : forall x y z : t, lt x y -> lt y z -> lt x z.\n  Proof. intros. etransitivity; eassumption. Qed.\n", "definition": " forall x y z : t, lt x y -> lt y z -> lt x z.\n  ", "proof": "Proof. intros. etransitivity; eassumption. Qed.", "proof_term": ["(fun (x y z : t) (H : lt x y) (H0 : lt y z) => transitivity H H0)"], "def_ranges": [35, 0, 35, 64], "proof_ranges": [36, 0, 36, 49], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": ["forall x y z : t, lt x y -> lt y z -> lt x z"], "goal_after": ["forall x y z : t, lt x y -> lt y z -> lt x z"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros.", "goal_before": ["forall x y z : t, lt x y -> lt y z -> lt x z"], "goal_after": ["lt x z"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (x y z : t) (H : lt x y) (H0 : lt y z) => ?Goal)"]}, {"text": "etransitivity; eassumption.", "goal_before": ["lt x z"], "goal_after": [], "proof_term_before": ["(fun (x y z : t) (H : lt x y) (H0 : lt y z) => ?Goal)"], "proof_term_after": ["(fun (x y z : t) (H : lt x y) (H0 : lt y z) => transitivity H H0)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y z : t) (H : lt x y) (H0 : lt y z) => transitivity H H0)"], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "intros. Show Proof.", "etransitivity; eassumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/dep-map/Coqlib.v", "name": "lt_not_eq", "text": "Lemma lt_not_eq : forall x y : t, lt x y -> ~ eq x y.\n  Proof. intros ? ? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.\n", "definition": " forall x y : t, lt x y -> ~ eq x y.\n  ", "proof": "Proof. intros ? ? Hlt Heq. rewrite Heq in Hlt. revert Hlt. apply StrictOrder_Irreflexive. Qed.", "proof_term": ["(fun (x y : t) (Hlt : lt x y) =>\n (fun Heq : eq x y =>\n  StrictOrder_Irreflexive y\n    ((fun lemma : eq x y =>\n      subrelation_proper O.lt_compat tt\n        (subrelation_respectful (subrelation_refl O.eq)\n           (subrelation_respectful (subrelation_refl O.eq)\n              iff_impl_subrelation)) x y lemma y y\n        (reflexive_proper_proxy\n           (reflexive_reflexive_proxy Equivalence_Reflexive) y)) Heq Hlt))\n :\n ~ eq x y)"], "def_ranges": [37, 0, 37, 55], "proof_ranges": [38, 0, 38, 96], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": ["forall x y : t, lt x y -> ~ eq x y"], "goal_after": ["forall x y : t, lt x y -> ~ eq x y"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros ? ? Hlt Heq.", "goal_before": ["forall x y : t, lt x y -> ~ eq x y"], "goal_after": ["False"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun (x y : t) (Hlt : lt x y) => (fun Heq : eq x y => ?Goal) : ~ eq x y)"]}, {"text": "rewrite Heq in Hlt.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (x y : t) (Hlt : lt x y) => (fun Heq : eq x y => ?Goal) : ~ eq x y)"], "proof_term_after": ["(fun (x y : t) (Hlt : lt x y) =>\n (fun Heq : eq x y =>\n  ?Goal@{Hlt:=(fun lemma : eq x y =>\n               subrelation_proper O.lt_compat tt\n                 (subrelation_respectful (subrelation_refl O.eq)\n                    (subrelation_respectful (subrelation_refl O.eq)\n                       iff_impl_subrelation)) x y lemma y y\n                 (reflexive_proper_proxy\n                    (reflexive_reflexive_proxy Equivalence_Reflexive) y)) Heq\n                Hlt})\n :\n ~ eq x y)"]}, {"text": "revert Hlt.", "goal_before": ["False"], "goal_after": ["lt y y -> False"], "proof_term_before": ["(fun (x y : t) (Hlt : lt x y) =>\n (fun Heq : eq x y =>\n  ?Goal@{Hlt:=(fun lemma : eq x y =>\n               subrelation_proper O.lt_compat tt\n                 (subrelation_respectful (subrelation_refl O.eq)\n                    (subrelation_respectful (subrelation_refl O.eq)\n                       iff_impl_subrelation)) x y lemma y y\n                 (reflexive_proper_proxy\n                    (reflexive_reflexive_proxy Equivalence_Reflexive) y)) Heq\n                Hlt})\n :\n ~ eq x y)"], "proof_term_after": ["(fun (x y : t) (Hlt : lt x y) =>\n (fun Heq : eq x y =>\n  ?Goal\n    ((fun lemma : eq x y =>\n      subrelation_proper O.lt_compat tt\n        (subrelation_respectful (subrelation_refl O.eq)\n           (subrelation_respectful (subrelation_refl O.eq)\n              iff_impl_subrelation)) x y lemma y y\n        (reflexive_proper_proxy\n           (reflexive_reflexive_proxy Equivalence_Reflexive) y)) Heq Hlt))\n :\n ~ eq x y)"]}, {"text": "apply StrictOrder_Irreflexive.", "goal_before": ["lt y y -> False"], "goal_after": [], "proof_term_before": ["(fun (x y : t) (Hlt : lt x y) =>\n (fun Heq : eq x y =>\n  ?Goal\n    ((fun lemma : eq x y =>\n      subrelation_proper O.lt_compat tt\n        (subrelation_respectful (subrelation_refl O.eq)\n           (subrelation_respectful (subrelation_refl O.eq)\n              iff_impl_subrelation)) x y lemma y y\n        (reflexive_proper_proxy\n           (reflexive_reflexive_proxy Equivalence_Reflexive) y)) Heq Hlt))\n :\n ~ eq x y)"], "proof_term_after": ["(fun (x y : t) (Hlt : lt x y) =>\n (fun Heq : eq x y =>\n  StrictOrder_Irreflexive y\n    ((fun lemma : eq x y =>\n      subrelation_proper O.lt_compat tt\n        (subrelation_respectful (subrelation_refl O.eq)\n           (subrelation_respectful (subrelation_refl O.eq)\n              iff_impl_subrelation)) x y lemma y y\n        (reflexive_proper_proxy\n           (reflexive_reflexive_proxy Equivalence_Reflexive) y)) Heq Hlt))\n :\n ~ eq x y)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x y : t) (Hlt : lt x y) =>\n (fun Heq : eq x y =>\n  StrictOrder_Irreflexive y\n    ((fun lemma : eq x y =>\n      subrelation_proper O.lt_compat tt\n        (subrelation_respectful (subrelation_refl O.eq)\n           (subrelation_respectful (subrelation_refl O.eq)\n              iff_impl_subrelation)) x y lemma y y\n        (reflexive_proper_proxy\n           (reflexive_reflexive_proxy Equivalence_Reflexive) y)) Heq Hlt))\n :\n ~ eq x y)"], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "intros ? ? Hlt Heq. Show Proof.", "rewrite Heq in Hlt. Show Proof.", "revert Hlt. Show Proof.", "apply StrictOrder_Irreflexive. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/dep-map/Coqlib.v", "name": "compare", "text": "Lemma compare : forall x y : t, OrderedType.Compare lt eq x y.\n  Proof.\n  intros x y. assert (H :=  (O.compare_spec x y)).  destruct (O.compare x y).\n  - constructor 2. now inversion H.\n  - constructor 1. now inversion H.\n  - constructor 3. now inversion H.\n  Qed.\n", "definition": " forall x y : t, OrderedType.Compare lt eq x y.\n  ", "proof": "Proof.\n  intros x y. assert (H :=  (O.compare_spec x y)).  destruct (O.compare x y).\n  - constructor 2. now inversion H.\n  - constructor 1. now inversion H.\n  - constructor 3. now inversion H.\n  Qed.", "proof_term": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT\n       (let H1 : Lt = Lt -> lt x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Lt -> lt x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Lt) =>\n               (fun H3 : Eq = Lt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.eq x y -> lt x y) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Lt) =>\n               (fun (_ : Lt = Lt) (H4 : O.lt x y) => H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Lt) =>\n               (fun H3 : Gt = Lt =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.lt y x -> lt x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     OrderedType.GT\n       (let H1 : Gt = Gt -> lt y x :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Gt -> lt y x) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Gt) =>\n               (fun H3 : Eq = Gt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Gt H3 in\n                False_ind (O.eq x y -> lt y x) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Gt) =>\n               (fun H3 : Lt = Gt =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Gt H3 in\n                False_ind (O.lt x y -> lt y x) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Gt) =>\n               (fun (_ : Gt = Gt) (H4 : O.lt y x) => H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n end H)"], "def_ranges": [40, 0, 40, 64], "proof_ranges": [41, 0, 46, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": ["forall x y : t, OrderedType.Compare lt eq x y"], "goal_after": ["forall x y : t, OrderedType.Compare lt eq x y"], "proof_term_before": [], "proof_term_after": ["?Goal"]}, {"text": "intros x y.", "goal_before": ["forall x y : t, OrderedType.Compare lt eq x y"], "goal_after": ["OrderedType.Compare lt eq x y"], "proof_term_before": ["?Goal"], "proof_term_after": ["(fun x y : t => ?Goal)"]}, {"text": "assert (H :=  (O.compare_spec x y)).", "goal_before": ["OrderedType.Compare lt eq x y"], "goal_after": ["OrderedType.Compare lt eq x y"], "proof_term_before": ["(fun x y : t => ?Goal)"], "proof_term_after": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n ?Goal)"]}, {"text": "destruct (O.compare x y).", "goal_before": ["OrderedType.Compare lt eq x y"], "goal_after": ["OrderedType.Compare lt eq x y", "OrderedType.Compare lt eq x y", "OrderedType.Compare lt eq x y"], "proof_term_before": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n ?Goal)"], "proof_term_after": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     ?Goal@{H:=H0}\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     ?Goal0@{H:=H0}\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal1@{H:=H0}\n end H)"]}, {"text": "constructor 2.", "goal_before": ["OrderedType.Compare lt eq x y", "OrderedType.Compare lt eq x y", "OrderedType.Compare lt eq x y"], "goal_after": ["eq x y", "OrderedType.Compare lt eq x y", "OrderedType.Compare lt eq x y"], "proof_term_before": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     ?Goal@{H:=H0}\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     ?Goal0@{H:=H0}\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal1@{H:=H0}\n end H)"], "proof_term_after": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ ?Goal1@{H:=H0}\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     ?Goal@{H:=H0}\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal0@{H:=H0}\n end H)"]}, {"text": "now inversion H.", "goal_before": ["eq x y", "OrderedType.Compare lt eq x y", "OrderedType.Compare lt eq x y"], "goal_after": ["OrderedType.Compare lt eq x y", "OrderedType.Compare lt eq x y"], "proof_term_before": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ ?Goal1@{H:=H0}\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     ?Goal@{H:=H0}\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal0@{H:=H0}\n end H)"], "proof_term_after": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     ?Goal@{H:=H0}\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal0@{H:=H0}\n end H)"]}, {"text": "constructor 1.", "goal_before": ["OrderedType.Compare lt eq x y", "OrderedType.Compare lt eq x y"], "goal_after": ["lt x y", "OrderedType.Compare lt eq x y"], "proof_term_before": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     ?Goal@{H:=H0}\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal0@{H:=H0}\n end H)"], "proof_term_after": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT ?Goal0@{H:=H0}\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal@{H:=H0}\n end H)"]}, {"text": "now inversion H.", "goal_before": ["lt x y", "OrderedType.Compare lt eq x y"], "goal_after": ["OrderedType.Compare lt eq x y"], "proof_term_before": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT ?Goal0@{H:=H0}\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal@{H:=H0}\n end H)"], "proof_term_after": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT\n       (let H1 : Lt = Lt -> lt x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Lt -> lt x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Lt) =>\n               (fun H3 : Eq = Lt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.eq x y -> lt x y) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Lt) =>\n               (fun (_ : Lt = Lt) (H4 : O.lt x y) => H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Lt) =>\n               (fun H3 : Gt = Lt =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.lt y x -> lt x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal@{H:=H0}\n end H)"]}, {"text": "constructor 3.", "goal_before": ["OrderedType.Compare lt eq x y"], "goal_after": ["lt y x"], "proof_term_before": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT\n       (let H1 : Lt = Lt -> lt x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Lt -> lt x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Lt) =>\n               (fun H3 : Eq = Lt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.eq x y -> lt x y) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Lt) =>\n               (fun (_ : Lt = Lt) (H4 : O.lt x y) => H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Lt) =>\n               (fun H3 : Gt = Lt =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.lt y x -> lt x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     ?Goal@{H:=H0}\n end H)"], "proof_term_after": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT\n       (let H1 : Lt = Lt -> lt x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Lt -> lt x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Lt) =>\n               (fun H3 : Eq = Lt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.eq x y -> lt x y) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Lt) =>\n               (fun (_ : Lt = Lt) (H4 : O.lt x y) => H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Lt) =>\n               (fun H3 : Gt = Lt =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.lt y x -> lt x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     OrderedType.GT ?Goal@{H:=H0}\n end H)"]}, {"text": "now inversion H.", "goal_before": ["lt y x"], "goal_after": [], "proof_term_before": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT\n       (let H1 : Lt = Lt -> lt x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Lt -> lt x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Lt) =>\n               (fun H3 : Eq = Lt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.eq x y -> lt x y) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Lt) =>\n               (fun (_ : Lt = Lt) (H4 : O.lt x y) => H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Lt) =>\n               (fun H3 : Gt = Lt =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.lt y x -> lt x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     OrderedType.GT ?Goal@{H:=H0}\n end H)"], "proof_term_after": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT\n       (let H1 : Lt = Lt -> lt x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Lt -> lt x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Lt) =>\n               (fun H3 : Eq = Lt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.eq x y -> lt x y) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Lt) =>\n               (fun (_ : Lt = Lt) (H4 : O.lt x y) => H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Lt) =>\n               (fun H3 : Gt = Lt =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.lt y x -> lt x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     OrderedType.GT\n       (let H1 : Gt = Gt -> lt y x :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Gt -> lt y x) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Gt) =>\n               (fun H3 : Eq = Gt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Gt H3 in\n                False_ind (O.eq x y -> lt y x) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Gt) =>\n               (fun H3 : Lt = Gt =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Gt H3 in\n                False_ind (O.lt x y -> lt y x) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Gt) =>\n               (fun (_ : Gt = Gt) (H4 : O.lt y x) => H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n end H)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun x y : t =>\n let H : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) (O.compare x y) :=\n   O.compare_spec x y in\n let c := O.compare x y in\n match\n   c as c0\n   return\n     (CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) c0 ->\n      OrderedType.Compare lt eq x y)\n with\n | Eq =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Eq =>\n     OrderedType.EQ\n       (let H1 : Eq = Eq -> eq x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Eq -> eq x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Eq) =>\n               (fun (_ : Eq = Eq) (H4 : O.eq x y) => H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Eq) =>\n               (fun H3 : Lt = Eq =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt x y -> eq x y) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Eq) =>\n               (fun H3 : Gt = Eq =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Eq H3 in\n                False_ind (O.lt y x -> eq x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Lt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Lt =>\n     OrderedType.LT\n       (let H1 : Lt = Lt -> lt x y :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Lt -> lt x y) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Lt) =>\n               (fun H3 : Eq = Lt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.eq x y -> lt x y) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Lt) =>\n               (fun (_ : Lt = Lt) (H4 : O.lt x y) => H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Lt) =>\n               (fun H3 : Gt = Lt =>\n                let H4 : False :=\n                  eq_ind Gt\n                    (fun e : comparison =>\n                     match e with\n                     | Gt => True\n                     | _ => False\n                     end) I Lt H3 in\n                False_ind (O.lt y x -> lt x y) H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n | Gt =>\n     fun H0 : CompareSpec (O.eq x y) (O.lt x y) (O.lt y x) Gt =>\n     OrderedType.GT\n       (let H1 : Gt = Gt -> lt y x :=\n          match H0 in (CompareSpec _ _ _ c0) return (c0 = Gt -> lt y x) with\n          | CompEq _ _ x0 =>\n              (fun (H1 : O.eq x y) (H2 : Eq = Gt) =>\n               (fun H3 : Eq = Gt =>\n                let H4 : False :=\n                  eq_ind Eq\n                    (fun e : comparison =>\n                     match e with\n                     | Eq => True\n                     | _ => False\n                     end) I Gt H3 in\n                False_ind (O.eq x y -> lt y x) H4) H2 H1) x0\n          | CompLt _ _ x0 =>\n              (fun (H1 : O.lt x y) (H2 : Lt = Gt) =>\n               (fun H3 : Lt = Gt =>\n                let H4 : False :=\n                  eq_ind Lt\n                    (fun e : comparison =>\n                     match e with\n                     | Lt => True\n                     | _ => False\n                     end) I Gt H3 in\n                False_ind (O.lt x y -> lt y x) H4) H2 H1) x0\n          | CompGt _ _ x0 =>\n              (fun (H1 : O.lt y x) (H2 : Gt = Gt) =>\n               (fun (_ : Gt = Gt) (H4 : O.lt y x) => H4) H2 H1) x0\n          end in\n        H1 Logic.eq_refl)\n end H)"], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "intros x y. Show Proof.", "assert (H :=  (O.compare_spec x y)). Show Proof.", "destruct (O.compare x y). Show Proof.", "constructor 2. Show Proof.", "now inversion H. Show Proof.", "constructor 1. Show Proof.", "now inversion H. Show Proof.", "constructor 3. Show Proof.", "now inversion H. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/Open/Stack.v", "name": "stack_lookup_add", "text": "Lemma stack_lookup_add (s : stack) (x : A) (v : val) :\n      ((stack_add x v s) : stack) x = v.\n  Proof.\n    unfold stack_add; consider (x ?[ eq ] x); intros H; [reflexivity|congruence].\n  Qed.\n", "definition": " stack) (x : A) (v : val) :\n      ((stack_add x v s) : stack) x = v.\n  ", "proof": "Proof.\n    unfold stack_add; consider (x ?[ eq ] x); intros H; [reflexivity|congruence].\n  Qed.", "proof_term": [], "def_ranges": [30, 0, 31, 40], "proof_ranges": [32, 0, 34, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold stack_add; consider (x ?[ eq ] x); intros H; [reflexivity|congruence].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "unfold stack_add; consider (x ?[ eq ] x); intros H; [reflexivity|congruence]. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/Open/Stack.v", "name": "stack_lookup_add2", "text": "Lemma stack_lookup_add2 (x y : A) (v : val) (s : stack) (Hneq: x <> y) :\n    (stack_add x v s) y = s y.\n  Proof.\n    unfold stack_add. consider (y ?[ eq ] x); intros; [congruence|reflexivity].\n  Qed.\n", "definition": " A) (v : val) (s : stack) (Hneq: x <> y) :\n    (stack_add x v s) y = s y.\n  ", "proof": "Proof.\n    unfold stack_add. consider (y ?[ eq ] x); intros; [congruence|reflexivity].\n  Qed.", "proof_term": [], "def_ranges": [36, 0, 37, 30], "proof_ranges": [38, 0, 40, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold stack_add.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (y ?[ eq ] x); intros; [congruence|reflexivity].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "unfold stack_add. Show Proof.", "consider (y ?[ eq ] x); intros; [congruence|reflexivity]. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/Open/Stack.v", "name": "stack_add_same", "text": "Lemma stack_add_same (s: stack) x:\n    stack_add x (s x) s = s.\n  Proof.\n    apply functional_extensionality.\n    intro x'. unfold stack_add.\n    consider (x' ?[ eq ] x); intros; subst; reflexivity.\n  Qed.\n", "definition": " stack) x:\n    stack_add x (s x) s = s.\n  ", "proof": "Proof.\n    apply functional_extensionality.\n    intro x'. unfold stack_add.\n    consider (x' ?[ eq ] x); intros; subst; reflexivity.\n  Qed.", "proof_term": [], "def_ranges": [42, 0, 43, 28], "proof_ranges": [44, 0, 48, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply functional_extensionality.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro x'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold stack_add.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (x' ?[ eq ] x); intros; subst; reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "apply functional_extensionality. Show Proof.", "intro x'. Show Proof.", "unfold stack_add. Show Proof.", "consider (x' ?[ eq ] x); intros; subst; reflexivity. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/Open/Stack.v", "name": "stack_add_overwrite", "text": "Lemma stack_add_overwrite (s: stack) x v v':\n    stack_add x v (stack_add x v' s) = stack_add x v s.\n  Proof.\n    apply functional_extensionality.\n    intro x'. unfold stack_add.\n    consider (x' ?[ eq ] x); intros; reflexivity.\n  Qed.\n", "definition": " stack) x v v':\n    stack_add x v (stack_add x v' s) = stack_add x v s.\n  ", "proof": "Proof.\n    apply functional_extensionality.\n    intro x'. unfold stack_add.\n    consider (x' ?[ eq ] x); intros; reflexivity.\n  Qed.", "proof_term": [], "def_ranges": [50, 0, 51, 55], "proof_ranges": [52, 0, 56, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply functional_extensionality.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intro x'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold stack_add.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (x' ?[ eq ] x); intros; reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "apply functional_extensionality. Show Proof.", "intro x'. Show Proof.", "unfold stack_add. Show Proof.", "consider (x' ?[ eq ] x); intros; reflexivity. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/Open/Stack.v", "name": "stack_add_val_eq", "text": "Lemma stack_add_val_eq (s : stack) (x : A) v1 v2 (Hs : stack_add x v1 s = stack_add x v2 s) :\n  \tv1 = v2.\n  Proof.\n    assert (stack_add x v1 s x = stack_add x v2 s x).\n    rewrite Hs. reflexivity.\n    do 2 rewrite stack_lookup_add in H. apply H.\n  Qed.\n", "definition": " stack) (x : A) v1 v2 (Hs : stack_add x v1 s = stack_add x v2 s) :\n  \tv1 = v2.\n  ", "proof": "Proof.\n    assert (stack_add x v1 s x = stack_add x v2 s x).\n    rewrite Hs. reflexivity.\n    do 2 rewrite stack_lookup_add in H. apply H.\n  Qed.", "proof_term": [], "def_ranges": [58, 0, 59, 11], "proof_ranges": [60, 0, 64, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (stack_add x v1 s x = stack_add x v2 s x).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite Hs.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "do 2 rewrite stack_lookup_add in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "assert (stack_add x v1 s x = stack_add x v2 s x). Show Proof.", "rewrite Hs. Show Proof.", "reflexivity. Show Proof.", "do 2 rewrite stack_lookup_add in H. Show Proof.", "apply H. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/UUSepAlg.v", "name": "sep_alg_unique_unit", "text": "Lemma sep_alg_unique_unit u1 u2 (Hu1 : sa_unit u1) (Hu2 : sa_unit u2)\n  : rel u1 u2.\n  Proof.\n    pose proof (uusa_unit u1 Hu2) as H.\n    apply sa_mulC in H. apply sa_unit_eq in H; eassumption.\n  Qed.\n", "definition": " sa_unit u1) (Hu2 : sa_unit u2)\n  : rel u1 u2.\n  ", "proof": "Proof.\n    pose proof (uusa_unit u1 Hu2) as H.\n    apply sa_mulC in H. apply sa_unit_eq in H; eassumption.\n  Qed.", "proof_term": [], "def_ranges": [19, 0, 20, 14], "proof_ranges": [21, 0, 24, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pose proof (uusa_unit u1 Hu2) as H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sa_mulC in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sa_unit_eq in H; eassumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "pose proof (uusa_unit u1 Hu2) as H. Show Proof.", "apply sa_mulC in H. Show Proof.", "apply sa_unit_eq in H; eassumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlg.v", "name": "sa_mul_monR", "text": "Lemma sa_mul_monR (a b c d : A) (Habc : sa_mul a b c) (Hcd: rel c d) : sa_mul a b d.\n  Proof.\n  \tpose proof (sa_unit_ex d) as [u [H1 H2]].\n  \tapply symmetry in Hcd.\n  \tapply (sa_mul_mon Hcd) in H2.\n  \tpose proof @sa_mulA as H3.\n  \tspecialize (H3 _ _ _ _ _ _ _ _ _ Habc H2).\n  \tdestruct H3 as [ac [H3 H4]].\n  \tapply (sa_unit_eq H1) in H3.\n  \tapply sa_mulC. eapply sa_mul_mon; [| eapply sa_mulC]; eassumption.\n  Qed.\n", "definition": " A) (Habc : sa_mul a b c) (Hcd: rel c d) : sa_mul a b d.\n  ", "proof": "Proof.\n  \tpose proof (sa_unit_ex d) as [u [H1 H2]].\n  \tapply symmetry in Hcd.\n  \tapply (sa_mul_mon Hcd) in H2.\n  \tpose proof @sa_mulA as H3.\n  \tspecialize (H3 _ _ _ _ _ _ _ _ _ Habc H2).\n  \tdestruct H3 as [ac [H3 H4]].\n  \tapply (sa_unit_eq H1) in H3.\n  \tapply sa_mulC. eapply sa_mul_mon; [| eapply sa_mulC]; eassumption.\n  Qed.", "proof_term": [], "def_ranges": [33, 0, 33, 86], "proof_ranges": [34, 0, 43, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pose proof (sa_unit_ex d) as [u [H1 H2]].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply symmetry in Hcd.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (sa_mul_mon Hcd) in H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pose proof @sa_mulA as H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "specialize (H3 _ _ _ _ _ _ _ _ _ Habc H2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H3 as [ac [H3 H4]].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (sa_unit_eq H1) in H3.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sa_mulC.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply sa_mul_mon; [| eapply sa_mulC]; eassumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "pose proof (sa_unit_ex d) as [u [H1 H2]]. Show Proof.", "apply symmetry in Hcd. Show Proof.", "apply (sa_mul_mon Hcd) in H2. Show Proof.", "pose proof @sa_mulA as H3. Show Proof.", "specialize (H3 _ _ _ _ _ _ _ _ _ Habc H2). Show Proof.", "destruct H3 as [ac [H3 H4]]. Show Proof.", "apply (sa_unit_eq H1) in H3. Show Proof.", "apply sa_mulC. Show Proof.", "eapply sa_mul_mon; [| eapply sa_mulC]; eassumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlg.v", "name": "sa_mulC2", "text": "Lemma sa_mulC2 a b c : sa_mul a b c <-> sa_mul b a c.\n  Proof.\n    split; apply sa_mulC.\n  Qed.\n", "definition": " sa_mul a b c <-> sa_mul b a c.\n  ", "proof": "Proof.\n    split; apply sa_mulC.\n  Qed.", "proof_term": [], "def_ranges": [45, 0, 45, 55], "proof_ranges": [46, 0, 48, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split; apply sa_mulC.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "split; apply sa_mulC. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlg.v", "name": "join_sub_units_eq", "text": "Lemma join_sub_units_eq A `{SepAlg A} (a b ea eb a': A):\n  sa_mul a a' b ->\n  sa_mul a ea a -> sa_unit ea ->\n  sa_mul b eb b -> sa_unit eb ->\n  rel ea eb.\nProof.\n  intros Hab Hmulea Hunitea Hmuleb Huniteb.\n  apply sa_mulC in Hmulea.\n  destruct (sa_mulA Hmulea Hab) as [b' [_ Hb']].\n  apply sa_mulC in Hb'.\n  destruct (sa_mulA Hb' Hmuleb) as [eab [Heab _]].\n  transitivity eab.\n  - symmetry. eauto using sa_unit_eq.\n  - apply sa_mulC in Heab. eauto using sa_unit_eq.\nQed.\n", "definition": " A):\n  sa_mul a a' b ->\n  sa_mul a ea a -> sa_unit ea ->\n  sa_mul b eb b -> sa_unit eb ->\n  rel ea eb.\n", "proof": "Proof.\n  intros Hab Hmulea Hunitea Hmuleb Huniteb.\n  apply sa_mulC in Hmulea.\n  destruct (sa_mulA Hmulea Hab) as [b' [_ Hb']].\n  apply sa_mulC in Hb'.\n  destruct (sa_mulA Hb' Hmuleb) as [eab [Heab _]].\n  transitivity eab.\n  - symmetry. eauto using sa_unit_eq.\n  - apply sa_mulC in Heab. eauto using sa_unit_eq.\nQed.", "proof_term": [], "def_ranges": [97, 0, 101, 12], "proof_ranges": [102, 0, 111, 4], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Hab Hmulea Hunitea Hmuleb Huniteb.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sa_mulC in Hmulea.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (sa_mulA Hmulea Hab) as [b' [_ Hb']].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sa_mulC in Hb'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (sa_mulA Hb' Hmuleb) as [eab [Heab _]].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "transitivity eab.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "symmetry.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eauto using sa_unit_eq.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sa_mulC in Heab.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eauto using sa_unit_eq.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "intros Hab Hmulea Hunitea Hmuleb Huniteb. Show Proof.", "apply sa_mulC in Hmulea. Show Proof.", "destruct (sa_mulA Hmulea Hab) as [b' [_ Hb']]. Show Proof.", "apply sa_mulC in Hb'. Show Proof.", "destruct (sa_mulA Hb' Hmuleb) as [eab [Heab _]]. Show Proof.", "transitivity eab. Show Proof.", "symmetry. Show Proof.", "eauto using sa_unit_eq. Show Proof.", "apply sa_mulC in Heab. Show Proof.", "eauto using sa_unit_eq. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlg.v", "name": "subheapT", "text": "Lemma subheapT (a b c : A) (Hab: a <= b) (Hbc: b <= c) : a <= c.\n  Proof.\n    unfold subheap in *.\n    destruct Hab as [f Hadb].\n    destruct Hbc as [g Hbfc].\n    destruct (sa_mulA Hadb Hbfc) as [ac [_ H]].\n    exists ac. apply H.\n  Qed.\n", "definition": " A) (Hab: a <= b) (Hbc: b <= c) : a <= c.\n  ", "proof": "Proof.\n    unfold subheap in *.\n    destruct Hab as [f Hadb].\n    destruct Hbc as [g Hbfc].\n    destruct (sa_mulA Hadb Hbfc) as [ac [_ H]].\n    exists ac. apply H.\n  Qed.", "proof_term": [], "def_ranges": [149, 0, 149, 66], "proof_ranges": [150, 0, 156, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold subheap in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Hab as [f Hadb].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Hbc as [g Hbfc].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (sa_mulA Hadb Hbfc) as [ac [_ H]].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists ac.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "unfold subheap in *. Show Proof.", "destruct Hab as [f Hadb]. Show Proof.", "destruct Hbc as [g Hbfc]. Show Proof.", "destruct (sa_mulA Hadb Hbfc) as [ac [_ H]]. Show Proof.", "exists ac. Show Proof.", "apply H. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlgPfun.v", "name": "update_shadow", "text": "Lemma update_shadow (f : pfun) (x : X) (y1 y2 : Y) :\n    pfun_eq (pfun_update (pfun_update f x y1) x y2) (pfun_update f x y2).\n  Proof.\n      unfold pfun_update; intro z.\n      consider (x ?[ eq ] z); intro; reflexivity.\n  Qed.\n", "definition": " pfun) (x : X) (y1 y2 : Y) :\n    pfun_eq (pfun_update (pfun_update f x y1) x y2) (pfun_update f x y2).\n  ", "proof": "Proof.\n      unfold pfun_update; intro z.\n      consider (x ?[ eq ] z); intro; reflexivity.\n  Qed.", "proof_term": [], "def_ranges": [35, 0, 36, 73], "proof_ranges": [37, 0, 40, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold pfun_update; intro z.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (x ?[ eq ] z); intro; reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "unfold pfun_update; intro z. Show Proof.", "consider (x ?[ eq ] z); intro; reflexivity. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlgPfun.v", "name": "update_lookup", "text": "Lemma update_lookup (f : pfun) (x : X) (y : Y) :\n    (pfun_update f x y) x = Some y.\n  Proof.\n    unfold pfun_update.\n    consider (x ?[ eq ] x); intros; [reflexivity|].\n    contradiction H. reflexivity.\n  Qed.\n", "definition": " pfun) (x : X) (y : Y) :\n    (pfun_update f x y) x = Some y.\n  ", "proof": "Proof.\n    unfold pfun_update.\n    consider (x ?[ eq ] x); intros; [reflexivity|].\n    contradiction H. reflexivity.\n  Qed.", "proof_term": [], "def_ranges": [42, 0, 43, 35], "proof_ranges": [44, 0, 48, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold pfun_update.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (x ?[ eq ] x); intros; [reflexivity|].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "contradiction H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "reflexivity.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "unfold pfun_update. Show Proof.", "consider (x ?[ eq ] x); intros; [reflexivity|]. Show Proof.", "contradiction H. Show Proof.", "reflexivity. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlgPfun.v", "name": "update_lookup_neq", "text": "Lemma update_lookup_neq (f : pfun) (x z : X) (y : Y) (H: x <> z) :\n    (pfun_update f x y) z = f z.\n  Proof.\n    unfold pfun_update.\n    consider (x ?[ eq ] z); intros; [|reflexivity].\n    contradiction H.\n  Qed.\n", "definition": " pfun) (x z : X) (y : Y) (H: x <> z) :\n    (pfun_update f x y) z = f z.\n  ", "proof": "Proof.\n    unfold pfun_update.\n    consider (x ?[ eq ] z); intros; [|reflexivity].\n    contradiction H.\n  Qed.", "proof_term": [], "def_ranges": [50, 0, 51, 32], "proof_ranges": [52, 0, 56, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold pfun_update.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (x ?[ eq ] z); intros; [|reflexivity].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "contradiction H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "unfold pfun_update. Show Proof.", "consider (x ?[ eq ] z); intros; [|reflexivity]. Show Proof.", "contradiction H. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlgPfun.v", "name": "update_commute", "text": "Lemma update_commute (f : X -> option Y) (x1 x2 : X) (y1 y2 : Y) (H : x1 <> x2) :\n    pfun_eq (pfun_update (pfun_update f x1 y1) x2 y2) (pfun_update (pfun_update f x2 y2) x1 y1).\n  Proof.\n    unfold pfun_update; intro z.\n    consider (x2 ?[ eq ] z); consider (x1 ?[ eq ] z); try reflexivity; intros; subst; firstorder.\n  Qed.\n", "definition": " X -> option Y) (x1 x2 : X) (y1 y2 : Y) (H : x1 <> x2) :\n    pfun_eq (pfun_update (pfun_update f x1 y1) x2 y2) (pfun_update (pfun_update f x2 y2) x1 y1).\n  ", "proof": "Proof.\n    unfold pfun_update; intro z.\n    consider (x2 ?[ eq ] z); consider (x1 ?[ eq ] z); try reflexivity; intros; subst; firstorder.\n  Qed.", "proof_term": [], "def_ranges": [58, 0, 59, 96], "proof_ranges": [60, 0, 63, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold pfun_update; intro z.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "consider (x2 ?[ eq ] z); consider (x1 ?[ eq ] z); try reflexivity; intros; subst; firstorder.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "unfold pfun_update; intro z. Show Proof.", "consider (x2 ?[ eq ] z); consider (x1 ?[ eq ] z); try reflexivity; intros; subst; firstorder. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlgPfun.v", "name": "pfun_in_sa_mulR", "text": "Lemma pfun_in_sa_mulR (a b c : X -> option Y) (x : X) (H : sa_mul a b c) (Hin : pfun_in c x) : pfun_in a x \\/ pfun_in b x.\n  Proof.\n    destruct Hin as [d Hin]; unfold sa_mul in H; simpl in H.\n    specialize (H x); rewrite Hin in H.\n    unfold pfun_in.\n    destruct H as [[H1 H2] | [H1 H2]]; subst.\n    + left; exists d; assumption.\n    + right; exists d; assumption.\n  Qed.\n", "definition": " X -> option Y) (x : X) (H : sa_mul a b c) (Hin : pfun_in c x) : pfun_in a x \\/ pfun_in b x.\n  ", "proof": "Proof.\n    destruct Hin as [d Hin]; unfold sa_mul in H; simpl in H.\n    specialize (H x); rewrite Hin in H.\n    unfold pfun_in.\n    destruct H as [[H1 H2] | [H1 H2]]; subst.\n    + left; exists d; assumption.\n    + right; exists d; assumption.\n  Qed.", "proof_term": [], "def_ranges": [128, 0, 128, 124], "proof_ranges": [129, 0, 136, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Hin as [d Hin]; unfold sa_mul in H; simpl in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "specialize (H x); rewrite Hin in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold pfun_in.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H as [[H1 H2] | [H1 H2]]; subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left; exists d; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "right; exists d; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "destruct Hin as [d Hin]; unfold sa_mul in H; simpl in H. Show Proof.", "specialize (H x); rewrite Hin in H. Show Proof.", "unfold pfun_in. Show Proof.", "destruct H as [[H1 H2] | [H1 H2]]; subst. Show Proof.", "left; exists d; assumption. Show Proof.", "right; exists d; assumption. Show Proof.", "Qed. Show Proof."]}, {"path": "/home/jizej/proverbot9001/coq-projects/ChargeCore/ChargeCore/src/ChargeCore/SepAlg/SepAlgPfun.v", "name": "pfun_mapsto_sa_mulR", "text": "Lemma pfun_mapsto_sa_mulR (a b c : X -> option Y) (x : X) (y : Y) (H : sa_mul a b c) (Hmap : c x = Some y) : a x = Some y \\/ b x = Some y.\n  Proof.\n    specialize (H x); simpl in H; rewrite Hmap in H.\n    unfold pfun_in.\n    destruct H as [[H1 H2] | [H1 H2]]; subst.\n    + left; assumption.\n    + right; assumption.\n  Qed.\n", "definition": " X -> option Y) (x : X) (y : Y) (H : sa_mul a b c) (Hmap : c x = Some y) : a x = Some y \\/ b x = Some y.\n  ", "proof": "Proof.\n    specialize (H x); simpl in H; rewrite Hmap in H.\n    unfold pfun_in.\n    destruct H as [[H1 H2] | [H1 H2]]; subst.\n    + left; assumption.\n    + right; assumption.\n  Qed.", "proof_term": [], "def_ranges": [138, 0, 138, 140], "proof_ranges": [139, 0, 145, 6], "only_proof_term": false, "proof_steps": [{"text": "Proof.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "specialize (H x); simpl in H; rewrite Hmap in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold pfun_in.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H as [[H1 H2] | [H1 H2]]; subst.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "left; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "right; assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "augmented_proof": ["Proof. Show Proof.", "specialize (H x); simpl in H; rewrite Hmap in H. Show Proof.", "unfold pfun_in. Show Proof.", "destruct H as [[H1 H2] | [H1 H2]]; subst. Show Proof.", "left; assumption. Show Proof.", "right; assumption. Show Proof.", "Qed. Show Proof."]}]