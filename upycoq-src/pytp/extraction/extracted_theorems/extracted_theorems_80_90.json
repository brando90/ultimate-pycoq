[{"path": "/home/jizej/proverbot9001/coq-projects/ramsey/Ramsey.v", "name": "Ramsey1", "text": "Theorem Ramsey1 :\n forall (A B : nat -> Prop) (YA YB : (nat -> nat) -> nat),\n full A YA -> full B YB -> full (inter A B) (combine YA YB).\nunfold full, inter, combine in |- *; intros A B YA YB FAYA FBYB f If.\napply\n (pre_Ramsey1 (fun x : nat => A (f x))\n    (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n    (fun x : nat => B (f x))\n    (fun g : nat -> nat => YB (fun x : nat => f (g x)))); \n unfold full in |- *; intros g Ig.\napply (FAYA (fun x : nat => f (g x))); auto with arith.\napply (FBYB (fun x : nat => f (g x))); auto with arith.\nQed.", "definition": "\n forall (A B : nat -> Prop) (YA YB : (nat -> nat) -> nat),\n full A YA -> full B YB -> full (inter A B) (combine YA YB).", "proof": "\nunfold full, inter, combine in |- *; intros A B YA YB FAYA FBYB f If.\napply\n (pre_Ramsey1 (fun x : nat => A (f x))\n    (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n    (fun x : nat => B (f x))\n    (fun g : nat -> nat => YB (fun x : nat => f (g x)))); \n unfold full in |- *; intros g Ig.\napply (FAYA (fun x : nat => f (g x))); auto with arith.\napply (FBYB (fun x : nat => f (g x))); auto with arith.\n", "def_ranges": [158, 0, 160, 60], "proof_ranges": [161, 0, 170, 4], "proof_steps": [{"text": "unfold full, inter, combine in |- *; intros A B YA YB FAYA FBYB f If.", "goal_before": ["forall (A B : nat -> Prop) (YA YB : (nat -> nat) -> nat),\nfull A YA -> full B YB -> full (inter A B) (combine YA YB)"], "goal_after": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "proof_term_before": [], "proof_term_after": ["((fun (A B : nat -> Prop) (YA YB : (nat -> nat) -> nat)\n    (FAYA : forall f : nat -> nat, increasing f -> A (f (YA f)))\n    (FBYB : forall f : nat -> nat, increasing f -> B (f (YB f)))\n    (f : nat -> nat) (If : increasing f) => ?Goal)\n :\n forall (A B : nat -> Prop) (YA YB : (nat -> nat) -> nat),\n full A YA -> full B YB -> full (inter A B) (combine YA YB))"]}, {"text": "apply", "goal_before": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "goal_after": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "proof_term_before": ["((fun (A B : nat -> Prop) (YA YB : (nat -> nat) -> nat)\n    (FAYA : forall f : nat -> nat, increasing f -> A (f (YA f)))\n    (FBYB : forall f : nat -> nat, increasing f -> B (f (YB f)))\n    (f : nat -> nat) (If : increasing f) => ?Goal)\n :\n forall (A B : nat -> Prop) (YA YB : (nat -> nat) -> nat),\n full A YA -> full B YB -> full (inter A B) (combine YA YB))"], "proof_term_after": []}, {"text": "(pre_Ramsey1 (fun x : nat => A (f x))", "goal_before": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "goal_after": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun g : nat -> nat => YA (fun x : nat => f (g x)))", "goal_before": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "goal_after": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun x : nat => B (f x))", "goal_before": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "goal_after": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun g : nat -> nat => YB (fun x : nat => f (g x))));", "goal_before": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "goal_after": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold full in |- *; intros g Ig.", "goal_before": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "goal_after": ["A\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x))))) /\\\nB\n  (f\n     (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))\n        (YB\n           (fun x : nat =>\n            f\n              (enumerate\n                 (fun g : nat -> nat => YA (fun x0 : nat => f (g x0))) x)))))"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Coq_Cats/Type_Cat/Equalizer.v", "name": "CoEq_rel_Ext", "text": "Theorem CoEq_rel_Ext : \u2200 (x : A) (y : B), CoEq_rel (f x) y = CoEq_rel (g x) y.\n  Proof.\n    intros x y.\n    assert (Hx : CoEq_rel (f x) (g x)).\n    {\n      constructor 1.\n      exists x; split; trivial.\n    }\n    apply PropExt; split; intros H.\n    {\n      apply CoEq_rel_sym in Hx.\n      apply (CoEq_rel_trans _ _ _ Hx H).\n    }\n    {\n      apply (CoEq_rel_trans _ _ _ Hx H).\n    }\n  Qed.\n", "definition": " \u2200 (x : A) (y : B), CoEq_rel (f x) y = CoEq_rel (g x) y.\n  ", "proof": "\n    intros x y.\n    assert (Hx : CoEq_rel (f x) (g x)).\n    {\n      constructor 1.\n      exists x; split; trivial.\n    }\n    apply PropExt; split; intros H.\n    {\n      apply CoEq_rel_sym in Hx.\n      apply (CoEq_rel_trans _ _ _ Hx H).\n    }\n    {\n      apply (CoEq_rel_trans _ _ _ Hx H).\n    }\n  ", "def_ranges": [101, 0, 101, 80], "proof_ranges": [102, 0, 117, 6], "proof_steps": [{"text": "intros x y.", "goal_before": ["\u2200 (x : A) (y : B), CoEq_rel (f x) y = CoEq_rel (g x) y"], "goal_after": ["CoEq_rel (f x) y = CoEq_rel (g x) y"], "proof_term_before": [], "proof_term_after": ["(fun (x : A) (y : B) => ?Goal)"]}, {"text": "assert (Hx : CoEq_rel (f x) (g x)).", "goal_before": ["CoEq_rel (f x) y = CoEq_rel (g x) y"], "goal_after": ["CoEq_rel (f x) (g x)", "CoEq_rel (f x) y = CoEq_rel (g x) y"], "proof_term_before": ["(fun (x : A) (y : B) => ?Goal)"], "proof_term_after": ["(fun (x : A) (y : B) => let Hx : CoEq_rel (f x) (g x) := ?Goal in ?Goal0)"]}, {"text": "constructor 1.", "goal_before": ["CoEq_rel (f x) (g x)", "CoEq_rel (f x) y = CoEq_rel (g x) y"], "goal_after": ["CoEq_rel_base (f x) (g x)", "CoEq_rel (f x) y = CoEq_rel (g x) y"], "proof_term_before": ["(fun (x : A) (y : B) => let Hx : CoEq_rel (f x) (g x) := ?Goal in ?Goal0)"], "proof_term_after": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) := rst_step B CoEq_rel_base (f x) (g x) ?Goal0\n   in\n ?Goal)"]}, {"text": "exists x; split; trivial.", "goal_before": ["CoEq_rel_base (f x) (g x)", "CoEq_rel (f x) y = CoEq_rel (g x) y"], "goal_after": ["CoEq_rel (f x) y = CoEq_rel (g x) y"], "proof_term_before": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) := rst_step B CoEq_rel_base (f x) (g x) ?Goal0\n   in\n ?Goal)"], "proof_term_after": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n ?Goal)"]}, {"text": "apply PropExt; split; intros H.", "goal_before": ["CoEq_rel (f x) y = CoEq_rel (g x) y"], "goal_after": ["CoEq_rel (g x) y", "CoEq_rel (f x) y"], "proof_term_before": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n ?Goal)"], "proof_term_after": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n PropExt (CoEq_rel (f x) y) (CoEq_rel (g x) y)\n   (conj (fun H : CoEq_rel (f x) y => ?Goal)\n      (fun H : CoEq_rel (g x) y => ?Goal0)))"]}, {"text": "apply CoEq_rel_sym in Hx.", "goal_before": ["CoEq_rel (g x) y", "CoEq_rel (f x) y"], "goal_after": ["CoEq_rel (g x) y", "CoEq_rel (f x) y"], "proof_term_before": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n PropExt (CoEq_rel (f x) y) (CoEq_rel (g x) y)\n   (conj (fun H : CoEq_rel (f x) y => ?Goal)\n      (fun H : CoEq_rel (g x) y => ?Goal0)))"], "proof_term_after": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n PropExt (CoEq_rel (f x) y) (CoEq_rel (g x) y)\n   (conj\n      (fun H : CoEq_rel (f x) y =>\n       let Hx0 : clos_refl_sym_trans B CoEq_rel_base (g x) (f x) :=\n         CoEq_rel_sym (f x) (g x) Hx in\n       ?Goal0@{Hx:=Hx0}) (fun H : CoEq_rel (g x) y => ?Goal)))"]}, {"text": "apply (CoEq_rel_trans _ _ _ Hx H).", "goal_before": ["CoEq_rel (g x) y", "CoEq_rel (f x) y"], "goal_after": ["CoEq_rel (f x) y"], "proof_term_before": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n PropExt (CoEq_rel (f x) y) (CoEq_rel (g x) y)\n   (conj\n      (fun H : CoEq_rel (f x) y =>\n       let Hx0 : clos_refl_sym_trans B CoEq_rel_base (g x) (f x) :=\n         CoEq_rel_sym (f x) (g x) Hx in\n       ?Goal0@{Hx:=Hx0}) (fun H : CoEq_rel (g x) y => ?Goal)))"], "proof_term_after": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n PropExt (CoEq_rel (f x) y) (CoEq_rel (g x) y)\n   (conj\n      (fun H : CoEq_rel (f x) y =>\n       let Hx0 : clos_refl_sym_trans B CoEq_rel_base (g x) (f x) :=\n         CoEq_rel_sym (f x) (g x) Hx in\n       CoEq_rel_trans (g x) (f x) y Hx0 H)\n      (fun H : CoEq_rel (g x) y => ?Goal)))"]}, {"text": "apply (CoEq_rel_trans _ _ _ Hx H).", "goal_before": ["CoEq_rel (f x) y"], "goal_after": [], "proof_term_before": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n PropExt (CoEq_rel (f x) y) (CoEq_rel (g x) y)\n   (conj\n      (fun H : CoEq_rel (f x) y =>\n       let Hx0 : clos_refl_sym_trans B CoEq_rel_base (g x) (f x) :=\n         CoEq_rel_sym (f x) (g x) Hx in\n       CoEq_rel_trans (g x) (f x) y Hx0 H)\n      (fun H : CoEq_rel (g x) y => ?Goal)))"], "proof_term_after": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n PropExt (CoEq_rel (f x) y) (CoEq_rel (g x) y)\n   (conj\n      (fun H : CoEq_rel (f x) y =>\n       let Hx0 : clos_refl_sym_trans B CoEq_rel_base (g x) (f x) :=\n         CoEq_rel_sym (f x) (g x) Hx in\n       CoEq_rel_trans (g x) (f x) y Hx0 H)\n      (fun H : CoEq_rel (g x) y => CoEq_rel_trans (f x) (g x) y Hx H)))"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (x : A) (y : B) =>\n let Hx : CoEq_rel (f x) (g x) :=\n   rst_step B CoEq_rel_base (f x) (g x)\n     (ex_intro (fun z : A => f z = f x \u2227 g z = g x) x (conj eq_refl eq_refl))\n   in\n PropExt (CoEq_rel (f x) y) (CoEq_rel (g x) y)\n   (conj\n      (fun H : CoEq_rel (f x) y =>\n       let Hx0 : clos_refl_sym_trans B CoEq_rel_base (g x) (f x) :=\n         CoEq_rel_sym (f x) (g x) Hx in\n       CoEq_rel_trans (g x) (f x) y Hx0 H)\n      (fun H : CoEq_rel (g x) y => CoEq_rel_trans (f x) (g x) y Hx H)))"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Coq_Cats/Type_Cat/SubObject_Classifier.v", "name": "Type_Cat_characteristic_function_unique", "text": "Theorem Type_Cat_characteristic_function_unique :\n    h = fun x => (exists y : A, (mono_morphism F) y = x).\n  Proof.\n    extensionality x.\n    apply PropExt; split.\n    {\n      intros Hx.\n      cut ((fun _ : unit => h x) = (fun _ => True)).\n      {\n        intros H.\n        set (W := equal_f (is_pullback_morph_ex_com_1\n                             hpb unit (fun _ => x) (fun _ => tt) H) tt).\n        cbn in W.\n        eexists; exact W.\n      }\n      {\n        extensionality y; apply PropExt; split; trivial.\n      }\n    }\n    {\n      intros [y []].\n      set (W := (equal_f (is_pullback_morph_com hpb))).\n      cbn in W.\n      rewrite W; trivial.\n    }\n  Qed.\n", "definition": "\n    h = fun x => (exists y : A, (mono_morphism F) y = x).\n  ", "proof": "\n    extensionality x.\n    apply PropExt; split.\n    {\n      intros Hx.\n      cut ((fun _ : unit => h x) = (fun _ => True)).\n      {\n        intros H.\n        set (W := equal_f (is_pullback_morph_ex_com_1\n                             hpb unit (fun _ => x) (fun _ => tt) H) tt).\n        cbn in W.\n        eexists; exact W.\n      }\n      {\n        extensionality y; apply PropExt; split; trivial.\n      }\n    }\n    {\n      intros [y []].\n      set (W := (equal_f (is_pullback_morph_com hpb))).\n      cbn in W.\n      rewrite W; trivial.\n    }\n  ", "def_ranges": [20, 0, 21, 57], "proof_ranges": [22, 0, 45, 6], "proof_steps": [{"text": "extensionality x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply PropExt; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros Hx.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut ((fun _ : unit => h x) = (fun _ => True)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "set (W := equal_f (is_pullback_morph_ex_com_1", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "hpb unit (fun _ => x) (fun _ => tt) H) tt).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eexists; exact W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "extensionality y; apply PropExt; split; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros [y []].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "set (W := (equal_f (is_pullback_morph_com hpb))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite W; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Coq_Cats/Type_Cat/Morphisms.v", "name": "Monic_From_Image_back_is_Monic", "text": "Theorem Monic_From_Image_back_is_Monic :\n    @is_Monic Type_Cat _ _ Monic_To_Image.\n  Proof.\n    intros T g h H.\n    extensionality x.\n    assert (H' :=\n              f_equal\n                (fun w : Monic_Image_of => (fun u : unit => projT1 w))\n                (equal_f H x)\n           ); clear H.\n    apply (equal_f (fm (unit : Type) (fun _ => (g x)) (fun _ => (h x)) H') tt).\n  Qed.\n", "definition": "\n    @is_Monic Type_Cat _ _ Monic_To_Image.\n  ", "proof": "\n    intros T g h H.\n    extensionality x.\n    assert (H' :=\n              f_equal\n                (fun w : Monic_Image_of => (fun u : unit => projT1 w))\n                (equal_f H x)\n           ); clear H.\n    apply (equal_f (fm (unit : Type) (fun _ => (g x)) (fun _ => (h x)) H') tt).\n  ", "def_ranges": [54, 0, 55, 42], "proof_ranges": [56, 0, 65, 6], "proof_steps": [{"text": "intros T g h H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "extensionality x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (H' :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "f_equal", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun w : Monic_Image_of => (fun u : unit => projT1 w))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(equal_f H x)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "); clear H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Coq_Cats/Type_Cat/Morphisms.v", "name": "Monic_To_Image_form_split_epic", "text": "Theorem Monic_To_Image_form_split_epic :\n    (\n      fun (x : Monic_Image_of) =>\n        Monic_To_Image (Monic_From_Image_back x)\n    ) = (fun x => x).\n  Proof.\n    extensionality x.\n    destruct x as [x [y Hxy]].\n    unfold Monic_To_Image.\n    cbn in *.\n    destruct Hxy; trivial.\n  Qed.\n", "definition": "\n    (\n      fun (x : Monic_Image_of) =>\n        Monic_To_Image (Monic_From_Image_back x)\n    ) = (fun x => x).\n  ", "proof": "\n    extensionality x.\n    destruct x as [x [y Hxy]].\n    unfold Monic_To_Image.\n    cbn in *.\n    destruct Hxy; trivial.\n  ", "def_ranges": [67, 0, 71, 21], "proof_ranges": [72, 0, 78, 6], "proof_steps": [{"text": "extensionality x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct x as [x [y Hxy]].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Monic_To_Image.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Hxy; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Coq_Cats/Type_Cat/Morphisms.v", "name": "Monic_Iso_Monic_Factorization", "text": "Theorem Monic_Iso_Monic_Factorization :\n    f = fun x =>  Monic_From_Image_forward (Monic_To_Image x).\n  Proof.\n    auto.\n  Qed.\n", "definition": "\n    f = fun x =>  Monic_From_Image_forward (Monic_To_Image x).\n  ", "proof": "\n    auto.\n  ", "def_ranges": [98, 0, 99, 62], "proof_ranges": [100, 0, 102, 6], "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Coq_Cats/Type_Cat/Morphisms.v", "name": "From_Image_back_form_split_epic", "text": "Theorem From_Image_back_form_split_epic :\n    \u2200 (x : Image_of), To_Image (From_Image_back x) = x.\n  Proof.\n    intros x.\n    apply sig_proof_irrelevance.\n    unfold From_Image_back; cbn.\n    destruct\n      (ConstructiveIndefiniteDescription_Type\n         A\n         (fun a : A => f a = proj1_sig x)\n         (proj2_sig x)\n      ) as [z Hz].\n    trivial.\n  Qed.\n", "definition": "\n    \u2200 (x : Image_of), To_Image (From_Image_back x) = x.\n  ", "proof": "\n    intros x.\n    apply sig_proof_irrelevance.\n    unfold From_Image_back; cbn.\n    destruct\n      (ConstructiveIndefiniteDescription_Type\n         A\n         (fun a : A => f a = proj1_sig x)\n         (proj2_sig x)\n      ) as [z Hz].\n    trivial.\n  ", "def_ranges": [150, 0, 151, 55], "proof_ranges": [152, 0, 163, 6], "proof_steps": [{"text": "intros x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply sig_proof_irrelevance.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold From_Image_back; cbn.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(ConstructiveIndefiniteDescription_Type", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "A", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun a : A => f a = proj1_sig x)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(proj2_sig x)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Coq_Cats/Type_Cat/Morphisms.v", "name": "split_Epic_Monic_Factorization", "text": "Theorem split_Epic_Monic_Factorization :\n    f = fun x =>  From_Image_forward (To_Image x).\n  Proof.\n    auto.\n  Qed.\n", "definition": "\n    f = fun x =>  From_Image_forward (To_Image x).\n  ", "proof": "\n    auto.\n  ", "def_ranges": [177, 0, 178, 50], "proof_ranges": [179, 0, 181, 6], "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Cat/Terminal.v", "name": "From_Term_Cat", "text": "Theorem From_Term_Cat : \u2200 h, (F @_a tt tt h)%morphism = id.\n  Proof.\n    destruct h.\n    change tt with (id 1 tt).\n    apply F_id.\n  Qed.\n", "definition": " \u2200 h, (F @_a tt tt h)%morphism = id.\n  ", "proof": "\n    destruct h.\n    change tt with (id 1 tt).\n    apply F_id.\n  ", "def_ranges": [43, 0, 43, 61], "proof_ranges": [44, 0, 48, 6], "proof_steps": [{"text": "destruct h.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change tt with (id 1 tt).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply F_id.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Cat/Exponential_Facts.v", "name": "Exp_Cat_morph_ex_compose", "text": "Theorem Exp_Cat_morph_ex_compose :\n    Exp_Cat_morph_ex (F \u2218 (Prod_Functor G (Functor_id C)))\n    = (Exp_Cat_morph_ex F) \u2218 G.\n  Proof.\n    Func_eq_simpl.\n    {\n      FunExt.\n      apply NatTrans_eq_simplify.\n      apply JMeq_eq.\n      ElimEq; trivial.\n    }\n    {\n      FunExt; cbn.\n      Func_eq_simpl.\n      FunExt.\n      cbn; auto.\n    }\n  Qed.\n", "definition": "\n    Exp_Cat_morph_ex (F \u2218 (Prod_Functor G (Functor_id C)))\n    = (Exp_Cat_morph_ex F) \u2218 G.\n  ", "proof": "\n    Func_eq_simpl.\n    {\n      FunExt.\n      apply NatTrans_eq_simplify.\n      apply JMeq_eq.\n      ElimEq; trivial.\n    }\n    {\n      FunExt; cbn.\n      Func_eq_simpl.\n      FunExt.\n      cbn; auto.\n    }\n  ", "def_ranges": [26, 0, 28, 31], "proof_ranges": [29, 0, 43, 6], "proof_steps": [{"text": "Func_eq_simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "FunExt.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply NatTrans_eq_simplify.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply JMeq_eq.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "ElimEq; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "FunExt; cbn.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Func_eq_simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "FunExt.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Cat/Cat_Iso.v", "name": "Cat_Iso_conv_inv_Cat_Iso_conv", "text": "Theorem Cat_Iso_conv_inv_Cat_Iso_conv {c c' : C} (h : c \u2013\u227b c')\n    : Cat_Iso_conv_inv (Cat_Iso_conv h) = h.\n  Proof.\n    unfold Cat_Iso_conv_inv, Cat_Iso_conv.\n    destruct Cat_Iso_Hom_conv; trivial.\n  Qed.\n", "definition": " C} (h : c \u2013\u227b c')\n    : Cat_Iso_conv_inv (Cat_Iso_conv h) = h.\n  ", "proof": "\n    unfold Cat_Iso_conv_inv, Cat_Iso_conv.\n    destruct Cat_Iso_Hom_conv; trivial.\n  ", "def_ranges": [113, 0, 114, 44], "proof_ranges": [115, 0, 118, 6], "proof_steps": [{"text": "unfold Cat_Iso_conv_inv, Cat_Iso_conv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Cat_Iso_Hom_conv; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Cat/Cat_Iso.v", "name": "Cat_Iso_conv_Cat_Iso_conv_inv", "text": "Theorem Cat_Iso_conv_Cat_Iso_conv_inv {c c' : C}\n          (h :\n             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))\n               \u2013\u227b (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))\n    :\n      Cat_Iso_conv (Cat_Iso_conv_inv h) = h.\n  Proof.\n    unfold Cat_Iso_conv_inv, Cat_Iso_conv.\n    destruct Cat_Iso_Hom_conv; trivial.\n  Qed. \n", "definition": " C}\n          (h :\n             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))\n               \u2013\u227b (((inverse_morphism I) _o) (((iso_morphism I) _o) c')))\n    :\n      Cat_Iso_conv (Cat_Iso_conv_inv h) = h.\n  ", "proof": "\n    unfold Cat_Iso_conv_inv, Cat_Iso_conv.\n    destruct Cat_Iso_Hom_conv; trivial.\n  ", "def_ranges": [123, 0, 128, 44], "proof_ranges": [129, 0, 132, 6], "proof_steps": [{"text": "unfold Cat_Iso_conv_inv, Cat_Iso_conv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Cat_Iso_Hom_conv; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Cat/Cat_Iso.v", "name": "Cat_Iso_conv_inv_I_inv_I", "text": "Theorem Cat_Iso_conv_inv_I_inv_I {c c' : C} (h : c \u2013\u227b c') :\n    Cat_Iso_conv_inv (((inverse_morphism I) _a) (((iso_morphism I) _a) h)) = h.\n  Proof.\n    match goal with\n      [|- ?A = ?B] =>\n      let H := fresh \"H\" in\n      cut (A ~= B); [intros H; rewrite H; trivial|]\n    end.\n    unfold Cat_Iso_conv_inv.\n    destruct Cat_Iso_Hom_conv.\n    change (I \u207b\u00b9 _a ((iso_morphism I) _a h)) with ((I \u207b\u00b9 \u2218 I)%morphism _a h).\n    apply (@JMeq_trans _ _ _ _ ((Functor_id _) _a h) _); trivial.\n    cbn_rewrite <- (left_inverse I).\n    trivial.\n  Qed.\n", "definition": " C} (h : c \u2013\u227b c') :\n    Cat_Iso_conv_inv (((inverse_morphism I) _a) (((iso_morphism I) _a) h)) = h.\n  ", "proof": "\n    match goal with\n      [|- ?A = ?B] =>\n      let H := fresh \"H\" in\n      cut (A ~= B); [intros H; rewrite H; trivial|]\n    end.\n    unfold Cat_Iso_conv_inv.\n    destruct Cat_Iso_Hom_conv.\n    change (I \u207b\u00b9 _a ((iso_morphism I) _a h)) with ((I \u207b\u00b9 \u2218 I)%morphism _a h).\n    apply (@JMeq_trans _ _ _ _ ((Functor_id _) _a h) _); trivial.\n    cbn_rewrite <- (left_inverse I).\n    trivial.\n  ", "def_ranges": [136, 0, 137, 79], "proof_ranges": [138, 0, 150, 6], "proof_steps": [{"text": "match goal with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[|- ?A = ?B] =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "let H := fresh \"H\" in", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (A ~= B); [intros H; rewrite H; trivial|]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "end.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Cat_Iso_conv_inv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct Cat_Iso_Hom_conv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "change (I \u207b\u00b9 _a ((iso_morphism I) _a h)) with ((I \u207b\u00b9 \u2218 I)%morphism _a h).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (@JMeq_trans _ _ _ _ ((Functor_id _) _a h) _); trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn_rewrite <- (left_inverse I).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Cat/Cat_Iso.v", "name": "Cat_Iso_conv_inv_compose", "text": "Theorem Cat_Iso_conv_inv_compose {c c' c'' : C}\n          (h :\n             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))\n               \u2013\u227b (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))\n          )\n          (h' :\n             (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))\n               \u2013\u227b (((inverse_morphism I) _o) (((iso_morphism I) _o) c''))\n          )\n    :\n      Cat_Iso_conv_inv (compose C h h')\n      = compose C (Cat_Iso_conv_inv h) (Cat_Iso_conv_inv h').\n  Proof.\n    unfold Cat_Iso_conv_inv, Cat_Iso_Hom_conv.\n    do 3 destruct Cat_Iso_Obj_conv; trivial.\n  Qed.\n", "definition": " C}\n          (h :\n             (((inverse_morphism I) _o) (((iso_morphism I) _o) c))\n               \u2013\u227b (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))\n          )\n          (h' :\n             (((inverse_morphism I) _o) (((iso_morphism I) _o) c'))\n               \u2013\u227b (((inverse_morphism I) _o) (((iso_morphism I) _o) c''))\n          )\n    :\n      Cat_Iso_conv_inv (compose C h h')\n      = compose C (Cat_Iso_conv_inv h) (Cat_Iso_conv_inv h').\n  ", "proof": "\n    unfold Cat_Iso_conv_inv, Cat_Iso_Hom_conv.\n    do 3 destruct Cat_Iso_Obj_conv; trivial.\n  ", "def_ranges": [153, 0, 164, 61], "proof_ranges": [165, 0, 168, 6], "proof_steps": [{"text": "unfold Cat_Iso_conv_inv, Cat_Iso_Hom_conv.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "do 3 destruct Cat_Iso_Obj_conv; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Cat/Cat_Iso.v", "name": "Cat_Iso_inv", "text": "Theorem Cat_Iso_inv\n          {c c' : C} (h : ((iso_morphism I) _o c) \u2013\u227b ((iso_morphism I) _o c'))\n    : {g : c \u2013\u227b c' | h = ((iso_morphism I) _a g)}.\n  Proof.\n    exists (Cat_Iso_conv_inv I ((inverse_morphism I) _a h)).\n    match goal with\n      [|- ?A = ?B] =>\n        etransitivity;\n        [apply (eq_sym (@Cat_Iso_conv_inv_I_inv_I D C (I\u207b\u00b9) _ _ A))|\n         etransitivity; [|apply (@Cat_Iso_conv_inv_I_inv_I D C (I\u207b\u00b9) _ _ B)]]\n    end.\n    do 2 apply f_equal.\n    match goal with\n      [|- ?A = ?B] =>\n        etransitivity;\n        [apply (eq_sym (@Cat_Iso_conv_Cat_Iso_conv_inv C D I _ _ A))|\n         etransitivity; [|apply (@Cat_Iso_conv_Cat_Iso_conv_inv C D I _ _ B)]]\n    end.\n    apply f_equal.\n    rewrite Cat_Iso_conv_inv_I_inv_I; trivial.\n  Qed.\n", "definition": " C} (h : ((iso_morphism I) _o c) \u2013\u227b ((iso_morphism I) _o c'))\n    : {g : c \u2013\u227b c' | h = ((iso_morphism I) _a g)}.\n  ", "proof": "\n    exists (Cat_Iso_conv_inv I ((inverse_morphism I) _a h)).\n    match goal with\n      [|- ?A = ?B] =>\n        etransitivity;\n        [apply (eq_sym (@Cat_Iso_conv_inv_I_inv_I D C (I\u207b\u00b9) _ _ A))|\n         etransitivity; [|apply (@Cat_Iso_conv_inv_I_inv_I D C (I\u207b\u00b9) _ _ B)]]\n    end.\n    do 2 apply f_equal.\n    match goal with\n      [|- ?A = ?B] =>\n        etransitivity;\n        [apply (eq_sym (@Cat_Iso_conv_Cat_Iso_conv_inv C D I _ _ A))|\n         etransitivity; [|apply (@Cat_Iso_conv_Cat_Iso_conv_inv C D I _ _ B)]]\n    end.\n    apply f_equal.\n    rewrite Cat_Iso_conv_inv_I_inv_I; trivial.\n  ", "def_ranges": [179, 0, 181, 50], "proof_ranges": [182, 0, 199, 6], "proof_steps": [{"text": "exists (Cat_Iso_conv_inv I ((inverse_morphism I) _a h)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "match goal with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[|- ?A = ?B] =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "etransitivity;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[apply (eq_sym (@Cat_Iso_conv_inv_I_inv_I D C (I\u207b\u00b9) _ _ A))|", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "etransitivity; [|apply (@Cat_Iso_conv_inv_I_inv_I D C (I\u207b\u00b9) _ _ B)]]", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "end.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "do 2 apply f_equal.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "match goal with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[|- ?A = ?B] =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "etransitivity;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "[apply (eq_sym (@Cat_Iso_conv_Cat_Iso_conv_inv C D I _ _ A))|", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/PreSheaf/Morphisms.v", "name": "PMCM_N_co_equalizes", "text": "Theorem PMCM_N_co_equalizes :\n      ((mono_morphism N) \u2218 (PMCM_PreSheaf_morph_of_function g))%nattrans\n      = ((mono_morphism N) \u2218 (PMCM_PreSheaf_morph_of_function h))%nattrans.\n    Proof.\n      apply NatTrans_eq_simplify.\n      extensionality x.\n      extensionality y.\n      destruct y as [y1 y2].\n      cbn in *.\n      set (W := equal_f (Trans_com (mono_morphism N) y1)).\n      cbn in W.\n      do 2 rewrite W.\n      rewrite (equal_f H).\n      trivial.\n    Qed.    \n", "definition": "\n      ((mono_morphism N) \u2218 (PMCM_PreSheaf_morph_of_function g))%nattrans\n      = ((mono_morphism N) \u2218 (PMCM_PreSheaf_morph_of_function h))%nattrans.\n    ", "proof": "\n      apply NatTrans_eq_simplify.\n      extensionality x.\n      extensionality y.\n      destruct y as [y1 y2].\n      cbn in *.\n      set (W := equal_f (Trans_com (mono_morphism N) y1)).\n      cbn in W.\n      do 2 rewrite W.\n      rewrite (equal_f H).\n      trivial.\n    ", "def_ranges": [77, 0, 79, 75], "proof_ranges": [80, 0, 91, 8], "proof_steps": [{"text": "apply NatTrans_eq_simplify.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "extensionality x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "extensionality y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct y as [y1 y2].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "set (W := equal_f (Trans_com (mono_morphism N) y1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "do 2 rewrite W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (equal_f H).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/PreSheaf/Morphisms.v", "name": "PreSheaf_Monic_components_is_Monic", "text": "Theorem PreSheaf_Monic_components_is_Monic : g = h.\n    Proof.\n      extensionality m.\n      assert (W :=\n                f_equal\n                  (fun w : (PMCM_PreSheaf_representing_d c d \u2013\u227b F)%nattrans =>\n                     Trans w c (id, m))\n                  (mono_morphism_monomorphic N _ _ _ PMCM_N_co_equalizes)\n             ).\n      cbn in W.\n      rewrite (F_id F) in W.\n      trivial.\n    Qed.\n", "definition": " g = h.\n    ", "proof": "\n      extensionality m.\n      assert (W :=\n                f_equal\n                  (fun w : (PMCM_PreSheaf_representing_d c d \u2013\u227b F)%nattrans =>\n                     Trans w c (id, m))\n                  (mono_morphism_monomorphic N _ _ _ PMCM_N_co_equalizes)\n             ).\n      cbn in W.\n      rewrite (F_id F) in W.\n      trivial.\n    ", "def_ranges": [93, 0, 93, 55], "proof_ranges": [94, 0, 105, 8], "proof_steps": [{"text": "extensionality m.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (W :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "f_equal", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun w : (PMCM_PreSheaf_representing_d c d \u2013\u227b F)%nattrans =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Trans w c (id, m))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(mono_morphism_monomorphic N _ _ _ PMCM_N_co_equalizes)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ").", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/PreSheaf/Morphisms.v", "name": "PECE_N_co_equalizes", "text": "Theorem PECE_N_co_equalizes :\n      ((PECE_PreSheaf_morph_of_function g) \u2218 (mono_morphism N))%nattrans =\n      ((PECE_PreSheaf_morph_of_function h) \u2218 (mono_morphism N))%nattrans.\n    Proof.\n      apply NatTrans_eq_simplify.\n      extensionality x.\n      extensionality y.\n      extensionality z.\n      cbn in *.\n      set (W := equal_f (Trans_com (mono_morphism N) z)).\n      cbn in W.\n      rewrite <- W.\n      rewrite (equal_f H).\n      trivial.\n    Qed.    \n", "definition": "\n      ((PECE_PreSheaf_morph_of_function g) \u2218 (mono_morphism N))%nattrans =\n      ((PECE_PreSheaf_morph_of_function h) \u2218 (mono_morphism N))%nattrans.\n    ", "proof": "\n      apply NatTrans_eq_simplify.\n      extensionality x.\n      extensionality y.\n      extensionality z.\n      cbn in *.\n      set (W := equal_f (Trans_com (mono_morphism N) z)).\n      cbn in W.\n      rewrite <- W.\n      rewrite (equal_f H).\n      trivial.\n    ", "def_ranges": [171, 0, 173, 73], "proof_ranges": [174, 0, 185, 8], "proof_steps": [{"text": "apply NatTrans_eq_simplify.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "extensionality x.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "extensionality y.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "extensionality z.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "set (W := equal_f (Trans_com (mono_morphism N) z)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (equal_f H).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/PreSheaf/Morphisms.v", "name": "PreSheaf_Epic_components_is_Epic", "text": "Theorem PreSheaf_Epic_components_is_Epic : g = h.\n    Proof.\n      extensionality m.\n      assert (W :=\n                f_equal\n                  (fun w : (G \u2013\u227b PECE_PreSheaf_representing_d)%nattrans =>\n                     Trans w c m id)\n                  (mono_morphism_monomorphic N _ _ _ PECE_N_co_equalizes)\n             ).\n      cbn in W.\n      rewrite (F_id G) in W.\n      trivial.\n    Qed.\n", "definition": " g = h.\n    ", "proof": "\n      extensionality m.\n      assert (W :=\n                f_equal\n                  (fun w : (G \u2013\u227b PECE_PreSheaf_representing_d)%nattrans =>\n                     Trans w c m id)\n                  (mono_morphism_monomorphic N _ _ _ PECE_N_co_equalizes)\n             ).\n      cbn in W.\n      rewrite (F_id G) in W.\n      trivial.\n    ", "def_ranges": [187, 0, 187, 53], "proof_ranges": [188, 0, 199, 8], "proof_steps": [{"text": "extensionality m.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (W :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "f_equal", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun w : (G \u2013\u227b PECE_PreSheaf_representing_d)%nattrans =>", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Trans w c m id)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(mono_morphism_monomorphic N _ _ _ PECE_N_co_equalizes)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ").", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in W.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/PreSheaf/Morphisms.v", "name": "split_Epic_Monic_Factorization", "text": "Theorem split_Epic_Monic_Factorization :\n    (mono_morphism N) =\n    (\n      (mono_morphism Monic_PreSheaf_Iso_Monic_Factor_Monic)\n        \u2218\n        (iso_morphism Monic_PreSheaf_Iso_Monic_Factor_Monic_Iso)\n    )%nattrans.\n  Proof.\n    apply NatTrans_eq_simplify; trivial.\n  Qed.\n", "definition": "\n    (mono_morphism N) =\n    (\n      (mono_morphism Monic_PreSheaf_Iso_Monic_Factor_Monic)\n        \u2218\n        (iso_morphism Monic_PreSheaf_Iso_Monic_Factor_Monic_Iso)\n    )%nattrans.\n  ", "proof": "\n    apply NatTrans_eq_simplify; trivial.\n  ", "def_ranges": [401, 0, 407, 15], "proof_ranges": [408, 0, 410, 6], "proof_steps": [{"text": "apply NatTrans_eq_simplify; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Yoneda/Yoneda.v", "name": "Yoneda_Iso", "text": "Theorem Yoneda_Iso (C : Category) : forall (c c' : Obj),\n    ((Yoneda C) _o c \u2243 (Yoneda C) _o c')%isomorphism \u2192 (c \u2243 c')%isomorphism.\nProof.\n  intros.\n  apply (Emb_Conservative _ _ (Yoneda_Emb C) _); trivial.\nQed.\n", "definition": " Category) : forall (c c' : Obj),\n    ((Yoneda C) _o c \u2243 (Yoneda C) _o c')%isomorphism \u2192 (c \u2243 c')%isomorphism.\n", "proof": "\n  intros.\n  apply (Emb_Conservative _ _ (Yoneda_Emb C) _); trivial.\n", "def_ranges": [214, 0, 215, 76], "proof_ranges": [216, 0, 219, 4], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (Emb_Conservative _ _ (Yoneda_Emb C) _); trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Yoneda/Yoneda.v", "name": "CoYoneda_Iso", "text": "Theorem CoYoneda_Iso (C : Category) : forall (c c' : Obj),\n    ((CoYoneda C) _o c \u2243 (CoYoneda C) _o c')%isomorphism \u2192 (c \u2243 c')%isomorphism.\nProof.\n  intros; Yoneda; trivial.\nQed.\n", "definition": " Category) : forall (c c' : Obj),\n    ((CoYoneda C) _o c \u2243 (CoYoneda C) _o c')%isomorphism \u2192 (c \u2243 c')%isomorphism.\n", "proof": "\n  intros; Yoneda; trivial.\n", "def_ranges": [224, 0, 225, 80], "proof_ranges": [226, 0, 228, 4], "proof_steps": [{"text": "intros; Yoneda; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/NatTrans/NatTrans.v", "name": "NatTrans_compose_assoc", "text": "Theorem NatTrans_compose_assoc {F G H I : (C \u2013\u227b C')%functor} (N : F \u2013\u227b G)\n          (N' : G \u2013\u227b H) (N'' : H \u2013\u227b I)\n    : ((N'' \u2218 N') \u2218 N = N'' \u2218 (N' \u2218 N))%nattrans\n  .\n  Proof.\n    apply NatTrans_eq_simplify; cbn; auto.\n  Qed.\n", "definition": " (C \u2013\u227b C')%functor} (N : F \u2013\u227b G)\n          (N' : G \u2013\u227b H) (N'' : H \u2013\u227b I)\n    : ((N'' \u2218 N') \u2218 N = N'' \u2218 (N' \u2218 N))%nattrans\n  .\n  ", "proof": "\n    apply NatTrans_eq_simplify; cbn; auto.\n  ", "def_ranges": [127, 0, 130, 3], "proof_ranges": [131, 0, 133, 6], "proof_steps": [{"text": "apply NatTrans_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/NatTrans/NatTrans.v", "name": "NatTrans_id_unit_left", "text": "Theorem NatTrans_id_unit_left {F G : (C \u2013\u227b C')%functor} (N : F \u2013\u227b G)\n    : (NatTrans_id G) \u2218 N = N.\n  Proof.\n    apply NatTrans_eq_simplify; cbn; auto.\n  Qed.\n", "definition": " (C \u2013\u227b C')%functor} (N : F \u2013\u227b G)\n    : (NatTrans_id G) \u2218 N = N.\n  ", "proof": "\n    apply NatTrans_eq_simplify; cbn; auto.\n  ", "def_ranges": [142, 0, 143, 30], "proof_ranges": [144, 0, 146, 6], "proof_steps": [{"text": "apply NatTrans_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/NatTrans/NatTrans.v", "name": "NatTrans_id_unit_right", "text": "Theorem NatTrans_id_unit_right {F G : (C \u2013\u227b C')%functor} (N : F \u2013\u227b G)\n    : N \u2218 (NatTrans_id F) = N.\n  Proof.\n    apply NatTrans_eq_simplify; cbn; auto.\n  Qed.\n", "definition": " (C \u2013\u227b C')%functor} (N : F \u2013\u227b G)\n    : N \u2218 (NatTrans_id F) = N.\n  ", "proof": "\n    apply NatTrans_eq_simplify; cbn; auto.\n  ", "def_ranges": [148, 0, 149, 30], "proof_ranges": [150, 0, 152, 6], "proof_steps": [{"text": "apply NatTrans_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Category/Composable_Chain.v", "name": "Compose_of_Chain_Compose", "text": "Theorem Compose_of_Chain_Compose (C : Category) (a b c : C)\n        (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c)\n  : ((Compose_of ch2) \u2218 (Compose_of ch1))%morphism =\n    Compose_of (Chain_Compose ch1 ch2).\nProof.\n  induction ch1; auto.\n  simpl.\n  rewrite <- assoc.\n  rewrite IHch1; trivial.\nQed.\n", "definition": " Category) (a b c : C)\n        (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c)\n  : ((Compose_of ch2) \u2218 (Compose_of ch1))%morphism =\n    Compose_of (Chain_Compose ch1 ch2).\n", "proof": "\n  induction ch1; auto.\n  simpl.\n  rewrite <- assoc.\n  rewrite IHch1; trivial.\n", "def_ranges": [57, 0, 60, 39], "proof_ranges": [61, 0, 66, 4], "proof_steps": [{"text": "induction ch1; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite IHch1; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Category/Composable_Chain.v", "name": "Forall_Links_Chain_Compose", "text": "Theorem Forall_Links_Chain_Compose (C : Category) (a b c : C)\n        (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c)\n        (P : \u2200 (x y : Obj), (x \u2013\u227b y) \u2192 Prop) :\n  Forall_Links ch1 P \u2192 Forall_Links ch2 P \u2192 Forall_Links (Chain_Compose ch1 ch2) P.\nProof.\n  intros H1 H2.\n  induction ch1.\n  simpl in *; auto.\n  destruct H1 as [H11 H12].\n  simpl in *; split; auto.\nQed.\n", "definition": " Category) (a b c : C)\n        (ch1 : Composable_Chain C a b) (ch2 : Composable_Chain C b c)\n        (P : \u2200 (x y : Obj), (x \u2013\u227b y) \u2192 Prop) :\n  Forall_Links ch1 P \u2192 Forall_Links ch2 P \u2192 Forall_Links (Chain_Compose ch1 ch2) P.\n", "proof": "\n  intros H1 H2.\n  induction ch1.\n  simpl in *; auto.\n  destruct H1 as [H11 H12].\n  simpl in *; split; auto.\n", "def_ranges": [72, 0, 75, 83], "proof_ranges": [76, 0, 82, 4], "proof_steps": [{"text": "intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "induction ch1.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H1 as [H11 H12].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl in *; split; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Category/Morph.v", "name": "Isomorphism_eq_simplify", "text": "Theorem Isomorphism_eq_simplify {C : Category} {a b : C} (I I' : a \u2243 b) :\n  (iso_morphism I = iso_morphism I') \u2192\n  (inverse_morphism I = inverse_morphism I') \u2192 I = I'.\nProof.\n  intros H1 H2.\n  destruct I as [iI inI Il Ir]; destruct I' as [iI' inI' Il' Ir'].\n  cbn in *.\n  destruct H1; destruct H2.\n  destruct (proof_irrelevance _ Il Il').\n  destruct (proof_irrelevance _ Ir Ir').\n  trivial.  \nQed.  \n", "definition": " Category} {a b : C} (I I' : a \u2243 b) :\n  (iso_morphism I = iso_morphism I') \u2192\n  (inverse_morphism I = inverse_morphism I') \u2192 I = I'.\n", "proof": "\n  intros H1 H2.\n  destruct I as [iI inI Il Ir]; destruct I' as [iI' inI' Il' Ir'].\n  cbn in *.\n  destruct H1; destruct H2.\n  destruct (proof_irrelevance _ Il Il').\n  destruct (proof_irrelevance _ Ir Ir').\n  trivial.  \n", "def_ranges": [88, 0, 90, 54], "proof_ranges": [91, 0, 99, 4], "proof_steps": [{"text": "intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct I as [iI inI Il Ir]; destruct I' as [iI' inI' Il' Ir'].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct H1; destruct H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (proof_irrelevance _ Il Il').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (proof_irrelevance _ Ir Ir').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Category/Morph.v", "name": "CoIso", "text": "Theorem CoIso {C : Category} (a b : C) : a \u2243\u2243 b ::> C \u2192 a \u2243\u2243 b ::> C^op. \n\nProof.\n  intros I.\n  eapply (Build_Isomorphism (C^op)%category _ _ (I\u207b\u00b9) I);\n    unfold compose; simpl; auto.\nQed.\n", "definition": " Category} (a b : C) : a \u2243\u2243 b ::> C \u2192 a \u2243\u2243 b ::> C^op. \n\n", "proof": "\n  intros I.\n  eapply (Build_Isomorphism (C^op)%category _ _ (I\u207b\u00b9) I);\n    unfold compose; simpl; auto.\n", "def_ranges": [355, 0, 355, 72], "proof_ranges": [355, 73, 360, 4], "proof_steps": [{"text": "intros I.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply (Build_Isomorphism (C^op)%category _ _ (I\u207b\u00b9) I);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold compose; simpl; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Functor/Functor_Ops.v", "name": "Functor_assoc", "text": "Theorem Functor_assoc : (H \u2218 G) \u2218 F = H \u2218 (G \u2218 F).\n  Proof.\n    Func_eq_simpl; trivial.\n  Qed.\n", "definition": " (H \u2218 G) \u2218 F = H \u2218 (G \u2218 F).\n  ", "proof": "\n    Func_eq_simpl; trivial.\n  ", "def_ranges": [55, 0, 55, 52], "proof_ranges": [56, 0, 58, 6], "proof_steps": [{"text": "Func_eq_simpl; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Functor/Functor_Ops.v", "name": "Functor_id_unit_left", "text": "Theorem Functor_id_unit_left : ((Functor_id C') \u2218 F)%functor = F.\n  Proof.\n    Func_eq_simpl; trivial.\n  Qed.\n", "definition": " ((Functor_id C') \u2218 F)%functor = F.\n  ", "proof": "\n    Func_eq_simpl; trivial.\n  ", "def_ranges": [74, 0, 74, 67], "proof_ranges": [75, 0, 77, 6], "proof_steps": [{"text": "Func_eq_simpl; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Functor/Functor_Ops.v", "name": "Functor_id_unit_right", "text": "Theorem Functor_id_unit_right : (Functor_compose (Functor_id _) F) = F.\n  Proof.\n    Func_eq_simpl; trivial.\n  Qed.\n", "definition": " (Functor_compose (Functor_id _) F) = F.\n  ", "proof": "\n    Func_eq_simpl; trivial.\n  ", "def_ranges": [80, 0, 80, 73], "proof_ranges": [81, 0, 83, 6], "proof_steps": [{"text": "Func_eq_simpl; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Functor/Functor.v", "name": "FA_extensionality", "text": "Theorem FA_extensionality (Oeq : F _o = G _o) :\n    (\n      \u2200 (a b : Obj)\n        (h : (a \u2013\u227b b)%morphism),\n        (\n          fun x y =>\n            match Oeq in _ = V return\n                  ((x \u2013\u227b y) \u2192 ((V x) \u2013\u227b (V y)))%morphism\n            with\n              eq_refl => F  @_a x y\n            end\n        ) _ _ h = G _a h\n    )\n    \u2192\n    (\n      fun x y =>\n        match Oeq in _ = V return\n              ((x \u2013\u227b y) \u2192 ((V x) \u2013\u227b (V y)))%morphism\n        with\n          eq_refl => F  @_a x y\n        end\n    ) = G @_a.\n  Proof.\n    auto.\n  Qed.\n", "definition": " F _o = G _o) :\n    (\n      \u2200 (a b : Obj)\n        (h : (a \u2013\u227b b)%morphism),\n        (\n          fun x y =>\n            match Oeq in _ = V return\n                  ((x \u2013\u227b y) \u2192 ((V x) \u2013\u227b (V y)))%morphism\n            with\n              eq_refl => F  @_a x y\n            end\n        ) _ _ h = G _a h\n    )\n    \u2192\n    (\n      fun x y =>\n        match Oeq in _ = V return\n              ((x \u2013\u227b y) \u2192 ((V x) \u2013\u227b (V y)))%morphism\n        with\n          eq_refl => F  @_a x y\n        end\n    ) = G @_a.\n  ", "proof": "\n    auto.\n  ", "def_ranges": [98, 0, 119, 14], "proof_ranges": [120, 0, 122, 6], "proof_steps": [{"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Functor/Representable/Hom_Func_Prop.v", "name": "Hom_Func_Twist", "text": "Theorem Hom_Func_Twist : (Hom_Func (C^op)) = (Hom_Func C) \u2218 (Twist_Func C (C^op)).\n  Proof.\n    Func_eq_simpl; cbn; auto.\n  Qed.\n", "definition": " (Hom_Func (C^op)) = (Hom_Func C) \u2218 (Twist_Func C (C^op)).\n  ", "proof": "\n    Func_eq_simpl; cbn; auto.\n  ", "def_ranges": [22, 0, 22, 84], "proof_ranges": [23, 0, 25, 6], "proof_steps": [{"text": "Func_eq_simpl; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Functor/Representable/Hom_Func_Prop.v", "name": "Prod_Func_Hom_Func_invl", "text": "Theorem Prod_Func_Hom_Func_invl :\n    N = Prod_Func_Hom_Func (Prod_Func_Hom_Func N).\n  Proof.\n    apply Isomorphism_eq_simplify;\n    apply NatTrans_eq_simplify; extensionality x; trivial.\n  Qed.    \n", "definition": "\n    N = Prod_Func_Hom_Func (Prod_Func_Hom_Func N).\n  ", "proof": "\n    apply Isomorphism_eq_simplify;\n    apply NatTrans_eq_simplify; extensionality x; trivial.\n  ", "def_ranges": [132, 0, 133, 50], "proof_ranges": [134, 0, 137, 6], "proof_steps": [{"text": "apply Isomorphism_eq_simplify;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply NatTrans_eq_simplify; extensionality x; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Comma.v", "name": "Comma_Hom_eq_simplify", "text": "Theorem Comma_Hom_eq_simplify {a b : Comma_Obj} (h h' : Comma_Hom a b) :\n    (@CMH_left _ _ h) = (@CMH_left _ _ h') \u2192\n    (@CMH_right _ _ h) = (@CMH_right _ _ h') \u2192 h = h'.\n  Proof.\n    intros H1 H2.\n    destruct h; destruct h'.\n    cbn in *.\n    ElimEq.\n    PIR.\n    trivial.\n  Qed.\n", "definition": " Comma_Obj} (h h' : Comma_Hom a b) :\n    (@CMH_left _ _ h) = (@CMH_left _ _ h') \u2192\n    (@CMH_right _ _ h) = (@CMH_right _ _ h') \u2192 h = h'.\n  ", "proof": "\n    intros H1 H2.\n    destruct h; destruct h'.\n    cbn in *.\n    ElimEq.\n    PIR.\n    trivial.\n  ", "def_ranges": [63, 0, 65, 54], "proof_ranges": [66, 0, 73, 6], "proof_steps": [{"text": "intros H1 H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct h; destruct h'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "ElimEq.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "PIR.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Comma.v", "name": "Comma_Hom_compose_assoc", "text": "Theorem Comma_Hom_compose_assoc {a b c d : Comma_Obj} (h : Comma_Hom a b)\n          (h' : Comma_Hom b c) (h'' : Comma_Hom c d) :\n    Comma_Hom_compose h (Comma_Hom_compose h' h'') =\n    Comma_Hom_compose (Comma_Hom_compose h h') h''.\n  Proof.                    \n    apply Comma_Hom_eq_simplify; cbn; auto.\n  Qed.    \n", "definition": " Comma_Obj} (h : Comma_Hom a b)\n          (h' : Comma_Hom b c) (h'' : Comma_Hom c d) :\n    Comma_Hom_compose h (Comma_Hom_compose h' h'') =\n    Comma_Hom_compose (Comma_Hom_compose h h') h''.\n  ", "proof": "                    \n    apply Comma_Hom_eq_simplify; cbn; auto.\n  ", "def_ranges": [93, 0, 96, 51], "proof_ranges": [97, 0, 99, 6], "proof_steps": [{"text": "apply Comma_Hom_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Comma.v", "name": "Comma_Hom_id_unit_left", "text": "Theorem Comma_Hom_id_unit_left {a b : Comma_Obj} (h : Comma_Hom a b) :\n    Comma_Hom_compose h (Comma_Hom_id b) = h.\n  Proof.\n    apply Comma_Hom_eq_simplify; cbn; auto.\n  Qed.\n", "definition": " Comma_Obj} (h : Comma_Hom a b) :\n    Comma_Hom_compose h (Comma_Hom_id b) = h.\n  ", "proof": "\n    apply Comma_Hom_eq_simplify; cbn; auto.\n  ", "def_ranges": [107, 0, 108, 45], "proof_ranges": [109, 0, 111, 6], "proof_steps": [{"text": "apply Comma_Hom_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Comma.v", "name": "Comma_Hom_id_unit_right", "text": "Theorem Comma_Hom_id_unit_right {a b : Comma_Obj} (h : Comma_Hom a b) :\n    Comma_Hom_compose (Comma_Hom_id a) h = h.\n  Proof.\n    apply Comma_Hom_eq_simplify; cbn; auto.\n  Qed.\n", "definition": " Comma_Obj} (h : Comma_Hom a b) :\n    Comma_Hom_compose (Comma_Hom_id a) h = h.\n  ", "proof": "\n    apply Comma_Hom_eq_simplify; cbn; auto.\n  ", "def_ranges": [113, 0, 114, 45], "proof_ranges": [115, 0, 117, 6], "proof_steps": [{"text": "apply Comma_Hom_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Prod_Cat/Operations.v", "name": "Prod_Functor_Cat_Proj", "text": "Theorem Prod_Functor_Cat_Proj {C D D' : Category} (F : C \u2013\u227b (D \u00d7 D')) :\n  ((Prod_Functor ((Cat_Proj1 _ _) \u2218 F) ((Cat_Proj2 _ _) \u2218 F))\n     \u2218 (Diag_Func C))%functor = F.\nProof.\n  Func_eq_simpl; trivial.\nQed.  \n", "definition": " Category} (F : C \u2013\u227b (D \u00d7 D')) :\n  ((Prod_Functor ((Cat_Proj1 _ _) \u2218 F) ((Cat_Proj2 _ _) \u2218 F))\n     \u2218 (Diag_Func C))%functor = F.\n", "proof": "\n  Func_eq_simpl; trivial.\n", "def_ranges": [65, 0, 67, 34], "proof_ranges": [68, 0, 70, 4], "proof_steps": [{"text": "Func_eq_simpl; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Prod_Cat/Operations.v", "name": "Twist_Prod_Func_Twist", "text": "Theorem Twist_Prod_Func_Twist :\n    (((Twist_Func _ _) \u2218 (Prod_Functor F G)) \u2218 (Twist_Func _ _))%functor =\n    Prod_Functor G F.\n  Proof.  \n    Func_eq_simpl; trivial.\n  Qed.\n", "definition": "\n    (((Twist_Func _ _) \u2218 (Prod_Functor F G)) \u2218 (Twist_Func _ _))%functor =\n    Prod_Functor G F.\n  ", "proof": "  \n    Func_eq_simpl; trivial.\n  ", "def_ranges": [83, 0, 85, 21], "proof_ranges": [86, 0, 88, 6], "proof_steps": [{"text": "Func_eq_simpl; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Prod_Cat/Operations.v", "name": "Prod_Functor_compose", "text": "Theorem Prod_Functor_compose :\n    ((Prod_Functor G G') \u2218 (Prod_Functor F F') =\n     Prod_Functor (G \u2218 F) (G' \u2218 F'))%functor.\n  Proof.\n    Func_eq_simpl; trivial.\n  Qed.    \n", "definition": "\n    ((Prod_Functor G G') \u2218 (Prod_Functor F F') =\n     Prod_Functor (G \u2218 F) (G' \u2218 F'))%functor.\n  ", "proof": "\n    Func_eq_simpl; trivial.\n  ", "def_ranges": [96, 0, 98, 45], "proof_ranges": [99, 0, 101, 6], "proof_steps": [{"text": "Func_eq_simpl; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Prod_Cat/Prod_Cat.v", "name": "Prod_compose_id", "text": "Theorem Prod_compose_id\n        (C D : Category)\n        (a b c : C) (d : D)\n        (f : a \u2013\u227b b) (g : b \u2013\u227b c)\n  : (g \u2218 f, id d)%morphism =\n    @compose (_ \u00d7 _) (_, _) (_, _) (_, _) (f, id d) (g, id d).\nProof.\n  cbn; auto.\nQed.\n", "definition": " Category)\n        (a b c : C) (d : D)\n        (f : a \u2013\u227b b) (g : b \u2013\u227b c)\n  : (g \u2218 f, id d)%morphism =\n    @compose (_ \u00d7 _) (_, _) (_, _) (_, _) (f, id d) (g, id d).\n", "proof": "\n  cbn; auto.\n", "def_ranges": [69, 0, 74, 62], "proof_ranges": [75, 0, 77, 4], "proof_steps": [{"text": "cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Prod_Cat/Prod_Cat.v", "name": "Prod_id_compose", "text": "Theorem Prod_id_compose\n        (C D : Category)\n        (a : C) (b c d : D)\n        (f : b \u2013\u227b c) (g : c \u2013\u227b d)\n  : (id a, g \u2218 f)%morphism =\n    @compose (_ \u00d7 _) (_, _) (_, _) (_, _) (id a, f) (id a, g).\nProof.\n  cbn; auto.\nQed.\n", "definition": " Category)\n        (a : C) (b c d : D)\n        (f : b \u2013\u227b c) (g : c \u2013\u227b d)\n  : (id a, g \u2218 f)%morphism =\n    @compose (_ \u00d7 _) (_, _) (_, _) (_, _) (id a, f) (id a, g).\n", "proof": "\n  cbn; auto.\n", "def_ranges": [79, 0, 84, 62], "proof_ranges": [85, 0, 87, 4], "proof_steps": [{"text": "cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Ext_Cons/Prod_Cat/Prod_Cat.v", "name": "Prod_cross_compose", "text": "Theorem Prod_cross_compose\n        (C D : Category)\n        (a b : C) (c d : D)\n        (f : a \u2013\u227b b) (g : c \u2013\u227b d)\n  : @compose\n      (_ \u00d7 _) (_, _) (_, _) (_, _)\n      (@id _ a, g) (f, @id _ d)\n    = @compose\n        (_ \u00d7 _) (_, _) (_, _) (_, _)\n        (f, @id _ c) (@id _ b, g)\n.\nProof.\n  cbn; auto.\nQed.\n", "definition": " Category)\n        (a b : C) (c d : D)\n        (f : a \u2013\u227b b) (g : c \u2013\u227b d)\n  : @compose\n      (_ \u00d7 _) (_, _) (_, _) (_, _)\n      (@id _ a, g) (f, @id _ d)\n    = @compose\n        (_ \u00d7 _) (_, _) (_, _) (_, _)\n        (f, @id _ c) (@id _ b, g)\n.\n", "proof": "\n  cbn; auto.\n", "def_ranges": [89, 0, 99, 1], "proof_ranges": [100, 0, 102, 4], "proof_steps": [{"text": "cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Adjunction/Adj_Facts.v", "name": "Hom_Adjunct_right_unique", "text": "Theorem Hom_Adjunct_right_unique : (G \u2243 G')%natiso.\n  Proof.\n    apply Hom_Adjunct_Duality in adj.\n    apply Hom_Adjunct_Duality in adj'.\n    apply (@Opposite_NatIso _ _ (G^op) (G'^op)).\n    apply (Hom_Adjunct_left_unique adj adj').\n  Defined.\n", "definition": " (G \u2243 G')%natiso.\n  ", "proof": "\n    apply Hom_Adjunct_Duality in adj.\n    apply Hom_Adjunct_Duality in adj'.\n    apply (@Opposite_NatIso _ _ (G^op) (G'^op)).\n    apply (Hom_Adjunct_left_unique adj adj').\n  ", "def_ranges": [115, 0, 115, 53], "proof_ranges": [116, 0, 121, 10], "proof_steps": [{"text": "apply Hom_Adjunct_Duality in adj.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Hom_Adjunct_Duality in adj'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (@Opposite_NatIso _ _ (G^op) (G'^op)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (Hom_Adjunct_left_unique adj adj').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Adjunction/Adj_Facts.v", "name": "Adjunct_left_unique", "text": "Theorem Adjunct_left_unique : (F \u2243 F' )%natiso.\n  Proof.\n    apply Adj_to_Hom_Adj in adj.\n    apply Adj_to_Hom_Adj in adj'.\n    eapply Hom_Adjunct_left_unique; eassumption.\n  Defined.\n", "definition": " (F \u2243 F' )%natiso.\n  ", "proof": "\n    apply Adj_to_Hom_Adj in adj.\n    apply Adj_to_Hom_Adj in adj'.\n    eapply Hom_Adjunct_left_unique; eassumption.\n  ", "def_ranges": [134, 0, 134, 49], "proof_ranges": [135, 0, 139, 10], "proof_steps": [{"text": "apply Adj_to_Hom_Adj in adj.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Adj_to_Hom_Adj in adj'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply Hom_Adjunct_left_unique; eassumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Adjunction/Adj_Facts.v", "name": "Adjunct_right_unique", "text": "Theorem Adjunct_right_unique : (G \u2243 G')%natiso.\n  Proof.\n    apply Adj_to_Hom_Adj in adj.\n    apply Adj_to_Hom_Adj in adj'.\n    eapply Hom_Adjunct_right_unique; eassumption.\n  Defined.\n", "definition": " (G \u2243 G')%natiso.\n  ", "proof": "\n    apply Adj_to_Hom_Adj in adj.\n    apply Adj_to_Hom_Adj in adj'.\n    eapply Hom_Adjunct_right_unique; eassumption.\n  ", "def_ranges": [152, 0, 152, 49], "proof_ranges": [153, 0, 157, 10], "proof_steps": [{"text": "apply Adj_to_Hom_Adj in adj.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply Adj_to_Hom_Adj in adj'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply Hom_Adjunct_right_unique; eassumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": false}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Adjunction/AFT/Solution_Set_Cond.v", "name": "ids_endomorphs_equalizer_morph_neutralizes_endomorphs", "text": "Theorem ids_endomorphs_equalizer_morph_neutralizes_endomorphs\n          (d : (SSC_Prod \u2013\u227b SSC_Prod)%morphism)\n    :\n      (d \u2218 equalizer_morph ids_endomorphs_equalizer)%morphism\n      = equalizer_morph ids_endomorphs_equalizer\n  .\n  Proof.\n    assert (H :=\n              f_equal\n                (fun w => ((Trans Endo_Prod d) \u2218 w)%morphism)\n                (equalizer_morph_com ids_endomorphs_equalizer)\n           ).\n    cbn -[equalizer_morph ids_endomorphs_equalizer Endo_Prod] in H.\n    unfold morph_to_Endo_Prod_endomorphs, morph_to_Endo_Prod_ids in H.\n    repeat rewrite assoc_sym in H.\n    assert (V :=\n           f_equal\n             (fun w :\n                    ((Functor_Ops.Functor_compose\n                        (Functor_To_1_Cat\n                           (Discr_Cat (SSC_Prod \u2013\u227b SSC_Prod)%morphism))\n                        Cone_Endo_Prod_endomorphs)\n                       \u2013\u227b Discr_Func endomorph_const)%nattrans\n              => Trans w d)\n             (cone_morph_com\n                (LRKE_morph_ex Endo_Prod Cone_Endo_Prod_endomorphs))\n        ).\n    cbn -[LRKE_morph_ex Endo_Prod] in V.\n    rewrite From_Term_Cat in V.\n    simpl_ids in V.\n    rewrite <- V in H.\n    clear V.\n    assert (V :=\n           f_equal\n             (fun w :\n                    ((Functor_Ops.Functor_compose\n                       (Functor_To_1_Cat\n                          (Discr_Cat (SSC_Prod \u2013\u227b SSC_Prod)%morphism))\n                       Cone_Endo_Prod_ids)\n                       \u2013\u227b Discr_Func endomorph_const)%nattrans\n              => Trans w d)\n             (cone_morph_com (LRKE_morph_ex Endo_Prod Cone_Endo_Prod_ids))\n        ).\n    cbn -[LRKE_morph_ex Endo_Prod] in V.\n    rewrite From_Term_Cat in V.\n    simpl_ids in V.\n    rewrite <- V in H.\n    clear V.\n    auto.\n  Qed.\n", "definition": " (SSC_Prod \u2013\u227b SSC_Prod)%morphism)\n    :\n      (d \u2218 equalizer_morph ids_endomorphs_equalizer)%morphism\n      = equalizer_morph ids_endomorphs_equalizer\n  .\n  ", "proof": "\n    assert (H :=\n              f_equal\n                (fun w => ((Trans Endo_Prod d) \u2218 w)%morphism)\n                (equalizer_morph_com ids_endomorphs_equalizer)\n           ).\n    cbn -[equalizer_morph ids_endomorphs_equalizer Endo_Prod] in H.\n    unfold morph_to_Endo_Prod_endomorphs, morph_to_Endo_Prod_ids in H.\n    repeat rewrite assoc_sym in H.\n    assert (V :=\n           f_equal\n             (fun w :\n                    ((Functor_Ops.Functor_compose\n                        (Functor_To_1_Cat\n                           (Discr_Cat (SSC_Prod \u2013\u227b SSC_Prod)%morphism))\n                        Cone_Endo_Prod_endomorphs)\n                       \u2013\u227b Discr_Func endomorph_const)%nattrans\n              => Trans w d)\n             (cone_morph_com\n                (LRKE_morph_ex Endo_Prod Cone_Endo_Prod_endomorphs))\n        ).\n    cbn -[LRKE_morph_ex Endo_Prod] in V.\n    rewrite From_Term_Cat in V.\n    simpl_ids in V.\n    rewrite <- V in H.\n    clear V.\n    assert (V :=\n           f_equal\n             (fun w :\n                    ((Functor_Ops.Functor_compose\n                       (Functor_To_1_Cat\n                          (Discr_Cat (SSC_Prod \u2013\u227b SSC_Prod)%morphism))\n                       Cone_Endo_Prod_ids)\n                       \u2013\u227b Discr_Func endomorph_const)%nattrans\n              => Trans w d)\n             (cone_morph_com (LRKE_morph_ex Endo_Prod Cone_Endo_Prod_ids))\n        ).\n    cbn -[LRKE_morph_ex Endo_Prod] in V.\n    rewrite From_Term_Cat in V.\n    simpl_ids in V.\n    rewrite <- V in H.\n    clear V.\n    auto.\n  ", "def_ranges": [155, 0, 160, 3], "proof_ranges": [161, 0, 204, 6], "proof_steps": [{"text": "assert (H :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "f_equal", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun w => ((Trans Endo_Prod d) \u2218 w)%morphism)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(equalizer_morph_com ids_endomorphs_equalizer)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ").", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn -[equalizer_morph ids_endomorphs_equalizer Endo_Prod] in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold morph_to_Endo_Prod_endomorphs, morph_to_Endo_Prod_ids in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite assoc_sym in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (V :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "f_equal", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun w :", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((Functor_Ops.Functor_compose", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Functor_To_1_Cat", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Discr_Cat (SSC_Prod \u2013\u227b SSC_Prod)%morphism))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Cone_Endo_Prod_endomorphs)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "\u2013\u227b Discr_Func endomorph_const)%nattrans", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "=> Trans w d)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(cone_morph_com", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(LRKE_morph_ex Endo_Prod Cone_Endo_Prod_endomorphs))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ").", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn -[LRKE_morph_ex Endo_Prod] in V.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite From_Term_Cat in V.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl_ids in V.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- V in H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "clear V.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (V :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "f_equal", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun w :", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((Functor_Ops.Functor_compose", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Functor_To_1_Cat", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Discr_Cat (SSC_Prod \u2013\u227b SSC_Prod)%morphism))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Adjunction/AFT/Solution_Set_Cond.v", "name": "equalizer_of_morphs_from_ids_endomorphs_equalizer_iso_RI", "text": "Theorem equalizer_of_morphs_from_ids_endomorphs_equalizer_iso_RI :\n      ((equalizer_morph (equalizer_of_morphs_from_ids_endomorphs_equalizer))\n         \u2218\n         ((SSC_Prod_WI _)\n            \u2218 (equalizer_morph ids_endomorphs_equalizer)))%morphism\n      =\n      id.\n    Proof.\n      apply (\n          mono_morphism_monomorphic\n            (@Equalizer_Monic _ _ _ _ _ ids_endomorphs_equalizer)\n        ).\n      rewrite id_unit_right.\n      repeat rewrite assoc_sym.\n      apply ids_endomorphs_equalizer_morph_neutralizes_endomorphs.      \n    Qed.\n", "definition": "\n      ((equalizer_morph (equalizer_of_morphs_from_ids_endomorphs_equalizer))\n         \u2218\n         ((SSC_Prod_WI _)\n            \u2218 (equalizer_morph ids_endomorphs_equalizer)))%morphism\n      =\n      id.\n    ", "proof": "\n      apply (\n          mono_morphism_monomorphic\n            (@Equalizer_Monic _ _ _ _ _ ids_endomorphs_equalizer)\n        ).\n      rewrite id_unit_right.\n      repeat rewrite assoc_sym.\n      apply ids_endomorphs_equalizer_morph_neutralizes_endomorphs.      \n    ", "def_ranges": [225, 0, 231, 9], "proof_ranges": [232, 0, 240, 8], "proof_steps": [{"text": "apply (", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "mono_morphism_monomorphic", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(@Equalizer_Monic _ _ _ _ _ ids_endomorphs_equalizer)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ").", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite id_unit_right.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "repeat rewrite assoc_sym.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Adjunction/AFT/Solution_Set_Cond.v", "name": "equalizer_of_morphs_from_ids_endomorphs_equalizer_iso_LI", "text": "Theorem equalizer_of_morphs_from_ids_endomorphs_equalizer_iso_LI :\n      (((SSC_Prod_WI _) \u2218 (equalizer_morph ids_endomorphs_equalizer))\n         \u2218\n         (equalizer_morph (equalizer_of_morphs_from_ids_endomorphs_equalizer))\n      )%morphism\n      =\n      id.\n    Proof.\n      apply (\n          mono_morphism_monomorphic\n            (@Equalizer_Monic _ _ _ _ _\n                              equalizer_of_morphs_from_ids_endomorphs_equalizer)\n        ).\n      unfold Equalizer_Monic.\n      cbn [mono_morphism].\n      rewrite assoc_sym.\n      simpl_ids.\n      trivial.\n      apply equalizer_of_morphs_from_ids_endomorphs_equalizer_iso_RI.\n    Qed.\n", "definition": "\n      (((SSC_Prod_WI _) \u2218 (equalizer_morph ids_endomorphs_equalizer))\n         \u2218\n         (equalizer_morph (equalizer_of_morphs_from_ids_endomorphs_equalizer))\n      )%morphism\n      =\n      id.\n    ", "proof": "\n      apply (\n          mono_morphism_monomorphic\n            (@Equalizer_Monic _ _ _ _ _\n                              equalizer_of_morphs_from_ids_endomorphs_equalizer)\n        ).\n      unfold Equalizer_Monic.\n      cbn [mono_morphism].\n      rewrite assoc_sym.\n      simpl_ids.\n      trivial.\n      apply equalizer_of_morphs_from_ids_endomorphs_equalizer_iso_RI.\n    ", "def_ranges": [242, 0, 248, 9], "proof_ranges": [249, 0, 261, 8], "proof_steps": [{"text": "apply (", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "mono_morphism_monomorphic", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(@Equalizer_Monic _ _ _ _ _", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "equalizer_of_morphs_from_ids_endomorphs_equalizer)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ").", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold Equalizer_Monic.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn [mono_morphism].", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite assoc_sym.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl_ids.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Adjunction/AFT/Commas_Complete/Commas_Equalizer.v", "name": "CMO_hom_a_equalizes", "text": "Theorem CMO_hom_a_equalizes :\n    ((G _a (CMH_right f)) \u2218 (CMO_hom a))%morphism\n    = ((G _a (CMH_right g)) \u2218 (CMO_hom a))%morphism\n  .\n  Proof.\n    rewrite (CMH_com f).\n    rewrite (CMH_com g).\n    destruct (CMH_left f); destruct (CMH_left g).\n    trivial.\n  Qed.      \n", "definition": "\n    ((G _a (CMH_right f)) \u2218 (CMO_hom a))%morphism\n    = ((G _a (CMH_right g)) \u2218 (CMO_hom a))%morphism\n  .\n  ", "proof": "\n    rewrite (CMH_com f).\n    rewrite (CMH_com g).\n    destruct (CMH_left f); destruct (CMH_left g).\n    trivial.\n  ", "def_ranges": [102, 0, 105, 3], "proof_ranges": [106, 0, 111, 6], "proof_steps": [{"text": "rewrite (CMH_com f).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (CMH_com g).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (CMH_left f); destruct (CMH_left g).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Archetypal/PreOrder_Cat/OmegaCat.v", "name": "Not_S_Tle", "text": "Theorem Not_S_Tle (n : nat) : Tle (S n) n \u2192 False.\nProof.\n  intros H.\n  induction n; inversion H; auto.\n  apply IHn.\n  apply Tle_remS; trivial.\nQed.\n", "definition": " nat) : Tle (S n) n \u2192 False.\n", "proof": "\n  intros H.\n  induction n; inversion H; auto.\n  apply IHn.\n  apply Tle_remS; trivial.\n", "def_ranges": [53, 0, 53, 50], "proof_ranges": [54, 0, 59, 4], "proof_steps": [{"text": "intros H.", "goal_before": ["S n \u2264 n \u2192 False"], "goal_after": ["False"], "proof_term_before": [], "proof_term_after": ["(fun (n : nat) (H : S n \u2264 n) => ?Goal)"]}, {"text": "induction n; inversion H; auto.", "goal_before": ["False"], "goal_after": ["False", "False"], "proof_term_before": ["(fun (n : nat) (H : S n \u2264 n) => ?Goal)"], "proof_term_after": ["(fun (n : nat) (H : S n \u2264 n) =>\n nat_ind (fun n0 : nat => S n0 \u2264 n0 \u2192 False)\n   (fun H0 : 1 \u2264 0 =>\n    let H1 : 0 = 0 \u2192 False :=\n      match H0 in (_ \u2264 n0) return (n0 = 0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : 1 = 0 =>\n          (fun H2 : 1 = 0 =>\n           let H3 : False :=\n             eq_ind 1\n               (fun e : nat => match e with\n                               | 0 => False\n                               | S _ => True\n                               end) I 0 H2 in\n           False_ind False H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : 1 \u2264 m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (1 \u2264 m0 \u2192 False) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat) (IHn : S n0 \u2264 n0 \u2192 False) (H0 : S (S n0) \u2264 S n0) =>\n    let H1 : S n0 = S n0 \u2192 False :=\n      match H0 in (_ \u2264 n1) return (n1 = S n0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : S (S n0) = S n0 =>\n          (fun H2 : S (S n0) = S n0 =>\n           let H3 : S n0 = n0 :=\n             f_equal\n               (fun e : nat => match e with\n                               | 0 => S n0\n                               | S n1 => n1\n                               end) H2 in\n           (fun H4 : S n0 = n0 =>\n            let H5 : S n0 = n0 := H4 in\n            eq_ind (S n0) (fun _ : nat => False) ?Goal@{n:=n0; H:=H0; H1:=H4}\n              n0 H5) H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : S (S n0) \u2264 m0) (H2 : S m0 = S n0) =>\n           (fun H3 : S m0 = S n0 =>\n            let H4 : m0 = n0 :=\n              f_equal\n                (fun e : nat => match e with\n                                | 0 => m0\n                                | S n1 => n1\n                                end) H3 in\n            (fun H5 : m0 = n0 =>\n             let H6 : m0 = n0 := H5 in\n             eq_ind_r (fun n1 : nat => S (S n0) \u2264 n1 \u2192 False)\n               (fun H7 : S (S n0) \u2264 n0 =>\n                ?Goal0@{n:=n0; H:=H0; m:=m0; H1:=H7; H0:=H5}) H6) H4) H2 H1)\n            m x\n      end in\n    H1 eq_refl) n H)"]}, {"text": "apply IHn.", "goal_before": ["False", "False"], "goal_after": ["S n \u2264 n", "False"], "proof_term_before": ["(fun (n : nat) (H : S n \u2264 n) =>\n nat_ind (fun n0 : nat => S n0 \u2264 n0 \u2192 False)\n   (fun H0 : 1 \u2264 0 =>\n    let H1 : 0 = 0 \u2192 False :=\n      match H0 in (_ \u2264 n0) return (n0 = 0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : 1 = 0 =>\n          (fun H2 : 1 = 0 =>\n           let H3 : False :=\n             eq_ind 1\n               (fun e : nat => match e with\n                               | 0 => False\n                               | S _ => True\n                               end) I 0 H2 in\n           False_ind False H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : 1 \u2264 m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (1 \u2264 m0 \u2192 False) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat) (IHn : S n0 \u2264 n0 \u2192 False) (H0 : S (S n0) \u2264 S n0) =>\n    let H1 : S n0 = S n0 \u2192 False :=\n      match H0 in (_ \u2264 n1) return (n1 = S n0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : S (S n0) = S n0 =>\n          (fun H2 : S (S n0) = S n0 =>\n           let H3 : S n0 = n0 :=\n             f_equal\n               (fun e : nat => match e with\n                               | 0 => S n0\n                               | S n1 => n1\n                               end) H2 in\n           (fun H4 : S n0 = n0 =>\n            let H5 : S n0 = n0 := H4 in\n            eq_ind (S n0) (fun _ : nat => False) ?Goal@{n:=n0; H:=H0; H1:=H4}\n              n0 H5) H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : S (S n0) \u2264 m0) (H2 : S m0 = S n0) =>\n           (fun H3 : S m0 = S n0 =>\n            let H4 : m0 = n0 :=\n              f_equal\n                (fun e : nat => match e with\n                                | 0 => m0\n                                | S n1 => n1\n                                end) H3 in\n            (fun H5 : m0 = n0 =>\n             let H6 : m0 = n0 := H5 in\n             eq_ind_r (fun n1 : nat => S (S n0) \u2264 n1 \u2192 False)\n               (fun H7 : S (S n0) \u2264 n0 =>\n                ?Goal0@{n:=n0; H:=H0; m:=m0; H1:=H7; H0:=H5}) H6) H4) H2 H1)\n            m x\n      end in\n    H1 eq_refl) n H)"], "proof_term_after": ["(fun (n : nat) (H : S n \u2264 n) =>\n nat_ind (fun n0 : nat => S n0 \u2264 n0 \u2192 False)\n   (fun H0 : 1 \u2264 0 =>\n    let H1 : 0 = 0 \u2192 False :=\n      match H0 in (_ \u2264 n0) return (n0 = 0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : 1 = 0 =>\n          (fun H2 : 1 = 0 =>\n           let H3 : False :=\n             eq_ind 1\n               (fun e : nat => match e with\n                               | 0 => False\n                               | S _ => True\n                               end) I 0 H2 in\n           False_ind False H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : 1 \u2264 m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (1 \u2264 m0 \u2192 False) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat) (IHn : S n0 \u2264 n0 \u2192 False) (H0 : S (S n0) \u2264 S n0) =>\n    let H1 : S n0 = S n0 \u2192 False :=\n      match H0 in (_ \u2264 n1) return (n1 = S n0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : S (S n0) = S n0 =>\n          (fun H2 : S (S n0) = S n0 =>\n           let H3 : S n0 = n0 :=\n             f_equal\n               (fun e : nat => match e with\n                               | 0 => S n0\n                               | S n1 => n1\n                               end) H2 in\n           (fun H4 : S n0 = n0 =>\n            let H5 : S n0 = n0 := H4 in\n            eq_ind (S n0) (fun _ : nat => False)\n              (IHn ?Goal0@{n:=n0; H:=H0; H1:=H4}) n0 H5) H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : S (S n0) \u2264 m0) (H2 : S m0 = S n0) =>\n           (fun H3 : S m0 = S n0 =>\n            let H4 : m0 = n0 :=\n              f_equal\n                (fun e : nat => match e with\n                                | 0 => m0\n                                | S n1 => n1\n                                end) H3 in\n            (fun H5 : m0 = n0 =>\n             let H6 : m0 = n0 := H5 in\n             eq_ind_r (fun n1 : nat => S (S n0) \u2264 n1 \u2192 False)\n               (fun H7 : S (S n0) \u2264 n0 =>\n                ?Goal@{n:=n0; H:=H0; m:=m0; H1:=H7; H0:=H5}) H6) H4) H2 H1) m\n            x\n      end in\n    H1 eq_refl) n H)"]}, {"text": "apply Tle_remS; trivial.", "goal_before": ["S n \u2264 n", "False"], "goal_after": ["S n \u2264 n", "False"], "proof_term_before": ["(fun (n : nat) (H : S n \u2264 n) =>\n nat_ind (fun n0 : nat => S n0 \u2264 n0 \u2192 False)\n   (fun H0 : 1 \u2264 0 =>\n    let H1 : 0 = 0 \u2192 False :=\n      match H0 in (_ \u2264 n0) return (n0 = 0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : 1 = 0 =>\n          (fun H2 : 1 = 0 =>\n           let H3 : False :=\n             eq_ind 1\n               (fun e : nat => match e with\n                               | 0 => False\n                               | S _ => True\n                               end) I 0 H2 in\n           False_ind False H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : 1 \u2264 m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (1 \u2264 m0 \u2192 False) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat) (IHn : S n0 \u2264 n0 \u2192 False) (H0 : S (S n0) \u2264 S n0) =>\n    let H1 : S n0 = S n0 \u2192 False :=\n      match H0 in (_ \u2264 n1) return (n1 = S n0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : S (S n0) = S n0 =>\n          (fun H2 : S (S n0) = S n0 =>\n           let H3 : S n0 = n0 :=\n             f_equal\n               (fun e : nat => match e with\n                               | 0 => S n0\n                               | S n1 => n1\n                               end) H2 in\n           (fun H4 : S n0 = n0 =>\n            let H5 : S n0 = n0 := H4 in\n            eq_ind (S n0) (fun _ : nat => False)\n              (IHn ?Goal0@{n:=n0; H:=H0; H1:=H4}) n0 H5) H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : S (S n0) \u2264 m0) (H2 : S m0 = S n0) =>\n           (fun H3 : S m0 = S n0 =>\n            let H4 : m0 = n0 :=\n              f_equal\n                (fun e : nat => match e with\n                                | 0 => m0\n                                | S n1 => n1\n                                end) H3 in\n            (fun H5 : m0 = n0 =>\n             let H6 : m0 = n0 := H5 in\n             eq_ind_r (fun n1 : nat => S (S n0) \u2264 n1 \u2192 False)\n               (fun H7 : S (S n0) \u2264 n0 =>\n                ?Goal@{n:=n0; H:=H0; m:=m0; H1:=H7; H0:=H5}) H6) H4) H2 H1) m\n            x\n      end in\n    H1 eq_refl) n H)"], "proof_term_after": ["(fun (n : nat) (H : S n \u2264 n) =>\n nat_ind (fun n0 : nat => S n0 \u2264 n0 \u2192 False)\n   (fun H0 : 1 \u2264 0 =>\n    let H1 : 0 = 0 \u2192 False :=\n      match H0 in (_ \u2264 n0) return (n0 = 0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : 1 = 0 =>\n          (fun H2 : 1 = 0 =>\n           let H3 : False :=\n             eq_ind 1\n               (fun e : nat => match e with\n                               | 0 => False\n                               | S _ => True\n                               end) I 0 H2 in\n           False_ind False H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : 1 \u2264 m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (1 \u2264 m0 \u2192 False) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat) (IHn : S n0 \u2264 n0 \u2192 False) (H0 : S (S n0) \u2264 S n0) =>\n    let H1 : S n0 = S n0 \u2192 False :=\n      match H0 in (_ \u2264 n1) return (n1 = S n0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : S (S n0) = S n0 =>\n          (fun H2 : S (S n0) = S n0 =>\n           let H3 : S n0 = n0 :=\n             f_equal\n               (fun e : nat => match e with\n                               | 0 => S n0\n                               | S n1 => n1\n                               end) H2 in\n           (fun H4 : S n0 = n0 =>\n            let H5 : S n0 = n0 := H4 in\n            eq_ind (S n0) (fun _ : nat => False)\n              (IHn ?Goal0@{n:=n0; H:=H0; H1:=H4}) n0 H5) H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : S (S n0) \u2264 m0) (H2 : S m0 = S n0) =>\n           (fun H3 : S m0 = S n0 =>\n            let H4 : m0 = n0 :=\n              f_equal\n                (fun e : nat => match e with\n                                | 0 => m0\n                                | S n1 => n1\n                                end) H3 in\n            (fun H5 : m0 = n0 =>\n             let H6 : m0 = n0 := H5 in\n             eq_ind_r (fun n1 : nat => S (S n0) \u2264 n1 \u2192 False)\n               (fun H7 : S (S n0) \u2264 n0 =>\n                ?Goal@{n:=n0; H:=H0; m:=m0; H1:=H7; H0:=H5}) H6) H4) H2 H1) m\n            x\n      end in\n    H1 eq_refl) n H)"]}, {"text": "Qed.", "goal_before": ["S n \u2264 n", "False"], "goal_after": ["0 \u2264 0", "0 \u2264 0", "S n \u2264 0", "\u2200 n : nat, S n \u2264 S (S m) \u2192 n \u2264 S m"], "proof_term_before": ["(fun (n : nat) (H : S n \u2264 n) =>\n nat_ind (fun n0 : nat => S n0 \u2264 n0 \u2192 False)\n   (fun H0 : 1 \u2264 0 =>\n    let H1 : 0 = 0 \u2192 False :=\n      match H0 in (_ \u2264 n0) return (n0 = 0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : 1 = 0 =>\n          (fun H2 : 1 = 0 =>\n           let H3 : False :=\n             eq_ind 1\n               (fun e : nat => match e with\n                               | 0 => False\n                               | S _ => True\n                               end) I 0 H2 in\n           False_ind False H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : 1 \u2264 m0) (H2 : S m0 = 0) =>\n           (fun H3 : S m0 = 0 =>\n            let H4 : False :=\n              eq_ind (S m0)\n                (fun e : nat => match e with\n                                | 0 => False\n                                | S _ => True\n                                end) I 0 H3 in\n            False_ind (1 \u2264 m0 \u2192 False) H4) H2 H1) m x\n      end in\n    H1 eq_refl)\n   (fun (n0 : nat) (IHn : S n0 \u2264 n0 \u2192 False) (H0 : S (S n0) \u2264 S n0) =>\n    let H1 : S n0 = S n0 \u2192 False :=\n      match H0 in (_ \u2264 n1) return (n1 = S n0 \u2192 False) with\n      | Tle_n _ =>\n          fun H1 : S (S n0) = S n0 =>\n          (fun H2 : S (S n0) = S n0 =>\n           let H3 : S n0 = n0 :=\n             f_equal\n               (fun e : nat => match e with\n                               | 0 => S n0\n                               | S n1 => n1\n                               end) H2 in\n           (fun H4 : S n0 = n0 =>\n            let H5 : S n0 = n0 := H4 in\n            eq_ind (S n0) (fun _ : nat => False)\n              (IHn ?Goal0@{n:=n0; H:=H0; H1:=H4}) n0 H5) H3) H1\n      | Tle_S _ m x =>\n          (fun (m0 : nat) (H1 : S (S n0) \u2264 m0) (H2 : S m0 = S n0) =>\n           (fun H3 : S m0 = S n0 =>\n            let H4 : m0 = n0 :=\n              f_equal\n                (fun e : nat => match e with\n                                | 0 => m0\n                                | S n1 => n1\n                                end) H3 in\n            (fun H5 : m0 = n0 =>\n             let H6 : m0 = n0 := H5 in\n             eq_ind_r (fun n1 : nat => S (S n0) \u2264 n1 \u2192 False)\n               (fun H7 : S (S n0) \u2264 n0 =>\n                ?Goal@{n:=n0; H:=H0; m:=m0; H1:=H7; H0:=H5}) H6) H4) H2 H1) m\n            x\n      end in\n    H1 eq_refl) n H)"], "proof_term_after": ["(fun n m : nat =>\n nat_rec (fun m0 : nat => \u2200 n0 : nat, S n0 \u2264 S m0 \u2192 n0 \u2264 m0)\n   (fun (n0 : nat) (H : S n0 \u2264 1) =>\n    nat_rec (fun n1 : nat => S n1 \u2264 1 \u2192 n1 \u2264 0)\n      (fun H0 : 1 \u2264 1 =>\n       let H1 :=\n         match H0 in (_ \u2264 n1) return (n1 = 1 \u2192 0 \u2264 0) with\n         | Tle_n _ => fun H1 : 1 = 1 => (fun _ : 1 = 1 => ?Goal1@{H:=H0}) H1\n         | Tle_S _ m0 x =>\n             (fun (m1 : nat) (H1 : 1 \u2264 m1) (H2 : S m1 = 1) =>\n              (fun H3 : S m1 = 1 =>\n               let H4 : m1 = 0 :=\n                 f_equal\n                   (fun e : nat => match e with\n                                   | 0 => m1\n                                   | S n1 => n1\n                                   end) H3 in\n               (fun H5 : m1 = 0 =>\n                let H6 : m1 = 0 := H5 in\n                eq_rec_r (fun n1 : nat => 1 \u2264 n1 \u2192 0 \u2264 0)\n                  (fun H7 : 1 \u2264 0 => ?Goal2@{H:=H0; m:=m1; H1:=H7; H0:=H5})\n                  H6) H4) H2 H1) m0 x\n         end in\n       H1 eq_refl)\n      (fun (n1 : nat) (IHn : S n1 \u2264 1 \u2192 n1 \u2264 0) (H0 : S (S n1) \u2264 1) =>\n       ?Goal0@{n:=n1; H:=H0}) n0 H)\n   (fun (m0 : nat) (IHm : \u2200 n0 : nat, S n0 \u2264 S m0 \u2192 n0 \u2264 m0) => ?Goal@{m:=m0})\n   m n)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Archetypal/PreOrder_Cat/OmegaCat.v", "name": "Tle_is_HProp", "text": "Theorem Tle_is_HProp {n m : nat} (H H' : Tle n m) : H = H'.\nProof.\n  dependent induction H.\n  dependent induction H'; trivial.\n  {\n    inversion H' as [H1| m' H1 H2].\n    {\n      contradict H1; clear.\n      induction m; auto.\n    }\n    {\n      subst.\n      contradict H1; clear.\n      induction m'.\n      + intros H; inversion H.\n      + intros H.\n        apply IHm'.\n        apply Tle_remS; trivial.\n    }\n  }\n  {\n    inversion H'.\n    + subst.\n      clear IHTle.\n      contradict H; clear.\n      intros H.\n      induction m.\n      * inversion H.\n      * apply IHm.\n        apply Tle_remS; trivial.\n    + subst.\n      dependent destruction H'.\n      {\n        clear IHTle.\n        contradict H; clear.\n        intros H.\n        induction m.\n        * inversion H.\n        * apply IHm.\n          apply Tle_remS; trivial.\n      }\n      {\n        apply f_equal.\n        apply IHTle.\n      }\n  }\nQed.\n", "definition": " nat} (H H' : Tle n m) : H = H'.\n", "proof": "\n  dependent induction H.\n  dependent induction H'; trivial.\n  {\n    inversion H' as [H1| m' H1 H2].\n    {\n      contradict H1; clear.\n      induction m; auto.\n    }\n    {\n      subst.\n      contradict H1; clear.\n      induction m'.\n      + intros H; inversion H.\n      + intros H.\n        apply IHm'.\n        apply Tle_remS; trivial.\n    }\n  }\n  {\n    inversion H'.\n    + subst.\n      clear IHTle.\n      contradict H; clear.\n      intros H.\n      induction m.\n      * inversion H.\n      * apply IHm.\n        apply Tle_remS; trivial.\n    + subst.\n      dependent destruction H'.\n      {\n        clear IHTle.\n        contradict H; clear.\n        intros H.\n        induction m.\n        * inversion H.\n        * apply IHm.\n          apply Tle_remS; trivial.\n      }\n      {\n        apply f_equal.\n        apply IHTle.\n      }\n  }\n", "def_ranges": [122, 0, 122, 59], "proof_ranges": [123, 0, 168, 4], "proof_steps": [{"text": "dependent induction H.", "goal_before": ["H = H'"], "goal_after": ["H = H'"], "proof_term_before": [], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) => ?Goal)"]}, {"text": "dependent induction H'; trivial.", "goal_before": ["H = H'"], "goal_after": ["H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) => ?Goal)"]}, {"text": "inversion H' as [H1| m' H1 H2].", "goal_before": ["H = H'"], "goal_after": ["H = H'", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) => ?Goal)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ => fun H0 : n = m => (fun H1 : n = m => ?Goal) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal0@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "contradict H1; clear.", "goal_before": ["H = H'", "H = H'"], "goal_after": ["n \u2260 m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ => fun H0 : n = m => (fun H1 : n = m => ?Goal) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal0@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m => False_ind (H = H') ((?Goal0 : n = m \u2192 False) H1))\n         H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "induction m; auto.", "goal_before": ["n \u2260 m", "H = H'"], "goal_after": ["n \u2260 0", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m => False_ind (H = H') ((?Goal0 : n = m \u2192 False) H1))\n         H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0) ?Goal0\n              (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal1@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "subst.", "goal_before": ["n \u2260 0", "n \u2260 S m", "H = H'"], "goal_after": ["n \u2260 0", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0) ?Goal0\n              (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal1@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0) ?Goal0\n              (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal1@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "contradict H1; clear.", "goal_before": ["n \u2260 0", "n \u2260 S m", "H = H'"], "goal_after": ["n \u2260 0", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0) ?Goal0\n              (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal1@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0) ?Goal0\n              (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal1@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "induction m'.", "goal_before": ["n \u2260 0", "n \u2260 S m", "H = H'"], "goal_after": ["n \u2260 0", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0) ?Goal0\n              (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal1@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0) ?Goal0\n              (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal1@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "intros H; inversion H.", "goal_before": ["n \u2260 0", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0) ?Goal0\n              (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal1@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "intros H.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "apply IHm'.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "apply Tle_remS; trivial.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "inversion H'.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "subst.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False) \n                         ?Goal1@{H:=H2; H0:=H4} H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "clear IHTle.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "contradict H; clear.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "intros H.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "induction m.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "inversion H.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "apply IHm.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "apply Tle_remS; trivial.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "subst.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "dependent destruction H'.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "clear IHTle.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "contradict H; clear.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "intros H.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "induction m.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "inversion H.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "apply IHm.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "apply Tle_remS; trivial.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "apply f_equal.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "apply IHTle.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["False", "n \u2260 S m", "H = H'"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"]}, {"text": "Qed.", "goal_before": ["False", "n \u2260 S m", "H = H'"], "goal_after": ["0 \u2264 0", "0 \u2264 0", "S n \u2264 0", "\u2200 n : nat, S n \u2264 S (S m) \u2192 n \u2264 S m"], "proof_term_before": ["(fun (n m : nat) (H H' : n \u2264 m) =>\n let H0 : m = m \u2192 H = H' :=\n   match H' as _ in (_ \u2264 n0) return (n0 = m \u2192 H = H') with\n   | Tle_n _ =>\n       fun H0 : n = m =>\n       (fun H1 : n = m =>\n        False_ind (H = H')\n          ((nat_ind (fun m0 : nat => n \u2260 m0)\n              ((fun H2 : n = 0 =>\n                let H3 : 0 = 0 \u2192 False :=\n                  match H2 in (_ = a) return (a = 0 \u2192 False) with\n                  | eq_refl =>\n                      fun H3 : n = 0 =>\n                      (fun H4 : n = 0 =>\n                       let H5 : n = 0 := H4 in\n                       eq_ind_r (fun _ : nat => False)\n                         (eq_ind_r (fun n0 : nat => n0 = 0 \u2192 False)\n                            (fun H6 : 0 = 0 => ?Goal1@{H0:=H6}) H2 H4) H5) H3\n                  end in\n                H3 eq_refl)\n               :\n               n \u2260 0) (fun (m0 : nat) (IHm : n \u2260 m0) => ?Goal0@{m:=m0}) m\n            :\n            n = m \u2192 False) H1)) H0\n   | Tle_S _ m0 x =>\n       (fun (m' : nat) (H1 : n \u2264 m') (H0 : S m' = m) =>\n        (fun (H2 : S m' = m) (H3 : n \u2264 m') => ?Goal@{H1:=H3}) H0 H1) m0 x\n   end in\n H0 eq_refl)"], "proof_term_after": ["(fun n m : nat =>\n nat_rec (fun m0 : nat => \u2200 n0 : nat, S n0 \u2264 S m0 \u2192 n0 \u2264 m0)\n   (fun (n0 : nat) (H : S n0 \u2264 1) =>\n    nat_rec (fun n1 : nat => S n1 \u2264 1 \u2192 n1 \u2264 0)\n      (fun H0 : 1 \u2264 1 =>\n       let H1 :=\n         match H0 in (_ \u2264 n1) return (n1 = 1 \u2192 0 \u2264 0) with\n         | Tle_n _ => fun H1 : 1 = 1 => (fun _ : 1 = 1 => ?Goal1@{H:=H0}) H1\n         | Tle_S _ m0 x =>\n             (fun (m1 : nat) (H1 : 1 \u2264 m1) (H2 : S m1 = 1) =>\n              (fun H3 : S m1 = 1 =>\n               let H4 : m1 = 0 :=\n                 f_equal\n                   (fun e : nat => match e with\n                                   | 0 => m1\n                                   | S n1 => n1\n                                   end) H3 in\n               (fun H5 : m1 = 0 =>\n                let H6 : m1 = 0 := H5 in\n                eq_rec_r (fun n1 : nat => 1 \u2264 n1 \u2192 0 \u2264 0)\n                  (fun H7 : 1 \u2264 0 => ?Goal2@{H:=H0; m:=m1; H1:=H7; H0:=H5})\n                  H6) H4) H2 H1) m0 x\n         end in\n       H1 eq_refl)\n      (fun (n1 : nat) (IHn : S n1 \u2264 1 \u2192 n1 \u2264 0) (H0 : S (S n1) \u2264 1) =>\n       ?Goal0@{n:=n1; H:=H0}) n0 H)\n   (fun (m0 : nat) (IHm : \u2200 n0 : nat, S n0 \u2264 S m0 \u2192 n0 \u2264 m0) => ?Goal@{m:=m0})\n   m n)"]}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Algebras/Algebras.v", "name": "Algebra_Hom_compose_assoc", "text": "Theorem Algebra_Hom_compose_assoc\n          {alg alg' alg'' alg''' : Algebra}\n          (f : Algebra_Hom alg alg')\n          (g : Algebra_Hom alg' alg'')\n          (h : Algebra_Hom alg'' alg''') :\n    (Algebra_Hom_compose f (Algebra_Hom_compose g h))\n    = (Algebra_Hom_compose (Algebra_Hom_compose f g) h).\n  Proof.\n    apply Algebra_Hom_eq_simplify; cbn; auto.\n  Qed.\n", "definition": " Algebra}\n          (f : Algebra_Hom alg alg')\n          (g : Algebra_Hom alg' alg'')\n          (h : Algebra_Hom alg'' alg''') :\n    (Algebra_Hom_compose f (Algebra_Hom_compose g h))\n    = (Algebra_Hom_compose (Algebra_Hom_compose f g) h).\n  ", "proof": "\n    apply Algebra_Hom_eq_simplify; cbn; auto.\n  ", "def_ranges": [87, 0, 93, 56], "proof_ranges": [94, 0, 96, 6], "proof_steps": [{"text": "apply Algebra_Hom_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Algebras/Algebras.v", "name": "Algebra_Hom_id_unit_left", "text": "Theorem Algebra_Hom_id_unit_left\n          {alg alg' : Algebra}\n          (f : Algebra_Hom alg alg') :\n    (Algebra_Hom_compose f (Algebra_Hom_id alg')) = f.\n  Proof.\n    apply Algebra_Hom_eq_simplify; cbn; auto.\n  Qed.\n", "definition": " Algebra}\n          (f : Algebra_Hom alg alg') :\n    (Algebra_Hom_compose f (Algebra_Hom_id alg')) = f.\n  ", "proof": "\n    apply Algebra_Hom_eq_simplify; cbn; auto.\n  ", "def_ranges": [105, 0, 108, 54], "proof_ranges": [109, 0, 111, 6], "proof_steps": [{"text": "apply Algebra_Hom_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Algebras/Algebras.v", "name": "Algebra_Hom_id_unit_right", "text": "Theorem Algebra_Hom_id_unit_right\n          {alg alg' : Algebra}\n          (f : Algebra_Hom alg alg') :\n    (Algebra_Hom_compose (Algebra_Hom_id alg) f) = f.\n  Proof.\n    apply Algebra_Hom_eq_simplify; cbn; auto.\n  Qed.\n", "definition": " Algebra}\n          (f : Algebra_Hom alg alg') :\n    (Algebra_Hom_compose (Algebra_Hom_id alg) f) = f.\n  ", "proof": "\n    apply Algebra_Hom_eq_simplify; cbn; auto.\n  ", "def_ranges": [114, 0, 117, 53], "proof_ranges": [118, 0, 120, 6], "proof_steps": [{"text": "apply Algebra_Hom_eq_simplify; cbn; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/KanExt/GlobaltoLocal.v", "name": "Cone_Morph_to_Cone_for_LoKan_Unique", "text": "Theorem Cone_Morph_to_Cone_for_LoKan_Unique : (M = M' :> (_ \u2013\u227b _)%nattrans).\n    Proof.\n      rewrite (Cone_Morph_to_Cone_for_LoKan_adj_unit_rke_id Cn M).\n      rewrite (Cone_Morph_to_Cone_for_LoKan_adj_unit_rke_id Cn M').\n      do 2 apply f_equal.\n      set (H := cone_morph_com M'); rewrite (cone_morph_com M) in H; exact H.\n    Qed.\n", "definition": " (M = M' :> (_ \u2013\u227b _)%nattrans).\n    ", "proof": "\n      rewrite (Cone_Morph_to_Cone_for_LoKan_adj_unit_rke_id Cn M).\n      rewrite (Cone_Morph_to_Cone_for_LoKan_adj_unit_rke_id Cn M').\n      do 2 apply f_equal.\n      set (H := cone_morph_com M'); rewrite (cone_morph_com M) in H; exact H.\n    ", "def_ranges": [116, 0, 116, 80], "proof_ranges": [117, 0, 122, 8], "proof_steps": [{"text": "rewrite (Cone_Morph_to_Cone_for_LoKan_adj_unit_rke_id Cn M).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite (Cone_Morph_to_Cone_for_LoKan_adj_unit_rke_id Cn M').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "do 2 apply f_equal.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "set (H := cone_morph_com M'); rewrite (cone_morph_com M) in H; exact H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/KanExt/LocalFacts/HomToCones.v", "name": "Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone_unique", "text": "Theorem\n      Hom_Local_Right_KanExt_to_Local_Right_KanExt_Morph_to_Terminal_Cone_unique\n      : h = h' :> (_ \u2013\u227b _)%nattrans.\n    Proof.\n      set (Mh :=\n             equal_f\n               (@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn h)\n               (Trans (inverse_morphism (HLRKE_Iso hlrke))\n                      hlrke (NatTrans_id hlrke))\n          ).\n      set (Mh' :=\n             equal_f\n               (@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn h')\n               (Trans (inverse_morphism\n                         (HLRKE_Iso hlrke)) hlrke (NatTrans_id hlrke))\n          ).\n      cbn in Mh, Mh'.\n      cbn_rewrite ((f_equal\n                      (fun w :\n                           ((@Fix_Bi_Func_2\n                               _ (Func_Cat _ _) _ hlrke (Hom_Func _))\n                              \u2013\u227b (@Fix_Bi_Func_2\n                                    _ (Func_Cat _ _) _ hlrke (Hom_Func _))\n                           )%nattrans\n                       => Trans w hlrke (NatTrans_id _))\n                      (right_inverse (HLRKE_Iso hlrke)))) in Mh Mh'.\n      repeat rewrite NatTrans_id_unit_left in Mh, Mh'.\n      destruct Mh; destruct Mh'.\n      apply f_equal.\n      etransitivity;\n        [symmetry; apply (cone_morph_com h) | apply (cone_morph_com h')].\n    Qed.\n", "definition": " h = h' :> (_ \u2013\u227b _)%nattrans.\n    ", "proof": "\n      set (Mh :=\n             equal_f\n               (@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn h)\n               (Trans (inverse_morphism (HLRKE_Iso hlrke))\n                      hlrke (NatTrans_id hlrke))\n          ).\n      set (Mh' :=\n             equal_f\n               (@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn h')\n               (Trans (inverse_morphism\n                         (HLRKE_Iso hlrke)) hlrke (NatTrans_id hlrke))\n          ).\n      cbn in Mh, Mh'.\n      cbn_rewrite ((f_equal\n                      (fun w :\n                           ((@Fix_Bi_Func_2\n                               _ (Func_Cat _ _) _ hlrke (Hom_Func _))\n                              \u2013\u227b (@Fix_Bi_Func_2\n                                    _ (Func_Cat _ _) _ hlrke (Hom_Func _))\n                           )%nattrans\n                       => Trans w hlrke (NatTrans_id _))\n                      (right_inverse (HLRKE_Iso hlrke)))) in Mh Mh'.\n      repeat rewrite NatTrans_id_unit_left in Mh, Mh'.\n      destruct Mh; destruct Mh'.\n      apply f_equal.\n      etransitivity;\n        [symmetry; apply (cone_morph_com h) | apply (cone_morph_com h')].\n    ", "def_ranges": [106, 0, 108, 36], "proof_ranges": [109, 0, 137, 8], "proof_steps": [{"text": "set (Mh :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "equal_f", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn h)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Trans (inverse_morphism (HLRKE_Iso hlrke))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "hlrke (NatTrans_id hlrke))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ").", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "set (Mh' :=", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "equal_f", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(@Trans_com _ _ _ _ (iso_morphism (HLRKE_Iso hlrke)) hlrke Cn h')", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Trans (inverse_morphism", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(HLRKE_Iso hlrke)) hlrke (NatTrans_id hlrke))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ").", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn in Mh, Mh'.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn_rewrite ((f_equal", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(fun w :", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((@Fix_Bi_Func_2", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "_ (Func_Cat _ _) _ hlrke (Hom_Func _))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "\u2013\u227b (@Fix_Bi_Func_2", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/KanExt/LocalFacts/Uniqueness.v", "name": "LoKan_Cone_Morph_eq_simplify", "text": "Theorem LoKan_Cone_Morph_eq_simplify : M = M' :> (_ \u2013\u227b _)%nattrans \u2192 M = M'.\n    Proof.\n      intros H.\n      destruct M; destruct M'; cbn in *.\n      ElimEq.\n      PIR.\n      trivial.\n    Qed.      \n", "definition": " M = M' :> (_ \u2013\u227b _)%nattrans \u2192 M = M'.\n    ", "proof": "\n      intros H.\n      destruct M; destruct M'; cbn in *.\n      ElimEq.\n      PIR.\n      trivial.\n    ", "def_ranges": [29, 0, 29, 80], "proof_ranges": [30, 0, 36, 8], "proof_steps": [{"text": "intros H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct M; destruct M'; cbn in *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "ElimEq.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "PIR.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/KanExt/LocalFacts/Uniqueness.v", "name": "LoKan_Cone_Morph_compose_assoc", "text": "Theorem LoKan_Cone_Morph_compose_assoc :\n      LoKan_Cone_Morph_compose h (LoKan_Cone_Morph_compose h' h'') =\n      LoKan_Cone_Morph_compose (LoKan_Cone_Morph_compose h h') h''.\n    Proof.\n      apply LoKan_Cone_Morph_eq_simplify.\n      apply NatTrans_compose_assoc.\n    Qed.      \n", "definition": "\n      LoKan_Cone_Morph_compose h (LoKan_Cone_Morph_compose h' h'') =\n      LoKan_Cone_Morph_compose (LoKan_Cone_Morph_compose h h') h''.\n    ", "proof": "\n      apply LoKan_Cone_Morph_eq_simplify.\n      apply NatTrans_compose_assoc.\n    ", "def_ranges": [83, 0, 85, 67], "proof_ranges": [86, 0, 89, 8], "proof_steps": [{"text": "apply LoKan_Cone_Morph_eq_simplify.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply NatTrans_compose_assoc.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/KanExt/LocalFacts/Uniqueness.v", "name": "LoKan_id_Cone_Morph_unit_right", "text": "Theorem LoKan_id_Cone_Morph_unit_right :\n      LoKan_Cone_Morph_compose (LoKan_id_Cone_Morph _) h = h.\n    Proof.    \n      apply LoKan_Cone_Morph_eq_simplify.\n      apply NatTrans_id_unit_right.\n    Qed.\n", "definition": "\n      LoKan_Cone_Morph_compose (LoKan_id_Cone_Morph _) h = h.\n    ", "proof": "    \n      apply LoKan_Cone_Morph_eq_simplify.\n      apply NatTrans_id_unit_right.\n    ", "def_ranges": [97, 0, 98, 61], "proof_ranges": [99, 0, 102, 8], "proof_steps": [{"text": "apply LoKan_Cone_Morph_eq_simplify.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply NatTrans_id_unit_right.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/KanExt/LocalFacts/Uniqueness.v", "name": "LoKan_id_Cone_Morph_unit_left", "text": "Theorem LoKan_id_Cone_Morph_unit_left :\n      LoKan_Cone_Morph_compose h (LoKan_id_Cone_Morph _) = h.\n    Proof.    \n      apply LoKan_Cone_Morph_eq_simplify.\n      apply NatTrans_id_unit_left.\n    Qed.\n", "definition": "\n      LoKan_Cone_Morph_compose h (LoKan_id_Cone_Morph _) = h.\n    ", "proof": "    \n      apply LoKan_Cone_Morph_eq_simplify.\n      apply NatTrans_id_unit_left.\n    ", "def_ranges": [104, 0, 105, 61], "proof_ranges": [106, 0, 109, 8], "proof_steps": [{"text": "apply LoKan_Cone_Morph_eq_simplify.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply NatTrans_id_unit_left.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/KanExt/LocalFacts/Uniqueness.v", "name": "Local_Right_KanExt_unique", "text": "Theorem Local_Right_KanExt_unique :\n      ((LRKE rke) \u2243\u2243 (LRKE rke') ::> LoKan_Cone_Cat)%isomorphism.\n    Proof (\n        Terminal_iso\n          (Local_Right_KanExt_terminal rke)\n          (Local_Right_KanExt_terminal rke')\n      ).\n      \n  End Local_Right_KanExt_unique.\n\n  (** If cones are isomorphic, then also are objects of their their images. *)\n  Section LoKan_Cone_Iso_object_Iso.\n    Context {Cn Cn' : LoKan_Cone p F}\n            (N : (Cn \u2243\u2243 Cn' ::> LoKan_Cone_Cat)%isomorphism).\n\n    Program Definition LoKan_Cone_Iso_object_Iso (c : C') :\n      (Cn _o c \u2243 Cn' _o c)%isomorphism :=\n      {|\n        iso_morphism := Trans (iso_morphism N) c;\n        inverse_morphism := Trans (inverse_morphism N) c\n      |}.\n\n    Next Obligation.\n    Proof.\n      change (Trans (inverse_morphism N) c \u2218 Trans (iso_morphism N) c)%morphism\n      with (Trans ((inverse_morphism N) \u2218 (iso_morphism N))%nattrans c).\n      cbn_rewrite (f_equal (cone_morph) (left_inverse N)); trivial.\n    Qed.\n", "definition": "\n      ((LRKE rke) \u2243\u2243 (LRKE rke') ::> LoKan_Cone_Cat)%isomorphism.\n    Proof (\n        Terminal_iso\n          (Local_Right_KanExt_terminal rke)\n          (Local_Right_KanExt_terminal rke')\n      ).\n      \n  End Local_Right_KanExt_unique.\n\n  (** If cones are isomorphic, then also are objects of their their images. *)\n  Section LoKan_Cone_Iso_object_Iso.\n    Context {Cn Cn' : LoKan_Cone p F}\n            (N : (Cn \u2243\u2243 Cn' ::> LoKan_Cone_Cat)%isomorphism).\n\n    Program Definition LoKan_Cone_Iso_object_Iso (c : C') :\n      (Cn _o c \u2243 Cn' _o c)%isomorphism :=\n      {|\n        iso_morphism := Trans (iso_morphism N) c;\n        inverse_morphism := Trans (inverse_morphism N) c\n      |}.\n\n    Next Obligation.\n    ", "proof": "\n      change (Trans (inverse_morphism N) c \u2218 Trans (iso_morphism N) c)%morphism\n      with (Trans ((inverse_morphism N) \u2218 (iso_morphism N))%nattrans c).\n      cbn_rewrite (f_equal (cone_morph) (left_inverse N)); trivial.\n    ", "def_ranges": [157, 0, 158, 65], "proof_ranges": [159, 0, 184, 8], "proof_steps": [{"text": "change (Trans (inverse_morphism N) c \u2218 Trans (iso_morphism N) c)%morphism", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with (Trans ((inverse_morphism N) \u2218 (iso_morphism N))%nattrans c).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cbn_rewrite (f_equal (cone_morph) (left_inverse N)); trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Basic_Cons/Equalizer.v", "name": "Equalizer_iso", "text": "Theorem Equalizer_iso (e1 e2 : Equalizer) : (e1 \u2243 e2)%isomorphism.\n  Proof.\n    apply (Build_Isomorphism _ _ _ (equalizer_morph_ex e2 _ (equalizer_morph e1)\n                                                       (equalizer_morph_com e1))\n                             ((equalizer_morph_ex e1 _ (equalizer_morph e2)\n                                                  (equalizer_morph_com e2))));\n    eapply equalizer_morph_unique; [| | simpl_ids; trivial| | |simpl_ids;\n                                      trivial]; try apply equalizer_morph_com;\n    rewrite <- assoc; repeat rewrite equalizer_morph_ex_com; auto.\n  Qed.\n", "definition": " Equalizer) : (e1 \u2243 e2)%isomorphism.\n  ", "proof": "\n    apply (Build_Isomorphism _ _ _ (equalizer_morph_ex e2 _ (equalizer_morph e1)\n                                                       (equalizer_morph_com e1))\n                             ((equalizer_morph_ex e1 _ (equalizer_morph e2)\n                                                  (equalizer_morph_com e2))));\n    eapply equalizer_morph_unique; [| | simpl_ids; trivial| | |simpl_ids;\n                                      trivial]; try apply equalizer_morph_com;\n    rewrite <- assoc; repeat rewrite equalizer_morph_ex_com; auto.\n  ", "def_ranges": [54, 0, 54, 68], "proof_ranges": [55, 0, 63, 6], "proof_steps": [{"text": "apply (Build_Isomorphism _ _ _ (equalizer_morph_ex e2 _ (equalizer_morph e1)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(equalizer_morph_com e1))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "((equalizer_morph_ex e1 _ (equalizer_morph e2)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(equalizer_morph_com e2))));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply equalizer_morph_unique; [| | simpl_ids; trivial| | |simpl_ids;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Basic_Cons/Exponential.v", "name": "Exponential_iso", "text": "Theorem Exponential_iso {C : Category} {HP : Has_Products C} (c d : C)\n        (E E' : (c \u21d1 d)%object) : (E \u2243 E')%isomorphism.\nProof.\n  eapply\n    (\n      Build_Isomorphism\n        _\n        _\n        _\n        (Exp_morph_ex E' _ (eval E))\n        (Exp_morph_ex E _ (eval E'))\n    );\n  eapply Exp_morph_unique; eauto;\n  simpl_ids;\n  match goal with\n      [|- (_ \u2218 ?M)%morphism = _] =>\n      match M with\n        (?U _a (?A \u2218 ?B, ?C))%morphism =>\n        assert (M = (U @_a (_, _) (_, _) (A, C))\n                          \u2218 (U @_a (_, _) (_, _) (B, C)))%morphism as HM;\n          [simpl_ids; rewrite <- F_compose; simpl; simpl_ids; trivial|rewrite HM]\n      end\n  end;\n  rewrite <- assoc;\n  repeat rewrite <- Exp_morph_com; auto.\nQed.\n", "definition": " Category} {HP : Has_Products C} (c d : C)\n        (E E' : (c \u21d1 d)%object) : (E \u2243 E')%isomorphism.\n", "proof": "\n  eapply\n    (\n      Build_Isomorphism\n        _\n        _\n        _\n        (Exp_morph_ex E' _ (eval E))\n        (Exp_morph_ex E _ (eval E'))\n    );\n  eapply Exp_morph_unique; eauto;\n  simpl_ids;\n  match goal with\n      [|- (_ \u2218 ?M)%morphism = _] =>\n      match M with\n        (?U _a (?A \u2218 ?B, ?C))%morphism =>\n        assert (M = (U @_a (_, _) (_, _) (A, C))\n                          \u2218 (U @_a (_, _) (_, _) (B, C)))%morphism as HM;\n          [simpl_ids; rewrite <- F_compose; simpl; simpl_ids; trivial|rewrite HM]\n      end\n  end;\n  rewrite <- assoc;\n  repeat rewrite <- Exp_morph_com; auto.\n", "def_ranges": [72, 0, 73, 55], "proof_ranges": [74, 0, 97, 4], "proof_steps": [{"text": "eapply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Build_Isomorphism", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "_", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "_", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "_", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Exp_morph_ex E' _ (eval E))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Exp_morph_ex E _ (eval E'))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ");", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply Exp_morph_unique; eauto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "simpl_ids;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "match goal with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Basic_Cons/Exponential.v", "name": "curry_uncurry", "text": "Theorem curry_uncurry (f : a \u2013\u227b (HE b c)) : curry (uncurry f) = f.\n    Proof.\n      unfold curry, uncurry.\n      eapply Exp_morph_unique; trivial.\n      rewrite <- Exp_morph_com; trivial.\n    Qed.\n", "definition": " a \u2013\u227b (HE b c)) : curry (uncurry f) = f.\n    ", "proof": "\n      unfold curry, uncurry.\n      eapply Exp_morph_unique; trivial.\n      rewrite <- Exp_morph_com; trivial.\n    ", "def_ranges": [128, 0, 128, 70], "proof_ranges": [129, 0, 133, 8], "proof_steps": [{"text": "unfold curry, uncurry.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply Exp_morph_unique; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- Exp_morph_com; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Basic_Cons/Exponential.v", "name": "uncurry_injective", "text": "Theorem uncurry_injective (f g : a \u2013\u227b (HE b c)) :\n      uncurry f = uncurry g \u2192 f = g.\n    Proof.\n      intros H.\n      rewrite <- (curry_uncurry f); rewrite <- (curry_uncurry g).\n      rewrite H; trivial.\n    Qed.\n", "definition": " a \u2013\u227b (HE b c)) :\n      uncurry f = uncurry g \u2192 f = g.\n    ", "proof": "\n      intros H.\n      rewrite <- (curry_uncurry f); rewrite <- (curry_uncurry g).\n      rewrite H; trivial.\n    ", "def_ranges": [161, 0, 162, 36], "proof_ranges": [163, 0, 167, 8], "proof_steps": [{"text": "intros H.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (curry_uncurry f); rewrite <- (curry_uncurry g).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite H; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Basic_Cons/Product.v", "name": "Product_iso", "text": "Theorem Product_iso {C : Category} (c d : Obj) (P : c \u00d7 d) (P' : c \u00d7 d)\n  : (P \u2243 P')%isomorphism.\nProof.\n  eapply (Build_Isomorphism _ _ _\n                            (Prod_morph_ex P' P Pi_1 Pi_2)\n                            (Prod_morph_ex P P' Pi_1 Pi_2));\n  eapply Prod_morph_unique; eauto;\n  rewrite <- assoc;\n  repeat (rewrite Prod_morph_com_1 || rewrite Prod_morph_com_2); auto.\nQed.\n", "definition": " Category} (c d : Obj) (P : c \u00d7 d) (P' : c \u00d7 d)\n  : (P \u2243 P')%isomorphism.\n", "proof": "\n  eapply (Build_Isomorphism _ _ _\n                            (Prod_morph_ex P' P Pi_1 Pi_2)\n                            (Prod_morph_ex P P' Pi_1 Pi_2));\n  eapply Prod_morph_unique; eauto;\n  rewrite <- assoc;\n  repeat (rewrite Prod_morph_com_1 || rewrite Prod_morph_com_2); auto.\n", "def_ranges": [79, 0, 80, 25], "proof_ranges": [81, 0, 88, 4], "proof_steps": [{"text": "eapply (Build_Isomorphism _ _ _", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Prod_morph_ex P' P Pi_1 Pi_2)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(Prod_morph_ex P P' Pi_1 Pi_2));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "eapply Prod_morph_unique; eauto;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/Categories/Basic_Cons/PullBack.v", "name": "PullBack_iso", "text": "Theorem PullBack_iso (p1 p2 : PullBack) : (p1 \u2243 p2)%isomorphism.\n  Proof.\n    apply\n      (\n        Build_Isomorphism\n          _\n          _\n          _\n          (\n            pullback_morph_ex\n              p2\n              _\n              (pullback_morph_1 p1)\n              (pullback_morph_2 p1)\n              (pullback_morph_com p1)\n          )\n          (\n            pullback_morph_ex\n              p1\n              _\n              (pullback_morph_1 p2)\n              (pullback_morph_2 p2)\n              (pullback_morph_com p2)\n          )\n      ); eapply pullback_morph_ex_unique;\n    match goal with\n      | [|- _ \u2218 id = _] => simpl_ids; trivial\n      | _ => idtac\n    end; try apply pullback_morph_com;\n    rewrite <- assoc;\n    repeat (rewrite pullback_morph_ex_com_1 || rewrite pullback_morph_ex_com_2);\n    trivial.\n  Qed.\n", "definition": " PullBack) : (p1 \u2243 p2)%isomorphism.\n  ", "proof": "\n    apply\n      (\n        Build_Isomorphism\n          _\n          _\n          _\n          (\n            pullback_morph_ex\n              p2\n              _\n              (pullback_morph_1 p1)\n              (pullback_morph_2 p1)\n              (pullback_morph_com p1)\n          )\n          (\n            pullback_morph_ex\n              p1\n              _\n              (pullback_morph_1 p2)\n              (pullback_morph_2 p2)\n              (pullback_morph_com p2)\n          )\n      ); eapply pullback_morph_ex_unique;\n    match goal with\n      | [|- _ \u2218 id = _] => simpl_ids; trivial\n      | _ => idtac\n    end; try apply pullback_morph_com;\n    rewrite <- assoc;\n    repeat (rewrite pullback_morph_ex_com_1 || rewrite pullback_morph_ex_com_2);\n    trivial.\n  ", "def_ranges": [114, 0, 114, 66], "proof_ranges": [115, 0, 146, 6], "proof_steps": [{"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Build_Isomorphism", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "_", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "_", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "_", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pullback_morph_ex", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "p2", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "_", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(pullback_morph_1 p1)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(pullback_morph_2 p1)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(pullback_morph_com p1)", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": ")", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pullback_morph_ex", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ruler-compass-geometry/D5_ParalleleConst.v", "name": "ParallelHalfLine", "text": "Theorem ParallelHalfLine : forall A B C D E : Point, \n\tforall H : Parallelogramm A B C D,\n\tHalfLine C D E ->\n\tClockwise A B E.\nProof.\n\tintros.\n\tdestruct (ExistsParallelogrammCenter A B C D H) as (I, H1).\n\tassert (H2 := ParallelogrammCenterClockwiseABI _ _ _ _ _ _ H1).\n\tassert (H3 := ParallelogrammCenterCongruentTriangles _ _ _ _ _ _ H1).\n\tassert (H4 := ParallelogrammCenterClockwiseICD _ _ _ _ _ _ H1).\n\tdestruct (CentralSymetPoint E I) as (F, (H5, H6)).\n \tintro; subst; elim (ClockwiseNotCollinear _ _ _ H4).\n \t  apply CollinearCAB; apply (HalfLineCollinear _ _ _ H0).\n \tassert (H7 : Clockwise C E I).\n \t apply H0; autoClockwise.\n \t assert (H8 : Clockwise F E A).\n \t  apply (ClockwiseBetweenMBC F E A I).\n \t   apply (BetweenSym _ _ _ H6).\n \t   destruct H1.\n \t     apply ClockwiseBCA; apply (EquiOrientedRev _ _ _ H1).\n \t     autoClockwise.\n \t  assert (CongruentStrictTriangles E I C F I A).\n \t   unfold ParallelogrammCenter in H1; apply CongruentOpposedStrictTriangles.\n \t    trivial.\n \t    apply BetweenSym; intuition.\n \t    autoDistance.\n \t    intuition.\n \t    intro; elim (ClockwiseNotCollinear _ _ _ H7); autoCollinear.\n \t   trivial.\n \t     assert (H10 : HalfLine A B F).\n \t    apply (AngleBHalfLine A B I F).\n \t     trivial.\n \t     apply ClockwiseCAB; apply (BetweenClockwiseAMC F E A I).\n \t      trivial.\n \t      apply BetweenSym; trivial.\n \t     rewrite\n \t      (CongruentStrictTrianglesA _ _ _ _ _ _\n \t         (CongruentStrictTrianglesACB _ _ _ _ _ _ H3)).\n \t       rewrite <- (CongruentStrictTrianglesC _ _ _ _ _ _ H9).\n \t       apply HalfLineAngleB.\n \t      autoDistinct.\n \t      autoDistinct.\n \t      trivial.\n \t    apply (HalfLineSym A B F).\n \t     autoDistinct.\n \t     trivial.\n \t     autoClockwise.\n Qed.\n", "definition": " forall A B C D E : Point, \n\tforall H : Parallelogramm A B C D,\n\tHalfLine C D E ->\n\tClockwise A B E.\n", "proof": "\n\tintros.\n\tdestruct (ExistsParallelogrammCenter A B C D H) as (I, H1).\n\tassert (H2 := ParallelogrammCenterClockwiseABI _ _ _ _ _ _ H1).\n\tassert (H3 := ParallelogrammCenterCongruentTriangles _ _ _ _ _ _ H1).\n\tassert (H4 := ParallelogrammCenterClockwiseICD _ _ _ _ _ _ H1).\n\tdestruct (CentralSymetPoint E I) as (F, (H5, H6)).\n \tintro; subst; elim (ClockwiseNotCollinear _ _ _ H4).\n \t  apply CollinearCAB; apply (HalfLineCollinear _ _ _ H0).\n \tassert (H7 : Clockwise C E I).\n \t apply H0; autoClockwise.\n \t assert (H8 : Clockwise F E A).\n \t  apply (ClockwiseBetweenMBC F E A I).\n \t   apply (BetweenSym _ _ _ H6).\n \t   destruct H1.\n \t     apply ClockwiseBCA; apply (EquiOrientedRev _ _ _ H1).\n \t     autoClockwise.\n \t  assert (CongruentStrictTriangles E I C F I A).\n \t   unfold ParallelogrammCenter in H1; apply CongruentOpposedStrictTriangles.\n \t    trivial.\n \t    apply BetweenSym; intuition.\n \t    autoDistance.\n \t    intuition.\n \t    intro; elim (ClockwiseNotCollinear _ _ _ H7); autoCollinear.\n \t   trivial.\n \t     assert (H10 : HalfLine A B F).\n \t    apply (AngleBHalfLine A B I F).\n \t     trivial.\n \t     apply ClockwiseCAB; apply (BetweenClockwiseAMC F E A I).\n \t      trivial.\n \t      apply BetweenSym; trivial.\n \t     rewrite\n \t      (CongruentStrictTrianglesA _ _ _ _ _ _\n \t         (CongruentStrictTrianglesACB _ _ _ _ _ _ H3)).\n \t       rewrite <- (CongruentStrictTrianglesC _ _ _ _ _ _ H9).\n \t       apply HalfLineAngleB.\n \t      autoDistinct.\n \t      autoDistinct.\n \t      trivial.\n \t    apply (HalfLineSym A B F).\n \t     autoDistinct.\n \t     trivial.\n \t     autoClockwise.\n ", "def_ranges": [113, 0, 116, 17], "proof_ranges": [117, 0, 160, 5], "proof_steps": [{"text": "intros.", "goal_before": ["forall A B C D E : Point,\nParallelogramm A B C D -> HalfLine C D E -> Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": [], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n => ?Goal)"]}, {"text": "destruct (ExistsParallelogrammCenter A B C D H) as (I, H1).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n => ?Goal)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) => ?Goal) x p)"]}, {"text": "assert (H2 := ParallelogrammCenterClockwiseABI _ _ _ _ _ _ H1).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) => ?Goal) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  ?Goal) x p)"]}, {"text": "assert (H3 := ParallelogrammCenterCongruentTriangles _ _ _ _ _ _ H1).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  ?Goal) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  ?Goal) x p)"]}, {"text": "assert (H4 := ParallelogrammCenterClockwiseICD _ _ _ _ _ _ H1).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  ?Goal) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  ?Goal) x p)"]}, {"text": "destruct (CentralSymetPoint E I) as (F, (H5, H6)).", "goal_before": ["Clockwise A B E"], "goal_after": ["E <> I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  ?Goal) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 := CentralSymetPoint E I ?Goal in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal0)\n         x1 x2\n   end) x0 p0) x p)"]}, {"text": "intro; subst; elim (ClockwiseNotCollinear _ _ _ H4).", "goal_before": ["E <> I", "Clockwise A B E"], "goal_after": ["Collinear I C D", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 := CentralSymetPoint E I ?Goal in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal0)\n         x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False (ClockwiseNotCollinear I C D H4 ?Goal0@{H0:=H6}))\n          H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal)\n         x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply CollinearCAB; apply (HalfLineCollinear _ _ _ H0).", "goal_before": ["Collinear I C D", "Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False (ClockwiseNotCollinear I C D H4 ?Goal0@{H0:=H6}))\n          H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal)\n         x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal)\n         x1 x2\n   end) x0 p0) x p)"]}, {"text": "assert (H7 : Clockwise C E I).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise C E I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal)\n         x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply H0; autoClockwise.", "goal_before": ["Clockwise C E I", "Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "assert (H8 : Clockwise F E A).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise F E A", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply (ClockwiseBetweenMBC F E A I).", "goal_before": ["Clockwise F E A", "Clockwise A B E"], "goal_after": ["Between F I E", "Clockwise I E A", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A := ClockwiseBetweenMBC F E A I ?Goal0 ?Goal1\n          in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply (BetweenSym _ _ _ H6).", "goal_before": ["Between F I E", "Clockwise I E A", "Clockwise A B E"], "goal_after": ["Clockwise I E A", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A := ClockwiseBetweenMBC F E A I ?Goal0 ?Goal1\n          in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6) ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "destruct H1.", "goal_before": ["Clockwise I E A", "Clockwise A B E"], "goal_after": ["Clockwise I E A", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6) ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (H9 : Distance I A = Distance I C)\n                 => ?Goal0@{H1:=H8; H8:=H9}) x3 x4\n            end in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply ClockwiseBCA; apply (EquiOrientedRev _ _ _ H1).", "goal_before": ["Clockwise I E A", "Clockwise A B E"], "goal_after": ["In Point (HalfPlane I C) E", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (H9 : Distance I A = Distance I C)\n                 => ?Goal0@{H1:=H8; H8:=H9}) x3 x4\n            end in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (H9 : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E ?Goal0@{H1:=H8; H8:=H9})) x3\n                  x4\n            end in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "autoClockwise.", "goal_before": ["In Point (HalfPlane I C) E", "Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (H9 : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E ?Goal0@{H1:=H8; H8:=H9})) x3\n                  x4\n            end in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "assert (CongruentStrictTriangles E I C F I A).", "goal_before": ["Clockwise A B E"], "goal_after": ["CongruentStrictTriangles E I C F I A", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A := ?Goal in ?Goal0) x1\n         x2\n   end) x0 p0) x p)"]}, {"text": "unfold ParallelogrammCenter in H1; apply CongruentOpposedStrictTriangles.", "goal_before": ["CongruentStrictTriangles E I C F I A", "Clockwise A B E"], "goal_after": ["Between E I F", "Between C I A", "Distance I E = Distance I F", "Distance I C = Distance I A", "~ Collinear E I C", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A := ?Goal in ?Goal0) x1\n         x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I \n            ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "trivial.", "goal_before": ["Between E I F", "Between C I A", "Distance I E = Distance I F", "Distance I C = Distance I A", "~ Collinear E I C", "Clockwise A B E"], "goal_after": ["Between C I A", "Distance I E = Distance I F", "Distance I C = Distance I A", "~ Collinear E I C", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I \n            ?Goal0 ?Goal1 ?Goal2 ?Goal3 ?Goal4 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6 \n            ?Goal0 ?Goal1 ?Goal2 ?Goal3 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply BetweenSym; intuition.", "goal_before": ["Between C I A", "Distance I E = Distance I F", "Distance I C = Distance I A", "~ Collinear E I C", "Clockwise A B E"], "goal_after": ["Distance I E = Distance I F", "Distance I C = Distance I A", "~ Collinear E I C", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6 \n            ?Goal0 ?Goal1 ?Goal2 ?Goal3 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1)) ?Goal0 ?Goal1 ?Goal2 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "autoDistance.", "goal_before": ["Distance I E = Distance I F", "Distance I C = Distance I A", "~ Collinear E I C", "Clockwise A B E"], "goal_after": ["Distance I C = Distance I A", "~ Collinear E I C", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1)) ?Goal0 ?Goal1 ?Goal2 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1) ?Goal0 \n            ?Goal1 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "intuition.", "goal_before": ["Distance I C = Distance I A", "~ Collinear E I C", "Clockwise A B E"], "goal_after": ["~ Collinear E I C", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1) ?Goal0 \n            ?Goal1 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1) \n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "intro; elim (ClockwiseNotCollinear _ _ _ H7); autoCollinear.", "goal_before": ["~ Collinear E I C", "Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1) \n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "trivial.", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "assert (H10 : HalfLine A B F).", "goal_before": ["Clockwise A B E"], "goal_after": ["HalfLine A B F", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply (AngleBHalfLine A B I F).", "goal_before": ["HalfLine A B F", "Clockwise A B E"], "goal_after": ["Clockwise A B I", "Clockwise A F I", "Angle B A I = Angle F A I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F ?Goal0 ?Goal1 ?Goal2 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "trivial.", "goal_before": ["Clockwise A B I", "Clockwise A F I", "Angle B A I = Angle F A I", "Clockwise A B E"], "goal_after": ["Clockwise A F I", "Angle B A I = Angle F A I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F ?Goal0 ?Goal1 ?Goal2 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F := AngleBHalfLine A B I F H2 ?Goal0 ?Goal1\n          in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply ClockwiseCAB; apply (BetweenClockwiseAMC F E A I).", "goal_before": ["Clockwise A F I", "Angle B A I = Angle F A I", "Clockwise A B E"], "goal_after": ["Clockwise F E A", "Between F I E", "Angle B A I = Angle F A I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F := AngleBHalfLine A B I F H2 ?Goal0 ?Goal1\n          in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A (BetweenClockwiseAMC F E A I ?Goal1 ?Goal2))\n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "trivial.", "goal_before": ["Clockwise F E A", "Between F I E", "Angle B A I = Angle F A I", "Clockwise A B E"], "goal_after": ["Between F I E", "Angle B A I = Angle F A I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A (BetweenClockwiseAMC F E A I ?Goal1 ?Goal2))\n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A (BetweenClockwiseAMC F E A I H8 ?Goal1))\n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply BetweenSym; trivial.", "goal_before": ["Between F I E", "Angle B A I = Angle F A I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle F A I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A (BetweenClockwiseAMC F E A I H8 ?Goal1))\n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6))) \n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "rewrite", "goal_before": ["Angle B A I = Angle F A I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle F A I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6))) \n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": []}, {"text": "(CongruentStrictTrianglesA _ _ _ _ _ _", "goal_before": ["Angle B A I = Angle F A I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle F A I", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6))) \n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "(CongruentStrictTrianglesACB _ _ _ _ _ _ H3)).", "goal_before": ["Angle B A I = Angle F A I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6))) \n            ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "rewrite <- (CongruentStrictTrianglesC _ _ _ _ _ _ H9).", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply HalfLineAngleB.", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "autoDistinct.", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "autoDistinct.", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "trivial.", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply (HalfLineSym A B F).", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "autoDistinct.", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "trivial.", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": ["Angle B A I = Angle E C I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "autoClockwise.", "goal_before": ["Angle B A I = Angle E C I", "Clockwise A B E"], "goal_after": [], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine C D E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine C D E0 -> False)\n          (fun H6 : HalfLine C D I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCAB C D I (HalfLineCollinear C D I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise C E I :=\n          H0 I\n            (and_ind\n               (fun (_ : E <> I)\n                  (_ : forall x3 : Point,\n                       Clockwise E I x3 -> Clockwise I F x3) =>\n                ClockwiseBCA I C D H4) H6\n             :\n             In Point (HalfPlane C D) I) in\n        let H8 : Clockwise F E A :=\n          ClockwiseBetweenMBC F E A I (BetweenSym E I F H6)\n            match H1 with\n            | conj x3 x4 =>\n                (fun (H8 : Between A I C) (_ : Distance I A = Distance I C)\n                 =>\n                 ClockwiseBCA A I E\n                   (EquiOrientedRev A I C H8 E\n                      (and_ind\n                         (fun (_ : A <> I)\n                            (_ : forall x5 : Point,\n                                 Clockwise A I x5 -> Clockwise I C x5) =>\n                          and_ind\n                            (fun (_ : E <> I)\n                               (_ : forall x5 : Point,\n                                    Clockwise E I x5 -> Clockwise I F x5) =>\n                             ClockwiseCAB C E I H7) H6) H8\n                       :\n                       In Point (HalfPlane I C) E))) x3 x4\n            end in\n        let H9 : CongruentStrictTriangles E I C F I A :=\n          CongruentOpposedStrictTriangles E C F A I H6\n            (BetweenSym A I C\n               (and_ind\n                  (fun (H9 : Between A I C) (_ : Distance I A = Distance I C)\n                   => H9) H1))\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                =>\n                eq_ind_r\n                  (fun l : LS =>\n                   Distance I A = Distance I C -> l = Distance I F)\n                  (eq_ind_r\n                     (fun l : LS =>\n                      Distance I A = Distance I C -> l = Distance I F)\n                     ((fun (_ : Distance E I = Distance I F)\n                         (_ : Distance I A = Distance I C) => eq_refl) H5) H5)\n                  (DistSym I E) H10\n                :\n                Distance I E = Distance I F) H1)\n            (and_ind\n               (fun (_ : Between A I C) (H10 : Distance I A = Distance I C)\n                => eq_sym H10 : Distance I C = Distance I A) H1)\n            ((fun H9 : Collinear E I C =>\n              False_ind False\n                (ClockwiseNotCollinear C E I H7\n                   (and_ind\n                      (fun\n                         (H10 : A <> I /\\\n                                (forall x3 : Point,\n                                 Clockwise A I x3 -> Clockwise I C x3))\n                         (_ : Distance I A = Distance I C) =>\n                       and_ind\n                         (fun (_ : E <> I)\n                            (_ : forall x3 : Point,\n                                 Clockwise E I x3 -> Clockwise I F x3) =>\n                          and_ind\n                            (fun (_ : A <> I)\n                               (_ : forall x3 : Point,\n                                    Clockwise A I x3 -> Clockwise I C x3) =>\n                             CollinearCAB E I C H9) H10) H6) H1\n                    :\n                    Collinear C E I)))\n             :\n             ~ Collinear E I C) in\n        let H10 : HalfLine A B F :=\n          AngleBHalfLine A B I F H2\n            (ClockwiseCAB F I A\n               (BetweenClockwiseAMC F E A I H8 (BetweenSym E I F H6)))\n            (eq_ind (Angle E C I) (fun a0 : AS => Angle B A I = a0) \n               ?Goal0 (Angle F A I)\n               (CongruentStrictTrianglesC E I C F I A H9)) in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ruler-compass-geometry/D5_ParalleleConst.v", "name": "HalfLineParallel", "text": "Theorem HalfLineParallel : forall A B C D E : Point,\n\tforall H : Parallelogramm A B C D,\n\tHalfLine D C E ->\n\tClockwise A B E.\nProof.\n\tintros.\n\tdestruct (ExistsParallelogrammCenter A B C D H) as (I, H1).\n\tassert (H2 := ParallelogrammCenterClockwiseABI _ _ _ _ _ _ H1).\n\tassert (H3 := ParallelogrammCenterCongruentTriangles _ _ _ _ _ _ H1).\n\tassert (H4 := ParallelogrammCenterClockwiseICD _ _ _ _ _ _ H1).\n\tdestruct (CentralSymetPoint E I) as (F, (H5, H6)).\n\t intro; subst; elim (ClockwiseNotCollinear _ _ _ H4).\n\t   apply CollinearCBA; apply (HalfLineCollinear _ _ _ H0).\n\t assert (H7 : Clockwise E D I).\n\t  generalizeChangeSense.\n\t    apply H6; autoClockwise.\n\t  assert (H8 : Clockwise E F B).\n\t   apply (ClockwiseBetweenAMC E F B I).\n\t    trivial.\n\t    assert\n\t     (H8 := BetweenSym _ _ _ (ParallelogrammCenterBetweenBID _ _ _ _ _ _ H1)).\n\t      apply ClockwiseCAB; canonize.\n\t      apply H11; autoClockwise.\n\t   assert (CongruentStrictTriangles D I E B I F).\n\t    unfold ParallelogrammCenter in H1; apply CongruentOpposedStrictTriangles.\n\t     apply (BetweenSym B I D (ParallelogrammCenterBetweenBID A B C D I H H1)).\n\t     trivial.\n\t     assert (H9 := ParallelogrammCenterMidPointBD A B C D I H H1); auto.\n\t     autoDistance.\n\t     intro; elim (ClockwiseNotCollinear _ _ _ H7); autoCollinear.\n\t    assert (H10 : HalfLine B A F).\n\t     apply (AngleCHalfLine B I A F).\n\t      autoClockwise.\n\t      apply ClockwiseCAB; apply (BetweenClockwiseMBC E F B I); trivial.\n\t      rewrite\n\t       (CongruentStrictTrianglesB _ _ _ _ _ _\n\t          (CongruentStrictTrianglesBCA _ _ _ _ _ _ H3)).\n\t        rewrite <- (CongruentStrictTrianglesA _ _ _ _ _ _ H9).\n\t        apply HalfLineAngleC.\n\t       autoDistinct.\n\t       autoDistinct.\n\t       trivial.\n\t     generalizeChangeSide.\n\t       apply H12.\n\t      autoDistinct.\n\t      autoClockwise.\nQed.\n", "definition": " forall A B C D E : Point,\n\tforall H : Parallelogramm A B C D,\n\tHalfLine D C E ->\n\tClockwise A B E.\n", "proof": "\n\tintros.\n\tdestruct (ExistsParallelogrammCenter A B C D H) as (I, H1).\n\tassert (H2 := ParallelogrammCenterClockwiseABI _ _ _ _ _ _ H1).\n\tassert (H3 := ParallelogrammCenterCongruentTriangles _ _ _ _ _ _ H1).\n\tassert (H4 := ParallelogrammCenterClockwiseICD _ _ _ _ _ _ H1).\n\tdestruct (CentralSymetPoint E I) as (F, (H5, H6)).\n\t intro; subst; elim (ClockwiseNotCollinear _ _ _ H4).\n\t   apply CollinearCBA; apply (HalfLineCollinear _ _ _ H0).\n\t assert (H7 : Clockwise E D I).\n\t  generalizeChangeSense.\n\t    apply H6; autoClockwise.\n\t  assert (H8 : Clockwise E F B).\n\t   apply (ClockwiseBetweenAMC E F B I).\n\t    trivial.\n\t    assert\n\t     (H8 := BetweenSym _ _ _ (ParallelogrammCenterBetweenBID _ _ _ _ _ _ H1)).\n\t      apply ClockwiseCAB; canonize.\n\t      apply H11; autoClockwise.\n\t   assert (CongruentStrictTriangles D I E B I F).\n\t    unfold ParallelogrammCenter in H1; apply CongruentOpposedStrictTriangles.\n\t     apply (BetweenSym B I D (ParallelogrammCenterBetweenBID A B C D I H H1)).\n\t     trivial.\n\t     assert (H9 := ParallelogrammCenterMidPointBD A B C D I H H1); auto.\n\t     autoDistance.\n\t     intro; elim (ClockwiseNotCollinear _ _ _ H7); autoCollinear.\n\t    assert (H10 : HalfLine B A F).\n\t     apply (AngleCHalfLine B I A F).\n\t      autoClockwise.\n\t      apply ClockwiseCAB; apply (BetweenClockwiseMBC E F B I); trivial.\n\t      rewrite\n\t       (CongruentStrictTrianglesB _ _ _ _ _ _\n\t          (CongruentStrictTrianglesBCA _ _ _ _ _ _ H3)).\n\t        rewrite <- (CongruentStrictTrianglesA _ _ _ _ _ _ H9).\n\t        apply HalfLineAngleC.\n\t       autoDistinct.\n\t       autoDistinct.\n\t       trivial.\n\t     generalizeChangeSide.\n\t       apply H12.\n\t      autoDistinct.\n\t      autoClockwise.\n", "def_ranges": [162, 0, 165, 17], "proof_ranges": [166, 0, 208, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall A B C D E : Point,\nParallelogramm A B C D -> HalfLine D C E -> Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": [], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n => ?Goal)"]}, {"text": "destruct (ExistsParallelogrammCenter A B C D H) as (I, H1).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n => ?Goal)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) => ?Goal) x p)"]}, {"text": "assert (H2 := ParallelogrammCenterClockwiseABI _ _ _ _ _ _ H1).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) => ?Goal) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  ?Goal) x p)"]}, {"text": "assert (H3 := ParallelogrammCenterCongruentTriangles _ _ _ _ _ _ H1).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  ?Goal) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  ?Goal) x p)"]}, {"text": "assert (H4 := ParallelogrammCenterClockwiseICD _ _ _ _ _ _ H1).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  ?Goal) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  ?Goal) x p)"]}, {"text": "destruct (CentralSymetPoint E I) as (F, (H5, H6)).", "goal_before": ["Clockwise A B E"], "goal_after": ["E <> I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  ?Goal) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 := CentralSymetPoint E I ?Goal in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal0)\n         x1 x2\n   end) x0 p0) x p)"]}, {"text": "intro; subst; elim (ClockwiseNotCollinear _ _ _ H4).", "goal_before": ["E <> I", "Clockwise A B E"], "goal_after": ["Collinear I C D", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 := CentralSymetPoint E I ?Goal in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal0)\n         x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False (ClockwiseNotCollinear I C D H4 ?Goal0@{H0:=H6}))\n          H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal)\n         x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply CollinearCBA; apply (HalfLineCollinear _ _ _ H0).", "goal_before": ["Collinear I C D", "Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False (ClockwiseNotCollinear I C D H4 ?Goal0@{H0:=H6}))\n          H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal)\n         x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal)\n         x1 x2\n   end) x0 p0) x p)"]}, {"text": "assert (H7 : Clockwise E D I).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise E D I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) => ?Goal)\n         x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"]}, {"text": "generalizeChangeSense.", "goal_before": ["Clockwise E D I", "Clockwise A B E"], "goal_after": ["Clockwise E D I", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (H7 : E <> I)\n               (H8 : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (H9 : forall x3 : Point,\n                       Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               ?Goal0@{H0:=H9; H6:=H10})\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply H6; autoClockwise.", "goal_before": ["Clockwise E D I", "Clockwise A B E"], "goal_after": ["Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (H7 : E <> I)\n               (H8 : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (H9 : forall x3 : Point,\n                       Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               ?Goal0@{H0:=H9; H6:=H10})\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (_ : E <> I)\n               (_ : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (_ : forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               H10 I (ClockwiseBCA I C D H4 : Clockwise C D I))\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "assert (H8 : Clockwise E F B).", "goal_before": ["Clockwise A B E"], "goal_after": ["Clockwise E F B", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (_ : E <> I)\n               (_ : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (_ : forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               H10 I (ClockwiseBCA I C D H4 : Clockwise C D I))\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (_ : E <> I)\n               (_ : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (_ : forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               H10 I (ClockwiseBCA I C D H4 : Clockwise C D I))\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        let H8 : Clockwise E F B := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"]}, {"text": "apply (ClockwiseBetweenAMC E F B I).", "goal_before": ["Clockwise E F B", "Clockwise A B E"], "goal_after": ["Between E I F", "Clockwise E I B", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (_ : E <> I)\n               (_ : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (_ : forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               H10 I (ClockwiseBCA I C D H4 : Clockwise C D I))\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        let H8 : Clockwise E F B := ?Goal in ?Goal0) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (_ : E <> I)\n               (_ : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (_ : forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               H10 I (ClockwiseBCA I C D H4 : Clockwise C D I))\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        let H8 : Clockwise E F B := ClockwiseBetweenAMC E F B I ?Goal0 ?Goal1\n          in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "trivial.", "goal_before": ["Between E I F", "Clockwise E I B", "Clockwise A B E"], "goal_after": ["Clockwise E I B", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (_ : E <> I)\n               (_ : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (_ : forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               H10 I (ClockwiseBCA I C D H4 : Clockwise C D I))\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        let H8 : Clockwise E F B := ClockwiseBetweenAMC E F B I ?Goal0 ?Goal1\n          in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (_ : E <> I)\n               (_ : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (_ : forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               H10 I (ClockwiseBCA I C D H4 : Clockwise C D I))\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        let H8 : Clockwise E F B := ClockwiseBetweenAMC E F B I H6 ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"]}, {"text": "assert", "goal_before": ["Clockwise E I B", "Clockwise A B E"], "goal_after": ["Clockwise E I B", "Clockwise A B E"], "proof_term_before": ["(fun (A B C D E : Point) (H : Parallelogramm A B C D) (H0 : HalfLine D C E)\n =>\n let s := ExistsParallelogrammCenter A B C D H in\n let (x, p) := s in\n (fun (I : Point) (H1 : ParallelogrammCenter A B C D H I) =>\n  let H2 : Clockwise A B I := ParallelogrammCenterClockwiseABI A B C D I H H1\n    in\n  let H3 : CongruentStrictTriangles A I B C I D :=\n    ParallelogrammCenterCongruentTriangles A B C D I H H1 in\n  let H4 : Clockwise I C D := ParallelogrammCenterClockwiseICD A B C D I H H1\n    in\n  let s0 :=\n    CentralSymetPoint E I\n      ((fun H5 : E = I =>\n        eq_ind_r (fun E0 : Point => HalfLine D C E0 -> False)\n          (fun H6 : HalfLine D C I =>\n           False_ind False\n             (ClockwiseNotCollinear I C D H4\n                (CollinearCBA D C I (HalfLineCollinear D C I H6)))) H5 H0)\n       :\n       E <> I) in\n  let (x0, p0) := s0 in\n  (fun (F : Point) (a : Distance E I = Distance I F /\\ Between E I F) =>\n   match a with\n   | conj x1 x2 =>\n       (fun (H5 : Distance E I = Distance I F) (H6 : Between E I F) =>\n        let H7 : Clockwise E D I :=\n          and_ind\n            (fun (_ : E <> I)\n               (_ : forall x3 : Point, Clockwise E I x3 -> Clockwise I F x3)\n             =>\n             ((fun\n                 (_ : forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3)\n                 (H10 : forall x3 : Point,\n                        Clockwise C D x3 -> Clockwise E D x3) =>\n               H10 I (ClockwiseBCA I C D H4 : Clockwise C D I))\n              :\n              (forall x3 : Point, Clockwise D C x3 -> Clockwise D E x3) ->\n              EquiOriented C D E D -> Clockwise E D I) H0\n               (ChangeSense D C E H0)) H6\n          :\n          Clockwise E D I in\n        let H8 : Clockwise E F B := ClockwiseBetweenAMC E F B I H6 ?Goal0 in\n        ?Goal) x1 x2\n   end) x0 p0) x p)"], "proof_term_after": []}, {"text": "(H8 := BetweenSym _ _ _ (ParallelogrammCenterBetweenBID _ _ _ _ _ _ H1)).", "goal_before": ["Clockwise E I B", "Clockwise A B E"], "goal_after": ["Clockwise E I B", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ClockwiseCAB; canonize.", "goal_before": ["Clockwise I B E", "Clockwise A B E"], "goal_after": ["Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H11; autoClockwise.", "goal_before": ["Clockwise I B E", "Clockwise A B E"], "goal_after": ["Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (CongruentStrictTriangles D I E B I F).", "goal_before": ["CongruentStrictTriangles D I E B I F", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["CongruentStrictTriangles D I E B I F", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold ParallelogrammCenter in H1; apply CongruentOpposedStrictTriangles.", "goal_before": ["Between D I B", "Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Between D I B", "Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (BetweenSym B I D (ParallelogrammCenterBetweenBID A B C D I H H1)).", "goal_before": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (H9 := ParallelogrammCenterMidPointBD A B C D I H H1); auto.", "goal_before": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "autoDistance.", "goal_before": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "intro; elim (ClockwiseNotCollinear _ _ _ H7); autoCollinear.", "goal_before": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "assert (H10 : HalfLine B A F).", "goal_before": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (AngleCHalfLine B I A F).", "goal_before": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Between E I F", "Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "autoClockwise.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply ClockwiseCAB; apply (BetweenClockwiseMBC E F B I); trivial.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "(CongruentStrictTrianglesB _ _ _ _ _ _", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "(CongruentStrictTrianglesBCA _ _ _ _ _ _ H3)).", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "rewrite <- (CongruentStrictTrianglesA _ _ _ _ _ _ H9).", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply HalfLineAngleC.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "autoDistinct.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "autoDistinct.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "trivial.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "generalizeChangeSide.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply H12.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}, {"text": "autoDistinct.", "goal_before": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "goal_after": ["Distance I D = Distance I B", "Distance I E = Distance I F", "~ Collinear D I E", "Clockwise I B E", "Clockwise A B E"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ruler-compass-geometry/D5_ParalleleConst.v", "name": "ParallelClockwise", "text": "Theorem ParallelClockwise : forall A B C : Point,\n\tClockwise A B C ->\n\texists D : Point, EquiDirected A B C D /\\ C <> D.\nProof.\n\tintros.\n\tdestruct (ExistsDParallelogramm _ _ _ H) as (D, H0).\n\texists D; canonize.\n\t do 6 right; left; intros E H4.\n\t   destruct (FourPointsIntersectionPoint C D A E) as (F, (H5, H6)).\n\t  unfold Parallelogramm in *; autoClockwise.\n\t  trivial.\n\t  apply ClockwiseBCA; apply (ClockwiseBetweenMBC E A B F).\n\t   apply BetweenSym; trivial.\n\t   destruct (CollinearHalfLine _ _ _ H5).\n\t    apply ClockwiseCAB; apply (ParallelHalfLine A B C D F H0 H1).\n\t    apply ClockwiseCAB; apply (HalfLineParallel A B C D F H0 H1).\n\t unfold Parallelogramm in *; intuition.\n\t   autoDistinct.\nQed.\n", "definition": " forall A B C : Point,\n\tClockwise A B C ->\n\texists D : Point, EquiDirected A B C D /\\ C <> D.\n", "proof": "\n\tintros.\n\tdestruct (ExistsDParallelogramm _ _ _ H) as (D, H0).\n\texists D; canonize.\n\t do 6 right; left; intros E H4.\n\t   destruct (FourPointsIntersectionPoint C D A E) as (F, (H5, H6)).\n\t  unfold Parallelogramm in *; autoClockwise.\n\t  trivial.\n\t  apply ClockwiseBCA; apply (ClockwiseBetweenMBC E A B F).\n\t   apply BetweenSym; trivial.\n\t   destruct (CollinearHalfLine _ _ _ H5).\n\t    apply ClockwiseCAB; apply (ParallelHalfLine A B C D F H0 H1).\n\t    apply ClockwiseCAB; apply (HalfLineParallel A B C D F H0 H1).\n\t unfold Parallelogramm in *; intuition.\n\t   autoDistinct.\n", "def_ranges": [210, 0, 212, 50], "proof_ranges": [213, 0, 228, 4], "proof_steps": [{"text": "intros.", "goal_before": ["forall A B C : Point,\nClockwise A B C -> exists D : Point, EquiDirected A B C D /\\ C <> D"], "goal_after": ["exists D : Point, EquiDirected A B C D /\\ C <> D"], "proof_term_before": [], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) => ?Goal)"]}, {"text": "destruct (ExistsDParallelogramm _ _ _ H) as (D, H0).", "goal_before": ["exists D : Point, EquiDirected A B C D /\\ C <> D"], "goal_after": ["exists D0 : Point, EquiDirected A B C D0 /\\ C <> D0"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) => ?Goal)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) => ?Goal) x p)"]}, {"text": "exists D; canonize.", "goal_before": ["exists D0 : Point, EquiDirected A B C D0 /\\ C <> D0"], "goal_after": ["(forall x : Point, Clockwise A B x -> Clockwise C D x) \\/\n(forall x : Point, Clockwise A B x -> Clockwise D C x) \\/\n(forall x : Point, Clockwise B A x -> Clockwise C D x) \\/\n(forall x : Point, Clockwise B A x -> Clockwise D C x) \\/\n(forall x : Point, Clockwise C D x -> Clockwise A B x) \\/\n(forall x : Point, Clockwise C D x -> Clockwise B A x) \\/\n(forall x : Point, Clockwise D C x -> Clockwise A B x) \\/\n(forall x : Point, Clockwise D C x -> Clockwise B A x)", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) => ?Goal) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj ?Goal ((fun H1 : C = D => ?Goal0) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "do 6 right; left; intros E H4.", "goal_before": ["(forall x : Point, Clockwise A B x -> Clockwise C D x) \\/\n(forall x : Point, Clockwise A B x -> Clockwise D C x) \\/\n(forall x : Point, Clockwise B A x -> Clockwise C D x) \\/\n(forall x : Point, Clockwise B A x -> Clockwise D C x) \\/\n(forall x : Point, Clockwise C D x -> Clockwise A B x) \\/\n(forall x : Point, Clockwise C D x -> Clockwise B A x) \\/\n(forall x : Point, Clockwise D C x -> Clockwise A B x) \\/\n(forall x : Point, Clockwise D C x -> Clockwise B A x)", "False"], "goal_after": ["Clockwise A B E", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj ?Goal ((fun H1 : C = D => ?Goal0) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) => ?Goal0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "destruct (FourPointsIntersectionPoint C D A E) as (F, (H5, H6)).", "goal_before": ["Clockwise A B E", "False"], "goal_after": ["Clockwise C D A", "Clockwise D C E", "Clockwise A B E", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) => ?Goal0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E \n                                 ?Goal0 ?Goal1 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) => \n                                   ?Goal2) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "unfold Parallelogramm in *; autoClockwise.", "goal_before": ["Clockwise C D A", "Clockwise D C E", "Clockwise A B E", "False"], "goal_after": ["Clockwise D C E", "Clockwise A B E", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E \n                                 ?Goal0 ?Goal1 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) => \n                                   ?Goal2) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) \n                                 ?Goal0 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) => \n                                   ?Goal1) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "trivial.", "goal_before": ["Clockwise D C E", "Clockwise A B E", "False"], "goal_after": ["Clockwise A B E", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) \n                                 ?Goal0 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) => \n                                   ?Goal1) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) => \n                                   ?Goal0) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "apply ClockwiseBCA; apply (ClockwiseBetweenMBC E A B F).", "goal_before": ["Clockwise A B E", "False"], "goal_after": ["Between E F A", "Clockwise F A B", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) => \n                                   ?Goal0) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F \n                                        ?Goal0 ?Goal1)) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "apply BetweenSym; trivial.", "goal_before": ["Between E F A", "Clockwise F A B", "False"], "goal_after": ["Clockwise F A B", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F \n                                        ?Goal0 ?Goal1)) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6) \n                                        ?Goal0)) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "destruct (CollinearHalfLine _ _ _ H5).", "goal_before": ["Clockwise F A B", "False"], "goal_after": ["Clockwise F A B", "Clockwise F A B", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6) \n                                        ?Goal0)) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ?Goal0) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ?Goal1) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "apply ClockwiseCAB; apply (ParallelHalfLine A B C D F H0 H1).", "goal_before": ["Clockwise F A B", "Clockwise F A B", "False"], "goal_after": ["Clockwise F A B", "False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ?Goal0) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ?Goal1) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ClockwiseCAB A B F\n                                                (ParallelHalfLine A B C D F\n                                                 H0 H1)) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ?Goal0) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "apply ClockwiseCAB; apply (HalfLineParallel A B C D F H0 H1).", "goal_before": ["Clockwise F A B", "False"], "goal_after": ["False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ClockwiseCAB A B F\n                                                (ParallelHalfLine A B C D F\n                                                 H0 H1)) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ?Goal0) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ClockwiseCAB A B F\n                                                (ParallelHalfLine A B C D F\n                                                 H0 H1)) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ClockwiseCAB A B F\n                                                (HalfLineParallel A B C D F\n                                                 H0 H1)) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "unfold Parallelogramm in *; intuition.", "goal_before": ["False"], "goal_after": ["False"], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ClockwiseCAB A B F\n                                                (ParallelHalfLine A B C D F\n                                                 H0 H1)) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ClockwiseCAB A B F\n                                                (HalfLineParallel A B C D F\n                                                 H0 H1)) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D => ?Goal) : C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ClockwiseCAB A B F\n                                                (ParallelHalfLine A B C D F\n                                                 H0 H1)) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ClockwiseCAB A B F\n                                                (HalfLineParallel A B C D F\n                                                 H0 H1)) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D =>\n         and_ind\n           (fun (H2 : Clockwise A B C)\n              (H3 : Clockwise A C D /\\\n                    Distance A B = Distance C D /\\\n                    Distance A D = Distance B C) =>\n            and_ind\n              (fun (H4 : Clockwise A C D)\n                 (H5 : Distance A B = Distance C D /\\\n                       Distance A D = Distance B C) =>\n               and_ind\n                 (fun (H6 : Distance A B = Distance C D)\n                    (H7 : Distance A D = Distance B C) =>\n                  ?Goal@{H0:=H4; H3:=H6; H5:=H7}) H5) H3) H0\n         :\n         False)\n        :\n        C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "autoDistinct.", "goal_before": ["False"], "goal_after": [], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ClockwiseCAB A B F\n                                                (ParallelHalfLine A B C D F\n                                                 H0 H1)) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ClockwiseCAB A B F\n                                                (HalfLineParallel A B C D F\n                                                 H0 H1)) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D =>\n         and_ind\n           (fun (H2 : Clockwise A B C)\n              (H3 : Clockwise A C D /\\\n                    Distance A B = Distance C D /\\\n                    Distance A D = Distance B C) =>\n            and_ind\n              (fun (H4 : Clockwise A C D)\n                 (H5 : Distance A B = Distance C D /\\\n                       Distance A D = Distance B C) =>\n               and_ind\n                 (fun (H6 : Distance A B = Distance C D)\n                    (H7 : Distance A D = Distance B C) =>\n                  ?Goal@{H0:=H4; H3:=H6; H5:=H7}) H5) H3) H0\n         :\n         False)\n        :\n        C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ClockwiseCAB A B F\n                                                (ParallelHalfLine A B C D F\n                                                 H0 H1)) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ClockwiseCAB A B F\n                                                (HalfLineParallel A B C D F\n                                                 H0 H1)) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D =>\n         and_ind\n           (fun (_ : Clockwise A B C)\n              (H3 : Clockwise A C D /\\\n                    Distance A B = Distance C D /\\\n                    Distance A D = Distance B C) =>\n            and_ind\n              (fun (H4 : Clockwise A C D)\n                 (H5 : Distance A B = Distance C D /\\\n                       Distance A D = Distance B C) =>\n               and_ind\n                 (fun (_ : Distance A B = Distance C D)\n                    (_ : Distance A D = Distance B C) =>\n                  ClockwiseDistinctBC A C D H4 H1 : False) H5) H3) H0\n         :\n         False)\n        :\n        C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"]}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": ["(fun (A B C : Point) (H : Clockwise A B C) =>\n let s := ExistsDParallelogramm A B C H in\n let (x, p) := s in\n (fun (D : Point) (H0 : Parallelogramm A B C D) =>\n  ex_intro (fun D0 : Point => EquiDirected A B C D0 /\\ C <> D0) D\n    (conj\n       (or_intror\n          (or_intror\n             (or_intror\n                (or_intror\n                   (or_intror\n                      (or_intror\n                         (or_introl\n                            (fun (E : Point) (H4 : Clockwise D C E) =>\n                             let s0 :=\n                               FourPointsIntersectionPoint C D A E\n                                 ((and_ind\n                                     (fun (_ : Clockwise A B C)\n                                        (H2 : Clockwise A C D /\\\n                                              Distance A B = Distance C D /\\\n                                              Distance A D = Distance B C) =>\n                                      and_ind\n                                        (fun (H3 : Clockwise A C D)\n                                           (H5 : Distance A B = Distance C D /\\\n                                                 Distance A D = Distance B C)\n                                         =>\n                                         and_ind\n                                           (fun\n                                              (_ : \n                                               Distance A B = \n                                               Distance C D)\n                                              (_ : \n                                               Distance A D = \n                                               Distance B C) =>\n                                            ClockwiseBCA A C D H3) H5) H2) H0\n                                   :\n                                   Clockwise C D A)\n                                  :\n                                  Clockwise C D A) H4 in\n                             let (x0, p0) := s0 in\n                             (fun (F : Point)\n                                (a : Collinear C D F /\\ Between A F E) =>\n                              match a with\n                              | conj x1 x2 =>\n                                  (fun (H5 : Collinear C D F)\n                                     (H6 : Between A F E) =>\n                                   ClockwiseBCA E A B\n                                     (ClockwiseBetweenMBC E A B F\n                                        (BetweenSym A F E H6)\n                                        (let o :\n                                           HalfLine C D F \\/ HalfLine D C F :=\n                                           CollinearHalfLine C D F H5 in\n                                         match o with\n                                         | or_introl x3 =>\n                                             (fun H1 : HalfLine C D F =>\n                                              ClockwiseCAB A B F\n                                                (ParallelHalfLine A B C D F\n                                                 H0 H1)) x3\n                                         | or_intror x3 =>\n                                             (fun H1 : HalfLine D C F =>\n                                              ClockwiseCAB A B F\n                                                (HalfLineParallel A B C D F\n                                                 H0 H1)) x3\n                                         end))) x1 x2\n                              end) x0 p0))))))))\n       ((fun H1 : C = D =>\n         and_ind\n           (fun (_ : Clockwise A B C)\n              (H3 : Clockwise A C D /\\\n                    Distance A B = Distance C D /\\\n                    Distance A D = Distance B C) =>\n            and_ind\n              (fun (H4 : Clockwise A C D)\n                 (H5 : Distance A B = Distance C D /\\\n                       Distance A D = Distance B C) =>\n               and_ind\n                 (fun (_ : Distance A B = Distance C D)\n                    (_ : Distance A D = Distance B C) =>\n                  ClockwiseDistinctBC A C D H4 H1 : False) H5) H3) H0\n         :\n         False)\n        :\n        C <> D)\n     :\n     EquiDirected A B C D /\\ C <> D)) x p)"], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ruler-compass-geometry/E5_Parallelisme.v", "name": "Parallel_exists", "text": "Theorem Parallel_exists : forall A : Point, forall (F : Figure) (D : Line F),\n\texists F' : Figure, (exists D' : Line F', ParallelLines F F' D D' /\\ F' A).\nProof.\n\tintros.\n\tpose (B := LineA F D); pose (C := LineB F D).\n\tdecompose [or] (FourCases B C A).\n\t destruct (ParallelClockwise _ _ _ H) as (E, (H0, H1)).\n\t   exists (Collinear A E).\n\t   exists (Ruler A E H1).\n\t   split.\n\t  unfold ParallelLines in |- *; auto.\n\t  autoCollinear.\n\t destruct (ParallelClockwise _ _ _ H0) as (E, (H, H1)).\n\t   exists (Collinear A E).\n\t   exists (Ruler A E H1).\n\t   split.\n\t  unfold ParallelLines in |- *; simpl in |- *.\n\t    apply EquiDirectedPermut; trivial.\n\t  autoCollinear.\n\t exists F; exists D; split.\n\t  unfold ParallelLines in |- *; apply EquiDirectedRefl.\n\t  apply (InFLine F D).\n\t    apply HalfLineCollinear; trivial.\n\t exists F; exists D; split.\n\t  unfold ParallelLines in |- *; apply EquiDirectedRefl.\n\t  apply (InFLine F D).\n\t    apply CollinearBAC; apply HalfLineCollinear; trivial.\nQed.\n", "definition": " forall A : Point, forall (F : Figure) (D : Line F),\n\texists F' : Figure, (exists D' : Line F', ParallelLines F F' D D' /\\ F' A).\n", "proof": "\n\tintros.\n\tpose (B := LineA F D); pose (C := LineB F D).\n\tdecompose [or] (FourCases B C A).\n\t destruct (ParallelClockwise _ _ _ H) as (E, (H0, H1)).\n\t   exists (Collinear A E).\n\t   exists (Ruler A E H1).\n\t   split.\n\t  unfold ParallelLines in |- *; auto.\n\t  autoCollinear.\n\t destruct (ParallelClockwise _ _ _ H0) as (E, (H, H1)).\n\t   exists (Collinear A E).\n\t   exists (Ruler A E H1).\n\t   split.\n\t  unfold ParallelLines in |- *; simpl in |- *.\n\t    apply EquiDirectedPermut; trivial.\n\t  autoCollinear.\n\t exists F; exists D; split.\n\t  unfold ParallelLines in |- *; apply EquiDirectedRefl.\n\t  apply (InFLine F D).\n\t    apply HalfLineCollinear; trivial.\n\t exists F; exists D; split.\n\t  unfold ParallelLines in |- *; apply EquiDirectedRefl.\n\t  apply (InFLine F D).\n\t    apply CollinearBAC; apply HalfLineCollinear; trivial.\n", "def_ranges": [6, 0, 7, 76], "proof_ranges": [8, 0, 33, 4], "proof_steps": [{"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "pose (B := LineA F D); pose (C := LineB F D).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "decompose [or] (FourCases B C A).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (ParallelClockwise _ _ _ H) as (E, (H0, H1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (Collinear A E).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (Ruler A E H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold ParallelLines in |- *; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "autoCollinear.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (ParallelClockwise _ _ _ H0) as (E, (H, H1)).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (Collinear A E).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists (Ruler A E H1).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold ParallelLines in |- *; simpl in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply EquiDirectedPermut; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "autoCollinear.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists F; exists D; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold ParallelLines in |- *; apply EquiDirectedRefl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (InFLine F D).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply HalfLineCollinear; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "exists F; exists D; split.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold ParallelLines in |- *; apply EquiDirectedRefl.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (InFLine F D).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply CollinearBAC; apply HalfLineCollinear; trivial.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/ruler-compass-geometry/E5_Parallelisme.v", "name": "Parallel_unicity", "text": "Theorem Parallel_unicity : forall A : Point, forall (F : Figure) (D : Line F),\nforall (F' F'' : Figure) (D' : Line F') (D'' : Line F''),\n\tParallelLines F F' D D' ->\n\tF' A ->\n\tParallelLines F F'' D D'' ->\n\tF'' A ->\n\tSuperimposed F' F''.\nProof.\n\tunfold ParallelLines in |- *; intros.\n\tdecompose [or] (ThreeCases (LineA F D) (LineB F D) A).\n\t destruct (ExistsDParallelogramm _ _ _ H3) as (B, H4).\n\t   apply (SuperimposedTrans F' (Collinear A B) F'').\n\t  apply (ParallelogrammSuperimposed _ _ _ _ _ _ H4 H H0).\n\t  apply SuperimposedSym;\n\t   apply (ParallelogrammSuperimposed _ _ _ _ _ _ H4 H1 H2).\n\t destruct (ExistsDParallelogramm _ _ _ H4) as (B, H5).\n\t   apply (SuperimposedTrans F' (Collinear A B) F'').\n\t  apply  (ParallelogrammSuperimposed _ _ _ _ _ _ H5 (EquiDirectedPermut _ _ _ _ H) H0).\n\t  apply SuperimposedSym;\n\t   apply (ParallelogrammSuperimposed _ _ _ _ _ _ H5 (EquiDirectedPermut _ _ _ _ H1) H2).\n\t apply (SuperimposedTrans F' F F'').\n\t  apply SuperimposedSym;\n\t   apply (CollinearSuperimposed _ _ _ _ _ H (InFLine _ _ _ H4) H0).\n\t  apply (CollinearSuperimposed _ _ _ _ _ H1 (InFLine _ _ _ H4) H2).\nQed.\n", "definition": " forall A : Point, forall (F : Figure) (D : Line F),\nforall (F' F'' : Figure) (D' : Line F') (D'' : Line F''),\n\tParallelLines F F' D D' ->\n\tF' A ->\n\tParallelLines F F'' D D'' ->\n\tF'' A ->\n\tSuperimposed F' F''.\n", "proof": "\n\tunfold ParallelLines in |- *; intros.\n\tdecompose [or] (ThreeCases (LineA F D) (LineB F D) A).\n\t destruct (ExistsDParallelogramm _ _ _ H3) as (B, H4).\n\t   apply (SuperimposedTrans F' (Collinear A B) F'').\n\t  apply (ParallelogrammSuperimposed _ _ _ _ _ _ H4 H H0).\n\t  apply SuperimposedSym;\n\t   apply (ParallelogrammSuperimposed _ _ _ _ _ _ H4 H1 H2).\n\t destruct (ExistsDParallelogramm _ _ _ H4) as (B, H5).\n\t   apply (SuperimposedTrans F' (Collinear A B) F'').\n\t  apply  (ParallelogrammSuperimposed _ _ _ _ _ _ H5 (EquiDirectedPermut _ _ _ _ H) H0).\n\t  apply SuperimposedSym;\n\t   apply (ParallelogrammSuperimposed _ _ _ _ _ _ H5 (EquiDirectedPermut _ _ _ _ H1) H2).\n\t apply (SuperimposedTrans F' F F'').\n\t  apply SuperimposedSym;\n\t   apply (CollinearSuperimposed _ _ _ _ _ H (InFLine _ _ _ H4) H0).\n\t  apply (CollinearSuperimposed _ _ _ _ _ H1 (InFLine _ _ _ H4) H2).\n", "def_ranges": [37, 0, 43, 21], "proof_ranges": [44, 0, 61, 4], "proof_steps": [{"text": "unfold ParallelLines in |- *; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "decompose [or] (ThreeCases (LineA F D) (LineB F D) A).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (ExistsDParallelogramm _ _ _ H3) as (B, H4).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (SuperimposedTrans F' (Collinear A B) F'').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (ParallelogrammSuperimposed _ _ _ _ _ _ H4 H H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply SuperimposedSym;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (ParallelogrammSuperimposed _ _ _ _ _ _ H4 H1 H2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "destruct (ExistsDParallelogramm _ _ _ H4) as (B, H5).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (SuperimposedTrans F' (Collinear A B) F'').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply  (ParallelogrammSuperimposed _ _ _ _ _ _ H5 (EquiDirectedPermut _ _ _ _ H) H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply SuperimposedSym;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (ParallelogrammSuperimposed _ _ _ _ _ _ H5 (EquiDirectedPermut _ _ _ _ H1) H2).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (SuperimposedTrans F' F F'').", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply SuperimposedSym;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (CollinearSuperimposed _ _ _ _ _ H (InFLine _ _ _ H4) H0).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/angles/point_Simson.v", "name": "droite_Simson", "text": "Theorem droite_Simson :\n forall A B C M P Q T : PO,\n ~ colineaire (vec C A) (vec C M) ->\n colineaire (vec C A) (vec C Q) ->\n colineaire (vec P C) (vec P B) ->\n colineaire (vec B A) (vec B T) ->\n orthogonal (vec T M) (vec T B) ->\n orthogonal (vec P M) (vec P B) ->\n orthogonal (vec Q M) (vec Q C) ->\n (colineaire (vec P Q) (vec P T) <-> sont_cocycliques C A M B).\nunfold iff in |- *.\nintros A B C M P Q S H H0 H1 H2 H3 H4 H5;\n (split; [ intros H6; try assumption | idtac ]).\napply reciproque_cocyclique; auto.\ncut\n (R\n    (plus (double (cons (vec C A) (vec C M)))\n       (double (cons (vec B M) (vec B A)))) zero); \n intros.\napply\n regulier\n  with\n    (a := double (cons (vec B M) (vec B A)))\n    (c := double (cons (vec B M) (vec B A))); auto.\napply\n transitive\n  with (double (plus (cons (vec B M) (vec B A)) (cons (vec B A) (vec B M))));\n auto.\napply transitive with (double zero); auto.\napply transitive with zero; auto.\napply\n transitive\n  with\n    (plus (double (cons (vec C A) (vec C M)))\n       (double (cons (vec B M) (vec B A)))); auto.\napply transitive with (double (cons (vec P Q) (vec P S))); auto.\napply symetrique.\napply (projete_ortho_cote (A:=A) (B:=B) (C:=C) (M:=M) (P:=P) (Q:=Q) (T:=S));\n auto.\nunfold colineaire in |- *; intros.\napply\n transitive\n  with\n    (plus (double (cons (vec C A) (vec C M)))\n       (double (cons (vec B M) (vec B A)))); auto.\napply (projete_ortho_cote (A:=A) (B:=B) (C:=C) (M:=M) (P:=P) (Q:=Q) (T:=S));\n auto.\ncut\n (R (double (cons (vec C A) (vec C M))) (double (cons (vec B A) (vec B M))));\n intros.\napply\n regulier\n  with\n    (a := double (cons (vec B A) (vec B M)))\n    (c := double (cons (vec B A) (vec B M))); auto.\napply\n transitive\n  with\n    (plus (double (cons (vec B A) (vec B M)))\n       (plus (double (cons (vec B A) (vec B M)))\n          (double (cons (vec B M) (vec B A))))); auto.\napply compatible; auto.\napply compatible; auto.\napply compatible; auto.\napply\n transitive\n  with (double (plus (cons (vec B A) (vec B M)) (cons (vec B M) (vec B A))));\n auto.\napply transitive with (double (cons (vec B A) (vec B A))); auto.\napply transitive with (double zero); auto.\ngeneralize (cocyclicite_six (A:=A) (B:=M) (C:=C) (D:=B)).\nintros H7; try assumption.\nelim H7;\n [ intros O H8; elim H8; intros H9 H10; clear H8 H7; try exact H10 | idtac ].\nelim H9; unfold circonscrit in |- *; intros H7 H8; clear H9; try exact H7.\napply cocyclique with O.\nelim H8; intros H9 H11; clear H8; try exact H9.\nelim H8; intros H9 H11; elim H11; intros H12 H13; clear H11 H8; auto.\nelim H8; intros H9 H11; elim H11; intros H12 H13; clear H11 H8; auto.\nelim H7; intros H9 H11; elim H11; intros H12 H13; clear H11 H7; auto.\nelim H7; intros H9 H11; elim H11; intros H12 H13; clear H11 H7; auto.\ntry exact H6.\nQed.", "definition": "\n forall A B C M P Q T : PO,\n ~ colineaire (vec C A) (vec C M) ->\n colineaire (vec C A) (vec C Q) ->\n colineaire (vec P C) (vec P B) ->\n colineaire (vec B A) (vec B T) ->\n orthogonal (vec T M) (vec T B) ->\n orthogonal (vec P M) (vec P B) ->\n orthogonal (vec Q M) (vec Q C) ->\n (colineaire (vec P Q) (vec P T) <-> sont_cocycliques C A M B).", "proof": "\nunfold iff in |- *.\nintros A B C M P Q S H H0 H1 H2 H3 H4 H5;\n (split; [ intros H6; try assumption | idtac ]).\napply reciproque_cocyclique; auto.\ncut\n (R\n    (plus (double (cons (vec C A) (vec C M)))\n       (double (cons (vec B M) (vec B A)))) zero); \n intros.\napply\n regulier\n  with\n    (a := double (cons (vec B M) (vec B A)))\n    (c := double (cons (vec B M) (vec B A))); auto.\napply\n transitive\n  with (double (plus (cons (vec B M) (vec B A)) (cons (vec B A) (vec B M))));\n auto.\napply transitive with (double zero); auto.\napply transitive with zero; auto.\napply\n transitive\n  with\n    (plus (double (cons (vec C A) (vec C M)))\n       (double (cons (vec B M) (vec B A)))); auto.\napply transitive with (double (cons (vec P Q) (vec P S))); auto.\napply symetrique.\napply (projete_ortho_cote (A:=A) (B:=B) (C:=C) (M:=M) (P:=P) (Q:=Q) (T:=S));\n auto.\nunfold colineaire in |- *; intros.\napply\n transitive\n  with\n    (plus (double (cons (vec C A) (vec C M)))\n       (double (cons (vec B M) (vec B A)))); auto.\napply (projete_ortho_cote (A:=A) (B:=B) (C:=C) (M:=M) (P:=P) (Q:=Q) (T:=S));\n auto.\ncut\n (R (double (cons (vec C A) (vec C M))) (double (cons (vec B A) (vec B M))));\n intros.\napply\n regulier\n  with\n    (a := double (cons (vec B A) (vec B M)))\n    (c := double (cons (vec B A) (vec B M))); auto.\napply\n transitive\n  with\n    (plus (double (cons (vec B A) (vec B M)))\n       (plus (double (cons (vec B A) (vec B M)))\n          (double (cons (vec B M) (vec B A))))); auto.\napply compatible; auto.\napply compatible; auto.\napply compatible; auto.\napply\n transitive\n  with (double (plus (cons (vec B A) (vec B M)) (cons (vec B M) (vec B A))));\n auto.\napply transitive with (double (cons (vec B A) (vec B A))); auto.\napply transitive with (double zero); auto.\ngeneralize (cocyclicite_six (A:=A) (B:=M) (C:=C) (D:=B)).\nintros H7; try assumption.\nelim H7;\n [ intros O H8; elim H8; intros H9 H10; clear H8 H7; try exact H10 | idtac ].\nelim H9; unfold circonscrit in |- *; intros H7 H8; clear H9; try exact H7.\napply cocyclique with O.\nelim H8; intros H9 H11; clear H8; try exact H9.\nelim H8; intros H9 H11; elim H11; intros H12 H13; clear H11 H8; auto.\nelim H8; intros H9 H11; elim H11; intros H12 H13; clear H11 H8; auto.\nelim H7; intros H9 H11; elim H11; intros H12 H13; clear H11 H7; auto.\nelim H7; intros H9 H11; elim H11; intros H12 H13; clear H11 H7; auto.\ntry exact H6.\n", "def_ranges": [109, 0, 118, 63], "proof_ranges": [119, 0, 191, 4], "proof_steps": [{"text": "unfold iff in |- *.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros A B C M P Q S H H0 H1 H2 H3 H4 H5;", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(split; [ intros H6; try assumption | idtac ]).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply reciproque_cocyclique; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(R", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus (double (cons (vec C A) (vec C M)))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(double (cons (vec B M) (vec B A)))) zero);", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "regulier", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(a := double (cons (vec B M) (vec B A)))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(c := double (cons (vec B M) (vec B A))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "transitive", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with (double (plus (cons (vec B M) (vec B A)) (cons (vec B A) (vec B M))));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply transitive with (double zero); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply transitive with zero; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "transitive", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus (double (cons (vec C A) (vec C M)))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(double (cons (vec B M) (vec B A)))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply transitive with (double (cons (vec P Q) (vec P S))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply symetrique.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (projete_ortho_cote (A:=A) (B:=B) (C:=C) (M:=M) (P:=P) (Q:=Q) (T:=S));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "unfold colineaire in |- *; intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "transitive", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus (double (cons (vec C A) (vec C M)))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(double (cons (vec B M) (vec B A)))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply (projete_ortho_cote (A:=A) (B:=B) (C:=C) (M:=M) (P:=P) (Q:=Q) (T:=S));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(R (double (cons (vec C A) (vec C M))) (double (cons (vec B A) (vec B M))));", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "regulier", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(a := double (cons (vec B A) (vec B M)))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(c := double (cons (vec B A) (vec B M))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "transitive", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus (double (cons (vec B A) (vec B M)))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus (double (cons (vec B A) (vec B M)))", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "(double (cons (vec B M) (vec B A))))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply compatible; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply compatible; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply compatible; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/angles/point_orthocentre.v", "name": "symetrique_orthocentre_cercle", "text": "Theorem symetrique_orthocentre_cercle :\n forall H' : PO,\n R (cons (vec H' B) (vec B C)) (cons (vec B C) (vec H B)) ->\n R (cons (vec H' C) (vec B C)) (cons (vec B C) (vec H C)) ->\n sont_cocycliques A B C H'.\nintros H' H0 H1; try assumption.\napply reciproque_cocyclique; auto.\ncut (R (cons (vec H C) (vec H B)) (cons (vec H' B) (vec H' C))).\nintros H2.\napply transitive with (double (cons (vec H C) (vec H B))); auto.\napply orthocentre_double.\napply reflexion with (vec B C); auto.\nQed.\n", "definition": "\n forall H' : PO,\n R (cons (vec H' B) (vec B C)) (cons (vec B C) (vec H B)) ->\n R (cons (vec H' C) (vec B C)) (cons (vec B C) (vec H C)) ->\n sont_cocycliques A B C H'.", "proof": "\nintros H' H0 H1; try assumption.\napply reciproque_cocyclique; auto.\ncut (R (cons (vec H C) (vec H B)) (cons (vec H' B) (vec H' C))).\nintros H2.\napply transitive with (double (cons (vec H C) (vec H B))); auto.\napply orthocentre_double.\napply reflexion with (vec B C); auto.\n", "def_ranges": [53, 0, 57, 27], "proof_ranges": [58, 0, 65, 4], "proof_steps": [{"text": "intros H' H0 H1; try assumption.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply reciproque_cocyclique; auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "cut (R (cons (vec H C) (vec H B)) (cons (vec H' B) (vec H' C))).", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "intros H2.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply transitive with (double (cons (vec H C) (vec H B))); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply orthocentre_double.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "apply reflexion with (vec B C); auto.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}, {"text": "Qed.", "goal_before": [], "goal_after": [], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}, {"path": "/home/jizej/proverbot9001/coq-projects/angles/point_angle.v", "name": "somme_triangle", "text": "Theorem somme_triangle :\n forall A B C : PO,\n R\n   (plus (cons (vec A B) (vec A C))\n      (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi.\nintros A B C; try assumption.\napply\n transitive\n  with\n    (plus (cons (vec A B) (vec A C))\n       (plus (cons (vec B C) (opp (vec A B)))\n          (cons (opp (vec A C)) (opp (vec B C))))).\napply compatible.\napply reflexive.\napply compatible.\napply vR_R_compatible.\napply v_refl.\napply v_sym.\napply opp_vect.\napply vR_R_compatible.\napply v_sym; apply opp_vect.\napply v_sym; apply opp_vect.\napply somme_pi.\nQed.\n", "definition": "\n forall A B C : PO,\n R\n   (plus (cons (vec A B) (vec A C))\n      (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi.", "proof": "\nintros A B C; try assumption.\napply\n transitive\n  with\n    (plus (cons (vec A B) (vec A C))\n       (plus (cons (vec B C) (opp (vec A B)))\n          (cons (opp (vec A C)) (opp (vec B C))))).\napply compatible.\napply reflexive.\napply compatible.\napply vR_R_compatible.\napply v_refl.\napply v_sym.\napply opp_vect.\napply vR_R_compatible.\napply v_sym; apply opp_vect.\napply v_sym; apply opp_vect.\napply somme_pi.\n", "def_ranges": [490, 0, 494, 71], "proof_ranges": [495, 0, 513, 4], "proof_steps": [{"text": "intros A B C; try assumption.", "goal_before": ["forall A B C : PO,\nR\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": ["(fun A B C : PO => ?Goal)"]}, {"text": "apply", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": ["(fun A B C : PO => ?Goal)"], "proof_term_after": []}, {"text": "transitive", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "with", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus (cons (vec A B) (vec A C))", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "(plus (cons (vec B C) (opp (vec A B)))", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "(cons (opp (vec A C)) (opp (vec B C))))).", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply compatible.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply reflexive.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply compatible.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply vR_R_compatible.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply v_refl.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply v_sym.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply opp_vect.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply vR_R_compatible.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}, {"text": "apply v_sym; apply opp_vect.", "goal_before": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "goal_after": ["R\n  (plus (cons (vec A B) (vec A C))\n     (plus (cons (vec B C) (vec B A)) (cons (vec C A) (vec C B)))) pi"], "proof_term_before": [], "proof_term_after": []}], "ends_qed": true}]